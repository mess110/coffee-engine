"use strict";

function download(t, e, n) {
    function r(t, e) {
        if ("download" in l) return l.href = t, l.setAttribute("download", g), l.innerHTML = "downloading...", 
        l.style.display = "none", c.body.appendChild(l), setTimeout(function() {
            l.click(), c.body.removeChild(l), !0 === e && setTimeout(function() {
                h.URL.revokeObjectURL(l.href);
            }, 250);
        }, 66), !0;
        var n = c.createElement("iframe");
        c.body.appendChild(n), e || (t = "data:" + t.replace(/^data:([\w\/\-\+]+)/, f)), 
        n.src = t, setTimeout(function() {
            c.body.removeChild(n);
        }, 333);
    }
    var o, a, s, h = window, f = "application/octet-stream", d = n || f, u = t, c = document, l = c.createElement("a"), p = function(t) {
        return String(t);
    }, m = h.Blob || h.MozBlob || h.WebKitBlob || p, w = h.MSBlobBuilder || h.WebKitBlobBuilder || h.BlobBuilder, g = e || "download";
    if ("true" === String(this) && (u = [ u, d ], d = u[0], u = u[1]), String(u).match(/^data\:[\w+\-]+\/[\w+\-]+[,;]/)) return navigator.msSaveBlob ? navigator.msSaveBlob(function(t) {
        var e = t.split(/[:;,]/), n = e[1], i = "base64" == e[2] ? atob : decodeURIComponent, r = i(e.pop()), o = r.length, a = 0, s = new Uint8Array(o);
        for (a; a < o; ++a) s[a] = r.charCodeAt(a);
        return new m([ s ], {
            type: n
        });
    }(u), g) : r(u);
    try {
        o = u instanceof m ? u : new m([ u ], {
            type: d
        });
    } catch (t) {
        w && (a = new w(), a.append([ u ]), o = a.getBlob(d));
    }
    if (navigator.msSaveBlob) return navigator.msSaveBlob(o, g);
    if (h.URL) r(h.URL.createObjectURL(o), !0); else {
        if ("string" == typeof o || o.constructor === p) try {
            return r("data:" + d + ";base64," + h.btoa(o));
        } catch (t) {
            return r("data:" + d + "," + encodeURIComponent(o));
        }
        s = new FileReader(), s.onload = function(t) {
            r(this.result);
        }, s.readAsDataURL(o);
    }
    return !0;
}

var Stats = function() {
    var startTime = Date.now(), prevTime = startTime, ms = 0, msMin = 1 / 0, msMax = 0, fps = 0, fpsMin = 1 / 0, fpsMax = 0, frames = 0, mode = 0, container = document.createElement("div");
    container.id = "stats", container.addEventListener("mousedown", function(event) {
        event.preventDefault(), setMode(++mode % 2);
    }, !1), container.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var fpsDiv = document.createElement("div");
    fpsDiv.id = "fps", fpsDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002", 
    container.appendChild(fpsDiv);
    var fpsText = document.createElement("div");
    fpsText.id = "fpsText", fpsText.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    fpsText.innerHTML = "FPS", fpsDiv.appendChild(fpsText);
    var fpsGraph = document.createElement("div");
    for (fpsGraph.id = "fpsGraph", fpsGraph.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff", 
    fpsDiv.appendChild(fpsGraph); fpsGraph.children.length < 74; ) {
        var bar = document.createElement("span");
        bar.style.cssText = "width:1px;height:30px;float:left;background-color:#113", fpsGraph.appendChild(bar);
    }
    var msDiv = document.createElement("div");
    msDiv.id = "ms", msDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none", 
    container.appendChild(msDiv);
    var msText = document.createElement("div");
    msText.id = "msText", msText.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    msText.innerHTML = "MS", msDiv.appendChild(msText);
    var msGraph = document.createElement("div");
    for (msGraph.id = "msGraph", msGraph.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0", 
    msDiv.appendChild(msGraph); msGraph.children.length < 74; ) {
        var bar = document.createElement("span");
        bar.style.cssText = "width:1px;height:30px;float:left;background-color:#131", msGraph.appendChild(bar);
    }
    var setMode = function(value) {
        switch (mode = value) {
          case 0:
            fpsDiv.style.display = "block", msDiv.style.display = "none";
            break;

          case 1:
            fpsDiv.style.display = "none", msDiv.style.display = "block";
        }
    }, updateGraph = function(dom, value) {
        dom.appendChild(dom.firstChild).style.height = value + "px";
    };
    return {
        REVISION: 12,
        domElement: container,
        setMode: setMode,
        begin: function() {
            startTime = Date.now();
        },
        end: function() {
            var time = Date.now();
            return ms = time - startTime, msMin = Math.min(msMin, ms), msMax = Math.max(msMax, ms), 
            msText.textContent = ms + " MS (" + msMin + "-" + msMax + ")", updateGraph(msGraph, Math.min(30, 30 - ms / 200 * 30)), 
            frames++, time > prevTime + 1e3 && (fps = Math.round(1e3 * frames / (time - prevTime)), 
            fpsMin = Math.min(fpsMin, fps), fpsMax = Math.max(fpsMax, fps), fpsText.textContent = fps + " FPS (" + fpsMin + "-" + fpsMax + ")", 
            updateGraph(fpsGraph, Math.min(30, 30 - fps / 100 * 30)), prevTime = time, frames = 0), 
            time;
        },
        update: function() {
            startTime = this.end();
        }
    };
};

"object" == typeof module && (module.exports = Stats), function() {
    if ("performance" in window == !1 && (window.performance = {}), Date.now = Date.now || function() {
        return new Date().getTime();
    }, "now" in window.performance == !1) {
        var offset = window.performance.timing && window.performance.timing.navigationStart ? window.performance.timing.navigationStart : Date.now();
        window.performance.now = function() {
            return Date.now() - offset;
        };
    }
}();

var TWEEN = TWEEN || function() {
    var _tweens = [];
    return {
        getAll: function() {
            return _tweens;
        },
        removeAll: function() {
            _tweens = [];
        },
        add: function(tween) {
            _tweens.push(tween);
        },
        remove: function(tween) {
            var i = _tweens.indexOf(tween);
            -1 !== i && _tweens.splice(i, 1);
        },
        update: function(time) {
            if (0 === _tweens.length) return !1;
            var i = 0;
            for (time = void 0 !== time ? time : window.performance.now(); i < _tweens.length; ) _tweens[i].update(time) ? i++ : _tweens.splice(i, 1);
            return !0;
        }
    };
}();

TWEEN.Tween = function(object) {
    var _object = object, _valuesStart = {}, _valuesEnd = {}, _valuesStartRepeat = {}, _duration = 1e3, _repeat = 0, _yoyo = !1, _isPlaying = !1, _reversed = !1, _delayTime = 0, _startTime = null, _easingFunction = TWEEN.Easing.Linear.None, _interpolationFunction = TWEEN.Interpolation.Linear, _chainedTweens = [], _onStartCallback = null, _onStartCallbackFired = !1, _onUpdateCallback = null, _onCompleteCallback = null, _onStopCallback = null;
    for (var field in object) _valuesStart[field] = parseFloat(object[field], 10);
    this.to = function(properties, duration) {
        return void 0 !== duration && (_duration = duration), _valuesEnd = properties, this;
    }, this.start = function(time) {
        TWEEN.add(this), _isPlaying = !0, _onStartCallbackFired = !1, _startTime = void 0 !== time ? time : window.performance.now(), 
        _startTime += _delayTime;
        for (var property in _valuesEnd) {
            if (_valuesEnd[property] instanceof Array) {
                if (0 === _valuesEnd[property].length) continue;
                _valuesEnd[property] = [ _object[property] ].concat(_valuesEnd[property]);
            }
            _valuesStart[property] = _object[property], _valuesStart[property] instanceof Array == !1 && (_valuesStart[property] *= 1), 
            _valuesStartRepeat[property] = _valuesStart[property] || 0;
        }
        return this;
    }, this.stop = function() {
        return _isPlaying ? (TWEEN.remove(this), _isPlaying = !1, null !== _onStopCallback && _onStopCallback.call(_object), 
        this.stopChainedTweens(), this) : this;
    }, this.stopChainedTweens = function() {
        for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) _chainedTweens[i].stop();
    }, this.delay = function(amount) {
        return _delayTime = amount, this;
    }, this.repeat = function(times) {
        return _repeat = times, this;
    }, this.yoyo = function(yoyo) {
        return _yoyo = yoyo, this;
    }, this.easing = function(easing) {
        return _easingFunction = easing, this;
    }, this.interpolation = function(interpolation) {
        return _interpolationFunction = interpolation, this;
    }, this.chain = function() {
        return _chainedTweens = arguments, this;
    }, this.onStart = function(callback) {
        return _onStartCallback = callback, this;
    }, this.onUpdate = function(callback) {
        return _onUpdateCallback = callback, this;
    }, this.onComplete = function(callback) {
        return _onCompleteCallback = callback, this;
    }, this.onStop = function(callback) {
        return _onStopCallback = callback, this;
    }, this.update = function(time) {
        var property;
        if (time < _startTime) return !0;
        !1 === _onStartCallbackFired && (null !== _onStartCallback && _onStartCallback.call(_object), 
        _onStartCallbackFired = !0);
        var elapsed = (time - _startTime) / _duration;
        elapsed = elapsed > 1 ? 1 : elapsed;
        var value = _easingFunction(elapsed);
        for (property in _valuesEnd) {
            var start = _valuesStart[property] || 0, end = _valuesEnd[property];
            end instanceof Array ? _object[property] = _interpolationFunction(end, value) : ("string" == typeof end && (end = start + parseFloat(end, 10)), 
            "number" == typeof end && (_object[property] = start + (end - start) * value));
        }
        if (null !== _onUpdateCallback && _onUpdateCallback.call(_object, value), 1 == elapsed) {
            if (_repeat > 0) {
                isFinite(_repeat) && _repeat--;
                for (property in _valuesStartRepeat) {
                    if ("string" == typeof _valuesEnd[property] && (_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10)), 
                    _yoyo) {
                        var tmp = _valuesStartRepeat[property];
                        _valuesStartRepeat[property] = _valuesEnd[property], _valuesEnd[property] = tmp;
                    }
                    _valuesStart[property] = _valuesStartRepeat[property];
                }
                return _yoyo && (_reversed = !_reversed), _startTime = time + _delayTime, !0;
            }
            null !== _onCompleteCallback && _onCompleteCallback.call(_object);
            for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) _chainedTweens[i].start(time);
            return !1;
        }
        return !0;
    };
}, TWEEN.Easing = {
    Linear: {
        None: function(k) {
            return k;
        }
    },
    Quadratic: {
        In: function(k) {
            return k * k;
        },
        Out: function(k) {
            return k * (2 - k);
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1);
        }
    },
    Cubic: {
        In: function(k) {
            return k * k * k;
        },
        Out: function(k) {
            return --k * k * k + 1;
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2);
        }
    },
    Quartic: {
        In: function(k) {
            return k * k * k * k;
        },
        Out: function(k) {
            return 1 - --k * k * k * k;
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2);
        }
    },
    Quintic: {
        In: function(k) {
            return k * k * k * k * k;
        },
        Out: function(k) {
            return --k * k * k * k * k + 1;
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2);
        }
    },
    Sinusoidal: {
        In: function(k) {
            return 1 - Math.cos(k * Math.PI / 2);
        },
        Out: function(k) {
            return Math.sin(k * Math.PI / 2);
        },
        InOut: function(k) {
            return .5 * (1 - Math.cos(Math.PI * k));
        }
    },
    Exponential: {
        In: function(k) {
            return 0 === k ? 0 : Math.pow(1024, k - 1);
        },
        Out: function(k) {
            return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
        },
        InOut: function(k) {
            return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (2 - Math.pow(2, -10 * (k - 1)));
        }
    },
    Circular: {
        In: function(k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        Out: function(k) {
            return Math.sqrt(1 - --k * k);
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        }
    },
    Elastic: {
        In: function(k) {
            var s, a = .1;
            return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
            -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4));
        },
        Out: function(k) {
            var s, a = .1;
            return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
            a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / .4) + 1);
        },
        InOut: function(k) {
            var s, a = .1;
            return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
            (k *= 2) < 1 ? a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * -.5 : a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * .5 + 1);
        }
    },
    Back: {
        In: function(k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        },
        Out: function(k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        },
        InOut: function(k) {
            var s = 2.5949095;
            return (k *= 2) < 1 ? k * k * ((s + 1) * k - s) * .5 : .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        }
    },
    Bounce: {
        In: function(k) {
            return 1 - TWEEN.Easing.Bounce.Out(1 - k);
        },
        Out: function(k) {
            return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
        },
        InOut: function(k) {
            return k < .5 ? .5 * TWEEN.Easing.Bounce.In(2 * k) : .5 * TWEEN.Easing.Bounce.Out(2 * k - 1) + .5;
        }
    }
}, TWEEN.Interpolation = {
    Linear: function(v, k) {
        var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.Linear;
        return k < 0 ? fn(v[0], v[1], f) : k > 1 ? fn(v[m], v[m - 1], m - f) : fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function(v, k) {
        var i, b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein;
        for (i = 0; i <= n; i++) b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        return b;
    },
    CatmullRom: function(v, k) {
        var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.CatmullRom;
        return v[0] === v[m] ? (k < 0 && (i = Math.floor(f = m * (1 + k))), fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i)) : k < 0 ? v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]) : k > 1 ? v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]) : fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    },
    Utils: {
        Linear: function(p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function(n, i) {
            var fc = TWEEN.Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: function() {
            var a = [ 1 ];
            return function(n) {
                var i, s = 1;
                if (a[n]) return a[n];
                for (i = n; i > 1; i--) s *= i;
                return a[n] = s;
            };
        }(),
        CatmullRom: function(p0, p1, p2, p3, t) {
            var v0 = .5 * (p2 - p0), v1 = .5 * (p3 - p1), t2 = t * t;
            return (2 * p1 - 2 * p2 + v0 + v1) * (t * t2) + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
    }
}, function(root) {
    "function" == typeof define && define.amd ? define([], function() {
        return TWEEN;
    }) : "object" == typeof exports ? module.exports = TWEEN : root.TWEEN = TWEEN;
}(this), function() {
    var t = function(t) {
        this.data = new Uint8Array(t), this.pos = 0;
    };
    t.prototype.seek = function(t) {
        this.pos = t;
    }, t.prototype.writeBytes = function(t) {
        for (var e = 0; e < t.length; e++) this.data[this.pos++] = t[e];
    }, t.prototype.writeByte = function(t) {
        this.data[this.pos++] = t;
    }, t.prototype.writeU8 = t.prototype.writeByte, t.prototype.writeU16BE = function(t) {
        this.data[this.pos++] = t >> 8, this.data[this.pos++] = t;
    }, t.prototype.writeDoubleBE = function(t) {
        for (var e = new Uint8Array(new Float64Array([ t ]).buffer), n = e.length - 1; n >= 0; n--) this.writeByte(e[n]);
    }, t.prototype.writeFloatBE = function(t) {
        for (var e = new Uint8Array(new Float32Array([ t ]).buffer), n = e.length - 1; n >= 0; n--) this.writeByte(e[n]);
    }, t.prototype.writeString = function(t) {
        for (var e = 0; e < t.length; e++) this.data[this.pos++] = t.charCodeAt(e);
    }, t.prototype.writeEBMLVarIntWidth = function(t, e) {
        switch (e) {
          case 1:
            this.writeU8(128 | t);
            break;

          case 2:
            this.writeU8(64 | t >> 8), this.writeU8(t);
            break;

          case 3:
            this.writeU8(32 | t >> 16), this.writeU8(t >> 8), this.writeU8(t);
            break;

          case 4:
            this.writeU8(16 | t >> 24), this.writeU8(t >> 16), this.writeU8(t >> 8), this.writeU8(t);
            break;

          case 5:
            this.writeU8(8 | t / 4294967296 & 7), this.writeU8(t >> 24), this.writeU8(t >> 16), 
            this.writeU8(t >> 8), this.writeU8(t);
            break;

          default:
            throw new RuntimeException("Bad EBML VINT size " + e);
        }
    }, t.prototype.measureEBMLVarInt = function(t) {
        if (t < 127) return 1;
        if (t < 16383) return 2;
        if (t < 2097151) return 3;
        if (t < 268435455) return 4;
        if (t < 34359738367) return 5;
        throw new RuntimeException("EBML VINT size not supported " + t);
    }, t.prototype.writeEBMLVarInt = function(t) {
        this.writeEBMLVarIntWidth(t, this.measureEBMLVarInt(t));
    }, t.prototype.writeUnsignedIntBE = function(t, e) {
        switch (void 0 === e && (e = this.measureUnsignedInt(t)), e) {
          case 5:
            this.writeU8(Math.floor(t / 4294967296));

          case 4:
            this.writeU8(t >> 24);

          case 3:
            this.writeU8(t >> 16);

          case 2:
            this.writeU8(t >> 8);

          case 1:
            this.writeU8(t);
            break;

          default:
            throw new RuntimeException("Bad UINT size " + e);
        }
    }, t.prototype.measureUnsignedInt = function(t) {
        return t < 256 ? 1 : t < 65536 ? 2 : t < 1 << 24 ? 3 : t < 4294967296 ? 4 : 5;
    }, t.prototype.getAsDataArray = function() {
        if (this.pos < this.data.byteLength) return this.data.subarray(0, this.pos);
        if (this.pos == this.data.byteLength) return this.data;
        throw "ArrayBufferDataStream's pos lies beyond end of buffer";
    }, "undefined" != typeof module && void 0 !== module.exports ? module.exports = t : window.ArrayBufferDataStream = t;
}(), function() {
    var t = function(t) {
        return function(e) {
            function n(t) {
                return new Promise(function(e, n) {
                    var i = new FileReader();
                    i.addEventListener("loadend", function() {
                        e(i.result);
                    }), i.readAsArrayBuffer(t);
                });
            }
            function i(t) {
                return new Promise(function(e, i) {
                    e(t instanceof Uint8Array ? t : t instanceof ArrayBuffer || ArrayBuffer.isView(t) ? new Uint8Array(t) : t instanceof Blob ? n(t).then(function(t) {
                        return new Uint8Array(t);
                    }) : n(new Blob([ t ])).then(function(t) {
                        return new Uint8Array(t);
                    }));
                });
            }
            function r(t) {
                var e = t.byteLength || t.length || t.size;
                if (!Number.isInteger(e)) throw "Failed to determine size of element";
                return e;
            }
            var o = [], a = Promise.resolve(), s = null, h = null;
            "undefined" != typeof FileWriter && e instanceof FileWriter ? s = e : t && e && (h = e), 
            this.pos = 0, this.length = 0, this.seek = function(t) {
                if (t < 0) throw "Offset may not be negative";
                if (isNaN(t)) throw "Offset may not be NaN";
                if (t > this.length) throw "Seeking beyond the end of file is not allowed";
                this.pos = t;
            }, this.write = function(e) {
                var n = {
                    offset: this.pos,
                    data: e,
                    length: r(e)
                }, f = n.offset >= this.length;
                this.pos += n.length, this.length = Math.max(this.length, this.pos), a = a.then(function() {
                    if (h) return new Promise(function(e, r) {
                        i(n.data).then(function(i) {
                            var r = 0, o = Buffer.from(i.buffer), a = function(i, o, s) {
                                r += o, r >= s.length ? e() : t.write(h, s, r, s.length - r, n.offset + r, a);
                            };
                            t.write(h, o, 0, o.length, n.offset, a);
                        });
                    });
                    if (s) return new Promise(function(t, e) {
                        s.onwriteend = t, s.seek(n.offset), s.write(new Blob([ n.data ]));
                    });
                    if (!f) for (var e = 0; e < o.length; e++) {
                        var r = o[e];
                        if (!(n.offset + n.length <= r.offset || n.offset >= r.offset + r.length)) {
                            if (n.offset < r.offset || n.offset + n.length > r.offset + r.length) throw new Error("Overwrite crosses blob boundaries");
                            return n.offset == r.offset && n.length == r.length ? void (r.data = n.data) : i(r.data).then(function(t) {
                                return r.data = t, i(n.data);
                            }).then(function(t) {
                                n.data = t, r.data.set(n.data, n.offset - r.offset);
                            });
                        }
                    }
                    o.push(n);
                });
            }, this.complete = function(t) {
                return a = h || s ? a.then(function() {
                    return null;
                }) : a.then(function() {
                    for (var e = [], n = 0; n < o.length; n++) e.push(o[n].data);
                    return new Blob(e, {
                        mimeType: t
                    });
                });
            };
        };
    };
    "undefined" != typeof module && void 0 !== module.exports ? module.exports = t(require("fs")) : window.BlobBuffer = t(null);
}(), function() {
    var t = function(t, e) {
        function n(t, e) {
            var n = {};
            return [ t, e ].forEach(function(t) {
                for (var e in t) Object.prototype.hasOwnProperty.call(t, e) && (n[e] = t[e]);
            }), n;
        }
        function i(t) {
            return !("string" != typeof t || !t.match(/^data:image\/webp;base64,/i)) && window.atob(t.substring("data:image/webp;base64,".length));
        }
        function r(t, e) {
            return i(t.toDataURL("image/webp", {
                quality: e
            }));
        }
        function o(t) {
            var e = t.indexOf("VP8 ");
            if (-1 == e) throw "Failed to identify beginning of keyframe in WebP image";
            return e += "VP8 ".length + 4, t.substring(e);
        }
        function a(t) {
            this.value = t;
        }
        function s(t) {
            this.value = t;
        }
        function h(t, e, n) {
            if (Array.isArray(n)) for (var i = 0; i < n.length; i++) h(t, e, n[i]); else if ("string" == typeof n) t.writeString(n); else if (n instanceof Uint8Array) t.writeBytes(n); else {
                if (!n.id) throw "Bad EBML datatype " + typeof n.data;
                if (n.offset = t.pos + e, t.writeUnsignedIntBE(n.id), Array.isArray(n.data)) {
                    var r, o, f;
                    -1 === n.size ? t.writeByte(255) : (r = t.pos, t.writeBytes([ 0, 0, 0, 0 ])), o = t.pos, 
                    n.dataOffset = o + e, h(t, e, n.data), -1 !== n.size && (f = t.pos, n.size = f - o, 
                    t.seek(r), t.writeEBMLVarIntWidth(n.size, 4), t.seek(f));
                } else if ("string" == typeof n.data) t.writeEBMLVarInt(n.data.length), n.dataOffset = t.pos + e, 
                t.writeString(n.data); else if ("number" == typeof n.data) n.size || (n.size = t.measureUnsignedInt(n.data)), 
                t.writeEBMLVarInt(n.size), n.dataOffset = t.pos + e, t.writeUnsignedIntBE(n.data, n.size); else if (n.data instanceof s) t.writeEBMLVarInt(8), 
                n.dataOffset = t.pos + e, t.writeDoubleBE(n.data.value); else if (n.data instanceof a) t.writeEBMLVarInt(4), 
                n.dataOffset = t.pos + e, t.writeFloatBE(n.data.value); else {
                    if (!(n.data instanceof Uint8Array)) throw "Bad EBML datatype " + typeof n.data;
                    t.writeEBMLVarInt(n.data.byteLength), n.dataOffset = t.pos + e, t.writeBytes(n.data);
                }
            }
        }
        return function(i) {
            function a(t) {
                return t - B.dataOffset;
            }
            function f() {
                var t = {
                    id: 21420,
                    size: 5,
                    data: 0
                }, e = {
                    id: 290298740,
                    data: []
                };
                for (var n in F) {
                    var i = F[n];
                    i.positionEBML = Object.create(t), e.data.push({
                        id: 19899,
                        data: [ {
                            id: 21419,
                            data: i.id
                        }, i.positionEBML ]
                    });
                }
                return e;
            }
            function d() {
                E = f();
                var e = {
                    id: 440786851,
                    data: [ {
                        id: 17030,
                        data: 1
                    }, {
                        id: 17143,
                        data: 1
                    }, {
                        id: 17138,
                        data: 4
                    }, {
                        id: 17139,
                        data: 8
                    }, {
                        id: 17026,
                        data: "webm"
                    }, {
                        id: 17031,
                        data: 2
                    }, {
                        id: 17029,
                        data: 2
                    } ]
                }, n = {
                    id: 357149030,
                    data: [ {
                        id: 2807729,
                        data: 1e6
                    }, {
                        id: 19840,
                        data: "webm-writer-js"
                    }, {
                        id: 22337,
                        data: "webm-writer-js"
                    }, _ ]
                }, i = {
                    id: 374648427,
                    data: [ {
                        id: 174,
                        data: [ {
                            id: 215,
                            data: A
                        }, {
                            id: 29637,
                            data: A
                        }, {
                            id: 156,
                            data: 0
                        }, {
                            id: 2274716,
                            data: "und"
                        }, {
                            id: 134,
                            data: "V_VP8"
                        }, {
                            id: 2459272,
                            data: "VP8"
                        }, {
                            id: 131,
                            data: 1
                        }, {
                            id: 224,
                            data: [ {
                                id: 176,
                                data: b
                            }, {
                                id: 186,
                                data: k
                            } ]
                        } ]
                    } ]
                };
                B = {
                    id: 408125543,
                    size: -1,
                    data: [ E, n, i ]
                };
                var r = new t(256);
                h(r, C.pos, [ e, B ]), C.write(r.getAsDataArray()), F.SegmentInfo.positionEBML.data = a(n.offset), 
                F.Tracks.positionEBML.data = a(i.offset);
            }
            function u(e) {
                var n = new t(4);
                if (!(e.trackNumber > 0 && e.trackNumber < 127)) throw "TrackNumber must be > 0 and < 127";
                return n.writeEBMLVarInt(e.trackNumber), n.writeU16BE(e.timecode), n.writeByte(128), 
                {
                    id: 163,
                    data: [ n.getAsDataArray(), e.frame ]
                };
            }
            function c(t) {
                return {
                    id: 524531317,
                    data: [ {
                        id: 231,
                        data: Math.round(t.timecode)
                    } ]
                };
            }
            function l(t, e, n) {
                M.push({
                    id: 187,
                    data: [ {
                        id: 179,
                        data: e
                    }, {
                        id: 183,
                        data: [ {
                            id: 247,
                            data: t
                        }, {
                            id: 241,
                            data: a(n)
                        } ]
                    } ]
                });
            }
            function p() {
                var e = {
                    id: 475249515,
                    data: M
                }, n = new t(16 + 32 * M.length);
                h(n, C.pos, e), C.write(n.getAsDataArray()), F.Cues.positionEBML.data = a(e.offset);
            }
            function m() {
                if (0 != T.length) {
                    for (var e = 0, n = 0; n < T.length; n++) e += T[n].frame.length;
                    for (var i = new t(e + 32 * T.length), r = c({
                        timecode: Math.round(U)
                    }), n = 0; n < T.length; n++) r.data.push(u(T[n]));
                    h(i, C.pos, r), C.write(i.getAsDataArray()), l(A, Math.round(U), r.offset), T = [], 
                    U += I, I = 0;
                }
            }
            function g(t) {
                t.trackNumber = A, t.timecode = Math.round(I), T.push(t), (I += t.duration) >= x && m();
            }
            function y() {
                var e = new t(E.size), n = C.pos;
                h(e, E.dataOffset, E.data), C.seek(E.dataOffset), C.write(e.getAsDataArray()), C.seek(n);
            }
            function v() {
                var e = new t(8), n = C.pos;
                e.writeDoubleBE(U), C.seek(_.dataOffset), C.write(e.getAsDataArray()), C.seek(n);
            }
            var b, k, B, E, x = 5e3, A = 1, L = !1, T = [], U = 0, I = 0, D = {
                quality: .95,
                fileWriter: null,
                fd: null,
                frameDuration: null,
                frameRate: null
            }, F = {
                Cues: {
                    id: new Uint8Array([ 28, 83, 187, 107 ]),
                    positionEBML: null
                },
                SegmentInfo: {
                    id: new Uint8Array([ 21, 73, 169, 102 ]),
                    positionEBML: null
                },
                Tracks: {
                    id: new Uint8Array([ 22, 84, 174, 107 ]),
                    positionEBML: null
                }
            }, _ = {
                id: 17545,
                data: new s(0)
            }, M = [], C = new e(i.fileWriter || i.fd);
            this.addFrame = function(t) {
                if (L) {
                    if (t.width != b || t.height != k) throw "Frame size differs from previous frames";
                } else b = t.width, k = t.height, d(), L = !0;
                var e = r(t, {
                    quality: i.quality
                });
                if (!e) throw "Couldn't decode WebP frame, does the browser support WebP?";
                g({
                    frame: o(e),
                    duration: i.frameDuration
                });
            }, this.complete = function() {
                return m(), p(), y(), v(), C.complete("video/webm");
            }, this.getWrittenSize = function() {
                return C.length;
            }, i = n(D, i || {}), function() {
                if (!i.frameDuration) {
                    if (!i.frameRate) throw "Missing required frameDuration or frameRate setting";
                    i.frameDuration = 1e3 / i.frameRate;
                }
            }();
        };
    };
    "undefined" != typeof module && void 0 !== module.exports ? module.exports = t(require("./ArrayBufferDataStream"), require("./BlobBuffer")) : window.WebMWriter = t(ArrayBufferDataStream, BlobBuffer);
}(), function() {
    function t(t) {
        var e, n = new Uint8Array(t);
        for (e = 0; e < t; e += 1) n[e] = 0;
        return n;
    }
    function e(e, n, i, r) {
        var o = n + i, a = t((parseInt(o / r) + 1) * r);
        return a.set(e), a;
    }
    function n(t, e, n) {
        return t = t.toString(n || 8), "000000000000".substr(t.length + 12 - e) + t;
    }
    function i(e, n, i) {
        var r, o;
        for (n = n || t(e.length), i = i || 0, r = 0, o = e.length; r < o; r += 1) n[i] = e.charCodeAt(r), 
        i += 1;
        return n;
    }
    function r(t) {
        var n, i, r, a = t.length % 3, s = "";
        for (n = 0, r = t.length - a; n < r; n += 3) i = (t[n] << 16) + (t[n + 1] << 8) + t[n + 2], 
        s += function(t) {
            return o[t >> 18 & 63] + o[t >> 12 & 63] + o[t >> 6 & 63] + o[63 & t];
        }(i);
        switch (s.length % 4) {
          case 1:
            s += "=";
            break;

          case 2:
            s += "==";
        }
        return s;
    }
    var o = [ "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/" ];
    window.utils = {}, window.utils.clean = t, window.utils.pad = n, window.utils.extend = e, 
    window.utils.stringToUint8 = i, window.utils.uint8ToBase64 = r;
}(), function() {
    function t(t, i) {
        var r = n.clean(512), o = 0;
        return e.forEach(function(e) {
            var n, i, a = t[e.field] || "";
            for (n = 0, i = a.length; n < i; n += 1) r[o] = a.charCodeAt(n), o += 1;
            o += e.length - n;
        }), "function" == typeof i ? i(r, o) : r;
    }
    var e, n = window.utils;
    e = [ {
        field: "fileName",
        length: 100
    }, {
        field: "fileMode",
        length: 8
    }, {
        field: "uid",
        length: 8
    }, {
        field: "gid",
        length: 8
    }, {
        field: "fileSize",
        length: 12
    }, {
        field: "mtime",
        length: 12
    }, {
        field: "checksum",
        length: 8
    }, {
        field: "type",
        length: 1
    }, {
        field: "linkName",
        length: 100
    }, {
        field: "ustar",
        length: 8
    }, {
        field: "owner",
        length: 32
    }, {
        field: "group",
        length: 32
    }, {
        field: "majorNumber",
        length: 8
    }, {
        field: "minorNumber",
        length: 8
    }, {
        field: "filenamePrefix",
        length: 155
    }, {
        field: "padding",
        length: 12
    } ], window.header = {}, window.header.structure = e, window.header.format = t;
}(), function() {
    function t(t) {
        this.written = 0, e = (t || 20) * r, this.out = i.clean(e), this.blocks = [], this.length = 0;
    }
    var e, n = window.header, i = window.utils, r = 512;
    t.prototype.append = function(t, e, o, a) {
        var s, h, f, d, u, c, l;
        if ("string" == typeof e) e = i.stringToUint8(e); else if (e.constructor !== Uint8Array.prototype.constructor) throw "Invalid input type. You gave me: " + e.constructor.toString().match(/function\s*([$A-Za-z_][0-9A-Za-z_]*)\s*\(/)[1];
        "function" == typeof o && (o, o = {}), o = o || {}, f = o.mode || 4095 & parseInt("777", 8), 
        d = o.mtime || Math.floor(+new Date() / 1e3), u = o.uid || 0, c = o.gid || 0, s = {
            fileName: t,
            fileMode: i.pad(f, 7),
            uid: i.pad(u, 7),
            gid: i.pad(c, 7),
            fileSize: i.pad(e.length, 11),
            mtime: i.pad(d, 11),
            checksum: "        ",
            type: "0",
            ustar: "ustar  ",
            owner: o.owner || "",
            group: o.group || ""
        }, h = 0, Object.keys(s).forEach(function(t) {
            var e, n, i = s[t];
            for (e = 0, n = i.length; e < n; e += 1) h += i.charCodeAt(e);
        }), s.checksum = i.pad(h, 6) + "\0 ", l = n.format(s);
        var p = Math.ceil(l.length / r) * r, m = Math.ceil(e.length / r) * r;
        this.blocks.push({
            header: l,
            input: e,
            headerLength: p,
            inputLength: m
        });
    }, t.prototype.save = function() {
        var t = [], e = [], n = 0, i = Math.pow(2, 20), o = [];
        return this.blocks.forEach(function(t) {
            n + t.headerLength + t.inputLength > i && (e.push({
                blocks: o,
                length: n
            }), o = [], n = 0), o.push(t), n += t.headerLength + t.inputLength;
        }), e.push({
            blocks: o,
            length: n
        }), e.forEach(function(e) {
            var n = new Uint8Array(e.length), i = 0;
            e.blocks.forEach(function(t) {
                n.set(t.header, i), i += t.headerLength, n.set(t.input, i), i += t.inputLength;
            }), t.push(n);
        }), t.push(new Uint8Array(2 * r)), new Blob(t, {
            type: "octet/stream"
        });
    }, t.prototype.clear = function() {
        this.written = 0, this.out = i.clean(e);
    }, window.Tar = t;
}(), function(t) {
    function e(t, n) {
        if ({}.hasOwnProperty.call(e.cache, t)) return e.cache[t];
        var i = e.resolve(t);
        if (!i) throw new Error("Failed to resolve module " + t);
        var r = {
            id: t,
            require: e,
            filename: t,
            exports: {},
            loaded: !1,
            parent: n,
            children: []
        };
        n && n.children.push(r);
        var o = t.slice(0, t.lastIndexOf("/") + 1);
        return e.cache[t] = r.exports, i.call(r.exports, r, r.exports, o, t), r.loaded = !0, 
        e.cache[t] = r.exports;
    }
    e.modules = {}, e.cache = {}, e.resolve = function(t) {
        return {}.hasOwnProperty.call(e.modules, t) ? e.modules[t] : void 0;
    }, e.define = function(t, n) {
        e.modules[t] = n;
    };
    var n = function(e) {
        return e = "/", {
            title: "browser",
            version: "v0.10.26",
            browser: !0,
            env: {},
            argv: [],
            nextTick: t.setImmediate || function(t) {
                setTimeout(t, 0);
            },
            cwd: function() {
                return e;
            },
            chdir: function(t) {
                e = t;
            }
        };
    }();
    e.define("/gif.coffee", function(t, n, i, r) {
        function o(t, e) {
            return {}.hasOwnProperty.call(t, e);
        }
        function a(t, e) {
            for (var n = 0, i = e.length; n < i; ++n) if (n in e && e[n] === t) return !0;
            return !1;
        }
        function s(t, e) {
            function n() {
                this.constructor = t;
            }
            for (var i in e) o(e, i) && (t[i] = e[i]);
            return n.prototype = e.prototype, t.prototype = new n(), t.__super__ = e.prototype, 
            t;
        }
        var h, f, d, u, c;
        d = e("events", t).EventEmitter, h = e("/browser.coffee", t), c = function(t) {
            function e(t) {
                var e, n;
                this.running = !1, this.options = {}, this.frames = [], this.freeWorkers = [], this.activeWorkers = [], 
                this.setOptions(t);
                for (e in f) n = f[e], null != this.options[e] ? this.options[e] : this.options[e] = n;
            }
            return s(e, t), f = {
                workerScript: "gif.worker.js",
                workers: 2,
                repeat: 0,
                background: "#fff",
                quality: 10,
                width: null,
                height: null,
                transparent: null
            }, u = {
                delay: 500,
                copy: !1
            }, e.prototype.setOption = function(t, e) {
                return this.options[t] = e, null == this._canvas || "width" !== t && "height" !== t ? void 0 : this._canvas[t] = e;
            }, e.prototype.setOptions = function(t) {
                var e, n;
                return function(i) {
                    for (e in t) o(t, e) && (n = t[e], i.push(this.setOption(e, n)));
                    return i;
                }.call(this, []);
            }, e.prototype.addFrame = function(t, e) {
                var n, i;
                null == e && (e = {}), n = {}, n.transparent = this.options.transparent;
                for (i in u) n[i] = e[i] || u[i];
                if (null != this.options.width || this.setOption("width", t.width), null != this.options.height || this.setOption("height", t.height), 
                "undefined" != typeof ImageData && null != ImageData && t instanceof ImageData) n.data = t.data; else if ("undefined" != typeof CanvasRenderingContext2D && null != CanvasRenderingContext2D && t instanceof CanvasRenderingContext2D || "undefined" != typeof WebGLRenderingContext && null != WebGLRenderingContext && t instanceof WebGLRenderingContext) e.copy ? n.data = this.getContextData(t) : n.context = t; else {
                    if (null == t.childNodes) throw new Error("Invalid image");
                    e.copy ? n.data = this.getImageData(t) : n.image = t;
                }
                return this.frames.push(n);
            }, e.prototype.render = function() {
                var t, e;
                if (this.running) throw new Error("Already running");
                if (null == this.options.width || null == this.options.height) throw new Error("Width and height must be set prior to rendering");
                this.running = !0, this.nextFrame = 0, this.finishedFrames = 0, this.imageParts = function(e) {
                    for (var n = function() {
                        var t;
                        t = [];
                        for (var e = 0; 0 <= this.frames.length ? e < this.frames.length : e > this.frames.length; 0 <= this.frames.length ? ++e : --e) t.push(e);
                        return t;
                    }.apply(this, arguments), i = 0, r = n.length; i < r; ++i) t = n[i], e.push(null);
                    return e;
                }.call(this, []), e = this.spawnWorkers();
                for (var n = function() {
                    var t;
                    t = [];
                    for (var n = 0; 0 <= e ? n < e : n > e; 0 <= e ? ++n : --n) t.push(n);
                    return t;
                }.apply(this, arguments), i = 0, r = n.length; i < r; ++i) t = n[i], this.renderNextFrame();
                return this.emit("start"), this.emit("progress", 0);
            }, e.prototype.abort = function() {
                for (var t; null != (t = this.activeWorkers.shift()); ) console.log("killing active worker"), 
                t.terminate();
                return this.running = !1, this.emit("abort");
            }, e.prototype.spawnWorkers = function() {
                var t;
                return t = Math.min(this.options.workers, this.frames.length), function() {
                    var e;
                    e = [];
                    for (var n = this.freeWorkers.length; this.freeWorkers.length <= t ? n < t : n > t; this.freeWorkers.length <= t ? ++n : --n) e.push(n);
                    return e;
                }.apply(this, arguments).forEach(function(t) {
                    return function(e) {
                        var n;
                        return console.log("spawning worker " + e), n = new Worker(t.options.workerScript), 
                        n.onmessage = function(t) {
                            return function(e) {
                                return t.activeWorkers.splice(t.activeWorkers.indexOf(n), 1), t.freeWorkers.push(n), 
                                t.frameFinished(e.data);
                            };
                        }(t), t.freeWorkers.push(n);
                    };
                }(this)), t;
            }, e.prototype.frameFinished = function(t) {
                return console.log("frame " + t.index + " finished - " + this.activeWorkers.length + " active"), 
                this.finishedFrames++, this.emit("progress", this.finishedFrames / this.frames.length), 
                this.imageParts[t.index] = t, a(null, this.imageParts) ? this.renderNextFrame() : this.finishRendering();
            }, e.prototype.finishRendering = function() {
                var t, e, n, i, r, o, a;
                r = 0;
                for (var s = 0, h = this.imageParts.length; s < h; ++s) e = this.imageParts[s], 
                r += (e.data.length - 1) * e.pageSize + e.cursor;
                r += e.pageSize - e.cursor, console.log("rendering finished - filesize " + Math.round(r / 1e3) + "kb"), 
                t = new Uint8Array(r), o = 0;
                for (var f = 0, d = this.imageParts.length; f < d; ++f) {
                    e = this.imageParts[f];
                    for (var u = 0, c = e.data.length; u < c; ++u) a = e.data[u], n = u, t.set(a, o), 
                    o += n === e.data.length - 1 ? e.cursor : e.pageSize;
                }
                return i = new Blob([ t ], {
                    type: "image/gif"
                }), this.emit("finished", i, t);
            }, e.prototype.renderNextFrame = function() {
                var t, e, n;
                if (0 === this.freeWorkers.length) throw new Error("No free workers");
                return this.nextFrame >= this.frames.length ? void 0 : (t = this.frames[this.nextFrame++], 
                n = this.freeWorkers.shift(), e = this.getTask(t), console.log("starting frame " + (e.index + 1) + " of " + this.frames.length), 
                this.activeWorkers.push(n), n.postMessage(e));
            }, e.prototype.getContextData = function(t) {
                return t.getImageData(0, 0, this.options.width, this.options.height).data;
            }, e.prototype.getImageData = function(t) {
                var e;
                return null != this._canvas || (this._canvas = document.createElement("canvas"), 
                this._canvas.width = this.options.width, this._canvas.height = this.options.height), 
                e = this._canvas.getContext("2d"), e.setFill = this.options.background, e.fillRect(0, 0, this.options.width, this.options.height), 
                e.drawImage(t, 0, 0), this.getContextData(e);
            }, e.prototype.getTask = function(t) {
                var e, n;
                if (e = this.frames.indexOf(t), n = {
                    index: e,
                    last: e === this.frames.length - 1,
                    delay: t.delay,
                    transparent: t.transparent,
                    width: this.options.width,
                    height: this.options.height,
                    quality: this.options.quality,
                    repeat: this.options.repeat,
                    canTransfer: "chrome" === h.name
                }, null != t.data) n.data = t.data; else if (null != t.context) n.data = this.getContextData(t.context); else {
                    if (null == t.image) throw new Error("Invalid frame");
                    n.data = this.getImageData(t.image);
                }
                return n;
            }, e;
        }(d), t.exports = c;
    }), e.define("/browser.coffee", function(t, e, n, i) {
        var r, o, a, s, h;
        s = navigator.userAgent.toLowerCase(), a = navigator.platform.toLowerCase(), h = s.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/) || [ null, "unknown", 0 ], 
        o = "ie" === h[1] && document.documentMode, r = {
            name: "version" === h[1] ? h[3] : h[1],
            version: o || parseFloat("opera" === h[1] && h[4] ? h[4] : h[2]),
            platform: {
                name: s.match(/ip(?:ad|od|hone)/) ? "ios" : (s.match(/(?:webos|android)/) || a.match(/mac|win|linux/) || [ "other" ])[0]
            }
        }, r[r.name] = !0, r[r.name + parseInt(r.version, 10)] = !0, r.platform[r.platform.name] = !0, 
        t.exports = r;
    }), e.define("events", function(t, e, i, r) {
        n.EventEmitter || (n.EventEmitter = function() {});
        var o = e.EventEmitter = n.EventEmitter, a = "function" == typeof Array.isArray ? Array.isArray : function(t) {
            return "[object Array]" === Object.prototype.toString.call(t);
        };
        o.prototype.setMaxListeners = function(t) {
            this._events || (this._events = {}), this._events.maxListeners = t;
        }, o.prototype.emit = function(t) {
            if ("error" === t && (!this._events || !this._events.error || a(this._events.error) && !this._events.error.length)) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
            if (!this._events) return !1;
            var e = this._events[t];
            if (!e) return !1;
            if ("function" != typeof e) {
                if (a(e)) {
                    for (var n = Array.prototype.slice.call(arguments, 1), i = e.slice(), r = 0, o = i.length; r < o; r++) i[r].apply(this, n);
                    return !0;
                }
                return !1;
            }
            switch (arguments.length) {
              case 1:
                e.call(this);
                break;

              case 2:
                e.call(this, arguments[1]);
                break;

              case 3:
                e.call(this, arguments[1], arguments[2]);
                break;

              default:
                var n = Array.prototype.slice.call(arguments, 1);
                e.apply(this, n);
            }
            return !0;
        }, o.prototype.addListener = function(t, e) {
            if ("function" != typeof e) throw new Error("addListener only takes instances of Function");
            if (this._events || (this._events = {}), this.emit("newListener", t, e), this._events[t]) if (a(this._events[t])) {
                if (!this._events[t].warned) {
                    var n;
                    (n = void 0 !== this._events.maxListeners ? this._events.maxListeners : 10) && n > 0 && this._events[t].length > n && (this._events[t].warned = !0, 
                    console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[t].length), 
                    console.trace());
                }
                this._events[t].push(e);
            } else this._events[t] = [ this._events[t], e ]; else this._events[t] = e;
            return this;
        }, o.prototype.on = o.prototype.addListener, o.prototype.once = function(t, e) {
            var n = this;
            return n.on(t, function i() {
                n.removeListener(t, i), e.apply(this, arguments);
            }), this;
        }, o.prototype.removeListener = function(t, e) {
            if ("function" != typeof e) throw new Error("removeListener only takes instances of Function");
            if (!this._events || !this._events[t]) return this;
            var n = this._events[t];
            if (a(n)) {
                var i = n.indexOf(e);
                if (i < 0) return this;
                n.splice(i, 1), 0 == n.length && delete this._events[t];
            } else this._events[t] === e && delete this._events[t];
            return this;
        }, o.prototype.removeAllListeners = function(t) {
            return t && this._events && this._events[t] && (this._events[t] = null), this;
        }, o.prototype.listeners = function(t) {
            return this._events || (this._events = {}), this._events[t] || (this._events[t] = []), 
            a(this._events[t]) || (this._events[t] = [ this._events[t] ]), this._events[t];
        };
    }), t.GIF = e("/gif.coffee");
}.call(this, this), function() {
    function t(t) {
        return t && t.Object === Object ? t : null;
    }
    function e(t) {
        return String("0000000" + t).slice(-7);
    }
    function n() {
        function t() {
            return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
        }
        return t() + t() + "-" + t() + "-" + t() + "-" + t() + "-" + t() + t() + t();
    }
    function i(t) {
        var e = {};
        this.settings = t, this.on = function(t, n) {
            e[t] = n;
        }, this.emit = function(t) {
            var n = e[t];
            n && n.apply(null, Array.prototype.slice.call(arguments, 1));
        }, this.filename = t.name || n(), this.extension = "", this.mimeType = "";
    }
    function r(t) {
        i.call(this, t), this.extension = ".tar", this.mimeType = "application/x-tar", this.fileExtension = "", 
        this.tape = null, this.count = 0;
    }
    function o(t) {
        r.call(this, t), this.type = "image/png", this.fileExtension = ".png";
    }
    function a(t) {
        r.call(this, t), this.type = "image/jpeg", this.fileExtension = ".jpg", this.quality = t.quality / 100 || .8;
    }
    function s(t) {
        "image/webp" !== document.createElement("canvas").toDataURL("image/webp").substr(5, 10) && console.log("WebP not supported - try another export format"), 
        i.call(this, t), this.quality = t.quality / 100 || .8, this.extension = ".webm", 
        this.mimeType = "video/webm", this.baseFilename = this.filename, this.frames = [], 
        this.part = 1, this.videoWriter = new WebMWriter({
            quality: this.quality,
            fileWriter: null,
            fd: null,
            frameRate: t.framerate
        });
    }
    function h(t) {
        i.call(this, t), t.quality = t.quality / 100 || .8, this.encoder = new FFMpegServer.Video(t), 
        this.encoder.on("process", function() {
            this.emit("process");
        }.bind(this)), this.encoder.on("finished", function(t, e) {
            var n = this.callback;
            n && (this.callback = void 0, n(t, e));
        }.bind(this)), this.encoder.on("progress", function(t) {
            this.settings.onProgress && this.settings.onProgress(t);
        }.bind(this)), this.encoder.on("error", function(t) {
            alert(JSON.stringify(t, null, 2));
        }.bind(this));
    }
    function f(t) {
        i.call(this, t), this.framerate = this.settings.framerate, this.type = "video/webm", 
        this.extension = ".webm", this.stream = null, this.mediaRecorder = null, this.chunks = [];
    }
    function d(t) {
        i.call(this, t), t.quality = 31 - (30 * t.quality / 100 || 10), t.workers = t.workers || 4, 
        this.extension = ".gif", this.mimeType = "image/gif", this.canvas = document.createElement("canvas"), 
        this.ctx = this.canvas.getContext("2d"), this.sizeSet = !1, this.encoder = new GIF({
            workers: t.workers,
            quality: t.quality,
            workerScript: t.workersPath + "gif.worker.js"
        }), this.encoder.on("progress", function(t) {
            this.settings.onProgress && this.settings.onProgress(t);
        }.bind(this)), this.encoder.on("finished", function(t) {
            var e = this.callback;
            e && (this.callback = void 0, e(t));
        }.bind(this));
    }
    function u(t) {
        function e() {
            function t() {
                return this._hooked || (this._hooked = !0, this._hookedTime = this.currentTime || 0, 
                this.pause(), nt.push(this)), this._hookedTime + _.startTime;
            }
            b("Capturer start"), U = window.Date.now(), T = U + _.startTime, D = window.performance.now(), 
            I = D + _.startTime, window.Date.prototype.getTime = function() {
                return T;
            }, window.Date.now = function() {
                return T;
            }, window.setTimeout = function(t, e) {
                var n = {
                    callback: t,
                    time: e,
                    triggerTime: T + e
                };
                return M.push(n), b("Timeout set to " + n.time), n;
            }, window.clearTimeout = function(t) {
                for (var e = 0; e < M.length; e++) M[e] != t || (M.splice(e, 1), b("Timeout cleared"));
            }, window.setInterval = function(t, e) {
                var n = {
                    callback: t,
                    time: e,
                    triggerTime: T + e
                };
                return C.push(n), b("Interval set to " + n.time), n;
            }, window.clearInterval = function(t) {
                return b("clear Interval"), null;
            }, window.requestAnimationFrame = function(t) {
                W.push(t);
            }, window.performance.now = function() {
                return I;
            };
            try {
                Object.defineProperty(HTMLVideoElement.prototype, "currentTime", {
                    get: t
                }), Object.defineProperty(HTMLAudioElement.prototype, "currentTime", {
                    get: t
                });
            } catch (t) {
                b(t);
            }
        }
        function n() {
            e(), F.start(), R = !0;
        }
        function i() {
            R = !1, F.stop(), c();
        }
        function r(t, e) {
            Z(t, 0, e);
        }
        function u() {
            r(y);
        }
        function c() {
            b("Capturer stop"), window.setTimeout = Z, window.setInterval = J, window.clearInterval = Y, 
            window.clearTimeout = $, window.requestAnimationFrame = Q, window.Date.prototype.getTime = et, 
            window.Date.now = X, window.performance.now = tt;
        }
        function l() {
            var t = S / _.framerate;
            (_.frameLimit && S >= _.frameLimit || _.timeLimit && t >= _.timeLimit) && (i(), 
            v());
            var e = new Date(null);
            e.setSeconds(t), _.motionBlurFrames > 2 ? j.textContent = "CCapture " + _.format + " | " + S + " frames (" + O + " inter) | " + e.toISOString().substr(11, 8) : j.textContent = "CCapture " + _.format + " | " + S + " frames | " + e.toISOString().substr(11, 8);
        }
        function p(t) {
            N.width === t.width && N.height === t.height || (N.width = t.width, N.height = t.height, 
            z = new Uint16Array(N.height * N.width * 4), V.fillStyle = "#0", V.fillRect(0, 0, N.width, N.height));
        }
        function m(t) {
            V.drawImage(t, 0, 0), q = V.getImageData(0, 0, N.width, N.height);
            for (var e = 0; e < z.length; e += 4) z[e] += q.data[e], z[e + 1] += q.data[e + 1], 
            z[e + 2] += q.data[e + 2];
            O++;
        }
        function w() {
            for (var t = q.data, e = 0; e < z.length; e += 4) t[e] = 2 * z[e] / _.motionBlurFrames, 
            t[e + 1] = 2 * z[e + 1] / _.motionBlurFrames, t[e + 2] = 2 * z[e + 2] / _.motionBlurFrames;
            V.putImageData(q, 0, 0), F.add(N), S++, O = 0, b("Full MB Frame! " + S + " " + T);
            for (var e = 0; e < z.length; e += 4) z[e] = 0, z[e + 1] = 0, z[e + 2] = 0;
            gc();
        }
        function g(t) {
            R && (_.motionBlurFrames > 2 ? (p(t), m(t), O >= .5 * _.motionBlurFrames ? w() : u()) : (F.add(t), 
            S++, b("Full Frame! " + S)));
        }
        function y() {
            var t = 1e3 / _.framerate, e = (S + O / _.motionBlurFrames) * t;
            T = U + e, I = D + e, nt.forEach(function(t) {
                t._hookedTime = e / 1e3;
            }), l(), b("Frame: " + S + " " + O);
            for (var n = 0; n < M.length; n++) T >= M[n].triggerTime && (r(M[n].callback), M.splice(n, 1));
            for (var n = 0; n < C.length; n++) T >= C[n].triggerTime && (r(C[n].callback), C[n].triggerTime += C[n].time);
            W.forEach(function(t) {
                r(t, T - k);
            }), W = [];
        }
        function v(t) {
            t || (t = function(t) {
                return download(t, F.filename + F.extension, F.mimeType), !1;
            }), F.save(t);
        }
        function b(t) {
            A && console.log(t);
        }
        function B(t, e) {
            P[t] = e;
        }
        function E(t) {
            var e = P[t];
            e && e.apply(null, Array.prototype.slice.call(arguments, 1));
        }
        function x(t) {
            E("progress", t);
        }
        var A, T, U, I, D, u, F, _ = t || {}, M = (new Date(), []), C = [], S = 0, O = 0, W = [], R = !1, P = {};
        _.framerate = _.framerate || 60, _.motionBlurFrames = 2 * (_.motionBlurFrames || 1), 
        A = _.verbose || !1, _.display || !1, _.step = 1e3 / _.framerate, _.timeLimit = _.timeLimit || 0, 
        _.frameLimit = _.frameLimit || 0, _.startTime = _.startTime || 0;
        var j = document.createElement("div");
        j.style.position = "absolute", j.style.left = j.style.top = 0, j.style.backgroundColor = "black", 
        j.style.fontFamily = "monospace", j.style.fontSize = "11px", j.style.padding = "5px", 
        j.style.color = "red", j.style.zIndex = 1e5, _.display && document.body.appendChild(j);
        var z, q, N = document.createElement("canvas"), V = N.getContext("2d");
        b("Step is set to " + _.step + "ms");
        var G = {
            gif: d,
            webm: s,
            ffmpegserver: h,
            png: o,
            jpg: a,
            "webm-mediarecorder": f
        }, H = G[_.format];
        if (!H) throw "Error: Incorrect or missing format: Valid formats are " + Object.keys(G).join(", ");
        if (F = new H(_), F.step = u, F.on("process", y), F.on("progress", x), "performance" in window == 0 && (window.performance = {}), 
        Date.now = Date.now || function() {
            return new Date().getTime();
        }, "now" in window.performance == 0) {
            var K = Date.now();
            performance.timing && performance.timing.navigationStart && (K = performance.timing.navigationStart), 
            window.performance.now = function() {
                return Date.now() - K;
            };
        }
        var Z = window.setTimeout, J = window.setInterval, Y = window.clearInterval, $ = window.clearTimeout, Q = window.requestAnimationFrame, X = window.Date.now, tt = window.performance.now, et = window.Date.prototype.getTime, nt = [];
        return {
            start: n,
            capture: g,
            stop: i,
            save: v,
            on: B
        };
    }
    var c = {
        function: !0,
        object: !0
    }, l = (parseFloat, parseInt, c[typeof exports] && exports && !exports.nodeType ? exports : void 0), p = c[typeof module] && module && !module.nodeType ? module : void 0, m = p && p.exports === l ? l : void 0, w = t(l && p && "object" == typeof global && global), g = t(c[typeof self] && self), y = t(c[typeof window] && window), v = t(c[typeof this] && this), b = w || y !== (v && v.window) && y || g || v || Function("return this")();
    "gc" in window || (window.gc = function() {}), HTMLCanvasElement.prototype.toBlob || Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
        value: function(t, e, n) {
            for (var i = atob(this.toDataURL(e, n).split(",")[1]), r = i.length, o = new Uint8Array(r), a = 0; a < r; a++) o[a] = i.charCodeAt(a);
            t(new Blob([ o ], {
                type: e || "image/png"
            }));
        }
    }), function() {
        if ("performance" in window == 0 && (window.performance = {}), Date.now = Date.now || function() {
            return new Date().getTime();
        }, "now" in window.performance == 0) {
            var t = Date.now();
            performance.timing && performance.timing.navigationStart && (t = performance.timing.navigationStart), 
            window.performance.now = function() {
                return Date.now() - t;
            };
        }
    }();
    var k = window.Date.now();
    i.prototype.start = function() {}, i.prototype.stop = function() {}, i.prototype.add = function() {}, 
    i.prototype.save = function() {}, i.prototype.dispose = function() {}, i.prototype.safeToProceed = function() {
        return !0;
    }, i.prototype.step = function() {
        console.log("Step not set!");
    }, r.prototype = Object.create(i.prototype), r.prototype.start = function() {
        this.dispose();
    }, r.prototype.add = function(t) {
        var n = new FileReader();
        n.onload = function() {
            this.tape.append(e(this.count) + this.fileExtension, new Uint8Array(n.result)), 
            this.count++, this.step();
        }.bind(this), n.readAsArrayBuffer(t);
    }, r.prototype.save = function(t) {
        t(this.tape.save());
    }, r.prototype.dispose = function() {
        this.tape = new Tar(), this.count = 0;
    }, o.prototype = Object.create(r.prototype), o.prototype.add = function(t) {
        t.toBlob(function(t) {
            r.prototype.add.call(this, t);
        }.bind(this), this.type);
    }, a.prototype = Object.create(r.prototype), a.prototype.add = function(t) {
        t.toBlob(function(t) {
            r.prototype.add.call(this, t);
        }.bind(this), this.type, this.quality);
    }, s.prototype = Object.create(i.prototype), s.prototype.start = function(t) {
        this.dispose();
    }, s.prototype.add = function(t) {
        this.videoWriter.addFrame(t), this.settings.autoSaveTime > 0 && this.frames.length / this.settings.framerate >= this.settings.autoSaveTime ? this.save(function(t) {
            this.filename = this.baseFilename + "-part-" + e(this.part), download(t, this.filename + this.extension, this.mimeType), 
            this.dispose(), this.part++, this.filename = this.baseFilename + "-part-" + e(this.part), 
            this.step();
        }.bind(this)) : this.step();
    }, s.prototype.save = function(t) {
        this.videoWriter.complete().then(t);
    }, s.prototype.dispose = function(t) {
        this.frames = [];
    }, h.prototype = Object.create(i.prototype), h.prototype.start = function() {
        this.encoder.start(this.settings);
    }, h.prototype.add = function(t) {
        this.encoder.add(t);
    }, h.prototype.save = function(t) {
        this.callback = t, this.encoder.end();
    }, h.prototype.safeToProceed = function() {
        return this.encoder.safeToProceed();
    }, f.prototype = Object.create(i.prototype), f.prototype.add = function(t) {
        this.stream || (this.stream = t.captureStream(this.framerate), this.mediaRecorder = new MediaRecorder(this.stream), 
        this.mediaRecorder.start(), this.mediaRecorder.ondataavailable = function(t) {
            this.chunks.push(t.data);
        }.bind(this)), this.step();
    }, f.prototype.save = function(t) {
        this.mediaRecorder.onstop = function(e) {
            var n = new Blob(this.chunks, {
                type: "video/webm"
            });
            this.chunks = [], t(n);
        }.bind(this), this.mediaRecorder.stop();
    }, d.prototype = Object.create(i.prototype), d.prototype.add = function(t) {
        this.sizeSet || (this.encoder.setOption("width", t.width), this.encoder.setOption("height", t.height), 
        this.sizeSet = !0), this.canvas.width = t.width, this.canvas.height = t.height, 
        this.ctx.drawImage(t, 0, 0), this.encoder.addFrame(this.ctx, {
            copy: !0,
            delay: this.settings.step
        }), this.step();
    }, d.prototype.save = function(t) {
        this.callback = t, this.encoder.render();
    }, (y || g || {}).CCapture = u, "function" == typeof define && "object" == typeof define.amd && define.amd ? define(function() {
        return u;
    }) : l && p ? (m && ((p.exports = u).CCapture = u), l.CCapture = u) : b.CCapture = u;
}(), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? factory(exports) : "function" == typeof define && define.amd ? define([ "exports" ], factory) : factory(global.THREE = global.THREE || {});
}(this, function(exports) {
    function EventDispatcher() {}
    function Vector2(x, y) {
        this.x = x || 0, this.y = y || 0;
    }
    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        Object.defineProperty(this, "id", {
            value: textureId++
        }), this.uuid = _Math.generateUUID(), this.name = "", this.image = void 0 !== image ? image : Texture.DEFAULT_IMAGE, 
        this.mipmaps = [], this.mapping = void 0 !== mapping ? mapping : Texture.DEFAULT_MAPPING, 
        this.wrapS = void 0 !== wrapS ? wrapS : ClampToEdgeWrapping, this.wrapT = void 0 !== wrapT ? wrapT : ClampToEdgeWrapping, 
        this.magFilter = void 0 !== magFilter ? magFilter : LinearFilter, this.minFilter = void 0 !== minFilter ? minFilter : LinearMipMapLinearFilter, 
        this.anisotropy = void 0 !== anisotropy ? anisotropy : 1, this.format = void 0 !== format ? format : RGBAFormat, 
        this.type = void 0 !== type ? type : UnsignedByteType, this.offset = new Vector2(0, 0), 
        this.repeat = new Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, 
        this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== encoding ? encoding : LinearEncoding, 
        this.version = 0, this.onUpdate = null;
    }
    function Vector4(x, y, z, w) {
        this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = void 0 !== w ? w : 1;
    }
    function WebGLRenderTarget(width, height, options) {
        this.uuid = _Math.generateUUID(), this.width = width, this.height = height, this.scissor = new Vector4(0, 0, width, height), 
        this.scissorTest = !1, this.viewport = new Vector4(0, 0, width, height), options = options || {}, 
        void 0 === options.minFilter && (options.minFilter = LinearFilter), this.texture = new Texture(void 0, void 0, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding), 
        this.depthBuffer = void 0 === options.depthBuffer || options.depthBuffer, this.stencilBuffer = void 0 === options.stencilBuffer || options.stencilBuffer, 
        this.depthTexture = void 0 !== options.depthTexture ? options.depthTexture : null;
    }
    function WebGLRenderTargetCube(width, height, options) {
        WebGLRenderTarget.call(this, width, height, options), this.activeCubeFace = 0, this.activeMipMapLevel = 0;
    }
    function Quaternion(x, y, z, w) {
        this._x = x || 0, this._y = y || 0, this._z = z || 0, this._w = void 0 !== w ? w : 1;
    }
    function Vector3(x, y, z) {
        this.x = x || 0, this.y = y || 0, this.z = z || 0;
    }
    function Matrix4() {
        this.elements = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding), 
        this.image = {
            data: data,
            width: width,
            height: height
        }, this.magFilter = void 0 !== magFilter ? magFilter : NearestFilter, this.minFilter = void 0 !== minFilter ? minFilter : NearestFilter, 
        this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
    }
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = void 0 !== images ? images : [], mapping = void 0 !== mapping ? mapping : CubeReflectionMapping, 
        Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding), 
        this.flipY = !1;
    }
    function UniformContainer() {
        this.seq = [], this.map = {};
    }
    function flatten(array, nBlocks, blockSize) {
        var firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0) return array;
        var n = nBlocks * blockSize, r = arrayCacheF32[n];
        if (void 0 === r && (r = new Float32Array(n), arrayCacheF32[n] = r), 0 !== nBlocks) {
            firstElem.toArray(r, 0);
            for (var i = 1, offset = 0; i !== nBlocks; ++i) offset += blockSize, array[i].toArray(r, offset);
        }
        return r;
    }
    function allocTexUnits(renderer, n) {
        var r = arrayCacheI32[n];
        void 0 === r && (r = new Int32Array(n), arrayCacheI32[n] = r);
        for (var i = 0; i !== n; ++i) r[i] = renderer.allocTextureUnit();
        return r;
    }
    function setValue1f(gl, v) {
        gl.uniform1f(this.addr, v);
    }
    function setValue1i(gl, v) {
        gl.uniform1i(this.addr, v);
    }
    function setValue2fv(gl, v) {
        void 0 === v.x ? gl.uniform2fv(this.addr, v) : gl.uniform2f(this.addr, v.x, v.y);
    }
    function setValue3fv(gl, v) {
        void 0 !== v.x ? gl.uniform3f(this.addr, v.x, v.y, v.z) : void 0 !== v.r ? gl.uniform3f(this.addr, v.r, v.g, v.b) : gl.uniform3fv(this.addr, v);
    }
    function setValue4fv(gl, v) {
        void 0 === v.x ? gl.uniform4fv(this.addr, v) : gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
    }
    function setValue2fm(gl, v) {
        gl.uniformMatrix2fv(this.addr, !1, v.elements || v);
    }
    function setValue3fm(gl, v) {
        void 0 === v.elements ? gl.uniformMatrix3fv(this.addr, !1, v) : (mat3array.set(v.elements), 
        gl.uniformMatrix3fv(this.addr, !1, mat3array));
    }
    function setValue4fm(gl, v) {
        void 0 === v.elements ? gl.uniformMatrix4fv(this.addr, !1, v) : (mat4array.set(v.elements), 
        gl.uniformMatrix4fv(this.addr, !1, mat4array));
    }
    function setValueT1(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit), renderer.setTexture2D(v || emptyTexture, unit);
    }
    function setValueT6(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit), renderer.setTextureCube(v || emptyCubeTexture, unit);
    }
    function setValue2iv(gl, v) {
        gl.uniform2iv(this.addr, v);
    }
    function setValue3iv(gl, v) {
        gl.uniform3iv(this.addr, v);
    }
    function setValue4iv(gl, v) {
        gl.uniform4iv(this.addr, v);
    }
    function getSingularSetter(type) {
        switch (type) {
          case 5126:
            return setValue1f;

          case 35664:
            return setValue2fv;

          case 35665:
            return setValue3fv;

          case 35666:
            return setValue4fv;

          case 35674:
            return setValue2fm;

          case 35675:
            return setValue3fm;

          case 35676:
            return setValue4fm;

          case 35678:
          case 36198:
            return setValueT1;

          case 35680:
            return setValueT6;

          case 5124:
          case 35670:
            return setValue1i;

          case 35667:
          case 35671:
            return setValue2iv;

          case 35668:
          case 35672:
            return setValue3iv;

          case 35669:
          case 35673:
            return setValue4iv;
        }
    }
    function setValue1fv(gl, v) {
        gl.uniform1fv(this.addr, v);
    }
    function setValue1iv(gl, v) {
        gl.uniform1iv(this.addr, v);
    }
    function setValueV2a(gl, v) {
        gl.uniform2fv(this.addr, flatten(v, this.size, 2));
    }
    function setValueV3a(gl, v) {
        gl.uniform3fv(this.addr, flatten(v, this.size, 3));
    }
    function setValueV4a(gl, v) {
        gl.uniform4fv(this.addr, flatten(v, this.size, 4));
    }
    function setValueM2a(gl, v) {
        gl.uniformMatrix2fv(this.addr, !1, flatten(v, this.size, 4));
    }
    function setValueM3a(gl, v) {
        gl.uniformMatrix3fv(this.addr, !1, flatten(v, this.size, 9));
    }
    function setValueM4a(gl, v) {
        gl.uniformMatrix4fv(this.addr, !1, flatten(v, this.size, 16));
    }
    function setValueT1a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) renderer.setTexture2D(v[i] || emptyTexture, units[i]);
    }
    function setValueT6a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
    function getPureArraySetter(type) {
        switch (type) {
          case 5126:
            return setValue1fv;

          case 35664:
            return setValueV2a;

          case 35665:
            return setValueV3a;

          case 35666:
            return setValueV4a;

          case 35674:
            return setValueM2a;

          case 35675:
            return setValueM3a;

          case 35676:
            return setValueM4a;

          case 35678:
            return setValueT1a;

          case 35680:
            return setValueT6a;

          case 5124:
          case 35670:
            return setValue1iv;

          case 35667:
          case 35671:
            return setValue2iv;

          case 35668:
          case 35672:
            return setValue3iv;

          case 35669:
          case 35673:
            return setValue4iv;
        }
    }
    function SingleUniform(id, activeInfo, addr) {
        this.id = id, this.addr = addr, this.setValue = getSingularSetter(activeInfo.type);
    }
    function PureArrayUniform(id, activeInfo, addr) {
        this.id = id, this.addr = addr, this.size = activeInfo.size, this.setValue = getPureArraySetter(activeInfo.type);
    }
    function StructuredUniform(id) {
        this.id = id, UniformContainer.call(this);
    }
    function addUniform(container, uniformObject) {
        container.seq.push(uniformObject), container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform(activeInfo, addr, container) {
        var path = activeInfo.name, pathLength = path.length;
        for (RePathPart.lastIndex = 0; ;) {
            var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = "]" === match[2], subscript = match[3];
            if (idIsIndex && (id |= 0), void 0 === subscript || "[" === subscript && matchEnd + 2 === pathLength) {
                addUniform(container, void 0 === subscript ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                break;
            }
            var map = container.map, next = map[id];
            void 0 === next && (next = new StructuredUniform(id), addUniform(container, next)), 
            container = next;
        }
    }
    function WebGLUniforms(gl, program, renderer) {
        UniformContainer.call(this), this.renderer = renderer;
        for (var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), i = 0; i < n; ++i) {
            var info = gl.getActiveUniform(program, i), path = info.name;
            parseUniform(info, gl.getUniformLocation(program, path), this);
        }
    }
    function Color(r, g, b) {
        return void 0 === g && void 0 === b ? this.set(r) : this.setRGB(r, g, b);
    }
    function Box2(min, max) {
        this.min = void 0 !== min ? min : new Vector2(1 / 0, 1 / 0), this.max = void 0 !== max ? max : new Vector2(-1 / 0, -1 / 0);
    }
    function WebGLFlareRenderer(renderer, gl, state, textures, capabilities) {
        function init() {
            var vertices = new Float32Array([ -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1 ]), faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
            vertexBuffer = gl.createBuffer(), elementBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), 
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer), 
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW), tempTexture = gl.createTexture(), 
            occlusionTexture = gl.createTexture(), state.bindTexture(gl.TEXTURE_2D, tempTexture), 
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST), 
            state.bindTexture(gl.TEXTURE_2D, occlusionTexture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST), 
            shader = {
                vertexShader: [ "uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}" ].join("\n"),
                fragmentShader: [ "uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}" ].join("\n")
            }, program = createProgram(shader), attributes = {
                vertex: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            }, uniforms = {
                renderType: gl.getUniformLocation(program, "renderType"),
                map: gl.getUniformLocation(program, "map"),
                occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
                opacity: gl.getUniformLocation(program, "opacity"),
                color: gl.getUniformLocation(program, "color"),
                scale: gl.getUniformLocation(program, "scale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                screenPosition: gl.getUniformLocation(program, "screenPosition")
            };
        }
        function createProgram(shader) {
            var program = gl.createProgram(), fragmentShader = gl.createShader(gl.FRAGMENT_SHADER), vertexShader = gl.createShader(gl.VERTEX_SHADER), prefix = "precision " + capabilities.precision + " float;\n";
            return gl.shaderSource(fragmentShader, prefix + shader.fragmentShader), gl.shaderSource(vertexShader, prefix + shader.vertexShader), 
            gl.compileShader(fragmentShader), gl.compileShader(vertexShader), gl.attachShader(program, fragmentShader), 
            gl.attachShader(program, vertexShader), gl.linkProgram(program), program;
        }
        var vertexBuffer, elementBuffer, shader, program, attributes, uniforms, tempTexture, occlusionTexture;
        this.render = function(flares, scene, camera, viewport) {
            if (0 !== flares.length) {
                var tempPosition = new Vector3(), invAspect = viewport.w / viewport.z, halfViewportWidth = .5 * viewport.z, halfViewportHeight = .5 * viewport.w, size = 16 / viewport.w, scale = new Vector2(size * invAspect, size), screenPosition = new Vector3(1, 1, 0), screenPositionPixels = new Vector2(1, 1), validArea = new Box2();
                validArea.min.set(viewport.x, viewport.y), validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)), 
                void 0 === program && init(), state.useProgram(program), state.initAttributes(), 
                state.enableAttribute(attributes.vertex), state.enableAttribute(attributes.uv), 
                state.disableUnusedAttributes(), gl.uniform1i(uniforms.occlusionMap, 0), gl.uniform1i(uniforms.map, 1), 
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, !1, 16, 0), 
                gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, !1, 16, 8), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer), 
                state.disable(gl.CULL_FACE), state.buffers.depth.setMask(!1);
                for (var i = 0, l = flares.length; i < l; i++) {
                    size = 16 / viewport.w, scale.set(size * invAspect, size);
                    var flare = flares[i];
                    if (tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]), 
                    tempPosition.applyMatrix4(camera.matrixWorldInverse), tempPosition.applyMatrix4(camera.projectionMatrix), 
                    screenPosition.copy(tempPosition), screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8, 
                    screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8, 
                    !0 === validArea.containsPoint(screenPositionPixels)) {
                        state.activeTexture(gl.TEXTURE0), state.bindTexture(gl.TEXTURE_2D, null), state.activeTexture(gl.TEXTURE1), 
                        state.bindTexture(gl.TEXTURE_2D, tempTexture), gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0), 
                        gl.uniform1i(uniforms.renderType, 0), gl.uniform2f(uniforms.scale, scale.x, scale.y), 
                        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z), 
                        state.disable(gl.BLEND), state.enable(gl.DEPTH_TEST), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0), 
                        state.activeTexture(gl.TEXTURE0), state.bindTexture(gl.TEXTURE_2D, occlusionTexture), 
                        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0), 
                        gl.uniform1i(uniforms.renderType, 1), state.disable(gl.DEPTH_TEST), state.activeTexture(gl.TEXTURE1), 
                        state.bindTexture(gl.TEXTURE_2D, tempTexture), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0), 
                        flare.positionScreen.copy(screenPosition), flare.customUpdateCallback ? flare.customUpdateCallback(flare) : flare.updateLensFlares(), 
                        gl.uniform1i(uniforms.renderType, 2), state.enable(gl.BLEND);
                        for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                            var sprite = flare.lensFlares[j];
                            sprite.opacity > .001 && sprite.scale > .001 && (screenPosition.x = sprite.x, screenPosition.y = sprite.y, 
                            screenPosition.z = sprite.z, size = sprite.size * sprite.scale / viewport.w, scale.x = size * invAspect, 
                            scale.y = size, gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z), 
                            gl.uniform2f(uniforms.scale, scale.x, scale.y), gl.uniform1f(uniforms.rotation, sprite.rotation), 
                            gl.uniform1f(uniforms.opacity, sprite.opacity), gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b), 
                            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst), 
                            textures.setTexture2D(sprite.texture, 1), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
                        }
                    }
                }
                state.enable(gl.CULL_FACE), state.enable(gl.DEPTH_TEST), state.buffers.depth.setMask(!0), 
                state.reset();
            }
        };
    }
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy), 
        this.needsUpdate = !0;
    }
    function WebGLSpriteRenderer(renderer, gl, state, textures, capabilities) {
        function init() {
            var vertices = new Float32Array([ -.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1 ]), faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
            vertexBuffer = gl.createBuffer(), elementBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), 
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer), 
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW), program = createProgram(), 
            attributes = {
                position: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            }, uniforms = {
                uvOffset: gl.getUniformLocation(program, "uvOffset"),
                uvScale: gl.getUniformLocation(program, "uvScale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                scale: gl.getUniformLocation(program, "scale"),
                color: gl.getUniformLocation(program, "color"),
                map: gl.getUniformLocation(program, "map"),
                opacity: gl.getUniformLocation(program, "opacity"),
                modelViewMatrix: gl.getUniformLocation(program, "modelViewMatrix"),
                projectionMatrix: gl.getUniformLocation(program, "projectionMatrix"),
                fogType: gl.getUniformLocation(program, "fogType"),
                fogDensity: gl.getUniformLocation(program, "fogDensity"),
                fogNear: gl.getUniformLocation(program, "fogNear"),
                fogFar: gl.getUniformLocation(program, "fogFar"),
                fogColor: gl.getUniformLocation(program, "fogColor"),
                alphaTest: gl.getUniformLocation(program, "alphaTest")
            };
            var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            canvas.width = 8, canvas.height = 8;
            var context = canvas.getContext("2d");
            context.fillStyle = "white", context.fillRect(0, 0, 8, 8), texture = new CanvasTexture(canvas);
        }
        function createProgram() {
            var program = gl.createProgram(), vertexShader = gl.createShader(gl.VERTEX_SHADER), fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            return gl.shaderSource(vertexShader, [ "precision " + capabilities.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}" ].join("\n")), 
            gl.shaderSource(fragmentShader, [ "precision " + capabilities.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}" ].join("\n")), 
            gl.compileShader(vertexShader), gl.compileShader(fragmentShader), gl.attachShader(program, vertexShader), 
            gl.attachShader(program, fragmentShader), gl.linkProgram(program), program;
        }
        function painterSortStable(a, b) {
            return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id;
        }
        var vertexBuffer, elementBuffer, program, attributes, uniforms, texture, spritePosition = new Vector3(), spriteRotation = new Quaternion(), spriteScale = new Vector3();
        this.render = function(sprites, scene, camera) {
            if (0 !== sprites.length) {
                void 0 === program && init(), state.useProgram(program), state.initAttributes(), 
                state.enableAttribute(attributes.position), state.enableAttribute(attributes.uv), 
                state.disableUnusedAttributes(), state.disable(gl.CULL_FACE), state.enable(gl.BLEND), 
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, !1, 16, 0), 
                gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, !1, 16, 8), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer), 
                gl.uniformMatrix4fv(uniforms.projectionMatrix, !1, camera.projectionMatrix.elements), 
                state.activeTexture(gl.TEXTURE0), gl.uniform1i(uniforms.map, 0);
                var oldFogType = 0, sceneFogType = 0, fog = scene.fog;
                fog ? (gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b), fog.isFog ? (gl.uniform1f(uniforms.fogNear, fog.near), 
                gl.uniform1f(uniforms.fogFar, fog.far), gl.uniform1i(uniforms.fogType, 1), oldFogType = 1, 
                sceneFogType = 1) : fog.isFogExp2 && (gl.uniform1f(uniforms.fogDensity, fog.density), 
                gl.uniform1i(uniforms.fogType, 2), oldFogType = 2, sceneFogType = 2)) : (gl.uniform1i(uniforms.fogType, 0), 
                oldFogType = 0, sceneFogType = 0);
                for (var i = 0, l = sprites.length; i < l; i++) {
                    var sprite = sprites[i];
                    sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld), 
                    sprite.z = -sprite.modelViewMatrix.elements[14];
                }
                sprites.sort(painterSortStable);
                for (var scale = [], i = 0, l = sprites.length; i < l; i++) {
                    var sprite = sprites[i], material = sprite.material;
                    if (!1 !== material.visible) {
                        sprite.onBeforeRender(renderer, scene, camera, void 0, material, void 0), gl.uniform1f(uniforms.alphaTest, material.alphaTest), 
                        gl.uniformMatrix4fv(uniforms.modelViewMatrix, !1, sprite.modelViewMatrix.elements), 
                        sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale), scale[0] = spriteScale.x, 
                        scale[1] = spriteScale.y;
                        var fogType = 0;
                        scene.fog && material.fog && (fogType = sceneFogType), oldFogType !== fogType && (gl.uniform1i(uniforms.fogType, fogType), 
                        oldFogType = fogType), null !== material.map ? (gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y), 
                        gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y)) : (gl.uniform2f(uniforms.uvOffset, 0, 0), 
                        gl.uniform2f(uniforms.uvScale, 1, 1)), gl.uniform1f(uniforms.opacity, material.opacity), 
                        gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b), 
                        gl.uniform1f(uniforms.rotation, material.rotation), gl.uniform2fv(uniforms.scale, scale), 
                        state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha), 
                        state.buffers.depth.setTest(material.depthTest), state.buffers.depth.setMask(material.depthWrite), 
                        textures.setTexture2D(material.map || texture, 0), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0), 
                        sprite.onAfterRender(renderer, scene, camera, void 0, material, void 0);
                    }
                }
                state.enable(gl.CULL_FACE), state.reset();
            }
        };
    }
    function Material() {
        Object.defineProperty(this, "id", {
            value: materialId++
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, 
        this.lights = !0, this.blending = NormalBlending, this.side = FrontSide, this.flatShading = !1, 
        this.vertexColors = NoColors, this.opacity = 1, this.transparent = !1, this.blendSrc = SrcAlphaFactor, 
        this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, 
        this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = LessEqualDepth, 
        this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, 
        this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, 
        this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, 
        this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, 
        this.userData = {}, this.needsUpdate = !0;
    }
    function ShaderMaterial(parameters) {
        Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, 
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", 
        this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, 
        this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, 
        this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [ 1, 1, 1 ],
            uv: [ 0, 0 ],
            uv2: [ 0, 0 ]
        }, this.index0AttributeName = void 0, void 0 !== parameters && (void 0 !== parameters.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), 
        this.setValues(parameters));
    }
    function MeshDepthMaterial(parameters) {
        Material.call(this), this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, 
        this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, 
        this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, 
        this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, 
        this.setValues(parameters);
    }
    function MeshDistanceMaterial(parameters) {
        Material.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Vector3(), 
        this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, 
        this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, 
        this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(parameters);
    }
    function Box3(min, max) {
        this.min = void 0 !== min ? min : new Vector3(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== max ? max : new Vector3(-1 / 0, -1 / 0, -1 / 0);
    }
    function Sphere(center, radius) {
        this.center = void 0 !== center ? center : new Vector3(), this.radius = void 0 !== radius ? radius : 0;
    }
    function Matrix3() {
        this.elements = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    function Plane(normal, constant) {
        this.normal = void 0 !== normal ? normal : new Vector3(1, 0, 0), this.constant = void 0 !== constant ? constant : 0;
    }
    function Frustum(p0, p1, p2, p3, p4, p5) {
        this.planes = [ void 0 !== p0 ? p0 : new Plane(), void 0 !== p1 ? p1 : new Plane(), void 0 !== p2 ? p2 : new Plane(), void 0 !== p3 ? p3 : new Plane(), void 0 !== p4 ? p4 : new Plane(), void 0 !== p5 ? p5 : new Plane() ];
    }
    function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
        function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
            var geometry = object.geometry, result = null, materialVariants = _depthMaterials, customMaterial = object.customDepthMaterial;
            if (isPointLight && (materialVariants = _distanceMaterials, customMaterial = object.customDistanceMaterial), 
            customMaterial) result = customMaterial; else {
                var useMorphing = !1;
                material.morphTargets && (geometry && geometry.isBufferGeometry ? useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0 : geometry && geometry.isGeometry && (useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0)), 
                object.isSkinnedMesh && !1 === material.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
                var useSkinning = object.isSkinnedMesh && material.skinning, variantIndex = 0;
                useMorphing && (variantIndex |= _MorphingFlag), useSkinning && (variantIndex |= _SkinningFlag), 
                result = materialVariants[variantIndex];
            }
            if (_renderer.localClippingEnabled && !0 === material.clipShadows && 0 !== material.clippingPlanes.length) {
                var keyA = result.uuid, keyB = material.uuid, materialsForVariant = _materialCache[keyA];
                void 0 === materialsForVariant && (materialsForVariant = {}, _materialCache[keyA] = materialsForVariant);
                var cachedMaterial = materialsForVariant[keyB];
                void 0 === cachedMaterial && (cachedMaterial = result.clone(), materialsForVariant[keyB] = cachedMaterial), 
                result = cachedMaterial;
            }
            result.visible = material.visible, result.wireframe = material.wireframe;
            var side = material.side;
            return scope.renderSingleSided && side == DoubleSide && (side = FrontSide), scope.renderReverseSided && (side === FrontSide ? side = BackSide : side === BackSide && (side = FrontSide)), 
            result.side = side, result.clipShadows = material.clipShadows, result.clippingPlanes = material.clippingPlanes, 
            result.clipIntersection = material.clipIntersection, result.wireframeLinewidth = material.wireframeLinewidth, 
            result.linewidth = material.linewidth, isPointLight && result.isMeshDistanceMaterial && (result.referencePosition.copy(lightPositionWorld), 
            result.nearDistance = shadowCameraNear, result.farDistance = shadowCameraFar), result;
        }
        function renderObject(object, camera, shadowCamera, isPointLight) {
            if (!1 !== object.visible) {
                if (object.layers.test(camera.layers) && (object.isMesh || object.isLine || object.isPoints) && object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    var geometry = _objects.update(object), material = object.material;
                    if (Array.isArray(material)) for (var groups = geometry.groups, k = 0, kl = groups.length; k < kl; k++) {
                        var group = groups[k], groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    } else if (material.visible) {
                        var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                    }
                }
                for (var children = object.children, i = 0, l = children.length; i < l; i++) renderObject(children[i], camera, shadowCamera, isPointLight);
            }
        }
        for (var _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = 1 + (_MorphingFlag | _SkinningFlag), _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {}, cubeDirections = [ new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0) ], cubeUps = [ new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1) ], cube2DViewPorts = [ new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4() ], i = 0; i !== _NumberOfMaterialVariants; ++i) {
            var useMorphing = 0 != (i & _MorphingFlag), useSkinning = 0 != (i & _SkinningFlag), depthMaterial = new MeshDepthMaterial({
                depthPacking: RGBADepthPacking,
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _depthMaterials[i] = depthMaterial;
            var distanceMaterial = new MeshDistanceMaterial({
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _distanceMaterials[i] = distanceMaterial;
        }
        var scope = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap, 
        this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function(lights, scene, camera) {
            if (!1 !== scope.enabled && (!1 !== scope.autoUpdate || !1 !== scope.needsUpdate) && 0 !== lights.length) {
                var _gl = _renderer.context, _state = _renderer.state;
                _state.disable(_gl.BLEND), _state.buffers.color.setClear(1, 1, 1, 1), _state.buffers.depth.setTest(!0), 
                _state.setScissorTest(!1);
                for (var faceCount, i = 0, il = lights.length; i < il; i++) {
                    var light = lights[i], shadow = light.shadow, isPointLight = light && light.isPointLight;
                    if (void 0 !== shadow) {
                        var shadowCamera = shadow.camera;
                        if (_shadowMapSize.copy(shadow.mapSize), _shadowMapSize.min(_maxShadowMapSize), 
                        isPointLight) {
                            var vpWidth = _shadowMapSize.x, vpHeight = _shadowMapSize.y;
                            cube2DViewPorts[0].set(2 * vpWidth, vpHeight, vpWidth, vpHeight), cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight), 
                            cube2DViewPorts[2].set(3 * vpWidth, vpHeight, vpWidth, vpHeight), cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight), 
                            cube2DViewPorts[4].set(3 * vpWidth, 0, vpWidth, vpHeight), cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight), 
                            _shadowMapSize.x *= 4, _shadowMapSize.y *= 2;
                        }
                        if (null === shadow.map) {
                            var pars = {
                                minFilter: NearestFilter,
                                magFilter: NearestFilter,
                                format: RGBAFormat
                            };
                            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars), shadow.map.texture.name = light.name + ".shadowMap", 
                            shadowCamera.updateProjectionMatrix();
                        }
                        shadow.isSpotLightShadow && shadow.update(light);
                        var shadowMap = shadow.map, shadowMatrix = shadow.matrix;
                        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld), shadowCamera.position.copy(_lightPositionWorld), 
                        isPointLight ? (faceCount = 6, shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z)) : (faceCount = 1, 
                        _lookTarget.setFromMatrixPosition(light.target.matrixWorld), shadowCamera.lookAt(_lookTarget), 
                        shadowCamera.updateMatrixWorld(), shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), 
                        shadowMatrix.multiply(shadowCamera.projectionMatrix), shadowMatrix.multiply(shadowCamera.matrixWorldInverse)), 
                        _renderer.setRenderTarget(shadowMap), _renderer.clear();
                        for (var face = 0; face < faceCount; face++) {
                            if (isPointLight) {
                                _lookTarget.copy(shadowCamera.position), _lookTarget.add(cubeDirections[face]), 
                                shadowCamera.up.copy(cubeUps[face]), shadowCamera.lookAt(_lookTarget), shadowCamera.updateMatrixWorld();
                                var vpDimensions = cube2DViewPorts[face];
                                _state.viewport(vpDimensions);
                            }
                            _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse), 
                            _frustum.setFromMatrix(_projScreenMatrix), renderObject(scene, camera, shadowCamera, isPointLight);
                        }
                    } else console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
                }
                scope.needsUpdate = !1;
            }
        };
    }
    function WebGLAttributes(gl) {
        function createBuffer(attribute, bufferType) {
            var array = attribute.array, usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW, buffer = gl.createBuffer();
            gl.bindBuffer(bufferType, buffer), gl.bufferData(bufferType, array, usage), attribute.onUploadCallback();
            var type = gl.FLOAT;
            return array instanceof Float32Array ? type = gl.FLOAT : array instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : array instanceof Uint16Array ? type = gl.UNSIGNED_SHORT : array instanceof Int16Array ? type = gl.SHORT : array instanceof Uint32Array ? type = gl.UNSIGNED_INT : array instanceof Int32Array ? type = gl.INT : array instanceof Int8Array ? type = gl.BYTE : array instanceof Uint8Array && (type = gl.UNSIGNED_BYTE), 
            {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
        }
        function updateBuffer(buffer, attribute, bufferType) {
            var array = attribute.array, updateRange = attribute.updateRange;
            gl.bindBuffer(bufferType, buffer), !1 === attribute.dynamic ? gl.bufferData(bufferType, array, gl.STATIC_DRAW) : -1 === updateRange.count ? gl.bufferSubData(bufferType, 0, array) : 0 === updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count)), 
            updateRange.count = -1);
        }
        function get(attribute) {
            return attribute.isInterleavedBufferAttribute && (attribute = attribute.data), buffers[attribute.uuid];
        }
        function remove(attribute) {
            attribute.isInterleavedBufferAttribute && (attribute = attribute.data);
            var data = buffers[attribute.uuid];
            data && (gl.deleteBuffer(data.buffer), delete buffers[attribute.uuid]);
        }
        function update(attribute, bufferType) {
            attribute.isInterleavedBufferAttribute && (attribute = attribute.data);
            var data = buffers[attribute.uuid];
            void 0 === data ? buffers[attribute.uuid] = createBuffer(attribute, bufferType) : data.version < attribute.version && (updateBuffer(data.buffer, attribute, bufferType), 
            data.version = attribute.version);
        }
        var buffers = {};
        return {
            get: get,
            remove: remove,
            update: update
        };
    }
    function Euler(x, y, z, order) {
        this._x = x || 0, this._y = y || 0, this._z = z || 0, this._order = order || Euler.DefaultOrder;
    }
    function Layers() {
        this.mask = 1;
    }
    function Object3D() {
        function onRotationChange() {
            quaternion.setFromEuler(rotation, !1);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, void 0, !1);
        }
        Object.defineProperty(this, "id", {
            value: object3DId++
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, 
        this.children = [], this.up = Object3D.DefaultUp.clone();
        var position = new Vector3(), rotation = new Euler(), quaternion = new Quaternion(), scale = new Vector3(1, 1, 1);
        rotation.onChange(onRotationChange), quaternion.onChange(onQuaternionChange), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: position
            },
            rotation: {
                enumerable: !0,
                value: rotation
            },
            quaternion: {
                enumerable: !0,
                value: quaternion
            },
            scale: {
                enumerable: !0,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, 
        this.matrixWorldNeedsUpdate = !1, this.layers = new Layers(), this.visible = !0, 
        this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, 
        this.userData = {};
    }
    function Camera() {
        Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new Matrix4(), 
        this.projectionMatrix = new Matrix4();
    }
    function OrthographicCamera(left, right, top, bottom, near, far) {
        Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, 
        this.left = left, this.right = right, this.top = top, this.bottom = bottom, this.near = void 0 !== near ? near : .1, 
        this.far = void 0 !== far ? far : 2e3, this.updateProjectionMatrix();
    }
    function PerspectiveCamera(fov, aspect, near, far) {
        Camera.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== fov ? fov : 50, 
        this.zoom = 1, this.near = void 0 !== near ? near : .1, this.far = void 0 !== far ? far : 2e3, 
        this.focus = 10, this.aspect = void 0 !== aspect ? aspect : 1, this.view = null, 
        this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    function Face3(a, b, c, normal, color, materialIndex) {
        this.a = a, this.b = b, this.c = c, this.normal = normal && normal.isVector3 ? normal : new Vector3(), 
        this.vertexNormals = Array.isArray(normal) ? normal : [], this.color = color && color.isColor ? color : new Color(), 
        this.vertexColors = Array.isArray(color) ? color : [], this.materialIndex = void 0 !== materialIndex ? materialIndex : 0;
    }
    function GeometryIdCount() {
        return count++;
    }
    function Geometry() {
        Object.defineProperty(this, "id", {
            value: GeometryIdCount()
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], 
        this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], this.morphTargets = [], 
        this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], 
        this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, 
        this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, 
        this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
    }
    function BufferAttribute(array, itemSize, normalized) {
        if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.uuid = _Math.generateUUID(), this.name = "", this.array = array, this.itemSize = itemSize, 
        this.count = void 0 !== array ? array.length / itemSize : 0, this.normalized = !0 === normalized, 
        this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function() {}, this.version = 0;
    }
    function Int8BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Int8Array(array), itemSize);
    }
    function Uint8BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Uint8Array(array), itemSize);
    }
    function Uint8ClampedBufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize);
    }
    function Int16BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Int16Array(array), itemSize);
    }
    function Uint16BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Uint16Array(array), itemSize);
    }
    function Int32BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Int32Array(array), itemSize);
    }
    function Uint32BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Uint32Array(array), itemSize);
    }
    function Float32BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Float32Array(array), itemSize);
    }
    function Float64BufferAttribute(array, itemSize) {
        BufferAttribute.call(this, new Float64Array(array), itemSize);
    }
    function DirectGeometry() {
        this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], 
        this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], 
        this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, 
        this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, 
        this.groupsNeedUpdate = !1;
    }
    function arrayMax(array) {
        if (0 === array.length) return -1 / 0;
        for (var max = array[0], i = 1, l = array.length; i < l; ++i) array[i] > max && (max = array[i]);
        return max;
    }
    function BufferGeometry() {
        Object.defineProperty(this, "id", {
            value: GeometryIdCount()
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "BufferGeometry", 
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], 
        this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        };
    }
    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        }, this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)), 
        this.mergeVertices();
    }
    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            var ix, iy, segmentWidth = width / gridX, segmentHeight = height / gridY, widthHalf = width / 2, heightHalf = height / 2, depthHalf = depth / 2, gridX1 = gridX + 1, gridY1 = gridY + 1, vertexCounter = 0, groupCount = 0, vector = new Vector3();
            for (iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    vector[u] = x * udir, vector[v] = y * vdir, vector[w] = depthHalf, vertices.push(vector.x, vector.y, vector.z), 
                    vector[u] = 0, vector[v] = 0, vector[w] = depth > 0 ? 1 : -1, normals.push(vector.x, vector.y, vector.z), 
                    uvs.push(ix / gridX), uvs.push(1 - iy / gridY), vertexCounter += 1;
                }
            }
            for (iy = 0; iy < gridY; iy++) for (ix = 0; ix < gridX; ix++) {
                var a = numberOfVertices + ix + gridX1 * iy, b = numberOfVertices + ix + gridX1 * (iy + 1), c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1), d = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices.push(a, b, d), indices.push(b, c, d), groupCount += 6;
            }
            scope.addGroup(groupStart, groupCount, materialIndex), groupStart += groupCount, 
            numberOfVertices += vertexCounter;
        }
        BufferGeometry.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        var scope = this;
        widthSegments = Math.floor(widthSegments) || 1, heightSegments = Math.floor(heightSegments) || 1, 
        depthSegments = Math.floor(depthSegments) || 1;
        var indices = [], vertices = [], normals = [], uvs = [], numberOfVertices = 0, groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0), 
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1), 
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2), 
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3), 
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4), 
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5), 
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function PlaneGeometry(width, height, widthSegments, heightSegments) {
        Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        }, this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments)), 
        this.mergeVertices();
    }
    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
        BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        var ix, iy, width_half = width / 2, height_half = height / 2, gridX = Math.floor(widthSegments) || 1, gridY = Math.floor(heightSegments) || 1, gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, indices = [], vertices = [], normals = [], uvs = [];
        for (iy = 0; iy < gridY1; iy++) {
            var y = iy * segment_height - height_half;
            for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices.push(x, -y, 0), normals.push(0, 0, 1), uvs.push(ix / gridX), uvs.push(1 - iy / gridY);
            }
        }
        for (iy = 0; iy < gridY; iy++) for (ix = 0; ix < gridX; ix++) {
            var a = ix + gridX1 * iy, b = ix + gridX1 * (iy + 1), c = ix + 1 + gridX1 * (iy + 1), d = ix + 1 + gridX1 * iy;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function MeshBasicMaterial(parameters) {
        Material.call(this), this.type = "MeshBasicMaterial", this.color = new Color(16777215), 
        this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, 
        this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, 
        this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
        this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", 
        this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, 
        this.setValues(parameters);
    }
    function Ray(origin, direction) {
        this.origin = void 0 !== origin ? origin : new Vector3(), this.direction = void 0 !== direction ? direction : new Vector3();
    }
    function Line3(start, end) {
        this.start = void 0 !== start ? start : new Vector3(), this.end = void 0 !== end ? end : new Vector3();
    }
    function Triangle(a, b, c) {
        this.a = void 0 !== a ? a : new Vector3(), this.b = void 0 !== b ? b : new Vector3(), 
        this.c = void 0 !== c ? c : new Vector3();
    }
    function Mesh(geometry, material) {
        Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== geometry ? geometry : new BufferGeometry(), 
        this.material = void 0 !== material ? material : new MeshBasicMaterial({
            color: 16777215 * Math.random()
        }), this.drawMode = TrianglesDrawMode, this.updateMorphTargets();
    }
    function WebGLBackground(renderer, state, geometries, premultipliedAlpha) {
        function render(renderList, scene, camera, forceClear) {
            var background = scene.background;
            null === background ? setClear(clearColor, clearAlpha) : background && background.isColor && (setClear(background, 1), 
            forceClear = !0), (renderer.autoClear || forceClear) && renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil), 
            background && background.isCubeTexture ? (void 0 === boxMesh && (boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                uniforms: ShaderLib.cube.uniforms,
                vertexShader: ShaderLib.cube.vertexShader,
                fragmentShader: ShaderLib.cube.fragmentShader,
                side: BackSide,
                depthTest: !0,
                depthWrite: !1,
                polygonOffset: !0,
                fog: !1
            })), boxMesh.geometry.removeAttribute("normal"), boxMesh.geometry.removeAttribute("uv"), 
            boxMesh.onBeforeRender = function(renderer, scene, camera) {
                var scale = camera.far;
                this.matrixWorld.makeScale(scale, scale, scale), this.matrixWorld.copyPosition(camera.matrixWorld), 
                this.material.polygonOffsetUnits = 10 * scale;
            }, geometries.update(boxMesh.geometry)), boxMesh.material.uniforms.tCube.value = background, 
            renderList.push(boxMesh, boxMesh.geometry, boxMesh.material, 0, null)) : background && background.isTexture && (void 0 === planeCamera && (planeCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1), 
            planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), geometries.update(planeMesh.geometry)), planeMesh.material.map = background, 
            renderer.renderBufferDirect(planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null));
        }
        function setClear(color, alpha) {
            state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
        }
        var planeCamera, planeMesh, boxMesh, clearColor = new Color(0), clearAlpha = 0;
        return {
            getClearColor: function() {
                return clearColor;
            },
            setClearColor: function(color, alpha) {
                clearColor.set(color), clearAlpha = void 0 !== alpha ? alpha : 1, setClear(clearColor, clearAlpha);
            },
            getClearAlpha: function() {
                return clearAlpha;
            },
            setClearAlpha: function(alpha) {
                clearAlpha = alpha, setClear(clearColor, clearAlpha);
            },
            render: render
        };
    }
    function painterSortStable(a, b) {
        return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program && b.program && a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;
    }
    function reversePainterSortStable(a, b) {
        return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;
    }
    function WebGLRenderList() {
        function init() {
            renderItemsIndex = 0, opaque.length = 0, transparent.length = 0;
        }
        function push(object, geometry, material, z, group) {
            var renderItem = renderItems[renderItemsIndex];
            void 0 === renderItem ? (renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                program: material.program,
                renderOrder: object.renderOrder,
                z: z,
                group: group
            }, renderItems[renderItemsIndex] = renderItem) : (renderItem.id = object.id, renderItem.object = object, 
            renderItem.geometry = geometry, renderItem.material = material, renderItem.program = material.program, 
            renderItem.renderOrder = object.renderOrder, renderItem.z = z, renderItem.group = group), 
            (!0 === material.transparent ? transparent : opaque).push(renderItem), renderItemsIndex++;
        }
        function sort() {
            opaque.length > 1 && opaque.sort(painterSortStable), transparent.length > 1 && transparent.sort(reversePainterSortStable);
        }
        var renderItems = [], renderItemsIndex = 0, opaque = [], transparent = [];
        return {
            opaque: opaque,
            transparent: transparent,
            init: init,
            push: push,
            sort: sort
        };
    }
    function WebGLRenderLists() {
        function get(scene, camera) {
            var hash = scene.id + "," + camera.id, list = lists[hash];
            return void 0 === list && (list = new WebGLRenderList(), lists[hash] = list), list;
        }
        function dispose() {
            lists = {};
        }
        var lists = {};
        return {
            get: get,
            dispose: dispose
        };
    }
    function absNumericalSort(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
    }
    function WebGLMorphtargets(gl) {
        function update(object, geometry, material, program) {
            var objectInfluences = object.morphTargetInfluences, length = objectInfluences.length, influences = influencesList[geometry.id];
            if (void 0 === influences) {
                influences = [];
                for (var i = 0; i < length; i++) influences[i] = [ i, 0 ];
                influencesList[geometry.id] = influences;
            }
            for (var morphTargets = material.morphTargets && geometry.morphAttributes.position, morphNormals = material.morphNormals && geometry.morphAttributes.normal, i = 0; i < length; i++) {
                var influence = influences[i];
                0 !== influence[1] && (morphTargets && geometry.removeAttribute("morphTarget" + i), 
                morphNormals && geometry.removeAttribute("morphNormal" + i));
            }
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                influence[0] = i, influence[1] = objectInfluences[i];
            }
            influences.sort(absNumericalSort);
            for (var i = 0; i < 8; i++) {
                var influence = influences[i];
                if (influence) {
                    var index = influence[0], value = influence[1];
                    if (value) {
                        morphTargets && geometry.addAttribute("morphTarget" + i, morphTargets[index]), morphNormals && geometry.addAttribute("morphNormal" + i, morphNormals[index]), 
                        morphInfluences[i] = value;
                        continue;
                    }
                }
                morphInfluences[i] = 0;
            }
            program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
        }
        var influencesList = {}, morphInfluences = new Float32Array(8);
        return {
            update: update
        };
    }
    function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
        function setMode(value) {
            mode = value;
        }
        function setIndex(value) {
            type = value.type, bytesPerElement = value.bytesPerElement;
        }
        function render(start, count) {
            gl.drawElements(mode, count, type, start * bytesPerElement), infoRender.calls++, 
            infoRender.vertices += count, mode === gl.TRIANGLES ? infoRender.faces += count / 3 : mode === gl.POINTS && (infoRender.points += count);
        }
        function renderInstances(geometry, start, count) {
            var extension = extensions.get("ANGLE_instanced_arrays");
            if (null === extension) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            extension.drawElementsInstancedANGLE(mode, count, type, start * bytesPerElement, geometry.maxInstancedCount), 
            infoRender.calls++, infoRender.vertices += count * geometry.maxInstancedCount, mode === gl.TRIANGLES ? infoRender.faces += geometry.maxInstancedCount * count / 3 : mode === gl.POINTS && (infoRender.points += geometry.maxInstancedCount * count);
        }
        var mode, type, bytesPerElement;
        this.setMode = setMode, this.setIndex = setIndex, this.render = render, this.renderInstances = renderInstances;
    }
    function WebGLBufferRenderer(gl, extensions, infoRender) {
        function setMode(value) {
            mode = value;
        }
        function render(start, count) {
            gl.drawArrays(mode, start, count), infoRender.calls++, infoRender.vertices += count, 
            mode === gl.TRIANGLES ? infoRender.faces += count / 3 : mode === gl.POINTS && (infoRender.points += count);
        }
        function renderInstances(geometry, start, count) {
            var extension = extensions.get("ANGLE_instanced_arrays");
            if (null === extension) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            var position = geometry.attributes.position;
            position.isInterleavedBufferAttribute ? (count = position.data.count, extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount)) : extension.drawArraysInstancedANGLE(mode, start, count, geometry.maxInstancedCount), 
            infoRender.calls++, infoRender.vertices += count * geometry.maxInstancedCount, mode === gl.TRIANGLES ? infoRender.faces += geometry.maxInstancedCount * count / 3 : mode === gl.POINTS && (infoRender.points += geometry.maxInstancedCount * count);
        }
        var mode;
        this.setMode = setMode, this.render = render, this.renderInstances = renderInstances;
    }
    function WebGLGeometries(gl, attributes, infoMemory) {
        function onGeometryDispose(event) {
            var geometry = event.target, buffergeometry = geometries[geometry.id];
            null !== buffergeometry.index && attributes.remove(buffergeometry.index);
            for (var name in buffergeometry.attributes) attributes.remove(buffergeometry.attributes[name]);
            geometry.removeEventListener("dispose", onGeometryDispose), delete geometries[geometry.id];
            var attribute = wireframeAttributes[geometry.id];
            attribute && (attributes.remove(attribute), delete wireframeAttributes[geometry.id]), 
            attribute = wireframeAttributes[buffergeometry.id], attribute && (attributes.remove(attribute), 
            delete wireframeAttributes[buffergeometry.id]), infoMemory.geometries--;
        }
        function get(object, geometry) {
            var buffergeometry = geometries[geometry.id];
            return buffergeometry || (geometry.addEventListener("dispose", onGeometryDispose), 
            geometry.isBufferGeometry ? buffergeometry = geometry : geometry.isGeometry && (void 0 === geometry._bufferGeometry && (geometry._bufferGeometry = new BufferGeometry().setFromObject(object)), 
            buffergeometry = geometry._bufferGeometry), geometries[geometry.id] = buffergeometry, 
            infoMemory.geometries++, buffergeometry);
        }
        function update(geometry) {
            var index = geometry.index, geometryAttributes = geometry.attributes;
            null !== index && attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
            for (var name in geometryAttributes) attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
            var morphAttributes = geometry.morphAttributes;
            for (var name in morphAttributes) for (var array = morphAttributes[name], i = 0, l = array.length; i < l; i++) attributes.update(array[i], gl.ARRAY_BUFFER);
        }
        function getWireframeAttribute(geometry) {
            var attribute = wireframeAttributes[geometry.id];
            if (attribute) return attribute;
            var indices = [], geometryIndex = geometry.index, geometryAttributes = geometry.attributes;
            if (null !== geometryIndex) for (var array = geometryIndex.array, i = 0, l = array.length; i < l; i += 3) {
                var a = array[i + 0], b = array[i + 1], c = array[i + 2];
                indices.push(a, b, b, c, c, a);
            } else for (var array = geometryAttributes.position.array, i = 0, l = array.length / 3 - 1; i < l; i += 3) {
                var a = i + 0, b = i + 1, c = i + 2;
                indices.push(a, b, b, c, c, a);
            }
            return attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1), 
            attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER), wireframeAttributes[geometry.id] = attribute, 
            attribute;
        }
        var geometries = {}, wireframeAttributes = {};
        return {
            get: get,
            update: update,
            getWireframeAttribute: getWireframeAttribute
        };
    }
    function UniformsCache() {
        var lights = {};
        return {
            get: function(light) {
                if (void 0 !== lights[light.id]) return lights[light.id];
                var uniforms;
                switch (light.type) {
                  case "DirectionalLight":
                    uniforms = {
                        direction: new Vector3(),
                        color: new Color(),
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "SpotLight":
                    uniforms = {
                        position: new Vector3(),
                        direction: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "PointLight":
                    uniforms = {
                        position: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;

                  case "HemisphereLight":
                    uniforms = {
                        direction: new Vector3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                    break;

                  case "RectAreaLight":
                    uniforms = {
                        color: new Color(),
                        position: new Vector3(),
                        halfWidth: new Vector3(),
                        halfHeight: new Vector3()
                    };
                }
                return lights[light.id] = uniforms, uniforms;
            }
        };
    }
    function WebGLLights() {
        function setup(lights, shadows, camera) {
            for (var r = 0, g = 0, b = 0, directionalLength = 0, pointLength = 0, spotLength = 0, rectAreaLength = 0, hemiLength = 0, viewMatrix = camera.matrixWorldInverse, i = 0, l = lights.length; i < l; i++) {
                var light = lights[i], color = light.color, intensity = light.intensity, distance = light.distance, shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
                if (light.isAmbientLight) r += color.r * intensity, g += color.g * intensity, b += color.b * intensity; else if (light.isDirectionalLight) {
                    var uniforms = cache.get(light);
                    if (uniforms.color.copy(light.color).multiplyScalar(light.intensity), uniforms.direction.setFromMatrixPosition(light.matrixWorld), 
                    vector3.setFromMatrixPosition(light.target.matrixWorld), uniforms.direction.sub(vector3), 
                    uniforms.direction.transformDirection(viewMatrix), uniforms.shadow = light.castShadow, 
                    light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias, uniforms.shadowRadius = shadow.radius, uniforms.shadowMapSize = shadow.mapSize;
                    }
                    state.directionalShadowMap[directionalLength] = shadowMap, state.directionalShadowMatrix[directionalLength] = light.shadow.matrix, 
                    state.directional[directionalLength] = uniforms, directionalLength++;
                } else if (light.isSpotLight) {
                    var uniforms = cache.get(light);
                    if (uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), 
                    uniforms.color.copy(color).multiplyScalar(intensity), uniforms.distance = distance, 
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld), vector3.setFromMatrixPosition(light.target.matrixWorld), 
                    uniforms.direction.sub(vector3), uniforms.direction.transformDirection(viewMatrix), 
                    uniforms.coneCos = Math.cos(light.angle), uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra)), 
                    uniforms.decay = 0 === light.distance ? 0 : light.decay, uniforms.shadow = light.castShadow, 
                    light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias, uniforms.shadowRadius = shadow.radius, uniforms.shadowMapSize = shadow.mapSize;
                    }
                    state.spotShadowMap[spotLength] = shadowMap, state.spotShadowMatrix[spotLength] = light.shadow.matrix, 
                    state.spot[spotLength] = uniforms, spotLength++;
                } else if (light.isRectAreaLight) {
                    var uniforms = cache.get(light);
                    uniforms.color.copy(color).multiplyScalar(intensity / (light.width * light.height)), 
                    uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), 
                    matrix42.identity(), matrix4.copy(light.matrixWorld), matrix4.premultiply(viewMatrix), 
                    matrix42.extractRotation(matrix4), uniforms.halfWidth.set(.5 * light.width, 0, 0), 
                    uniforms.halfHeight.set(0, .5 * light.height, 0), uniforms.halfWidth.applyMatrix4(matrix42), 
                    uniforms.halfHeight.applyMatrix4(matrix42), state.rectArea[rectAreaLength] = uniforms, 
                    rectAreaLength++;
                } else if (light.isPointLight) {
                    var uniforms = cache.get(light);
                    if (uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), 
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity), uniforms.distance = light.distance, 
                    uniforms.decay = 0 === light.distance ? 0 : light.decay, uniforms.shadow = light.castShadow, 
                    light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias, uniforms.shadowRadius = shadow.radius, uniforms.shadowMapSize = shadow.mapSize, 
                        uniforms.shadowCameraNear = shadow.camera.near, uniforms.shadowCameraFar = shadow.camera.far;
                    }
                    state.pointShadowMap[pointLength] = shadowMap, state.pointShadowMatrix[pointLength] = light.shadow.matrix, 
                    state.point[pointLength] = uniforms, pointLength++;
                } else if (light.isHemisphereLight) {
                    var uniforms = cache.get(light);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld), uniforms.direction.transformDirection(viewMatrix), 
                    uniforms.direction.normalize(), uniforms.skyColor.copy(light.color).multiplyScalar(intensity), 
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity), state.hemi[hemiLength] = uniforms, 
                    hemiLength++;
                }
            }
            state.ambient[0] = r, state.ambient[1] = g, state.ambient[2] = b, state.directional.length = directionalLength, 
            state.spot.length = spotLength, state.rectArea.length = rectAreaLength, state.point.length = pointLength, 
            state.hemi.length = hemiLength, state.hash = directionalLength + "," + pointLength + "," + spotLength + "," + rectAreaLength + "," + hemiLength + "," + shadows.length;
        }
        var cache = new UniformsCache(), state = {
            hash: "",
            ambient: [ 0, 0, 0 ],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }, vector3 = new Vector3(), matrix4 = new Matrix4(), matrix42 = new Matrix4();
        return {
            setup: setup,
            state: state
        };
    }
    function WebGLObjects(geometries, infoRender) {
        function update(object) {
            var frame = infoRender.frame, geometry = object.geometry, buffergeometry = geometries.get(object, geometry);
            return updateList[buffergeometry.id] !== frame && (geometry.isGeometry && buffergeometry.updateFromObject(object), 
            geometries.update(buffergeometry), updateList[buffergeometry.id] = frame), buffergeometry;
        }
        function clear() {
            updateList = {};
        }
        var updateList = {};
        return {
            update: update,
            clear: clear
        };
    }
    function addLineNumbers(string) {
        for (var lines = string.split("\n"), i = 0; i < lines.length; i++) lines[i] = i + 1 + ": " + lines[i];
        return lines.join("\n");
    }
    function WebGLShader(gl, type, string) {
        var shader = gl.createShader(type);
        return gl.shaderSource(shader, string), gl.compileShader(shader), !1 === gl.getShaderParameter(shader, gl.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), 
        "" !== gl.getShaderInfoLog(shader) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === gl.VERTEX_SHADER ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string)), 
        shader;
    }
    function getEncodingComponents(encoding) {
        switch (encoding) {
          case LinearEncoding:
            return [ "Linear", "( value )" ];

          case sRGBEncoding:
            return [ "sRGB", "( value )" ];

          case RGBEEncoding:
            return [ "RGBE", "( value )" ];

          case RGBM7Encoding:
            return [ "RGBM", "( value, 7.0 )" ];

          case RGBM16Encoding:
            return [ "RGBM", "( value, 16.0 )" ];

          case RGBDEncoding:
            return [ "RGBD", "( value, 256.0 )" ];

          case GammaEncoding:
            return [ "Gamma", "( value, float( GAMMA_FACTOR ) )" ];

          default:
            throw new Error("unsupported encoding: " + encoding);
        }
    }
    function getTexelDecodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
    }
    function getTexelEncodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
    }
    function getToneMappingFunction(functionName, toneMapping) {
        var toneMappingName;
        switch (toneMapping) {
          case LinearToneMapping:
            toneMappingName = "Linear";
            break;

          case ReinhardToneMapping:
            toneMappingName = "Reinhard";
            break;

          case Uncharted2ToneMapping:
            toneMappingName = "Uncharted2";
            break;

          case CineonToneMapping:
            toneMappingName = "OptimizedCineon";
            break;

          default:
            throw new Error("unsupported toneMapping: " + toneMapping);
        }
        return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
    }
    function generateExtensions(extensions, parameters, rendererExtensions) {
        return extensions = extensions || {}, [ extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : "" ].filter(filterEmptyLine).join("\n");
    }
    function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
            var value = defines[name];
            !1 !== value && chunks.push("#define " + name + " " + value);
        }
        return chunks.join("\n");
    }
    function fetchAttributeLocations(gl, program, identifiers) {
        for (var attributes = {}, n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES), i = 0; i < n; i++) {
            var info = gl.getActiveAttrib(program, i), name = info.name;
            attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
    }
    function filterEmptyLine(string) {
        return "" !== string;
    }
    function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
    }
    function parseIncludes(string) {
        function replace(match, include) {
            var replace = ShaderChunk[include];
            if (void 0 === replace) throw new Error("Can not resolve #include <" + include + ">");
            return parseIncludes(replace);
        }
        var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;
        return string.replace(pattern, replace);
    }
    function unrollLoops(string) {
        function replace(match, start, end, snippet) {
            for (var unroll = "", i = parseInt(start); i < parseInt(end); i++) unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
            return unroll;
        }
        var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        return string.replace(pattern, replace);
    }
    function WebGLProgram(renderer, extensions, code, material, shader, parameters) {
        var gl = renderer.context, defines = material.defines, vertexShader = shader.vertexShader, fragmentShader = shader.fragmentShader, shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
        parameters.shadowMapType === PCFShadowMap ? shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF" : parameters.shadowMapType === PCFSoftShadowMap && (shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT");
        var envMapTypeDefine = "ENVMAP_TYPE_CUBE", envMapModeDefine = "ENVMAP_MODE_REFLECTION", envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        if (parameters.envMap) {
            switch (material.envMap.mapping) {
              case CubeReflectionMapping:
              case CubeRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                break;

              case CubeUVReflectionMapping:
              case CubeUVRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                break;

              case EquirectangularReflectionMapping:
              case EquirectangularRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
                break;

              case SphericalReflectionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
            }
            switch (material.envMap.mapping) {
              case CubeRefractionMapping:
              case EquirectangularRefractionMapping:
                envMapModeDefine = "ENVMAP_MODE_REFRACTION";
            }
            switch (material.combine) {
              case MultiplyOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                break;

              case MixOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                break;

              case AddOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
            }
        }
        var prefixVertex, prefixFragment, gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1, customExtensions = generateExtensions(material.extensions, parameters, extensions), customDefines = generateDefines(defines), program = gl.createProgram();
        material.isRawShaderMaterial ? (prefixVertex = [ customDefines, "\n" ].filter(filterEmptyLine).join("\n"), 
        prefixFragment = [ customExtensions, customDefines, "\n" ].filter(filterEmptyLine).join("\n")) : (prefixVertex = [ "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + shader.name, customDefines, parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && !1 === parameters.flatShading ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n" ].filter(filterEmptyLine).join("\n"), 
        prefixFragment = [ customExtensions, "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + shader.name, customDefines, parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest : "", "#define GAMMA_FACTOR " + gammaFactorDefine, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.gradientMap ? "#define USE_GRADIENTMAP" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (parameters.numClippingPlanes - parameters.numClipIntersection), parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", parameters.envMap && extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", parameters.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "", parameters.dithering ? "#define DITHERING" : "", parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk.encodings_pars_fragment : "", parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "", parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "", parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "", parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "", parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "", "\n" ].filter(filterEmptyLine).join("\n")), 
        vertexShader = parseIncludes(vertexShader), vertexShader = replaceLightNums(vertexShader, parameters), 
        fragmentShader = parseIncludes(fragmentShader), fragmentShader = replaceLightNums(fragmentShader, parameters), 
        material.isShaderMaterial || (vertexShader = unrollLoops(vertexShader), fragmentShader = unrollLoops(fragmentShader));
        var vertexGlsl = prefixVertex + vertexShader, fragmentGlsl = prefixFragment + fragmentShader, glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl), glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader), gl.attachShader(program, glFragmentShader), 
        void 0 !== material.index0AttributeName ? gl.bindAttribLocation(program, 0, material.index0AttributeName) : !0 === parameters.morphTargets && gl.bindAttribLocation(program, 0, "position"), 
        gl.linkProgram(program);
        var programLog = gl.getProgramInfoLog(program), vertexLog = gl.getShaderInfoLog(glVertexShader), fragmentLog = gl.getShaderInfoLog(glFragmentShader), runnable = !0, haveDiagnostics = !0;
        !1 === gl.getProgramParameter(program, gl.LINK_STATUS) ? (runnable = !1, console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog)) : "" !== programLog ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog) : "" !== vertexLog && "" !== fragmentLog || (haveDiagnostics = !1), 
        haveDiagnostics && (this.diagnostics = {
            runnable: runnable,
            material: material,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        }), gl.deleteShader(glVertexShader), gl.deleteShader(glFragmentShader);
        var cachedUniforms;
        this.getUniforms = function() {
            return void 0 === cachedUniforms && (cachedUniforms = new WebGLUniforms(gl, program, renderer)), 
            cachedUniforms;
        };
        var cachedAttributes;
        return this.getAttributes = function() {
            return void 0 === cachedAttributes && (cachedAttributes = fetchAttributeLocations(gl, program)), 
            cachedAttributes;
        }, this.destroy = function() {
            gl.deleteProgram(program), this.program = void 0;
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), 
                    this.getAttributes();
                }
            }
        }), this.id = programIdCount++, this.code = code, this.usedTimes = 1, this.program = program, 
        this.vertexShader = glVertexShader, this.fragmentShader = glFragmentShader, this;
    }
    function WebGLPrograms(renderer, extensions, capabilities) {
        function allocateBones(object) {
            var skeleton = object.skeleton, bones = skeleton.bones;
            if (capabilities.floatVertexTextures) return 1024;
            var nVertexUniforms = capabilities.maxVertexUniforms, nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4), maxBones = Math.min(nVertexMatrices, bones.length);
            return maxBones < bones.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + "."), 
            0) : maxBones;
        }
        function getTextureEncodingFromMap(map, gammaOverrideLinear) {
            var encoding;
            return map ? map.isTexture ? encoding = map.encoding : map.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), 
            encoding = map.texture.encoding) : encoding = LinearEncoding, encoding === LinearEncoding && gammaOverrideLinear && (encoding = GammaEncoding), 
            encoding;
        }
        var programs = [], shaderIDs = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow"
        }, parameterNames = [ "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering" ];
        this.getParameters = function(material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
            var shaderID = shaderIDs[material.type], maxBones = object.isSkinnedMesh ? allocateBones(object) : 0, precision = capabilities.precision;
            null !== material.precision && (precision = capabilities.getMaxPrecision(material.precision)) !== material.precision && console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
            var currentRenderTarget = renderer.getRenderTarget();
            return {
                shaderID: shaderID,
                precision: precision,
                supportsVertexTextures: capabilities.vertexTextures,
                outputEncoding: getTextureEncodingFromMap(currentRenderTarget ? currentRenderTarget.texture : null, renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                gradientMap: !!material.gradientMap,
                combine: material.combine,
                vertexColors: material.vertexColors,
                fog: !!fog,
                useFog: material.fog,
                fogExp: fog && fog.isFogExp2,
                flatShading: material.flatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                skinning: material.skinning && maxBones > 0,
                maxBones: maxBones,
                useVertexTexture: capabilities.floatVertexTextures,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
                dithering: material.dithering,
                shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: renderer.toneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                depthPacking: void 0 !== material.depthPacking && material.depthPacking
            };
        }, this.getProgramCode = function(material, parameters) {
            var array = [];
            if (parameters.shaderID ? array.push(parameters.shaderID) : (array.push(material.fragmentShader), 
            array.push(material.vertexShader)), void 0 !== material.defines) for (var name in material.defines) array.push(name), 
            array.push(material.defines[name]);
            for (var i = 0; i < parameterNames.length; i++) array.push(parameters[parameterNames[i]]);
            return array.push(material.onBeforeCompile.toString()), array.push(renderer.gammaOutput), 
            array.join();
        }, this.acquireProgram = function(material, shader, parameters, code) {
            for (var program, p = 0, pl = programs.length; p < pl; p++) {
                var programInfo = programs[p];
                if (programInfo.code === code) {
                    program = programInfo, ++program.usedTimes;
                    break;
                }
            }
            return void 0 === program && (program = new WebGLProgram(renderer, extensions, code, material, shader, parameters), 
            programs.push(program)), program;
        }, this.releaseProgram = function(program) {
            if (0 == --program.usedTimes) {
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1], programs.pop(), program.destroy();
            }
        }, this.programs = programs;
    }
    function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, infoMemory) {
        function clampToMaxSize(image, maxSize) {
            if (image.width > maxSize || image.height > maxSize) {
                var scale = maxSize / Math.max(image.width, image.height), canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = Math.floor(image.width * scale), canvas.height = Math.floor(image.height * scale);
                return canvas.getContext("2d").drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height), 
                console.warn("THREE.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image), 
                canvas;
            }
            return image;
        }
        function isPowerOfTwo(image) {
            return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
        }
        function makePowerOfTwo(image) {
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
                var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = _Math.nearestPowerOfTwo(image.width), canvas.height = _Math.nearestPowerOfTwo(image.height);
                return canvas.getContext("2d").drawImage(image, 0, 0, canvas.width, canvas.height), 
                console.warn("THREE.WebGLRenderer: image is not power of two (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image), 
                canvas;
            }
            return image;
        }
        function textureNeedsPowerOfTwo(texture) {
            return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {
            return texture.generateMipmaps && isPowerOfTwo && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function filterFallback(f) {
            return f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ? _gl.NEAREST : _gl.LINEAR;
        }
        function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener("dispose", onTextureDispose), deallocateTexture(texture), 
            infoMemory.textures--;
        }
        function onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener("dispose", onRenderTargetDispose), deallocateRenderTarget(renderTarget), 
            infoMemory.textures--;
        }
        function deallocateTexture(texture) {
            var textureProperties = properties.get(texture);
            if (texture.image && textureProperties.__image__webglTextureCube) _gl.deleteTexture(textureProperties.__image__webglTextureCube); else {
                if (void 0 === textureProperties.__webglInit) return;
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            properties.remove(texture);
        }
        function deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget), textureProperties = properties.get(renderTarget.texture);
            if (renderTarget) {
                if (void 0 !== textureProperties.__webglTexture && _gl.deleteTexture(textureProperties.__webglTexture), 
                renderTarget.depthTexture && renderTarget.depthTexture.dispose(), renderTarget.isWebGLRenderTargetCube) for (var i = 0; i < 6; i++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]), 
                renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]); else _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer), 
                renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
                properties.remove(renderTarget.texture), properties.remove(renderTarget);
            }
        }
        function setTexture2D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (void 0 === image) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", texture); else {
                    if (!1 !== image.complete) return void uploadTexture(textureProperties, texture, slot);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", texture);
                }
            }
            state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
            var textureProperties = properties.get(texture);
            if (6 === texture.image.length) if (texture.version > 0 && textureProperties.__version !== texture.version) {
                textureProperties.__image__webglTextureCube || (texture.addEventListener("dispose", onTextureDispose), 
                textureProperties.__image__webglTextureCube = _gl.createTexture(), infoMemory.textures++), 
                state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube), 
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                for (var isCompressed = texture && texture.isCompressedTexture, isDataTexture = texture.image[0] && texture.image[0].isDataTexture, cubeImage = [], i = 0; i < 6; i++) cubeImage[i] = isCompressed || isDataTexture ? isDataTexture ? texture.image[i].image : texture.image[i] : clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = utils.convert(texture.format), glType = utils.convert(texture.type);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                for (var i = 0; i < 6; i++) if (isCompressed) for (var mipmap, mipmaps = cubeImage[i].mipmaps, j = 0, jl = mipmaps.length; j < jl; j++) mipmap = mipmaps[j], 
                texture.format !== RGBAFormat && texture.format !== RGBFormat ? state.getCompressedTextureFormats().indexOf(glFormat) > -1 ? state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data); else isDataTexture ? state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage) && _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP), 
                textureProperties.__version = texture.version, texture.onUpdate && texture.onUpdate(texture);
            } else state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
        }
        function setTextureCubeDynamic(texture, slot) {
            state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
        }
        function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
            var extension;
            if (isPowerOfTwoImage ? (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, utils.convert(texture.wrapS)), 
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, utils.convert(texture.wrapT)), 
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, utils.convert(texture.magFilter)), 
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, utils.convert(texture.minFilter))) : (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE), 
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE), texture.wrapS === ClampToEdgeWrapping && texture.wrapT === ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", texture), 
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter)), 
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter)), 
            texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", texture)), 
            extension = extensions.get("EXT_texture_filter_anisotropic")) {
                if (texture.type === FloatType && null === extensions.get("OES_texture_float_linear")) return;
                if (texture.type === HalfFloatType && null === extensions.get("OES_texture_half_float_linear")) return;
                (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) && (_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy())), 
                properties.get(texture).__currentAnisotropy = texture.anisotropy);
            }
        }
        function uploadTexture(textureProperties, texture, slot) {
            void 0 === textureProperties.__webglInit && (textureProperties.__webglInit = !0, 
            texture.addEventListener("dispose", onTextureDispose), textureProperties.__webglTexture = _gl.createTexture(), 
            infoMemory.textures++), state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture), 
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha), 
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
            textureNeedsPowerOfTwo(texture) && !1 === isPowerOfTwo(image) && (image = makePowerOfTwo(image));
            var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = utils.convert(texture.format), glType = utils.convert(texture.type);
            setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
            var mipmap, mipmaps = texture.mipmaps;
            if (texture.isDepthTexture) {
                var internalFormat = _gl.DEPTH_COMPONENT;
                if (texture.type === FloatType) {
                    if (!_isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    internalFormat = _gl.DEPTH_COMPONENT32F;
                } else _isWebGL2 && (internalFormat = _gl.DEPTH_COMPONENT16);
                texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT && texture.type !== UnsignedShortType && texture.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), 
                texture.type = UnsignedShortType, glType = utils.convert(texture.type)), texture.format === DepthStencilFormat && (internalFormat = _gl.DEPTH_STENCIL, 
                texture.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), 
                texture.type = UnsignedInt248Type, glType = utils.convert(texture.type))), state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
            } else if (texture.isDataTexture) if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i], state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                texture.generateMipmaps = !1;
            } else state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data); else if (texture.isCompressedTexture) for (var i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i], 
            texture.format !== RGBAFormat && texture.format !== RGBFormat ? state.getCompressedTextureFormats().indexOf(glFormat) > -1 ? state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data); else if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i], state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                texture.generateMipmaps = !1;
            } else state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
            textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage) && _gl.generateMipmap(_gl.TEXTURE_2D), 
            textureProperties.__version = texture.version, texture.onUpdate && texture.onUpdate(texture);
        }
        function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = utils.convert(renderTarget.texture.format), glType = utils.convert(renderTarget.texture.type);
            state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null), 
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0), 
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderBufferStorage(renderbuffer, renderTarget) {
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer), renderTarget.depthBuffer && !renderTarget.stencilBuffer ? (_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height), 
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)) : renderTarget.depthBuffer && renderTarget.stencilBuffer ? (_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height), 
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)) : _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height), 
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }
        function setupDepthTexture(framebuffer, renderTarget) {
            if (renderTarget && renderTarget.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
            if (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), !renderTarget.depthTexture || !renderTarget.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            properties.get(renderTarget.depthTexture).__webglTexture && renderTarget.depthTexture.image.width === renderTarget.width && renderTarget.depthTexture.image.height === renderTarget.height || (renderTarget.depthTexture.image.width = renderTarget.width, 
            renderTarget.depthTexture.image.height = renderTarget.height, renderTarget.depthTexture.needsUpdate = !0), 
            setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0); else {
                if (renderTarget.depthTexture.format !== DepthStencilFormat) throw new Error("Unknown depthTexture format");
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            }
        }
        function setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget), isCube = !0 === renderTarget.isWebGLRenderTargetCube;
            if (renderTarget.depthTexture) {
                if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            } else if (isCube) {
                renderTargetProperties.__webglDepthbuffer = [];
                for (var i = 0; i < 6; i++) _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]), 
                renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
            } else _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer), 
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget), textureProperties = properties.get(renderTarget.texture);
            renderTarget.addEventListener("dispose", onRenderTargetDispose), textureProperties.__webglTexture = _gl.createTexture(), 
            infoMemory.textures++;
            var isCube = !0 === renderTarget.isWebGLRenderTargetCube, isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; i < 6; i++) renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
            } else renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isCube) {
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                for (var i = 0; i < 6; i++) setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo) && _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP), 
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
            } else state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo), 
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D), 
            textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo) && _gl.generateMipmap(_gl.TEXTURE_2D), 
            state.bindTexture(_gl.TEXTURE_2D, null);
            renderTarget.depthBuffer && setupDepthRenderbuffer(renderTarget);
        }
        function updateRenderTargetMipmap(renderTarget) {
            var texture = renderTarget.texture;
            if (textureNeedsGenerateMipmaps(texture, isPowerOfTwo(renderTarget))) {
                var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D, webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture), _gl.generateMipmap(target), state.bindTexture(target, null);
            }
        }
        var _isWebGL2 = "undefined" != typeof WebGL2RenderingContext && _gl instanceof WebGL2RenderingContext;
        this.setTexture2D = setTexture2D, this.setTextureCube = setTextureCube, this.setTextureCubeDynamic = setTextureCubeDynamic, 
        this.setupRenderTarget = setupRenderTarget, this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    }
    function WebGLProperties() {
        function get(object) {
            var uuid = object.uuid, map = properties[uuid];
            return void 0 === map && (map = {}, properties[uuid] = map), map;
        }
        function remove(object) {
            delete properties[object.uuid];
        }
        function clear() {
            properties = {};
        }
        var properties = {};
        return {
            get: get,
            remove: remove,
            clear: clear
        };
    }
    function WebGLState(gl, extensions, utils) {
        function ColorBuffer() {
            var locked = !1, color = new Vector4(), currentColorMask = null, currentColorClear = new Vector4(0, 0, 0, 0);
            return {
                setMask: function(colorMask) {
                    currentColorMask === colorMask || locked || (gl.colorMask(colorMask, colorMask, colorMask, colorMask), 
                    currentColorMask = colorMask);
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(r, g, b, a, premultipliedAlpha) {
                    !0 === premultipliedAlpha && (r *= a, g *= a, b *= a), color.set(r, g, b, a), !1 === currentColorClear.equals(color) && (gl.clearColor(r, g, b, a), 
                    currentColorClear.copy(color));
                },
                reset: function() {
                    locked = !1, currentColorMask = null, currentColorClear.set(-1, 0, 0, 0);
                }
            };
        }
        function DepthBuffer() {
            var locked = !1, currentDepthMask = null, currentDepthFunc = null, currentDepthClear = null;
            return {
                setTest: function(depthTest) {
                    depthTest ? enable(gl.DEPTH_TEST) : disable(gl.DEPTH_TEST);
                },
                setMask: function(depthMask) {
                    currentDepthMask === depthMask || locked || (gl.depthMask(depthMask), currentDepthMask = depthMask);
                },
                setFunc: function(depthFunc) {
                    if (currentDepthFunc !== depthFunc) {
                        if (depthFunc) switch (depthFunc) {
                          case NeverDepth:
                            gl.depthFunc(gl.NEVER);
                            break;

                          case AlwaysDepth:
                            gl.depthFunc(gl.ALWAYS);
                            break;

                          case LessDepth:
                            gl.depthFunc(gl.LESS);
                            break;

                          case LessEqualDepth:
                            gl.depthFunc(gl.LEQUAL);
                            break;

                          case EqualDepth:
                            gl.depthFunc(gl.EQUAL);
                            break;

                          case GreaterEqualDepth:
                            gl.depthFunc(gl.GEQUAL);
                            break;

                          case GreaterDepth:
                            gl.depthFunc(gl.GREATER);
                            break;

                          case NotEqualDepth:
                            gl.depthFunc(gl.NOTEQUAL);
                            break;

                          default:
                            gl.depthFunc(gl.LEQUAL);
                        } else gl.depthFunc(gl.LEQUAL);
                        currentDepthFunc = depthFunc;
                    }
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(depth) {
                    currentDepthClear !== depth && (gl.clearDepth(depth), currentDepthClear = depth);
                },
                reset: function() {
                    locked = !1, currentDepthMask = null, currentDepthFunc = null, currentDepthClear = null;
                }
            };
        }
        function StencilBuffer() {
            var locked = !1, currentStencilMask = null, currentStencilFunc = null, currentStencilRef = null, currentStencilFuncMask = null, currentStencilFail = null, currentStencilZFail = null, currentStencilZPass = null, currentStencilClear = null;
            return {
                setTest: function(stencilTest) {
                    stencilTest ? enable(gl.STENCIL_TEST) : disable(gl.STENCIL_TEST);
                },
                setMask: function(stencilMask) {
                    currentStencilMask === stencilMask || locked || (gl.stencilMask(stencilMask), currentStencilMask = stencilMask);
                },
                setFunc: function(stencilFunc, stencilRef, stencilMask) {
                    currentStencilFunc === stencilFunc && currentStencilRef === stencilRef && currentStencilFuncMask === stencilMask || (gl.stencilFunc(stencilFunc, stencilRef, stencilMask), 
                    currentStencilFunc = stencilFunc, currentStencilRef = stencilRef, currentStencilFuncMask = stencilMask);
                },
                setOp: function(stencilFail, stencilZFail, stencilZPass) {
                    currentStencilFail === stencilFail && currentStencilZFail === stencilZFail && currentStencilZPass === stencilZPass || (gl.stencilOp(stencilFail, stencilZFail, stencilZPass), 
                    currentStencilFail = stencilFail, currentStencilZFail = stencilZFail, currentStencilZPass = stencilZPass);
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(stencil) {
                    currentStencilClear !== stencil && (gl.clearStencil(stencil), currentStencilClear = stencil);
                },
                reset: function() {
                    locked = !1, currentStencilMask = null, currentStencilFunc = null, currentStencilRef = null, 
                    currentStencilFuncMask = null, currentStencilFail = null, currentStencilZFail = null, 
                    currentStencilZPass = null, currentStencilClear = null;
                }
            };
        }
        function createTexture(type, target, count) {
            var data = new Uint8Array(4), texture = gl.createTexture();
            gl.bindTexture(type, texture), gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST), 
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            for (var i = 0; i < count; i++) gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            return texture;
        }
        function initAttributes() {
            for (var i = 0, l = newAttributes.length; i < l; i++) newAttributes[i] = 0;
        }
        function enableAttribute(attribute) {
            if (newAttributes[attribute] = 1, 0 === enabledAttributes[attribute] && (gl.enableVertexAttribArray(attribute), 
            enabledAttributes[attribute] = 1), 0 !== attributeDivisors[attribute]) {
                extensions.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attribute, 0), 
                attributeDivisors[attribute] = 0;
            }
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
            if (newAttributes[attribute] = 1, 0 === enabledAttributes[attribute] && (gl.enableVertexAttribArray(attribute), 
            enabledAttributes[attribute] = 1), attributeDivisors[attribute] !== meshPerAttribute) {
                extensions.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attribute, meshPerAttribute), 
                attributeDivisors[attribute] = meshPerAttribute;
            }
        }
        function disableUnusedAttributes() {
            for (var i = 0, l = enabledAttributes.length; i !== l; ++i) enabledAttributes[i] !== newAttributes[i] && (gl.disableVertexAttribArray(i), 
            enabledAttributes[i] = 0);
        }
        function enable(id) {
            !0 !== capabilities[id] && (gl.enable(id), capabilities[id] = !0);
        }
        function disable(id) {
            !1 !== capabilities[id] && (gl.disable(id), capabilities[id] = !1);
        }
        function getCompressedTextureFormats() {
            if (null === compressedTextureFormats && (compressedTextureFormats = [], extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1"))) for (var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS), i = 0; i < formats.length; i++) compressedTextureFormats.push(formats[i]);
            return compressedTextureFormats;
        }
        function useProgram(program) {
            return currentProgram !== program && (gl.useProgram(program), currentProgram = program, 
            !0);
        }
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            if (blending !== NoBlending ? enable(gl.BLEND) : disable(gl.BLEND), blending !== CustomBlending) {
                if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) switch (blending) {
                  case AdditiveBlending:
                    premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE)) : (gl.blendEquation(gl.FUNC_ADD), 
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE));
                    break;

                  case SubtractiveBlending:
                    premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA)) : (gl.blendEquation(gl.FUNC_ADD), 
                    gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR));
                    break;

                  case MultiplyBlending:
                    premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA)) : (gl.blendEquation(gl.FUNC_ADD), 
                    gl.blendFunc(gl.ZERO, gl.SRC_COLOR));
                    break;

                  default:
                    premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)) : (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), 
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA));
                }
                currentBlendEquation = null, currentBlendSrc = null, currentBlendDst = null, currentBlendEquationAlpha = null, 
                currentBlendSrcAlpha = null, currentBlendDstAlpha = null;
            } else blendEquationAlpha = blendEquationAlpha || blendEquation, blendSrcAlpha = blendSrcAlpha || blendSrc, 
            blendDstAlpha = blendDstAlpha || blendDst, blendEquation === currentBlendEquation && blendEquationAlpha === currentBlendEquationAlpha || (gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha)), 
            currentBlendEquation = blendEquation, currentBlendEquationAlpha = blendEquationAlpha), 
            blendSrc === currentBlendSrc && blendDst === currentBlendDst && blendSrcAlpha === currentBlendSrcAlpha && blendDstAlpha === currentBlendDstAlpha || (gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha)), 
            currentBlendSrc = blendSrc, currentBlendDst = blendDst, currentBlendSrcAlpha = blendSrcAlpha, 
            currentBlendDstAlpha = blendDstAlpha);
            currentBlending = blending, currentPremultipledAlpha = premultipliedAlpha;
        }
        function setMaterial(material) {
            material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE), setFlipSided(material.side === BackSide), 
            !0 === material.transparent ? setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : setBlending(NoBlending), 
            depthBuffer.setFunc(material.depthFunc), depthBuffer.setTest(material.depthTest), 
            depthBuffer.setMask(material.depthWrite), colorBuffer.setMask(material.colorWrite), 
            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        function setFlipSided(flipSided) {
            currentFlipSided !== flipSided && (flipSided ? gl.frontFace(gl.CW) : gl.frontFace(gl.CCW), 
            currentFlipSided = flipSided);
        }
        function setCullFace(cullFace) {
            cullFace !== CullFaceNone ? (enable(gl.CULL_FACE), cullFace !== currentCullFace && (cullFace === CullFaceBack ? gl.cullFace(gl.BACK) : cullFace === CullFaceFront ? gl.cullFace(gl.FRONT) : gl.cullFace(gl.FRONT_AND_BACK))) : disable(gl.CULL_FACE), 
            currentCullFace = cullFace;
        }
        function setLineWidth(width) {
            width !== currentLineWidth && (lineWidthAvailable && gl.lineWidth(width), currentLineWidth = width);
        }
        function setPolygonOffset(polygonOffset, factor, units) {
            polygonOffset ? (enable(gl.POLYGON_OFFSET_FILL), currentPolygonOffsetFactor === factor && currentPolygonOffsetUnits === units || (gl.polygonOffset(factor, units), 
            currentPolygonOffsetFactor = factor, currentPolygonOffsetUnits = units)) : disable(gl.POLYGON_OFFSET_FILL);
        }
        function setScissorTest(scissorTest) {
            scissorTest ? enable(gl.SCISSOR_TEST) : disable(gl.SCISSOR_TEST);
        }
        function activeTexture(webglSlot) {
            void 0 === webglSlot && (webglSlot = gl.TEXTURE0 + maxTextures - 1), currentTextureSlot !== webglSlot && (gl.activeTexture(webglSlot), 
            currentTextureSlot = webglSlot);
        }
        function bindTexture(webglType, webglTexture) {
            null === currentTextureSlot && activeTexture();
            var boundTexture = currentBoundTextures[currentTextureSlot];
            void 0 === boundTexture && (boundTexture = {
                type: void 0,
                texture: void 0
            }, currentBoundTextures[currentTextureSlot] = boundTexture), boundTexture.type === webglType && boundTexture.texture === webglTexture || (gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]), 
            boundTexture.type = webglType, boundTexture.texture = webglTexture);
        }
        function compressedTexImage2D() {
            try {
                gl.compressedTexImage2D.apply(gl, arguments);
            } catch (error) {
                console.error("THREE.WebGLState:", error);
            }
        }
        function texImage2D() {
            try {
                gl.texImage2D.apply(gl, arguments);
            } catch (error) {
                console.error("THREE.WebGLState:", error);
            }
        }
        function scissor(scissor) {
            !1 === currentScissor.equals(scissor) && (gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w), 
            currentScissor.copy(scissor));
        }
        function viewport(viewport) {
            !1 === currentViewport.equals(viewport) && (gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w), 
            currentViewport.copy(viewport));
        }
        function reset() {
            for (var i = 0; i < enabledAttributes.length; i++) 1 === enabledAttributes[i] && (gl.disableVertexAttribArray(i), 
            enabledAttributes[i] = 0);
            capabilities = {}, compressedTextureFormats = null, currentTextureSlot = null, currentBoundTextures = {}, 
            currentProgram = null, currentBlending = null, currentFlipSided = null, currentCullFace = null, 
            colorBuffer.reset(), depthBuffer.reset(), stencilBuffer.reset();
        }
        var colorBuffer = new ColorBuffer(), depthBuffer = new DepthBuffer(), stencilBuffer = new StencilBuffer(), maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), newAttributes = new Uint8Array(maxVertexAttributes), enabledAttributes = new Uint8Array(maxVertexAttributes), attributeDivisors = new Uint8Array(maxVertexAttributes), capabilities = {}, compressedTextureFormats = null, currentProgram = null, currentBlending = null, currentBlendEquation = null, currentBlendSrc = null, currentBlendDst = null, currentBlendEquationAlpha = null, currentBlendSrcAlpha = null, currentBlendDstAlpha = null, currentPremultipledAlpha = !1, currentFlipSided = null, currentCullFace = null, currentLineWidth = null, currentPolygonOffsetFactor = null, currentPolygonOffsetUnits = null, maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS), version = parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]), lineWidthAvailable = parseFloat(version) >= 1, currentTextureSlot = null, currentBoundTextures = {}, currentScissor = new Vector4(), currentViewport = new Vector4(), emptyTextures = {};
        return emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1), 
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6), 
        colorBuffer.setClear(0, 0, 0, 1), depthBuffer.setClear(1), stencilBuffer.setClear(0), 
        enable(gl.DEPTH_TEST), depthBuffer.setFunc(LessEqualDepth), setFlipSided(!1), setCullFace(CullFaceBack), 
        enable(gl.CULL_FACE), enable(gl.BLEND), setBlending(NormalBlending), {
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            enableAttributeAndDivisor: enableAttributeAndDivisor,
            disableUnusedAttributes: disableUnusedAttributes,
            enable: enable,
            disable: disable,
            getCompressedTextureFormats: getCompressedTextureFormats,
            useProgram: useProgram,
            setBlending: setBlending,
            setMaterial: setMaterial,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            scissor: scissor,
            viewport: viewport,
            reset: reset
        };
    }
    function WebGLCapabilities(gl, extensions, parameters) {
        function getMaxAnisotropy() {
            if (void 0 !== maxAnisotropy) return maxAnisotropy;
            var extension = extensions.get("EXT_texture_filter_anisotropic");
            return maxAnisotropy = null !== extension ? gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        }
        function getMaxPrecision(precision) {
            if ("highp" === precision) {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) return "highp";
                precision = "mediump";
            }
            return "mediump" === precision && gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        var maxAnisotropy, precision = void 0 !== parameters.precision ? parameters.precision : "highp", maxPrecision = getMaxPrecision(precision);
        maxPrecision !== precision && (console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead."), 
        precision = maxPrecision);
        var logarithmicDepthBuffer = !0 === parameters.logarithmicDepthBuffer && !!extensions.get("EXT_frag_depth"), maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE), maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS), maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures = maxVertexTextures > 0, floatFragmentTextures = !!extensions.get("OES_texture_float");
        return {
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: vertexTextures && floatFragmentTextures
        };
    }
    function ArrayCamera(array) {
        PerspectiveCamera.call(this), this.cameras = array || [];
    }
    function WebVRManager(renderer) {
        function onVRDisplayPresentChange() {
            if (null !== device && device.isPresenting) {
                var eyeParameters = device.getEyeParameters("left"), renderWidth = eyeParameters.renderWidth, renderHeight = eyeParameters.renderHeight;
                currentPixelRatio = renderer.getPixelRatio(), currentSize = renderer.getSize(), 
                renderer.setDrawingBufferSize(2 * renderWidth, renderHeight, 1);
            } else scope.enabled && renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
        }
        var scope = this, device = null, frameData = null;
        "VRFrameData" in window && (frameData = new window.VRFrameData());
        var matrixWorldInverse = new Matrix4(), standingMatrix = new Matrix4(), standingMatrixInverse = new Matrix4(), cameraL = new PerspectiveCamera();
        cameraL.bounds = new Vector4(0, 0, .5, 1), cameraL.layers.enable(1);
        var cameraR = new PerspectiveCamera();
        cameraR.bounds = new Vector4(.5, 0, .5, 1), cameraR.layers.enable(2);
        var cameraVR = new ArrayCamera([ cameraL, cameraR ]);
        cameraVR.layers.enable(1), cameraVR.layers.enable(2);
        var currentSize, currentPixelRatio;
        window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, !1), 
        this.enabled = !1, this.standing = !1, this.getDevice = function() {
            return device;
        }, this.setDevice = function(value) {
            void 0 !== value && (device = value);
        }, this.getCamera = function(camera) {
            if (null === device) return camera;
            device.depthNear = camera.near, device.depthFar = camera.far, device.getFrameData(frameData);
            var pose = frameData.pose;
            null !== pose.position ? camera.position.fromArray(pose.position) : camera.position.set(0, 0, 0), 
            null !== pose.orientation && camera.quaternion.fromArray(pose.orientation), camera.updateMatrixWorld();
            var stageParameters = device.stageParameters;
            if (this.standing && stageParameters && (standingMatrix.fromArray(stageParameters.sittingToStandingTransform), 
            standingMatrixInverse.getInverse(standingMatrix), camera.matrixWorld.multiply(standingMatrix), 
            camera.matrixWorldInverse.multiply(standingMatrixInverse)), !1 === device.isPresenting) return camera;
            cameraL.near = camera.near, cameraR.near = camera.near, cameraL.far = camera.far, 
            cameraR.far = camera.far, cameraVR.matrixWorld.copy(camera.matrixWorld), cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse), 
            cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix), cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix), 
            this.standing && stageParameters && (cameraL.matrixWorldInverse.multiply(standingMatrixInverse), 
            cameraR.matrixWorldInverse.multiply(standingMatrixInverse));
            var parent = camera.parent;
            null !== parent && (matrixWorldInverse.getInverse(parent.matrixWorld), cameraL.matrixWorldInverse.multiply(matrixWorldInverse), 
            cameraR.matrixWorldInverse.multiply(matrixWorldInverse)), cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse), 
            cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse), cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix), 
            cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix), cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            var layers = device.getLayers();
            if (layers.length) {
                var layer = layers[0];
                null !== layer.leftBounds && 4 === layer.leftBounds.length && cameraL.bounds.fromArray(layer.leftBounds), 
                null !== layer.rightBounds && 4 === layer.rightBounds.length && cameraR.bounds.fromArray(layer.rightBounds);
            }
            return cameraVR;
        }, this.getStandingMatrix = function() {
            return standingMatrix;
        }, this.submitFrame = function() {
            device && device.isPresenting && device.submitFrame();
        }, this.dispose = function() {
            window.removeEventListener("vrdisplaypresentchange", onVRDisplayPresentChange);
        };
    }
    function WebGLExtensions(gl) {
        var extensions = {};
        return {
            get: function(name) {
                if (void 0 !== extensions[name]) return extensions[name];
                var extension;
                switch (name) {
                  case "WEBGL_depth_texture":
                    extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;

                  case "EXT_texture_filter_anisotropic":
                    extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;

                  case "WEBGL_compressed_texture_s3tc":
                    extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;

                  case "WEBGL_compressed_texture_pvrtc":
                    extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;

                  case "WEBGL_compressed_texture_etc1":
                    extension = gl.getExtension("WEBGL_compressed_texture_etc1");
                    break;

                  default:
                    extension = gl.getExtension(name);
                }
                return null === extension && console.warn("THREE.WebGLRenderer: " + name + " extension not supported."), 
                extensions[name] = extension, extension;
            }
        };
    }
    function WebGLClipping() {
        function resetGlobalState() {
            uniform.value !== globalState && (uniform.value = globalState, uniform.needsUpdate = numGlobalPlanes > 0), 
            scope.numPlanes = numGlobalPlanes, scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = null !== planes ? planes.length : 0, dstArray = null;
            if (0 !== nPlanes) {
                if (dstArray = uniform.value, !0 !== skipTransform || null === dstArray) {
                    var flatSize = dstOffset + 4 * nPlanes, viewMatrix = camera.matrixWorldInverse;
                    viewNormalMatrix.getNormalMatrix(viewMatrix), (null === dstArray || dstArray.length < flatSize) && (dstArray = new Float32Array(flatSize));
                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix), 
                    plane.normal.toArray(dstArray, i4), dstArray[i4 + 3] = plane.constant;
                }
                uniform.value = dstArray, uniform.needsUpdate = !0;
            }
            return scope.numPlanes = nPlanes, dstArray;
        }
        var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = !1, renderingShadows = !1, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = uniform, this.numPlanes = 0, this.numIntersection = 0, this.init = function(planes, enableLocalClipping, camera) {
            var enabled = 0 !== planes.length || enableLocalClipping || 0 !== numGlobalPlanes || localClippingEnabled;
            return localClippingEnabled = enableLocalClipping, globalState = projectPlanes(planes, camera, 0), 
            numGlobalPlanes = planes.length, enabled;
        }, this.beginShadows = function() {
            renderingShadows = !0, projectPlanes(null);
        }, this.endShadows = function() {
            renderingShadows = !1, resetGlobalState();
        }, this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
            if (!localClippingEnabled || null === planes || 0 === planes.length || renderingShadows && !clipShadows) renderingShadows ? projectPlanes(null) : resetGlobalState(); else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = 4 * nGlobal, dstArray = cache.clippingState || null;
                uniform.value = dstArray, dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) dstArray[i] = globalState[i];
                cache.clippingState = dstArray, this.numIntersection = clipIntersection ? this.numPlanes : 0, 
                this.numPlanes += nGlobal;
            }
        };
    }
    function WebGLUtils(gl, extensions) {
        function convert(p) {
            var extension;
            if (p === RepeatWrapping) return gl.REPEAT;
            if (p === ClampToEdgeWrapping) return gl.CLAMP_TO_EDGE;
            if (p === MirroredRepeatWrapping) return gl.MIRRORED_REPEAT;
            if (p === NearestFilter) return gl.NEAREST;
            if (p === NearestMipMapNearestFilter) return gl.NEAREST_MIPMAP_NEAREST;
            if (p === NearestMipMapLinearFilter) return gl.NEAREST_MIPMAP_LINEAR;
            if (p === LinearFilter) return gl.LINEAR;
            if (p === LinearMipMapNearestFilter) return gl.LINEAR_MIPMAP_NEAREST;
            if (p === LinearMipMapLinearFilter) return gl.LINEAR_MIPMAP_LINEAR;
            if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
            if (p === ByteType) return gl.BYTE;
            if (p === ShortType) return gl.SHORT;
            if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
            if (p === IntType) return gl.INT;
            if (p === UnsignedIntType) return gl.UNSIGNED_INT;
            if (p === FloatType) return gl.FLOAT;
            if (p === HalfFloatType && null !== (extension = extensions.get("OES_texture_half_float"))) return extension.HALF_FLOAT_OES;
            if (p === AlphaFormat) return gl.ALPHA;
            if (p === RGBFormat) return gl.RGB;
            if (p === RGBAFormat) return gl.RGBA;
            if (p === LuminanceFormat) return gl.LUMINANCE;
            if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
            if (p === DepthFormat) return gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
            if (p === AddEquation) return gl.FUNC_ADD;
            if (p === SubtractEquation) return gl.FUNC_SUBTRACT;
            if (p === ReverseSubtractEquation) return gl.FUNC_REVERSE_SUBTRACT;
            if (p === ZeroFactor) return gl.ZERO;
            if (p === OneFactor) return gl.ONE;
            if (p === SrcColorFactor) return gl.SRC_COLOR;
            if (p === OneMinusSrcColorFactor) return gl.ONE_MINUS_SRC_COLOR;
            if (p === SrcAlphaFactor) return gl.SRC_ALPHA;
            if (p === OneMinusSrcAlphaFactor) return gl.ONE_MINUS_SRC_ALPHA;
            if (p === DstAlphaFactor) return gl.DST_ALPHA;
            if (p === OneMinusDstAlphaFactor) return gl.ONE_MINUS_DST_ALPHA;
            if (p === DstColorFactor) return gl.DST_COLOR;
            if (p === OneMinusDstColorFactor) return gl.ONE_MINUS_DST_COLOR;
            if (p === SrcAlphaSaturateFactor) return gl.SRC_ALPHA_SATURATE;
            if ((p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) && null !== (extension = extensions.get("WEBGL_compressed_texture_s3tc"))) {
                if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            if ((p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) && null !== (extension = extensions.get("WEBGL_compressed_texture_pvrtc"))) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (p === RGB_ETC1_Format && null !== (extension = extensions.get("WEBGL_compressed_texture_etc1"))) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            if ((p === MinEquation || p === MaxEquation) && null !== (extension = extensions.get("EXT_blend_minmax"))) {
                if (p === MinEquation) return extension.MIN_EXT;
                if (p === MaxEquation) return extension.MAX_EXT;
            }
            return p === UnsignedInt248Type && null !== (extension = extensions.get("WEBGL_depth_texture")) ? extension.UNSIGNED_INT_24_8_WEBGL : 0;
        }
        return {
            convert: convert
        };
    }
    function WebGLRenderer(parameters) {
        function getTargetPixelRatio() {
            return null === _currentRenderTarget ? _pixelRatio : 1;
        }
        function initGLContext() {
            extensions = new WebGLExtensions(_gl), extensions.get("WEBGL_depth_texture"), extensions.get("OES_texture_float"), 
            extensions.get("OES_texture_float_linear"), extensions.get("OES_texture_half_float"), 
            extensions.get("OES_texture_half_float_linear"), extensions.get("OES_standard_derivatives"), 
            extensions.get("ANGLE_instanced_arrays"), extensions.get("OES_element_index_uint") && (BufferGeometry.MaxIndex = 4294967296), 
            utils = new WebGLUtils(_gl, extensions), capabilities = new WebGLCapabilities(_gl, extensions, parameters), 
            state = new WebGLState(_gl, extensions, utils), state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio)), 
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio)), properties = new WebGLProperties(), 
            textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, _infoMemory), 
            attributes = new WebGLAttributes(_gl), geometries = new WebGLGeometries(_gl, attributes, _infoMemory), 
            objects = new WebGLObjects(geometries, _infoRender), morphtargets = new WebGLMorphtargets(_gl), 
            programCache = new WebGLPrograms(_this, extensions, capabilities), lights = new WebGLLights(), 
            renderLists = new WebGLRenderLists(), background = new WebGLBackground(_this, state, geometries, _premultipliedAlpha), 
            bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender), indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender), 
            flareRenderer = new WebGLFlareRenderer(_this, _gl, state, textures, capabilities), 
            spriteRenderer = new WebGLSpriteRenderer(_this, _gl, state, textures, capabilities), 
            _this.info.programs = programCache.programs, _this.context = _gl, _this.capabilities = capabilities, 
            _this.extensions = extensions, _this.properties = properties, _this.renderLists = renderLists, 
            _this.state = state;
        }
        function onContextLost(event) {
            event.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _isContextLost = !0;
        }
        function onContextRestore(event) {
            console.log("THREE.WebGLRenderer: Context Restored."), _isContextLost = !1, initGLContext();
        }
        function onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener("dispose", onMaterialDispose), deallocateMaterial(material);
        }
        function deallocateMaterial(material) {
            releaseMaterialProgramReference(material), properties.remove(material);
        }
        function releaseMaterialProgramReference(material) {
            var programInfo = properties.get(material).program;
            material.program = void 0, void 0 !== programInfo && programCache.releaseProgram(programInfo);
        }
        function renderObjectImmediate(object, program, material) {
            object.render(function(object) {
                _this.renderBufferImmediate(object, program, material);
            });
        }
        function setupVertexAttributes(material, program, geometry, startIndex) {
            if (geometry && geometry.isInstancedBufferGeometry && null === extensions.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            void 0 === startIndex && (startIndex = 0), state.initAttributes();
            var geometryAttributes = geometry.attributes, programAttributes = program.getAttributes(), materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    var geometryAttribute = geometryAttributes[name];
                    if (void 0 !== geometryAttribute) {
                        var normalized = geometryAttribute.normalized, size = geometryAttribute.itemSize, attribute = attributes.get(geometryAttribute);
                        if (void 0 === attribute) continue;
                        var buffer = attribute.buffer, type = attribute.type, bytesPerElement = attribute.bytesPerElement;
                        if (geometryAttribute.isInterleavedBufferAttribute) {
                            var data = geometryAttribute.data, stride = data.stride, offset = geometryAttribute.offset;
                            data && data.isInstancedInterleavedBuffer ? (state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute), 
                            void 0 === geometry.maxInstancedCount && (geometry.maxInstancedCount = data.meshPerAttribute * data.count)) : state.enableAttribute(programAttribute), 
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer), _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, (startIndex * stride + offset) * bytesPerElement);
                        } else geometryAttribute.isInstancedBufferAttribute ? (state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute), 
                        void 0 === geometry.maxInstancedCount && (geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count)) : state.enableAttribute(programAttribute), 
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer), _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement);
                    } else if (void 0 !== materialDefaultAttributeValues) {
                        var value = materialDefaultAttributeValues[name];
                        if (void 0 !== value) switch (value.length) {
                          case 2:
                            _gl.vertexAttrib2fv(programAttribute, value);
                            break;

                          case 3:
                            _gl.vertexAttrib3fv(programAttribute, value);
                            break;

                          case 4:
                            _gl.vertexAttrib4fv(programAttribute, value);
                            break;

                          default:
                            _gl.vertexAttrib1fv(programAttribute, value);
                        }
                    }
                }
            }
            state.disableUnusedAttributes();
        }
        function start() {
            isAnimating || ((vr.getDevice() || window).requestAnimationFrame(loop), isAnimating = !0);
        }
        function loop(time) {
            null !== onAnimationFrame && onAnimationFrame(time), (vr.getDevice() || window).requestAnimationFrame(loop);
        }
        function projectObject(object, camera, sortObjects) {
            if (object.visible) {
                if (object.layers.test(camera.layers)) if (object.isLight) lightsArray.push(object), 
                object.castShadow && shadowsArray.push(object); else if (object.isSprite) object.frustumCulled && !_frustum.intersectsSprite(object) || spritesArray.push(object); else if (object.isLensFlare) flaresArray.push(object); else if (object.isImmediateRenderObject) sortObjects && _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix), 
                currentRenderList.push(object, null, object.material, _vector3.z, null); else if ((object.isMesh || object.isLine || object.isPoints) && (object.isSkinnedMesh && object.skeleton.update(), 
                !object.frustumCulled || _frustum.intersectsObject(object))) {
                    sortObjects && _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    var geometry = objects.update(object), material = object.material;
                    if (Array.isArray(material)) for (var groups = geometry.groups, i = 0, l = groups.length; i < l; i++) {
                        var group = groups[i], groupMaterial = material[group.materialIndex];
                        groupMaterial && groupMaterial.visible && currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);
                    } else material.visible && currentRenderList.push(object, geometry, material, _vector3.z, null);
                }
                for (var children = object.children, i = 0, l = children.length; i < l; i++) projectObject(children[i], camera, sortObjects);
            }
        }
        function renderObjects(renderList, scene, camera, overrideMaterial) {
            for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i], object = renderItem.object, geometry = renderItem.geometry, material = void 0 === overrideMaterial ? renderItem.material : overrideMaterial, group = renderItem.group;
                if (camera.isArrayCamera) {
                    _currentArrayCamera = camera;
                    for (var cameras = camera.cameras, j = 0, jl = cameras.length; j < jl; j++) {
                        var camera2 = cameras[j];
                        if (object.layers.test(camera2.layers)) {
                            var bounds = camera2.bounds, x = bounds.x * _width, y = bounds.y * _height, width = bounds.z * _width, height = bounds.w * _height;
                            state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio)), 
                            renderObject(object, scene, camera2, geometry, material, group);
                        }
                    }
                } else _currentArrayCamera = null, renderObject(object, scene, camera, geometry, material, group);
            }
        }
        function renderObject(object, scene, camera, geometry, material, group) {
            if (object.onBeforeRender(_this, scene, camera, geometry, material, group), object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld), 
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix), object.isImmediateRenderObject) {
                state.setMaterial(material);
                var program = setProgram(camera, scene.fog, material, object);
                _currentGeometryProgram = "", renderObjectImmediate(object, program, material);
            } else _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
            object.onAfterRender(_this, scene, camera, geometry, material, group);
        }
        function initMaterial(material, fog, object) {
            var materialProperties = properties.get(material), parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object), code = programCache.getProgramCode(material, parameters), program = materialProperties.program, programChange = !0;
            if (void 0 === program) material.addEventListener("dispose", onMaterialDispose); else if (program.code !== code) releaseMaterialProgramReference(material); else {
                if (void 0 !== parameters.shaderID) return;
                programChange = !1;
            }
            if (programChange) {
                if (parameters.shaderID) {
                    var shader = ShaderLib[parameters.shaderID];
                    materialProperties.shader = {
                        name: material.type,
                        uniforms: UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                } else materialProperties.shader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };
                material.onBeforeCompile(materialProperties.shader), program = programCache.acquireProgram(material, materialProperties.shader, parameters, code), 
                materialProperties.program = program, material.program = program;
            }
            var programAttributes = program.getAttributes();
            if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < _this.maxMorphTargets; i++) programAttributes["morphTarget" + i] >= 0 && material.numSupportedMorphTargets++;
            }
            if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < _this.maxMorphNormals; i++) programAttributes["morphNormal" + i] >= 0 && material.numSupportedMorphNormals++;
            }
            var uniforms = materialProperties.shader.uniforms;
            (material.isShaderMaterial || material.isRawShaderMaterial) && !0 !== material.clipping || (materialProperties.numClippingPlanes = _clipping.numPlanes, 
            materialProperties.numIntersection = _clipping.numIntersection, uniforms.clippingPlanes = _clipping.uniform), 
            materialProperties.fog = fog, materialProperties.lightsHash = lights.state.hash, 
            material.lights && (uniforms.ambientLightColor.value = lights.state.ambient, uniforms.directionalLights.value = lights.state.directional, 
            uniforms.spotLights.value = lights.state.spot, uniforms.rectAreaLights.value = lights.state.rectArea, 
            uniforms.pointLights.value = lights.state.point, uniforms.hemisphereLights.value = lights.state.hemi, 
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap, uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix, 
            uniforms.spotShadowMap.value = lights.state.spotShadowMap, uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix, 
            uniforms.pointShadowMap.value = lights.state.pointShadowMap, uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix);
            var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
            materialProperties.uniformsList = uniformsList;
        }
        function setProgram(camera, fog, material, object) {
            _usedTextureUnits = 0;
            var materialProperties = properties.get(material);
            if (_clippingEnabled && (_localClippingEnabled || camera !== _currentCamera)) {
                var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
            }
            !1 === material.needsUpdate && (void 0 === materialProperties.program ? material.needsUpdate = !0 : material.fog && materialProperties.fog !== fog ? material.needsUpdate = !0 : material.lights && materialProperties.lightsHash !== lights.state.hash ? material.needsUpdate = !0 : void 0 === materialProperties.numClippingPlanes || materialProperties.numClippingPlanes === _clipping.numPlanes && materialProperties.numIntersection === _clipping.numIntersection || (material.needsUpdate = !0)), 
            material.needsUpdate && (initMaterial(material, fog, object), material.needsUpdate = !1);
            var refreshProgram = !1, refreshMaterial = !1, refreshLights = !1, program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms;
            if (state.useProgram(program.program) && (refreshProgram = !0, refreshMaterial = !0, 
            refreshLights = !0), material.id !== _currentMaterialId && (_currentMaterialId = material.id, 
            refreshMaterial = !0), refreshProgram || camera !== _currentCamera) {
                if (p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix), capabilities.logarithmicDepthBuffer && p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2)), 
                _currentCamera !== (_currentArrayCamera || camera) && (_currentCamera = _currentArrayCamera || camera, 
                refreshMaterial = !0, refreshLights = !0), material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    void 0 !== uCamPos && uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                }
                (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) && p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
            }
            if (material.skinning) {
                p_uniforms.setOptional(_gl, object, "bindMatrix"), p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
                var skeleton = object.skeleton;
                if (skeleton) {
                    var bones = skeleton.bones;
                    if (capabilities.floatVertexTextures) {
                        if (void 0 === skeleton.boneTexture) {
                            var size = Math.sqrt(4 * bones.length);
                            size = _Math.nextPowerOfTwo(Math.ceil(size)), size = Math.max(size, 4);
                            var boneMatrices = new Float32Array(size * size * 4);
                            boneMatrices.set(skeleton.boneMatrices);
                            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                            skeleton.boneMatrices = boneMatrices, skeleton.boneTexture = boneTexture, skeleton.boneTextureSize = size;
                        }
                        p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture), p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
                    } else p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
                }
            }
            return refreshMaterial && (p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure), 
            p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint), 
            material.lights && markUniformsLightsNeedsUpdate(m_uniforms, refreshLights), fog && material.fog && refreshUniformsFog(m_uniforms, fog), 
            material.isMeshBasicMaterial ? refreshUniformsCommon(m_uniforms, material) : material.isMeshLambertMaterial ? (refreshUniformsCommon(m_uniforms, material), 
            refreshUniformsLambert(m_uniforms, material)) : material.isMeshPhongMaterial ? (refreshUniformsCommon(m_uniforms, material), 
            material.isMeshToonMaterial ? refreshUniformsToon(m_uniforms, material) : refreshUniformsPhong(m_uniforms, material)) : material.isMeshStandardMaterial ? (refreshUniformsCommon(m_uniforms, material), 
            material.isMeshPhysicalMaterial ? refreshUniformsPhysical(m_uniforms, material) : refreshUniformsStandard(m_uniforms, material)) : material.isMeshDepthMaterial ? (refreshUniformsCommon(m_uniforms, material), 
            refreshUniformsDepth(m_uniforms, material)) : material.isMeshDistanceMaterial ? (refreshUniformsCommon(m_uniforms, material), 
            refreshUniformsDistance(m_uniforms, material)) : material.isMeshNormalMaterial ? (refreshUniformsCommon(m_uniforms, material), 
            refreshUniformsNormal(m_uniforms, material)) : material.isLineBasicMaterial ? (refreshUniformsLine(m_uniforms, material), 
            material.isLineDashedMaterial && refreshUniformsDash(m_uniforms, material)) : material.isPointsMaterial ? refreshUniformsPoints(m_uniforms, material) : material.isShadowMaterial && (m_uniforms.color.value = material.color, 
            m_uniforms.opacity.value = material.opacity), void 0 !== m_uniforms.ltcMat && (m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE), 
            void 0 !== m_uniforms.ltcMag && (m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE), 
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this)), 
            p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix), p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix), 
            p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld), program;
        }
        function refreshUniformsCommon(uniforms, material) {
            uniforms.opacity.value = material.opacity, material.color && (uniforms.diffuse.value = material.color), 
            material.emissive && uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity), 
            material.map && (uniforms.map.value = material.map), material.alphaMap && (uniforms.alphaMap.value = material.alphaMap), 
            material.specularMap && (uniforms.specularMap.value = material.specularMap), material.envMap && (uniforms.envMap.value = material.envMap, 
            uniforms.flipEnvMap.value = material.envMap && material.envMap.isCubeTexture ? -1 : 1, 
            uniforms.reflectivity.value = material.reflectivity, uniforms.refractionRatio.value = material.refractionRatio), 
            material.lightMap && (uniforms.lightMap.value = material.lightMap, uniforms.lightMapIntensity.value = material.lightMapIntensity), 
            material.aoMap && (uniforms.aoMap.value = material.aoMap, uniforms.aoMapIntensity.value = material.aoMapIntensity);
            var uvScaleMap;
            if (material.map ? uvScaleMap = material.map : material.specularMap ? uvScaleMap = material.specularMap : material.displacementMap ? uvScaleMap = material.displacementMap : material.normalMap ? uvScaleMap = material.normalMap : material.bumpMap ? uvScaleMap = material.bumpMap : material.roughnessMap ? uvScaleMap = material.roughnessMap : material.metalnessMap ? uvScaleMap = material.metalnessMap : material.alphaMap ? uvScaleMap = material.alphaMap : material.emissiveMap && (uvScaleMap = material.emissiveMap), 
            void 0 !== uvScaleMap) {
                uvScaleMap.isWebGLRenderTarget && (uvScaleMap = uvScaleMap.texture);
                var offset = uvScaleMap.offset, repeat = uvScaleMap.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
        }
        function refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value = material.color, uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize, uniforms.totalSize.value = material.dashSize + material.gapSize, 
            uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material) {
            if (uniforms.diffuse.value = material.color, uniforms.opacity.value = material.opacity, 
            uniforms.size.value = material.size * _pixelRatio, uniforms.scale.value = .5 * _height, 
            uniforms.map.value = material.map, null !== material.map) {
                var offset = material.map.offset, repeat = material.map.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
        }
        function refreshUniformsFog(uniforms, fog) {
            uniforms.fogColor.value = fog.color, fog.isFog ? (uniforms.fogNear.value = fog.near, 
            uniforms.fogFar.value = fog.far) : fog.isFogExp2 && (uniforms.fogDensity.value = fog.density);
        }
        function refreshUniformsLambert(uniforms, material) {
            material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap);
        }
        function refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value = material.specular, uniforms.shininess.value = Math.max(material.shininess, 1e-4), 
            material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap), material.bumpMap && (uniforms.bumpMap.value = material.bumpMap, 
            uniforms.bumpScale.value = material.bumpScale), material.normalMap && (uniforms.normalMap.value = material.normalMap, 
            uniforms.normalScale.value.copy(material.normalScale)), material.displacementMap && (uniforms.displacementMap.value = material.displacementMap, 
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias);
        }
        function refreshUniformsToon(uniforms, material) {
            refreshUniformsPhong(uniforms, material), material.gradientMap && (uniforms.gradientMap.value = material.gradientMap);
        }
        function refreshUniformsStandard(uniforms, material) {
            uniforms.roughness.value = material.roughness, uniforms.metalness.value = material.metalness, 
            material.roughnessMap && (uniforms.roughnessMap.value = material.roughnessMap), 
            material.metalnessMap && (uniforms.metalnessMap.value = material.metalnessMap), 
            material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap), material.bumpMap && (uniforms.bumpMap.value = material.bumpMap, 
            uniforms.bumpScale.value = material.bumpScale), material.normalMap && (uniforms.normalMap.value = material.normalMap, 
            uniforms.normalScale.value.copy(material.normalScale)), material.displacementMap && (uniforms.displacementMap.value = material.displacementMap, 
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias), 
            material.envMap && (uniforms.envMapIntensity.value = material.envMapIntensity);
        }
        function refreshUniformsPhysical(uniforms, material) {
            uniforms.clearCoat.value = material.clearCoat, uniforms.clearCoatRoughness.value = material.clearCoatRoughness, 
            refreshUniformsStandard(uniforms, material);
        }
        function refreshUniformsDepth(uniforms, material) {
            material.displacementMap && (uniforms.displacementMap.value = material.displacementMap, 
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias);
        }
        function refreshUniformsDistance(uniforms, material) {
            material.displacementMap && (uniforms.displacementMap.value = material.displacementMap, 
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias), 
            uniforms.referencePosition.value.copy(material.referencePosition), uniforms.nearDistance.value = material.nearDistance, 
            uniforms.farDistance.value = material.farDistance;
        }
        function refreshUniformsNormal(uniforms, material) {
            material.bumpMap && (uniforms.bumpMap.value = material.bumpMap, uniforms.bumpScale.value = material.bumpScale), 
            material.normalMap && (uniforms.normalMap.value = material.normalMap, uniforms.normalScale.value.copy(material.normalScale)), 
            material.displacementMap && (uniforms.displacementMap.value = material.displacementMap, 
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias);
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value, uniforms.directionalLights.needsUpdate = value, 
            uniforms.pointLights.needsUpdate = value, uniforms.spotLights.needsUpdate = value, 
            uniforms.rectAreaLights.needsUpdate = value, uniforms.hemisphereLights.needsUpdate = value;
        }
        function allocTextureUnit() {
            var textureUnit = _usedTextureUnits;
            return textureUnit >= capabilities.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures), 
            _usedTextureUnits += 1, textureUnit;
        }
        console.log("THREE.WebGLRenderer", REVISION), parameters = parameters || {};
        var _canvas = void 0 !== parameters.canvas ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = void 0 !== parameters.context ? parameters.context : null, _alpha = void 0 !== parameters.alpha && parameters.alpha, _depth = void 0 === parameters.depth || parameters.depth, _stencil = void 0 === parameters.stencil || parameters.stencil, _antialias = void 0 !== parameters.antialias && parameters.antialias, _premultipliedAlpha = void 0 === parameters.premultipliedAlpha || parameters.premultipliedAlpha, _preserveDrawingBuffer = void 0 !== parameters.preserveDrawingBuffer && parameters.preserveDrawingBuffer, lightsArray = [], shadowsArray = [], currentRenderList = null, spritesArray = [], flaresArray = [];
        this.domElement = _canvas, this.context = null, this.autoClear = !0, this.autoClearColor = !0, 
        this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], 
        this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, 
        this.physicallyCorrectLights = !1, this.toneMapping = LinearToneMapping, this.toneMappingExposure = 1, 
        this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var _this = this, _isContextLost = !1, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = "", _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, _usedTextureUnits = 0, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = !1, _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = !1, _localClippingEnabled = !1, _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(), _infoMemory = {
            geometries: 0,
            textures: 0
        }, _infoRender = {
            frame: 0,
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        };
        this.info = {
            render: _infoRender,
            memory: _infoMemory,
            programs: null
        };
        var _gl;
        try {
            var contextAttributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer
            };
            if (null === (_gl = _context || _canvas.getContext("webgl", contextAttributes) || _canvas.getContext("experimental-webgl", contextAttributes))) throw null !== _canvas.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
            void 0 === _gl.getShaderPrecisionFormat && (_gl.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                };
            }), _canvas.addEventListener("webglcontextlost", onContextLost, !1), _canvas.addEventListener("webglcontextrestored", onContextRestore, !1);
        } catch (error) {
            console.error("THREE.WebGLRenderer: " + error);
        }
        var extensions, capabilities, state, properties, textures, attributes, geometries, objects, lights, programCache, renderLists, background, morphtargets, bufferRenderer, indexedBufferRenderer, flareRenderer, spriteRenderer, utils;
        initGLContext();
        var vr = new WebVRManager(_this);
        this.vr = vr;
        var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
        this.shadowMap = shadowMap, this.getContext = function() {
            return _gl;
        }, this.getContextAttributes = function() {
            return _gl.getContextAttributes();
        }, this.forceContextLoss = function() {
            var extension = extensions.get("WEBGL_lose_context");
            extension && extension.loseContext();
        }, this.forceContextRestore = function() {
            var extension = extensions.get("WEBGL_lose_context");
            extension && extension.restoreContext();
        }, this.getPixelRatio = function() {
            return _pixelRatio;
        }, this.setPixelRatio = function(value) {
            void 0 !== value && (_pixelRatio = value, this.setSize(_width, _height, !1));
        }, this.getSize = function() {
            return {
                width: _width,
                height: _height
            };
        }, this.setSize = function(width, height, updateStyle) {
            var device = vr.getDevice();
            if (device && device.isPresenting) return void console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            _width = width, _height = height, _canvas.width = width * _pixelRatio, _canvas.height = height * _pixelRatio, 
            !1 !== updateStyle && (_canvas.style.width = width + "px", _canvas.style.height = height + "px"), 
            this.setViewport(0, 0, width, height);
        }, this.getDrawingBufferSize = function() {
            return {
                width: _width * _pixelRatio,
                height: _height * _pixelRatio
            };
        }, this.setDrawingBufferSize = function(width, height, pixelRatio) {
            _width = width, _height = height, _pixelRatio = pixelRatio, _canvas.width = width * pixelRatio, 
            _canvas.height = height * pixelRatio, this.setViewport(0, 0, width, height);
        }, this.setViewport = function(x, y, width, height) {
            _viewport.set(x, _height - y - height, width, height), state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
        }, this.setScissor = function(x, y, width, height) {
            _scissor.set(x, _height - y - height, width, height), state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
        }, this.setScissorTest = function(boolean) {
            state.setScissorTest(_scissorTest = boolean);
        }, this.getClearColor = background.getClearColor, this.setClearColor = background.setClearColor, 
        this.getClearAlpha = background.getClearAlpha, this.setClearAlpha = background.setClearAlpha, 
        this.clear = function(color, depth, stencil) {
            var bits = 0;
            (void 0 === color || color) && (bits |= _gl.COLOR_BUFFER_BIT), (void 0 === depth || depth) && (bits |= _gl.DEPTH_BUFFER_BIT), 
            (void 0 === stencil || stencil) && (bits |= _gl.STENCIL_BUFFER_BIT), _gl.clear(bits);
        }, this.clearColor = function() {
            this.clear(!0, !1, !1);
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1);
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0);
        }, this.clearTarget = function(renderTarget, color, depth, stencil) {
            this.setRenderTarget(renderTarget), this.clear(color, depth, stencil);
        }, this.dispose = function() {
            _canvas.removeEventListener("webglcontextlost", onContextLost, !1), _canvas.removeEventListener("webglcontextrestored", onContextRestore, !1), 
            renderLists.dispose(), vr.dispose();
        }, this.renderBufferImmediate = function(object, program, material) {
            state.initAttributes();
            var buffers = properties.get(object);
            object.hasPositions && !buffers.position && (buffers.position = _gl.createBuffer()), 
            object.hasNormals && !buffers.normal && (buffers.normal = _gl.createBuffer()), object.hasUvs && !buffers.uv && (buffers.uv = _gl.createBuffer()), 
            object.hasColors && !buffers.color && (buffers.color = _gl.createBuffer());
            var programAttributes = program.getAttributes();
            if (object.hasPositions && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position), 
            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW), state.enableAttribute(programAttributes.position), 
            _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, !1, 0, 0)), object.hasNormals) {
                if (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal), !material.isMeshPhongMaterial && !material.isMeshStandardMaterial && !material.isMeshNormalMaterial && !0 === material.flatShading) for (var i = 0, l = 3 * object.count; i < l; i += 9) {
                    var array = object.normalArray, nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3, ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3, nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                    array[i + 0] = nx, array[i + 1] = ny, array[i + 2] = nz, array[i + 3] = nx, array[i + 4] = ny, 
                    array[i + 5] = nz, array[i + 6] = nx, array[i + 7] = ny, array[i + 8] = nz;
                }
                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW), state.enableAttribute(programAttributes.normal), 
                _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, !1, 0, 0);
            }
            object.hasUvs && material.map && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv), 
            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW), state.enableAttribute(programAttributes.uv), 
            _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, !1, 0, 0)), object.hasColors && material.vertexColors !== NoColors && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color), 
            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW), state.enableAttribute(programAttributes.color), 
            _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, !1, 0, 0)), state.disableUnusedAttributes(), 
            _gl.drawArrays(_gl.TRIANGLES, 0, object.count), object.count = 0;
        }, this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
            state.setMaterial(material);
            var program = setProgram(camera, fog, material, object), geometryProgram = geometry.id + "_" + program.id + "_" + (!0 === material.wireframe), updateBuffers = !1;
            geometryProgram !== _currentGeometryProgram && (_currentGeometryProgram = geometryProgram, 
            updateBuffers = !0), object.morphTargetInfluences && (morphtargets.update(object, geometry, material, program), 
            updateBuffers = !0);
            var index = geometry.index, position = geometry.attributes.position, rangeFactor = 1;
            !0 === material.wireframe && (index = geometries.getWireframeAttribute(geometry), 
            rangeFactor = 2);
            var attribute, renderer = bufferRenderer;
            null !== index && (attribute = attributes.get(index), renderer = indexedBufferRenderer, 
            renderer.setIndex(attribute)), updateBuffers && (setupVertexAttributes(material, program, geometry), 
            null !== index && _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer));
            var dataCount = 0;
            null !== index ? dataCount = index.count : void 0 !== position && (dataCount = position.count);
            var rangeStart = geometry.drawRange.start * rangeFactor, rangeCount = geometry.drawRange.count * rangeFactor, groupStart = null !== group ? group.start * rangeFactor : 0, groupCount = null !== group ? group.count * rangeFactor : 1 / 0, drawStart = Math.max(rangeStart, groupStart), drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1, drawCount = Math.max(0, drawEnd - drawStart + 1);
            if (0 !== drawCount) {
                if (object.isMesh) if (!0 === material.wireframe) state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio()), 
                renderer.setMode(_gl.LINES); else switch (object.drawMode) {
                  case TrianglesDrawMode:
                    renderer.setMode(_gl.TRIANGLES);
                    break;

                  case TriangleStripDrawMode:
                    renderer.setMode(_gl.TRIANGLE_STRIP);
                    break;

                  case TriangleFanDrawMode:
                    renderer.setMode(_gl.TRIANGLE_FAN);
                } else if (object.isLine) {
                    var lineWidth = material.linewidth;
                    void 0 === lineWidth && (lineWidth = 1), state.setLineWidth(lineWidth * getTargetPixelRatio()), 
                    object.isLineSegments ? renderer.setMode(_gl.LINES) : object.isLineLoop ? renderer.setMode(_gl.LINE_LOOP) : renderer.setMode(_gl.LINE_STRIP);
                } else object.isPoints && renderer.setMode(_gl.POINTS);
                geometry && geometry.isInstancedBufferGeometry ? geometry.maxInstancedCount > 0 && renderer.renderInstances(geometry, drawStart, drawCount) : renderer.render(drawStart, drawCount);
            }
        }, this.compile = function(scene, camera) {
            lightsArray.length = 0, shadowsArray.length = 0, scene.traverse(function(object) {
                object.isLight && (lightsArray.push(object), object.castShadow && shadowsArray.push(object));
            }), lights.setup(lightsArray, shadowsArray, camera), scene.traverse(function(object) {
                if (object.material) if (Array.isArray(object.material)) for (var i = 0; i < object.material.length; i++) initMaterial(object.material[i], scene.fog, object); else initMaterial(object.material, scene.fog, object);
            });
        };
        var isAnimating = !1, onAnimationFrame = null;
        this.animate = function(callback) {
            onAnimationFrame = callback, start();
        }, this.render = function(scene, camera, renderTarget, forceClear) {
            if (!camera || !camera.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!_isContextLost) {
                _currentGeometryProgram = "", _currentMaterialId = -1, _currentCamera = null, !0 === scene.autoUpdate && scene.updateMatrixWorld(), 
                null === camera.parent && camera.updateMatrixWorld(), vr.enabled && (camera = vr.getCamera(camera)), 
                _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse), 
                _frustum.setFromMatrix(_projScreenMatrix), lightsArray.length = 0, shadowsArray.length = 0, 
                spritesArray.length = 0, flaresArray.length = 0, _localClippingEnabled = this.localClippingEnabled, 
                _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera), 
                currentRenderList = renderLists.get(scene, camera), currentRenderList.init(), projectObject(scene, camera, _this.sortObjects), 
                !0 === _this.sortObjects && currentRenderList.sort(), _clippingEnabled && _clipping.beginShadows(), 
                shadowMap.render(shadowsArray, scene, camera), lights.setup(lightsArray, shadowsArray, camera), 
                _clippingEnabled && _clipping.endShadows(), _infoRender.frame++, _infoRender.calls = 0, 
                _infoRender.vertices = 0, _infoRender.faces = 0, _infoRender.points = 0, void 0 === renderTarget && (renderTarget = null), 
                this.setRenderTarget(renderTarget), background.render(currentRenderList, scene, camera, forceClear);
                var opaqueObjects = currentRenderList.opaque, transparentObjects = currentRenderList.transparent;
                if (scene.overrideMaterial) {
                    var overrideMaterial = scene.overrideMaterial;
                    opaqueObjects.length && renderObjects(opaqueObjects, scene, camera, overrideMaterial), 
                    transparentObjects.length && renderObjects(transparentObjects, scene, camera, overrideMaterial);
                } else opaqueObjects.length && renderObjects(opaqueObjects, scene, camera), transparentObjects.length && renderObjects(transparentObjects, scene, camera);
                spriteRenderer.render(spritesArray, scene, camera), flareRenderer.render(flaresArray, scene, camera, _currentViewport), 
                renderTarget && textures.updateRenderTargetMipmap(renderTarget), state.buffers.depth.setTest(!0), 
                state.buffers.depth.setMask(!0), state.buffers.color.setMask(!0), state.setPolygonOffset(!1), 
                vr.enabled && vr.submitFrame();
            }
        }, this.setFaceCulling = function(cullFace, frontFaceDirection) {
            state.setCullFace(cullFace), state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
        }, this.allocTextureUnit = allocTextureUnit, this.setTexture2D = function() {
            var warned = !1;
            return function(texture, slot) {
                texture && texture.isWebGLRenderTarget && (warned || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), 
                warned = !0), texture = texture.texture), textures.setTexture2D(texture, slot);
            };
        }(), this.setTexture = function() {
            var warned = !1;
            return function(texture, slot) {
                warned || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), 
                warned = !0), textures.setTexture2D(texture, slot);
            };
        }(), this.setTextureCube = function() {
            var warned = !1;
            return function(texture, slot) {
                texture && texture.isWebGLRenderTargetCube && (warned || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), 
                warned = !0), texture = texture.texture), texture && texture.isCubeTexture || Array.isArray(texture.image) && 6 === texture.image.length ? textures.setTextureCube(texture, slot) : textures.setTextureCubeDynamic(texture, slot);
            };
        }(), this.getRenderTarget = function() {
            return _currentRenderTarget;
        }, this.setRenderTarget = function(renderTarget) {
            _currentRenderTarget = renderTarget, renderTarget && void 0 === properties.get(renderTarget).__webglFramebuffer && textures.setupRenderTarget(renderTarget);
            var framebuffer = null, isCube = !1;
            if (renderTarget) {
                var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                renderTarget.isWebGLRenderTargetCube ? (framebuffer = __webglFramebuffer[renderTarget.activeCubeFace], 
                isCube = !0) : framebuffer = __webglFramebuffer, _currentViewport.copy(renderTarget.viewport), 
                _currentScissor.copy(renderTarget.scissor), _currentScissorTest = renderTarget.scissorTest;
            } else _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio), _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio), 
            _currentScissorTest = _scissorTest;
            if (_currentFramebuffer !== framebuffer && (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), 
            _currentFramebuffer = framebuffer), state.viewport(_currentViewport), state.scissor(_currentScissor), 
            state.setScissorTest(_currentScissorTest), isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
            }
        }, this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
            if (!renderTarget || !renderTarget.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            var framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (framebuffer) {
                var restore = !1;
                framebuffer !== _currentFramebuffer && (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), 
                restore = !0);
                try {
                    var texture = renderTarget.texture, textureFormat = texture.format, textureType = texture.type;
                    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    if (!(textureType === UnsignedByteType || utils.convert(textureType) === _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) || textureType === FloatType && (extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float")) || textureType === HalfFloatType && extensions.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    _gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE ? x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height && _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
                } finally {
                    restore && _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                }
            }
        };
    }
    function FogExp2(color, density) {
        this.name = "", this.color = new Color(color), this.density = void 0 !== density ? density : 25e-5;
    }
    function Fog(color, near, far) {
        this.name = "", this.color = new Color(color), this.near = void 0 !== near ? near : 1, 
        this.far = void 0 !== far ? far : 1e3;
    }
    function Scene() {
        Object3D.call(this), this.type = "Scene", this.background = null, this.fog = null, 
        this.overrideMaterial = null, this.autoUpdate = !0;
    }
    function LensFlare(texture, size, distance, blending, color) {
        Object3D.call(this), this.lensFlares = [], this.positionScreen = new Vector3(), 
        this.customUpdateCallback = void 0, void 0 !== texture && this.add(texture, size, distance, blending, color);
    }
    function SpriteMaterial(parameters) {
        Material.call(this), this.type = "SpriteMaterial", this.color = new Color(16777215), 
        this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(parameters);
    }
    function Sprite(material) {
        Object3D.call(this), this.type = "Sprite", this.material = void 0 !== material ? material : new SpriteMaterial();
    }
    function LOD() {
        Object3D.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        });
    }
    function Skeleton(bones, boneInverses) {
        if (bones = bones || [], this.bones = bones.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), 
        void 0 === boneInverses) this.calculateInverses(); else if (this.bones.length === boneInverses.length) this.boneInverses = boneInverses.slice(0); else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var i = 0, il = this.bones.length; i < il; i++) this.boneInverses.push(new Matrix4());
        }
    }
    function Bone() {
        Object3D.call(this), this.type = "Bone";
    }
    function SkinnedMesh(geometry, material) {
        Mesh.call(this, geometry, material), this.type = "SkinnedMesh", this.bindMode = "attached", 
        this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4();
        var bones = this.initBones(), skeleton = new Skeleton(bones);
        this.bind(skeleton, this.matrixWorld), this.normalizeSkinWeights();
    }
    function LineBasicMaterial(parameters) {
        Material.call(this), this.type = "LineBasicMaterial", this.color = new Color(16777215), 
        this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, 
        this.setValues(parameters);
    }
    function Line(geometry, material, mode) {
        if (1 === mode) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), 
        new LineSegments(geometry, material);
        Object3D.call(this), this.type = "Line", this.geometry = void 0 !== geometry ? geometry : new BufferGeometry(), 
        this.material = void 0 !== material ? material : new LineBasicMaterial({
            color: 16777215 * Math.random()
        });
    }
    function LineSegments(geometry, material) {
        Line.call(this, geometry, material), this.type = "LineSegments";
    }
    function LineLoop(geometry, material) {
        Line.call(this, geometry, material), this.type = "LineLoop";
    }
    function PointsMaterial(parameters) {
        Material.call(this), this.type = "PointsMaterial", this.color = new Color(16777215), 
        this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(parameters);
    }
    function Points(geometry, material) {
        Object3D.call(this), this.type = "Points", this.geometry = void 0 !== geometry ? geometry : new BufferGeometry(), 
        this.material = void 0 !== material ? material : new PointsMaterial({
            color: 16777215 * Math.random()
        });
    }
    function Group() {
        Object3D.call(this), this.type = "Group";
    }
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        function update() {
            requestAnimationFrame(update), video.readyState >= video.HAVE_CURRENT_DATA && (scope.needsUpdate = !0);
        }
        Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy), 
        this.generateMipmaps = !1;
        var scope = this;
        update();
    }
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding), 
        this.image = {
            width: width,
            height: height
        }, this.mipmaps = mipmaps, this.flipY = !1, this.generateMipmaps = !1;
    }
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        if ((format = void 0 !== format ? format : DepthFormat) !== DepthFormat && format !== DepthStencilFormat) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === type && format === DepthFormat && (type = UnsignedShortType), void 0 === type && format === DepthStencilFormat && (type = UnsignedInt248Type), 
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy), 
        this.image = {
            width: width,
            height: height
        }, this.magFilter = void 0 !== magFilter ? magFilter : NearestFilter, this.minFilter = void 0 !== minFilter ? minFilter : NearestFilter, 
        this.flipY = !1, this.generateMipmaps = !1;
    }
    function WireframeGeometry(geometry) {
        BufferGeometry.call(this), this.type = "WireframeGeometry";
        var i, j, l, o, ol, e, edge1, edge2, key, vertex, vertices = [], edge = [ 0, 0 ], edges = {}, keys = [ "a", "b", "c" ];
        if (geometry && geometry.isGeometry) {
            var faces = geometry.faces;
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (j = 0; j < 3; j++) edge1 = face[keys[j]], edge2 = face[keys[(j + 1) % 3]], 
                edge[0] = Math.min(edge1, edge2), edge[1] = Math.max(edge1, edge2), key = edge[0] + "," + edge[1], 
                void 0 === edges[key] && (edges[key] = {
                    index1: edge[0],
                    index2: edge[1]
                });
            }
            for (key in edges) e = edges[key], vertex = geometry.vertices[e.index1], vertices.push(vertex.x, vertex.y, vertex.z), 
            vertex = geometry.vertices[e.index2], vertices.push(vertex.x, vertex.y, vertex.z);
        } else if (geometry && geometry.isBufferGeometry) {
            var position, indices, groups, group, start, count, index1, index2;
            if (vertex = new Vector3(), null !== geometry.index) {
                for (position = geometry.attributes.position, indices = geometry.index, groups = geometry.groups, 
                0 === groups.length && (groups = [ {
                    start: 0,
                    count: indices.count,
                    materialIndex: 0
                } ]), o = 0, ol = groups.length; o < ol; ++o) for (group = groups[o], start = group.start, 
                count = group.count, i = start, l = start + count; i < l; i += 3) for (j = 0; j < 3; j++) edge1 = indices.getX(i + j), 
                edge2 = indices.getX(i + (j + 1) % 3), edge[0] = Math.min(edge1, edge2), edge[1] = Math.max(edge1, edge2), 
                key = edge[0] + "," + edge[1], void 0 === edges[key] && (edges[key] = {
                    index1: edge[0],
                    index2: edge[1]
                });
                for (key in edges) e = edges[key], vertex.fromBufferAttribute(position, e.index1), 
                vertices.push(vertex.x, vertex.y, vertex.z), vertex.fromBufferAttribute(position, e.index2), 
                vertices.push(vertex.x, vertex.y, vertex.z);
            } else for (position = geometry.attributes.position, i = 0, l = position.count / 3; i < l; i++) for (j = 0; j < 3; j++) index1 = 3 * i + j, 
            vertex.fromBufferAttribute(position, index1), vertices.push(vertex.x, vertex.y, vertex.z), 
            index2 = 3 * i + (j + 1) % 3, vertex.fromBufferAttribute(position, index2), vertices.push(vertex.x, vertex.y, vertex.z);
        }
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
    function ParametricGeometry(func, slices, stacks) {
        Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        }, this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks)), 
        this.mergeVertices();
    }
    function ParametricBufferGeometry(func, slices, stacks) {
        BufferGeometry.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        var i, j, indices = [], vertices = [], normals = [], uvs = [], normal = new Vector3(), p0 = new Vector3(), p1 = new Vector3(), pu = new Vector3(), pv = new Vector3(), sliceCount = slices + 1;
        for (i = 0; i <= stacks; i++) {
            var v = i / stacks;
            for (j = 0; j <= slices; j++) {
                var u = j / slices;
                p0 = func(u, v, p0), vertices.push(p0.x, p0.y, p0.z), u - 1e-5 >= 0 ? (p1 = func(u - 1e-5, v, p1), 
                pu.subVectors(p0, p1)) : (p1 = func(u + 1e-5, v, p1), pu.subVectors(p1, p0)), v - 1e-5 >= 0 ? (p1 = func(u, v - 1e-5, p1), 
                pv.subVectors(p0, p1)) : (p1 = func(u, v + 1e-5, p1), pv.subVectors(p1, p0)), normal.crossVectors(pu, pv).normalize(), 
                normals.push(normal.x, normal.y, normal.z), uvs.push(u, v);
            }
        }
        for (i = 0; i < stacks; i++) for (j = 0; j < slices; j++) {
            var a = i * sliceCount + j, b = i * sliceCount + j + 1, c = (i + 1) * sliceCount + j + 1, d = (i + 1) * sliceCount + j;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function PolyhedronGeometry(vertices, indices, radius, detail) {
        Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail)), 
        this.mergeVertices();
    }
    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
        function subdivideFace(a, b, c, detail) {
            var i, j, cols = Math.pow(2, detail), v = [];
            for (i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols), bj = b.clone().lerp(c, i / cols), rows = cols - i;
                for (j = 0; j <= rows; j++) v[i][j] = 0 === j && i === cols ? aj : aj.clone().lerp(bj, j / rows);
            }
            for (i = 0; i < cols; i++) for (j = 0; j < 2 * (cols - i) - 1; j++) {
                var k = Math.floor(j / 2);
                j % 2 == 0 ? (pushVertex(v[i][k + 1]), pushVertex(v[i + 1][k]), pushVertex(v[i][k])) : (pushVertex(v[i][k + 1]), 
                pushVertex(v[i + 1][k + 1]), pushVertex(v[i + 1][k]));
            }
        }
        function correctSeam() {
            for (var i = 0; i < uvBuffer.length; i += 6) {
                var x0 = uvBuffer[i + 0], x1 = uvBuffer[i + 2], x2 = uvBuffer[i + 4], max = Math.max(x0, x1, x2), min = Math.min(x0, x1, x2);
                max > .9 && min < .1 && (x0 < .2 && (uvBuffer[i + 0] += 1), x1 < .2 && (uvBuffer[i + 2] += 1), 
                x2 < .2 && (uvBuffer[i + 4] += 1));
            }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
            var stride = 3 * index;
            vertex.x = vertices[stride + 0], vertex.y = vertices[stride + 1], vertex.z = vertices[stride + 2];
        }
        function correctUVs() {
            for (var a = new Vector3(), b = new Vector3(), c = new Vector3(), centroid = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), i = 0, j = 0; i < vertexBuffer.length; i += 9, 
            j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]), b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]), 
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]), uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]), 
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]), uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]), 
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi), correctUV(uvB, j + 2, b, azi), correctUV(uvC, j + 4, c, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            azimuth < 0 && 1 === uv.x && (uvBuffer[stride] = uv.x - 1), 0 === vector.x && 0 === vector.z && (uvBuffer[stride] = azimuth / 2 / Math.PI + .5);
        }
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
        BufferGeometry.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        }, radius = radius || 1, detail = detail || 0;
        var vertexBuffer = [], uvBuffer = [];
        !function(detail) {
            for (var a = new Vector3(), b = new Vector3(), c = new Vector3(), i = 0; i < indices.length; i += 3) getVertexByIndex(indices[i + 0], a), 
            getVertexByIndex(indices[i + 1], b), getVertexByIndex(indices[i + 2], c), subdivideFace(a, b, c, detail);
        }(detail), function(radius) {
            for (var vertex = new Vector3(), i = 0; i < vertexBuffer.length; i += 3) vertex.x = vertexBuffer[i + 0], 
            vertex.y = vertexBuffer[i + 1], vertex.z = vertexBuffer[i + 2], vertex.normalize().multiplyScalar(radius), 
            vertexBuffer[i + 0] = vertex.x, vertexBuffer[i + 1] = vertex.y, vertexBuffer[i + 2] = vertex.z;
        }(radius), function() {
            for (var vertex = new Vector3(), i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0], vertex.y = vertexBuffer[i + 1], vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + .5, v = inclination(vertex) / Math.PI + .5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs(), correctSeam();
        }(), this.addAttribute("position", new Float32BufferAttribute(vertexBuffer, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3)), 
        this.addAttribute("uv", new Float32BufferAttribute(uvBuffer, 2)), 0 === detail ? this.computeVertexNormals() : this.normalizeNormals();
    }
    function TetrahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function TetrahedronBufferGeometry(radius, detail) {
        var vertices = [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ], indices = [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "TetrahedronBufferGeometry", 
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function OctahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function OctahedronBufferGeometry(radius, detail) {
        var vertices = [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ], indices = [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "OctahedronBufferGeometry", 
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function IcosahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function IcosahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2, vertices = [ -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1 ], indices = [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "IcosahedronBufferGeometry", 
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function DodecahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function DodecahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2, r = 1 / t, vertices = [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r ], indices = [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "DodecahedronBufferGeometry", 
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
        Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        }, void 0 !== taper && console.warn("THREE.TubeGeometry: taper has been removed.");
        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
        this.tangents = bufferGeometry.tangents, this.normals = bufferGeometry.normals, 
        this.binormals = bufferGeometry.binormals, this.fromBufferGeometry(bufferGeometry), 
        this.mergeVertices();
    }
    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
        function generateSegment(i) {
            var P = path.getPointAt(i / tubularSegments), N = frames.normals[i], B = frames.binormals[i];
            for (j = 0; j <= radialSegments; j++) {
                var v = j / radialSegments * Math.PI * 2, sin = Math.sin(v), cos = -Math.cos(v);
                normal.x = cos * N.x + sin * B.x, normal.y = cos * N.y + sin * B.y, normal.z = cos * N.z + sin * B.z, 
                normal.normalize(), normals.push(normal.x, normal.y, normal.z), vertex.x = P.x + radius * normal.x, 
                vertex.y = P.y + radius * normal.y, vertex.z = P.z + radius * normal.z, vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        function generateIndices() {
            for (j = 1; j <= tubularSegments; j++) for (i = 1; i <= radialSegments; i++) {
                var a = (radialSegments + 1) * (j - 1) + (i - 1), b = (radialSegments + 1) * j + (i - 1), c = (radialSegments + 1) * j + i, d = (radialSegments + 1) * (j - 1) + i;
                indices.push(a, b, d), indices.push(b, c, d);
            }
        }
        function generateUVs() {
            for (i = 0; i <= tubularSegments; i++) for (j = 0; j <= radialSegments; j++) uv.x = i / tubularSegments, 
            uv.y = j / radialSegments, uvs.push(uv.x, uv.y);
        }
        BufferGeometry.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        }, tubularSegments = tubularSegments || 64, radius = radius || 1, radialSegments = radialSegments || 8, 
        closed = closed || !1;
        var frames = path.computeFrenetFrames(tubularSegments, closed);
        this.tangents = frames.tangents, this.normals = frames.normals, this.binormals = frames.binormals;
        var i, j, vertex = new Vector3(), normal = new Vector3(), uv = new Vector2(), vertices = [], normals = [], uvs = [], indices = [];
        !function() {
            for (i = 0; i < tubularSegments; i++) generateSegment(i);
            generateSegment(!1 === closed ? tubularSegments : 0), generateUVs(), generateIndices();
        }(), this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
        Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        }, void 0 !== heightScale && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), 
        this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q)), 
        this.mergeVertices();
    }
    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
        function calculatePositionOnCurve(u, p, q, radius, position) {
            var cu = Math.cos(u), su = Math.sin(u), quOverP = q / p * u, cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * .5 * cu, position.y = radius * (2 + cs) * su * .5, 
            position.z = radius * Math.sin(quOverP) * .5;
        }
        BufferGeometry.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        }, radius = radius || 100, tube = tube || 40, tubularSegments = Math.floor(tubularSegments) || 64, 
        radialSegments = Math.floor(radialSegments) || 8, p = p || 2, q = q || 3;
        var i, j, indices = [], vertices = [], normals = [], uvs = [], vertex = new Vector3(), normal = new Vector3(), P1 = new Vector3(), P2 = new Vector3(), B = new Vector3(), T = new Vector3(), N = new Vector3();
        for (i = 0; i <= tubularSegments; ++i) {
            var u = i / tubularSegments * p * Math.PI * 2;
            for (calculatePositionOnCurve(u, p, q, radius, P1), calculatePositionOnCurve(u + .01, p, q, radius, P2), 
            T.subVectors(P2, P1), N.addVectors(P2, P1), B.crossVectors(T, N), N.crossVectors(B, T), 
            B.normalize(), N.normalize(), j = 0; j <= radialSegments; ++j) {
                var v = j / radialSegments * Math.PI * 2, cx = -tube * Math.cos(v), cy = tube * Math.sin(v);
                vertex.x = P1.x + (cx * N.x + cy * B.x), vertex.y = P1.y + (cx * N.y + cy * B.y), 
                vertex.z = P1.z + (cx * N.z + cy * B.z), vertices.push(vertex.x, vertex.y, vertex.z), 
                normal.subVectors(vertex, P1).normalize(), normals.push(normal.x, normal.y, normal.z), 
                uvs.push(i / tubularSegments), uvs.push(j / radialSegments);
            }
        }
        for (j = 1; j <= tubularSegments; j++) for (i = 1; i <= radialSegments; i++) {
            var a = (radialSegments + 1) * (j - 1) + (i - 1), b = (radialSegments + 1) * j + (i - 1), c = (radialSegments + 1) * j + i, d = (radialSegments + 1) * (j - 1) + i;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        }, this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc)), 
        this.mergeVertices();
    }
    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        BufferGeometry.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        }, radius = radius || 100, tube = tube || 40, radialSegments = Math.floor(radialSegments) || 8, 
        tubularSegments = Math.floor(tubularSegments) || 6, arc = arc || 2 * Math.PI;
        var j, i, indices = [], vertices = [], normals = [], uvs = [], center = new Vector3(), vertex = new Vector3(), normal = new Vector3();
        for (j = 0; j <= radialSegments; j++) for (i = 0; i <= tubularSegments; i++) {
            var u = i / tubularSegments * arc, v = j / radialSegments * Math.PI * 2;
            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u), vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u), 
            vertex.z = tube * Math.sin(v), vertices.push(vertex.x, vertex.y, vertex.z), center.x = radius * Math.cos(u), 
            center.y = radius * Math.sin(u), normal.subVectors(vertex, center).normalize(), 
            normals.push(normal.x, normal.y, normal.z), uvs.push(i / tubularSegments), uvs.push(j / radialSegments);
        }
        for (j = 1; j <= radialSegments; j++) for (i = 1; i <= tubularSegments; i++) {
            var a = (tubularSegments + 1) * j + i - 1, b = (tubularSegments + 1) * (j - 1) + i - 1, c = (tubularSegments + 1) * (j - 1) + i, d = (tubularSegments + 1) * j + i;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function ExtrudeGeometry(shapes, options) {
        Geometry.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: shapes,
            options: options
        }, this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options)), this.mergeVertices();
    }
    function ExtrudeBufferGeometry(shapes, options) {
        void 0 !== shapes && (BufferGeometry.call(this), this.type = "ExtrudeBufferGeometry", 
        shapes = Array.isArray(shapes) ? shapes : [ shapes ], this.addShapeList(shapes, options), 
        this.computeVertexNormals());
    }
    function TextGeometry(text, parameters) {
        Geometry.call(this), this.type = "TextGeometry", this.parameters = {
            text: text,
            parameters: parameters
        }, this.fromBufferGeometry(new TextBufferGeometry(text, parameters)), this.mergeVertices();
    }
    function TextBufferGeometry(text, parameters) {
        parameters = parameters || {};
        var font = parameters.font;
        if (!font || !font.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), 
        new Geometry();
        var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
        parameters.amount = void 0 !== parameters.height ? parameters.height : 50, void 0 === parameters.bevelThickness && (parameters.bevelThickness = 10), 
        void 0 === parameters.bevelSize && (parameters.bevelSize = 8), void 0 === parameters.bevelEnabled && (parameters.bevelEnabled = !1), 
        ExtrudeBufferGeometry.call(this, shapes, parameters), this.type = "TextBufferGeometry";
    }
    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)), 
        this.mergeVertices();
    }
    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        BufferGeometry.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, radius = radius || 50, widthSegments = Math.max(3, Math.floor(widthSegments) || 8), 
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6), phiStart = void 0 !== phiStart ? phiStart : 0, 
        phiLength = void 0 !== phiLength ? phiLength : 2 * Math.PI, thetaStart = void 0 !== thetaStart ? thetaStart : 0, 
        thetaLength = void 0 !== thetaLength ? thetaLength : Math.PI;
        var ix, iy, thetaEnd = thetaStart + thetaLength, index = 0, grid = [], vertex = new Vector3(), normal = new Vector3(), indices = [], vertices = [], normals = [], uvs = [];
        for (iy = 0; iy <= heightSegments; iy++) {
            var verticesRow = [], v = iy / heightSegments;
            for (ix = 0; ix <= widthSegments; ix++) {
                var u = ix / widthSegments;
                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), 
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength), vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), 
                vertices.push(vertex.x, vertex.y, vertex.z), normal.set(vertex.x, vertex.y, vertex.z).normalize(), 
                normals.push(normal.x, normal.y, normal.z), uvs.push(u, 1 - v), verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        for (iy = 0; iy < heightSegments; iy++) for (ix = 0; ix < widthSegments; ix++) {
            var a = grid[iy][ix + 1], b = grid[iy][ix], c = grid[iy + 1][ix], d = grid[iy + 1][ix + 1];
            (0 !== iy || thetaStart > 0) && indices.push(a, b, d), (iy !== heightSegments - 1 || thetaEnd < Math.PI) && indices.push(b, c, d);
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength)), 
        this.mergeVertices();
    }
    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        BufferGeometry.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, innerRadius = innerRadius || 20, outerRadius = outerRadius || 50, thetaStart = void 0 !== thetaStart ? thetaStart : 0, 
        thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI, thetaSegments = void 0 !== thetaSegments ? Math.max(3, thetaSegments) : 8, 
        phiSegments = void 0 !== phiSegments ? Math.max(1, phiSegments) : 1;
        var segment, j, i, indices = [], vertices = [], normals = [], uvs = [], radius = innerRadius, radiusStep = (outerRadius - innerRadius) / phiSegments, vertex = new Vector3(), uv = new Vector2();
        for (j = 0; j <= phiSegments; j++) {
            for (i = 0; i <= thetaSegments; i++) segment = thetaStart + i / thetaSegments * thetaLength, 
            vertex.x = radius * Math.cos(segment), vertex.y = radius * Math.sin(segment), vertices.push(vertex.x, vertex.y, vertex.z), 
            normals.push(0, 0, 1), uv.x = (vertex.x / outerRadius + 1) / 2, uv.y = (vertex.y / outerRadius + 1) / 2, 
            uvs.push(uv.x, uv.y);
            radius += radiusStep;
        }
        for (j = 0; j < phiSegments; j++) {
            var thetaSegmentLevel = j * (thetaSegments + 1);
            for (i = 0; i < thetaSegments; i++) {
                segment = i + thetaSegmentLevel;
                var a = segment, b = segment + thetaSegments + 1, c = segment + thetaSegments + 2, d = segment + 1;
                indices.push(a, b, d), indices.push(b, c, d);
            }
        }
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function LatheGeometry(points, segments, phiStart, phiLength) {
        Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        }, this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength)), 
        this.mergeVertices();
    }
    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
        BufferGeometry.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        }, segments = Math.floor(segments) || 12, phiStart = phiStart || 0, phiLength = phiLength || 2 * Math.PI, 
        phiLength = _Math.clamp(phiLength, 0, 2 * Math.PI);
        var base, i, j, indices = [], vertices = [], uvs = [], inverseSegments = 1 / segments, vertex = new Vector3(), uv = new Vector2();
        for (i = 0; i <= segments; i++) {
            var phi = phiStart + i * inverseSegments * phiLength, sin = Math.sin(phi), cos = Math.cos(phi);
            for (j = 0; j <= points.length - 1; j++) vertex.x = points[j].x * sin, vertex.y = points[j].y, 
            vertex.z = points[j].x * cos, vertices.push(vertex.x, vertex.y, vertex.z), uv.x = i / segments, 
            uv.y = j / (points.length - 1), uvs.push(uv.x, uv.y);
        }
        for (i = 0; i < segments; i++) for (j = 0; j < points.length - 1; j++) {
            base = j + i * points.length;
            var a = base, b = base + points.length, c = base + points.length + 1, d = base + 1;
            indices.push(a, b, d), indices.push(b, c, d);
        }
        if (this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("uv", new Float32BufferAttribute(uvs, 2)), this.computeVertexNormals(), 
        phiLength === 2 * Math.PI) {
            var normals = this.attributes.normal.array, n1 = new Vector3(), n2 = new Vector3(), n = new Vector3();
            for (base = segments * points.length * 3, i = 0, j = 0; i < points.length; i++, 
            j += 3) n1.x = normals[j + 0], n1.y = normals[j + 1], n1.z = normals[j + 2], n2.x = normals[base + j + 0], 
            n2.y = normals[base + j + 1], n2.z = normals[base + j + 2], n.addVectors(n1, n2).normalize(), 
            normals[j + 0] = normals[base + j + 0] = n.x, normals[j + 1] = normals[base + j + 1] = n.y, 
            normals[j + 2] = normals[base + j + 2] = n.z;
        }
    }
    function ShapeGeometry(shapes, curveSegments) {
        Geometry.call(this), this.type = "ShapeGeometry", "object" == typeof curveSegments && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), 
        curveSegments = curveSegments.curveSegments), this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        }, this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments)), this.mergeVertices();
    }
    function ShapeBufferGeometry(shapes, curveSegments) {
        function addShape(shape) {
            var i, l, shapeHole, indexOffset = vertices.length / 3, points = shape.extractPoints(curveSegments), shapeVertices = points.shape, shapeHoles = points.holes;
            if (!1 === ShapeUtils.isClockWise(shapeVertices)) for (shapeVertices = shapeVertices.reverse(), 
            i = 0, l = shapeHoles.length; i < l; i++) shapeHole = shapeHoles[i], !0 === ShapeUtils.isClockWise(shapeHole) && (shapeHoles[i] = shapeHole.reverse());
            var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (i = 0, l = shapeHoles.length; i < l; i++) shapeHole = shapeHoles[i], shapeVertices = shapeVertices.concat(shapeHole);
            for (i = 0, l = shapeVertices.length; i < l; i++) {
                var vertex = shapeVertices[i];
                vertices.push(vertex.x, vertex.y, 0), normals.push(0, 0, 1), uvs.push(vertex.x, vertex.y);
            }
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i], a = face[0] + indexOffset, b = face[1] + indexOffset, c = face[2] + indexOffset;
                indices.push(a, b, c), groupCount += 3;
            }
        }
        BufferGeometry.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        }, curveSegments = curveSegments || 12;
        var indices = [], vertices = [], normals = [], uvs = [], groupStart = 0, groupCount = 0;
        if (!1 === Array.isArray(shapes)) addShape(shapes); else for (var i = 0; i < shapes.length; i++) addShape(shapes[i]), 
        this.addGroup(groupStart, groupCount, i), groupStart += groupCount, groupCount = 0;
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function EdgesGeometry(geometry, thresholdAngle) {
        BufferGeometry.call(this), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: thresholdAngle
        }, thresholdAngle = void 0 !== thresholdAngle ? thresholdAngle : 1;
        var edge1, edge2, key, geometry2, vertices = [], thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle), edge = [ 0, 0 ], edges = {}, keys = [ "a", "b", "c" ];
        geometry.isBufferGeometry ? (geometry2 = new Geometry(), geometry2.fromBufferGeometry(geometry)) : geometry2 = geometry.clone(), 
        geometry2.mergeVertices(), geometry2.computeFaceNormals();
        for (var sourceVertices = geometry2.vertices, faces = geometry2.faces, i = 0, l = faces.length; i < l; i++) for (var face = faces[i], j = 0; j < 3; j++) edge1 = face[keys[j]], 
        edge2 = face[keys[(j + 1) % 3]], edge[0] = Math.min(edge1, edge2), edge[1] = Math.max(edge1, edge2), 
        key = edge[0] + "," + edge[1], void 0 === edges[key] ? edges[key] = {
            index1: edge[0],
            index2: edge[1],
            face1: i,
            face2: void 0
        } : edges[key].face2 = i;
        for (key in edges) {
            var e = edges[key];
            if (void 0 === e.face2 || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
                var vertex = sourceVertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z), vertex = sourceVertices[e.index2], 
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength)), 
        this.mergeVertices();
    }
    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        function generateCap(top) {
            var x, centerIndexStart, centerIndexEnd, uv = new Vector2(), vertex = new Vector3(), groupCount = 0, radius = !0 === top ? radiusTop : radiusBottom, sign = !0 === top ? 1 : -1;
            for (centerIndexStart = index, x = 1; x <= radialSegments; x++) vertices.push(0, halfHeight * sign, 0), 
            normals.push(0, sign, 0), uvs.push(.5, .5), index++;
            for (centerIndexEnd = index, x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments, theta = u * thetaLength + thetaStart, cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
                vertex.x = radius * sinTheta, vertex.y = halfHeight * sign, vertex.z = radius * cosTheta, 
                vertices.push(vertex.x, vertex.y, vertex.z), normals.push(0, sign, 0), uv.x = .5 * cosTheta + .5, 
                uv.y = .5 * sinTheta * sign + .5, uvs.push(uv.x, uv.y), index++;
            }
            for (x = 0; x < radialSegments; x++) {
                var c = centerIndexStart + x, i = centerIndexEnd + x;
                !0 === top ? indices.push(i, i + 1, c) : indices.push(i + 1, i, c), groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, !0 === top ? 1 : 2), groupStart += groupCount;
        }
        BufferGeometry.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        var scope = this;
        radiusTop = void 0 !== radiusTop ? radiusTop : 20, radiusBottom = void 0 !== radiusBottom ? radiusBottom : 20, 
        height = void 0 !== height ? height : 100, radialSegments = Math.floor(radialSegments) || 8, 
        heightSegments = Math.floor(heightSegments) || 1, openEnded = void 0 !== openEnded && openEnded, 
        thetaStart = void 0 !== thetaStart ? thetaStart : 0, thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI;
        var indices = [], vertices = [], normals = [], uvs = [], index = 0, indexArray = [], halfHeight = height / 2, groupStart = 0;
        !function() {
            var x, y, normal = new Vector3(), vertex = new Vector3(), groupCount = 0, slope = (radiusBottom - radiusTop) / height;
            for (y = 0; y <= heightSegments; y++) {
                var indexRow = [], v = y / heightSegments, radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments, theta = u * thetaLength + thetaStart, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                    vertex.x = radius * sinTheta, vertex.y = -v * height + halfHeight, vertex.z = radius * cosTheta, 
                    vertices.push(vertex.x, vertex.y, vertex.z), normal.set(sinTheta, slope, cosTheta).normalize(), 
                    normals.push(normal.x, normal.y, normal.z), uvs.push(u, 1 - v), indexRow.push(index++);
                }
                indexArray.push(indexRow);
            }
            for (x = 0; x < radialSegments; x++) for (y = 0; y < heightSegments; y++) {
                var a = indexArray[y][x], b = indexArray[y + 1][x], c = indexArray[y + 1][x + 1], d = indexArray[y][x + 1];
                indices.push(a, b, d), indices.push(b, c, d), groupCount += 6;
            }
            scope.addGroup(groupStart, groupCount, 0), groupStart += groupCount;
        }(), !1 === openEnded && (radiusTop > 0 && generateCap(!0), radiusBottom > 0 && generateCap(!1)), 
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength), 
        this.type = "ConeGeometry", this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength), 
        this.type = "ConeBufferGeometry", this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength)), 
        this.mergeVertices();
    }
    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
        BufferGeometry.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, radius = radius || 50, segments = void 0 !== segments ? Math.max(3, segments) : 8, 
        thetaStart = void 0 !== thetaStart ? thetaStart : 0, thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI;
        var i, s, indices = [], vertices = [], normals = [], uvs = [], vertex = new Vector3(), uv = new Vector2();
        for (vertices.push(0, 0, 0), normals.push(0, 0, 1), uvs.push(.5, .5), s = 0, i = 3; s <= segments; s++, 
        i += 3) {
            var segment = thetaStart + s / segments * thetaLength;
            vertex.x = radius * Math.cos(segment), vertex.y = radius * Math.sin(segment), vertices.push(vertex.x, vertex.y, vertex.z), 
            normals.push(0, 0, 1), uv.x = (vertices[i] / radius + 1) / 2, uv.y = (vertices[i + 1] / radius + 1) / 2, 
            uvs.push(uv.x, uv.y);
        }
        for (i = 1; i <= segments; i++) indices.push(i, i + 1, 0);
        this.setIndex(indices), this.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new Float32BufferAttribute(normals, 3)), this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    function ShadowMaterial(parameters) {
        Material.call(this), this.type = "ShadowMaterial", this.color = new Color(0), this.opacity = 1, 
        this.lights = !0, this.transparent = !0, this.setValues(parameters);
    }
    function RawShaderMaterial(parameters) {
        ShaderMaterial.call(this, parameters), this.type = "RawShaderMaterial";
    }
    function MeshStandardMaterial(parameters) {
        Material.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = .5, 
        this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, 
        this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, 
        this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, 
        this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, 
        this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, 
        this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, 
        this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", 
        this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(parameters);
    }
    function MeshPhysicalMaterial(parameters) {
        MeshStandardMaterial.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, 
        this.clearCoatRoughness = 0, this.setValues(parameters);
    }
    function MeshPhongMaterial(parameters) {
        Material.call(this), this.type = "MeshPhongMaterial", this.color = new Color(16777215), 
        this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, 
        this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), 
        this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, 
        this.normalMap = null, this.normalScale = new Vector2(1, 1), this.displacementMap = null, 
        this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, 
        this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, 
        this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", 
        this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, 
        this.setValues(parameters);
    }
    function MeshToonMaterial(parameters) {
        MeshPhongMaterial.call(this), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(parameters);
    }
    function MeshNormalMaterial(parameters) {
        Material.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, 
        this.normalMap = null, this.normalScale = new Vector2(1, 1), this.displacementMap = null, 
        this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, 
        this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, 
        this.setValues(parameters);
    }
    function MeshLambertMaterial(parameters) {
        Material.call(this), this.type = "MeshLambertMaterial", this.color = new Color(16777215), 
        this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, 
        this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, 
        this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, 
        this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
        this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", 
        this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, 
        this.setValues(parameters);
    }
    function LineDashedMaterial(parameters) {
        LineBasicMaterial.call(this), this.type = "LineDashedMaterial", this.scale = 1, 
        this.dashSize = 3, this.gapSize = 1, this.setValues(parameters);
    }
    function LoadingManager(onLoad, onProgress, onError) {
        var scope = this, isLoading = !1, itemsLoaded = 0, itemsTotal = 0;
        this.onStart = void 0, this.onLoad = onLoad, this.onProgress = onProgress, this.onError = onError, 
        this.itemStart = function(url) {
            itemsTotal++, !1 === isLoading && void 0 !== scope.onStart && scope.onStart(url, itemsLoaded, itemsTotal), 
            isLoading = !0;
        }, this.itemEnd = function(url) {
            itemsLoaded++, void 0 !== scope.onProgress && scope.onProgress(url, itemsLoaded, itemsTotal), 
            itemsLoaded === itemsTotal && (isLoading = !1, void 0 !== scope.onLoad && scope.onLoad());
        }, this.itemError = function(url) {
            void 0 !== scope.onError && scope.onError(url);
        };
    }
    function FileLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function CompressedTextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this._parser = null;
    }
    function DataTextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this._parser = null;
    }
    function ImageLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function CubeTextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function TextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function Light(color, intensity) {
        Object3D.call(this), this.type = "Light", this.color = new Color(color), this.intensity = void 0 !== intensity ? intensity : 1, 
        this.receiveShadow = void 0;
    }
    function HemisphereLight(skyColor, groundColor, intensity) {
        Light.call(this, skyColor, intensity), this.type = "HemisphereLight", this.castShadow = void 0, 
        this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color(groundColor);
    }
    function LightShadow(camera) {
        this.camera = camera, this.bias = 0, this.radius = 1, this.mapSize = new Vector2(512, 512), 
        this.map = null, this.matrix = new Matrix4();
    }
    function SpotLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(50, 1, .5, 500));
    }
    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
        Light.call(this, color, intensity), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), 
        this.updateMatrix(), this.target = new Object3D(), Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI;
            },
            set: function(power) {
                this.intensity = power / Math.PI;
            }
        }), this.distance = void 0 !== distance ? distance : 0, this.angle = void 0 !== angle ? angle : Math.PI / 3, 
        this.penumbra = void 0 !== penumbra ? penumbra : 0, this.decay = void 0 !== decay ? decay : 1, 
        this.shadow = new SpotLightShadow();
    }
    function PointLight(color, intensity, distance, decay) {
        Light.call(this, color, intensity), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI;
            },
            set: function(power) {
                this.intensity = power / (4 * Math.PI);
            }
        }), this.distance = void 0 !== distance ? distance : 0, this.decay = void 0 !== decay ? decay : 1, 
        this.shadow = new LightShadow(new PerspectiveCamera(90, 1, .5, 500));
    }
    function DirectionalLightShadow() {
        LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, .5, 500));
    }
    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), 
        this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadow();
    }
    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity), this.type = "AmbientLight", this.castShadow = void 0;
    }
    function RectAreaLight(color, intensity, width, height) {
        Light.call(this, color, intensity), this.type = "RectAreaLight", this.position.set(0, 1, 0), 
        this.updateMatrix(), this.width = void 0 !== width ? width : 10, this.height = void 0 !== height ? height : 10;
    }
    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions, this._cachedIndex = 0, this.resultBuffer = void 0 !== resultBuffer ? resultBuffer : new sampleValues.constructor(sampleSize), 
        this.sampleValues = sampleValues, this.valueSize = sampleSize;
    }
    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer), 
        this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
    }
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    function KeyframeTrackConstructor(name, times, values, interpolation) {
        if (void 0 === name) throw new Error("track name is undefined");
        if (void 0 === times || 0 === times.length) throw new Error("no keyframes in track named " + name);
        this.name = name, this.times = AnimationUtils.convertArray(times, this.TimeBufferType), 
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType), this.setInterpolation(interpolation || this.DefaultInterpolation), 
        this.validate(), this.optimize();
    }
    function VectorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    function QuaternionKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function NumberKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function StringKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function BooleanKeyframeTrack(name, times, values) {
        KeyframeTrackConstructor.call(this, name, times, values);
    }
    function ColorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function KeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.apply(this, arguments);
    }
    function AnimationClip(name, duration, tracks) {
        this.name = name, this.tracks = tracks, this.duration = void 0 !== duration ? duration : -1, 
        this.uuid = _Math.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize();
    }
    function MaterialLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this.textures = {};
    }
    function BufferGeometryLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function Loader() {
        this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {};
    }
    function JSONLoader(manager) {
        "boolean" == typeof manager && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), 
        manager = void 0), this.manager = void 0 !== manager ? manager : DefaultLoadingManager, 
        this.withCredentials = !1;
    }
    function ObjectLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this.texturePath = "";
    }
    function CatmullRom(t, p0, p1, p2, p3) {
        var v0 = .5 * (p2 - p0), v1 = .5 * (p3 - p1), t2 = t * t;
        return (2 * p1 - 2 * p2 + v0 + v1) * (t * t2) + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function QuadraticBezierP0(t, p) {
        var k = 1 - t;
        return k * k * p;
    }
    function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP2(t, p) {
        return t * t * p;
    }
    function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
    }
    function CubicBezierP0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    }
    function CubicBezierP1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    }
    function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP3(t, p) {
        return t * t * t * p;
    }
    function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
    }
    function Curve() {
        this.arcLengthDivisions = 200;
    }
    function LineCurve(v1, v2) {
        Curve.call(this), this.v1 = v1, this.v2 = v2;
    }
    function CurvePath() {
        Curve.call(this), this.curves = [], this.autoClose = !1;
    }
    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        Curve.call(this), this.aX = aX, this.aY = aY, this.xRadius = xRadius, this.yRadius = yRadius, 
        this.aStartAngle = aStartAngle, this.aEndAngle = aEndAngle, this.aClockwise = aClockwise, 
        this.aRotation = aRotation || 0;
    }
    function SplineCurve(points) {
        Curve.call(this), this.points = void 0 === points ? [] : points;
    }
    function CubicBezierCurve(v0, v1, v2, v3) {
        Curve.call(this), this.v0 = v0, this.v1 = v1, this.v2 = v2, this.v3 = v3;
    }
    function QuadraticBezierCurve(v0, v1, v2) {
        Curve.call(this), this.v0 = v0, this.v1 = v1, this.v2 = v2;
    }
    function Path(points) {
        CurvePath.call(this), this.currentPoint = new Vector2(), points && this.fromPoints(points);
    }
    function Shape() {
        Path.apply(this, arguments), this.holes = [];
    }
    function ShapePath() {
        this.subPaths = [], this.currentPath = null;
    }
    function Font(data) {
        this.data = data;
    }
    function FontLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function AudioLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function StereoCamera() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new PerspectiveCamera(), 
        this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera(), 
        this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
    }
    function CubeCamera(near, far, cubeResolution) {
        Object3D.call(this), this.type = "CubeCamera";
        var cameraPX = new PerspectiveCamera(90, 1, near, far);
        cameraPX.up.set(0, -1, 0), cameraPX.lookAt(new Vector3(1, 0, 0)), this.add(cameraPX);
        var cameraNX = new PerspectiveCamera(90, 1, near, far);
        cameraNX.up.set(0, -1, 0), cameraNX.lookAt(new Vector3(-1, 0, 0)), this.add(cameraNX);
        var cameraPY = new PerspectiveCamera(90, 1, near, far);
        cameraPY.up.set(0, 0, 1), cameraPY.lookAt(new Vector3(0, 1, 0)), this.add(cameraPY);
        var cameraNY = new PerspectiveCamera(90, 1, near, far);
        cameraNY.up.set(0, 0, -1), cameraNY.lookAt(new Vector3(0, -1, 0)), this.add(cameraNY);
        var cameraPZ = new PerspectiveCamera(90, 1, near, far);
        cameraPZ.up.set(0, -1, 0), cameraPZ.lookAt(new Vector3(0, 0, 1)), this.add(cameraPZ);
        var cameraNZ = new PerspectiveCamera(90, 1, near, far);
        cameraNZ.up.set(0, -1, 0), cameraNZ.lookAt(new Vector3(0, 0, -1)), this.add(cameraNZ);
        var options = {
            format: RGBFormat,
            magFilter: LinearFilter,
            minFilter: LinearFilter
        };
        this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options), 
        this.renderTarget.texture.name = "CubeCamera", this.update = function(renderer, scene) {
            null === this.parent && this.updateMatrixWorld();
            var renderTarget = this.renderTarget, generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = !1, renderTarget.activeCubeFace = 0, renderer.render(scene, cameraPX, renderTarget), 
            renderTarget.activeCubeFace = 1, renderer.render(scene, cameraNX, renderTarget), 
            renderTarget.activeCubeFace = 2, renderer.render(scene, cameraPY, renderTarget), 
            renderTarget.activeCubeFace = 3, renderer.render(scene, cameraNY, renderTarget), 
            renderTarget.activeCubeFace = 4, renderer.render(scene, cameraPZ, renderTarget), 
            renderTarget.texture.generateMipmaps = generateMipmaps, renderTarget.activeCubeFace = 5, 
            renderer.render(scene, cameraNZ, renderTarget), renderer.setRenderTarget(null);
        }, this.clear = function(renderer, color, depth, stencil) {
            for (var renderTarget = this.renderTarget, i = 0; i < 6; i++) renderTarget.activeCubeFace = i, 
            renderer.setRenderTarget(renderTarget), renderer.clear(color, depth, stencil);
            renderer.setRenderTarget(null);
        };
    }
    function AudioListener() {
        Object3D.call(this), this.type = "AudioListener", this.context = AudioContext.getContext(), 
        this.gain = this.context.createGain(), this.gain.connect(this.context.destination), 
        this.filter = null;
    }
    function Audio(listener) {
        Object3D.call(this), this.type = "Audio", this.context = listener.context, this.gain = this.context.createGain(), 
        this.gain.connect(listener.getInput()), this.autoplay = !1, this.buffer = null, 
        this.loop = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, 
        this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [];
    }
    function PositionalAudio(listener) {
        Audio.call(this, listener), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
    }
    function AudioAnalyser(audio, fftSize) {
        this.analyser = audio.context.createAnalyser(), this.analyser.fftSize = void 0 !== fftSize ? fftSize : 2048, 
        this.data = new Uint8Array(this.analyser.frequencyBinCount), audio.getOutput().connect(this.analyser);
    }
    function PropertyMixer(binding, typeName, valueSize) {
        this.binding = binding, this.valueSize = valueSize;
        var mixFunction, bufferType = Float64Array;
        switch (typeName) {
          case "quaternion":
            mixFunction = this._slerp;
            break;

          case "string":
          case "bool":
            bufferType = Array, mixFunction = this._select;
            break;

          default:
            mixFunction = this._lerp;
        }
        this.buffer = new bufferType(4 * valueSize), this._mixBufferRegion = mixFunction, 
        this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0;
    }
    function Composite(targetGroup, path, optionalParsedPath) {
        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup, this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    function PropertyBinding(rootNode, path, parsedPath) {
        this.path = path, this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path), 
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode, 
        this.rootNode = rootNode;
    }
    function AnimationObjectGroup(var_args) {
        this.uuid = _Math.generateUUID(), this._objects = Array.prototype.slice.call(arguments), 
        this.nCachedObjects_ = 0;
        var indices = {};
        this._indicesByUUID = indices;
        for (var i = 0, n = arguments.length; i !== n; ++i) indices[arguments[i].uuid] = i;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var scope = this;
        this.stats = {
            objects: {
                get total() {
                    return scope._objects.length;
                },
                get inUse() {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject() {
                return scope._bindings.length;
            }
        };
    }
    function AnimationAction(mixer, clip, localRoot) {
        this._mixer = mixer, this._clip = clip, this._localRoot = localRoot || null;
        for (var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks), interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        }, i = 0; i !== nTracks; ++i) {
            var interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant, interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings, this._interpolants = interpolants, 
        this._propertyBindings = new Array(nTracks), this._cacheIndex = null, this._byClipCacheIndex = null, 
        this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, 
        this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, 
        this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, 
        this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, 
        this.zeroSlopeAtEnd = !0;
    }
    function AnimationMixer(root) {
        this._root = root, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, 
        this.timeScale = 1;
    }
    function Uniform(value) {
        "string" == typeof value && (console.warn("THREE.Uniform: Type parameter is no longer needed."), 
        value = arguments[1]), this.value = value;
    }
    function InstancedBufferGeometry() {
        BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
    }
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
        this.uuid = _Math.generateUUID(), this.data = interleavedBuffer, this.itemSize = itemSize, 
        this.offset = offset, this.normalized = !0 === normalized;
    }
    function InterleavedBuffer(array, stride) {
        this.uuid = _Math.generateUUID(), this.array = array, this.stride = stride, this.count = void 0 !== array ? array.length / stride : 0, 
        this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.onUploadCallback = function() {}, this.version = 0;
    }
    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
        InterleavedBuffer.call(this, array, stride), this.meshPerAttribute = meshPerAttribute || 1;
    }
    function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
        BufferAttribute.call(this, array, itemSize), this.meshPerAttribute = meshPerAttribute || 1;
    }
    function Raycaster(origin, direction, near, far) {
        this.ray = new Ray(origin, direction), this.near = near || 0, this.far = far || 1 / 0, 
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), 
                    this.Points;
                }
            }
        });
    }
    function ascSort(a, b) {
        return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects, recursive) {
        if (!1 !== object.visible && (object.raycast(raycaster, intersects), !0 === recursive)) for (var children = object.children, i = 0, l = children.length; i < l; i++) intersectObject(children[i], raycaster, intersects, !0);
    }
    function Clock(autoStart) {
        this.autoStart = void 0 === autoStart || autoStart, this.startTime = 0, this.oldTime = 0, 
        this.elapsedTime = 0, this.running = !1;
    }
    function Spherical(radius, phi, theta) {
        return this.radius = void 0 !== radius ? radius : 1, this.phi = void 0 !== phi ? phi : 0, 
        this.theta = void 0 !== theta ? theta : 0, this;
    }
    function Cylindrical(radius, theta, y) {
        return this.radius = void 0 !== radius ? radius : 1, this.theta = void 0 !== theta ? theta : 0, 
        this.y = void 0 !== y ? y : 0, this;
    }
    function ImmediateRenderObject(material) {
        Object3D.call(this), this.material = material, this.render = function(renderCallback) {};
    }
    function VertexNormalsHelper(object, size, hex, linewidth) {
        this.object = object, this.size = void 0 !== size ? size : 1;
        var color = void 0 !== hex ? hex : 16711680, width = void 0 !== linewidth ? linewidth : 1, nNormals = 0, objGeometry = this.object.geometry;
        objGeometry && objGeometry.isGeometry ? nNormals = 3 * objGeometry.faces.length : objGeometry && objGeometry.isBufferGeometry && (nNormals = objGeometry.attributes.normal.count);
        var geometry = new BufferGeometry(), positions = new Float32BufferAttribute(2 * nNormals * 3, 3);
        geometry.addAttribute("position", positions), LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function SpotLightHelper(light, color) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld, 
        this.matrixAutoUpdate = !1, this.color = color;
        for (var geometry = new BufferGeometry(), positions = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1 ], i = 0, j = 1; i < 32; i++, 
        j++) {
            var p1 = i / 32 * Math.PI * 2, p2 = j / 32 * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.addAttribute("position", new Float32BufferAttribute(positions, 3));
        var material = new LineBasicMaterial({
            fog: !1
        });
        this.cone = new LineSegments(geometry, material), this.add(this.cone), this.update();
    }
    function getBoneList(object) {
        var boneList = [];
        object && object.isBone && boneList.push(object);
        for (var i = 0; i < object.children.length; i++) boneList.push.apply(boneList, getBoneList(object.children[i]));
        return boneList;
    }
    function SkeletonHelper(object) {
        for (var bones = getBoneList(object), geometry = new BufferGeometry(), vertices = [], colors = [], color1 = new Color(0, 0, 1), color2 = new Color(0, 1, 0), i = 0; i < bones.length; i++) {
            var bone = bones[i];
            bone.parent && bone.parent.isBone && (vertices.push(0, 0, 0), vertices.push(0, 0, 0), 
            colors.push(color1.r, color1.g, color1.b), colors.push(color2.r, color2.g, color2.b));
        }
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        LineSegments.call(this, geometry, material), this.root = object, this.bones = bones, 
        this.matrix = object.matrixWorld, this.matrixAutoUpdate = !1, this.onBeforeRender();
    }
    function PointLightHelper(light, sphereSize, color) {
        this.light = light, this.light.updateMatrixWorld(), this.color = color;
        var geometry = new SphereBufferGeometry(sphereSize, 4, 2), material = new MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
        Mesh.call(this, geometry, material), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, 
        this.update();
    }
    function RectAreaLightHelper(light, color) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld, 
        this.matrixAutoUpdate = !1, this.color = color;
        var material = new LineBasicMaterial({
            fog: !1
        }), geometry = new BufferGeometry();
        geometry.addAttribute("position", new BufferAttribute(new Float32Array(15), 3)), 
        this.line = new Line(geometry, material), this.add(this.line), this.update();
    }
    function HemisphereLightHelper(light, size, color) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld, 
        this.matrixAutoUpdate = !1, this.color = color;
        var geometry = new OctahedronBufferGeometry(size);
        geometry.rotateY(.5 * Math.PI), this.material = new MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = VertexColors);
        var position = geometry.getAttribute("position"), colors = new Float32Array(3 * position.count);
        geometry.addAttribute("color", new BufferAttribute(colors, 3)), this.add(new Mesh(geometry, this.material)), 
        this.update();
    }
    function GridHelper(size, divisions, color1, color2) {
        size = size || 10, divisions = divisions || 10, color1 = new Color(void 0 !== color1 ? color1 : 4473924), 
        color2 = new Color(void 0 !== color2 ? color2 : 8947848);
        for (var center = divisions / 2, step = size / divisions, halfSize = size / 2, vertices = [], colors = [], i = 0, j = 0, k = -halfSize; i <= divisions; i++, 
        k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k), vertices.push(k, 0, -halfSize, k, 0, halfSize);
            var color = i === center ? color1 : color2;
            color.toArray(colors, j), j += 3, color.toArray(colors, j), j += 3, color.toArray(colors, j), 
            j += 3, color.toArray(colors, j), j += 3;
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
        radius = radius || 10, radials = radials || 16, circles = circles || 8, divisions = divisions || 64, 
        color1 = new Color(void 0 !== color1 ? color1 : 4473924), color2 = new Color(void 0 !== color2 ? color2 : 8947848);
        var x, z, v, i, j, r, color, vertices = [], colors = [];
        for (i = 0; i <= radials; i++) v = i / radials * (2 * Math.PI), x = Math.sin(v) * radius, 
        z = Math.cos(v) * radius, vertices.push(0, 0, 0), vertices.push(x, 0, z), color = 1 & i ? color1 : color2, 
        colors.push(color.r, color.g, color.b), colors.push(color.r, color.g, color.b);
        for (i = 0; i <= circles; i++) for (color = 1 & i ? color1 : color2, r = radius - radius / circles * i, 
        j = 0; j < divisions; j++) v = j / divisions * (2 * Math.PI), x = Math.sin(v) * r, 
        z = Math.cos(v) * r, vertices.push(x, 0, z), colors.push(color.r, color.g, color.b), 
        v = (j + 1) / divisions * (2 * Math.PI), x = Math.sin(v) * r, z = Math.cos(v) * r, 
        vertices.push(x, 0, z), colors.push(color.r, color.g, color.b);
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    function FaceNormalsHelper(object, size, hex, linewidth) {
        this.object = object, this.size = void 0 !== size ? size : 1;
        var color = void 0 !== hex ? hex : 16776960, width = void 0 !== linewidth ? linewidth : 1, nNormals = 0, objGeometry = this.object.geometry;
        objGeometry && objGeometry.isGeometry ? nNormals = objGeometry.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var geometry = new BufferGeometry(), positions = new Float32BufferAttribute(2 * nNormals * 3, 3);
        geometry.addAttribute("position", positions), LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function DirectionalLightHelper(light, size, color) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld, 
        this.matrixAutoUpdate = !1, this.color = color, void 0 === size && (size = 1);
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute([ -size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0 ], 3));
        var material = new LineBasicMaterial({
            fog: !1
        });
        this.lightPlane = new Line(geometry, material), this.add(this.lightPlane), geometry = new BufferGeometry(), 
        geometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 0, 1 ], 3)), 
        this.targetLine = new Line(geometry, material), this.add(this.targetLine), this.update();
    }
    function CameraHelper(camera) {
        function addLine(a, b, color) {
            addPoint(a, color), addPoint(b, color);
        }
        function addPoint(id, color) {
            vertices.push(0, 0, 0), colors.push(color.r, color.g, color.b), void 0 === pointMap[id] && (pointMap[id] = []), 
            pointMap[id].push(vertices.length / 3 - 1);
        }
        var geometry = new BufferGeometry(), material = new LineBasicMaterial({
            color: 16777215,
            vertexColors: FaceColors
        }), vertices = [], colors = [], pointMap = {}, colorFrustum = new Color(16755200), colorCone = new Color(16711680), colorUp = new Color(43775), colorTarget = new Color(16777215), colorCross = new Color(3355443);
        addLine("n1", "n2", colorFrustum), addLine("n2", "n4", colorFrustum), addLine("n4", "n3", colorFrustum), 
        addLine("n3", "n1", colorFrustum), addLine("f1", "f2", colorFrustum), addLine("f2", "f4", colorFrustum), 
        addLine("f4", "f3", colorFrustum), addLine("f3", "f1", colorFrustum), addLine("n1", "f1", colorFrustum), 
        addLine("n2", "f2", colorFrustum), addLine("n3", "f3", colorFrustum), addLine("n4", "f4", colorFrustum), 
        addLine("p", "n1", colorCone), addLine("p", "n2", colorCone), addLine("p", "n3", colorCone), 
        addLine("p", "n4", colorCone), addLine("u1", "u2", colorUp), addLine("u2", "u3", colorUp), 
        addLine("u3", "u1", colorUp), addLine("c", "t", colorTarget), addLine("p", "c", colorCross), 
        addLine("cn1", "cn2", colorCross), addLine("cn3", "cn4", colorCross), addLine("cf1", "cf2", colorCross), 
        addLine("cf3", "cf4", colorCross), geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)), 
        geometry.addAttribute("color", new Float32BufferAttribute(colors, 3)), LineSegments.call(this, geometry, material), 
        this.camera = camera, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), 
        this.matrix = camera.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = pointMap, 
        this.update();
    }
    function BoxHelper(object, color) {
        this.object = object, void 0 === color && (color = 16776960);
        var indices = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]), positions = new Float32Array(24), geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1)), geometry.addAttribute("position", new BufferAttribute(positions, 3)), 
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function Box3Helper(box, hex) {
        this.type = "Box3Helper", this.box = box;
        var color = void 0 !== hex ? hex : 16776960, indices = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]), positions = [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1 ], geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1)), geometry.addAttribute("position", new Float32BufferAttribute(positions, 3)), 
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        })), this.geometry.computeBoundingSphere(), this.onBeforeRender();
    }
    function PlaneHelper(plane, size, hex) {
        this.type = "PlaneHelper", this.plane = plane, this.size = void 0 === size ? 1 : size;
        var color = void 0 !== hex ? hex : 16776960, positions = [ 1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ], geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(positions, 3)), geometry.computeBoundingSphere(), 
        Line.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        var positions2 = [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1 ], geometry2 = new BufferGeometry();
        geometry2.addAttribute("position", new Float32BufferAttribute(positions2, 3)), geometry2.computeBoundingSphere(), 
        this.add(new Mesh(geometry2, new MeshBasicMaterial({
            color: color,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        }))), this.onBeforeRender();
    }
    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        Object3D.call(this), void 0 === color && (color = 16776960), void 0 === length && (length = 1), 
        void 0 === headLength && (headLength = .2 * length), void 0 === headWidth && (headWidth = .2 * headLength), 
        void 0 === lineGeometry && (lineGeometry = new BufferGeometry(), lineGeometry.addAttribute("position", new Float32BufferAttribute([ 0, 0, 0, 0, 1, 0 ], 3)), 
        coneGeometry = new CylinderBufferGeometry(0, .5, 1, 5, 1), coneGeometry.translate(0, -.5, 0)), 
        this.position.copy(origin), this.line = new Line(lineGeometry, new LineBasicMaterial({
            color: color
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
            color: color
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(dir), 
        this.setLength(length, headLength, headWidth);
    }
    function AxisHelper(size) {
        size = size || 1;
        var vertices = [ 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size ], colors = [ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ], geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.addAttribute("color", new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    function CubicPoly() {
        function init(x0, x1, t0, t1) {
            c0 = x0, c1 = t0, c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1, c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
        return {
            initCatmullRom: function(x0, x1, x2, x3, tension) {
                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
                var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1, t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                t1 *= dt1, t2 *= dt1, init(x1, x2, t1, t2);
            },
            calc: function(t) {
                var t2 = t * t;
                return c0 + c1 * t + c2 * t2 + c3 * (t2 * t);
            }
        };
    }
    function CatmullRomCurve3(points) {
        Curve.call(this), points.length < 2 && console.warn("THREE.CatmullRomCurve3: Points array needs at least two entries."), 
        this.points = points || [], this.closed = !1;
    }
    function CubicBezierCurve3(v0, v1, v2, v3) {
        Curve.call(this), this.v0 = v0, this.v1 = v1, this.v2 = v2, this.v3 = v3;
    }
    function QuadraticBezierCurve3(v0, v1, v2) {
        Curve.call(this), this.v0 = v0, this.v1 = v1, this.v2 = v2;
    }
    function LineCurve3(v1, v2) {
        Curve.call(this), this.v1 = v1, this.v2 = v2;
    }
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    }
    function Face4(a, b, c, d, normal, color, materialIndex) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), 
        new Face3(a, b, c, normal, color, materialIndex);
    }
    function MeshFaceMaterial(materials) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), 
        materials;
    }
    function MultiMaterial(materials) {
        return void 0 === materials && (materials = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), 
        materials.isMultiMaterial = !0, materials.materials = materials, materials.clone = function() {
            return materials.slice();
        }, materials;
    }
    function PointCloud(geometry, material) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Points(geometry, material);
    }
    function Particle(material) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Sprite(material);
    }
    function ParticleSystem(geometry, material) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Points(geometry, material);
    }
    function PointCloudMaterial(parameters) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), 
        new PointsMaterial(parameters);
    }
    function ParticleBasicMaterial(parameters) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), 
        new PointsMaterial(parameters);
    }
    function ParticleSystemMaterial(parameters) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), 
        new PointsMaterial(parameters);
    }
    function Vertex(x, y, z) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), 
        new Vector3(x, y, z);
    }
    function DynamicBufferAttribute(array, itemSize) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), 
        new BufferAttribute(array, itemSize).setDynamic(!0);
    }
    function Int8Attribute(array, itemSize) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), 
        new Int8BufferAttribute(array, itemSize);
    }
    function Uint8Attribute(array, itemSize) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), 
        new Uint8BufferAttribute(array, itemSize);
    }
    function Uint8ClampedAttribute(array, itemSize) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), 
        new Uint8ClampedBufferAttribute(array, itemSize);
    }
    function Int16Attribute(array, itemSize) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), 
        new Int16BufferAttribute(array, itemSize);
    }
    function Uint16Attribute(array, itemSize) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), 
        new Uint16BufferAttribute(array, itemSize);
    }
    function Int32Attribute(array, itemSize) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), 
        new Int32BufferAttribute(array, itemSize);
    }
    function Uint32Attribute(array, itemSize) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), 
        new Uint32BufferAttribute(array, itemSize);
    }
    function Float32Attribute(array, itemSize) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), 
        new Float32BufferAttribute(array, itemSize);
    }
    function Float64Attribute(array, itemSize) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), 
        new Float64BufferAttribute(array, itemSize);
    }
    function ClosedSplineCurve3(points) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), 
        CatmullRomCurve3.call(this, points), this.type = "catmullrom", this.closed = !0;
    }
    function SplineCurve3(points) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), 
        CatmullRomCurve3.call(this, points), this.type = "catmullrom";
    }
    function Spline(points) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), 
        CatmullRomCurve3.call(this, points), this.type = "catmullrom";
    }
    function BoundingBoxHelper(object, color) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), 
        new BoxHelper(object, color);
    }
    function EdgesHelper(object, hex) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), 
        new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
            color: void 0 !== hex ? hex : 16777215
        }));
    }
    function WireframeHelper(object, hex) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), 
        new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
            color: void 0 !== hex ? hex : 16777215
        }));
    }
    function XHRLoader(manager) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new FileLoader(manager);
    }
    function BinaryTextureLoader(manager) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), 
        new DataTextureLoader(manager);
    }
    function Projector() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), 
        this.projectVector = function(vector, camera) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), vector.project(camera);
        }, this.unprojectVector = function(vector, camera) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), 
            vector.unproject(camera);
        }, this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
        };
    }
    function CanvasRenderer() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), 
        this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), 
        this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, 
        this.setSize = function() {};
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(value) {
        return "number" == typeof value && isFinite(value) && Math.floor(value) === value;
    }), void 0 === Math.sign && (Math.sign = function(x) {
        return x < 0 ? -1 : x > 0 ? 1 : +x;
    }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        }
    }), void 0 === Object.assign && function() {
        Object.assign = function(target) {
            if (void 0 === target || null === target) throw new TypeError("Cannot convert undefined or null to object");
            for (var output = Object(target), index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (void 0 !== source && null !== source) for (var nextKey in source) Object.prototype.hasOwnProperty.call(source, nextKey) && (output[nextKey] = source[nextKey]);
            }
            return output;
        };
    }(), Object.assign(EventDispatcher.prototype, {
        addEventListener: function(type, listener) {
            void 0 === this._listeners && (this._listeners = {});
            var listeners = this._listeners;
            void 0 === listeners[type] && (listeners[type] = []), -1 === listeners[type].indexOf(listener) && listeners[type].push(listener);
        },
        hasEventListener: function(type, listener) {
            if (void 0 === this._listeners) return !1;
            var listeners = this._listeners;
            return void 0 !== listeners[type] && -1 !== listeners[type].indexOf(listener);
        },
        removeEventListener: function(type, listener) {
            if (void 0 !== this._listeners) {
                var listeners = this._listeners, listenerArray = listeners[type];
                if (void 0 !== listenerArray) {
                    var index = listenerArray.indexOf(listener);
                    -1 !== index && listenerArray.splice(index, 1);
                }
            }
        },
        dispatchEvent: function(event) {
            if (void 0 !== this._listeners) {
                var listeners = this._listeners, listenerArray = listeners[event.type];
                if (void 0 !== listenerArray) {
                    event.target = this;
                    for (var array = listenerArray.slice(0), i = 0, l = array.length; i < l; i++) array[i].call(this, event);
                }
            }
        }
    });
    var REVISION = "87", MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, FrontFaceDirectionCW = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, FrontSide = 0, BackSide = 1, DoubleSide = 2, NoColors = 0, FaceColors = 1, VertexColors = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, Uncharted2ToneMapping = 3, CineonToneMapping = 4, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, SphericalReflectionMapping = 305, CubeUVReflectionMapping = 306, CubeUVRefractionMapping = 307, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipMapNearestFilter = 1004, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipMapNearestFilter = 1007, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedShort565Type = 1019, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, RGBEFormat = RGBAFormat, DepthFormat = 1026, DepthStencilFormat = 1027, RGB_S3TC_DXT1_Format = 2001, RGBA_S3TC_DXT1_Format = 2002, RGBA_S3TC_DXT3_Format = 2003, RGBA_S3TC_DXT5_Format = 2004, RGB_PVRTC_4BPPV1_Format = 2100, RGB_PVRTC_2BPPV1_Format = 2101, RGBA_PVRTC_4BPPV1_Format = 2102, RGBA_PVRTC_2BPPV1_Format = 2103, RGB_ETC1_Format = 2151, LoopRepeat = 2201, ZeroCurvatureEnding = 2400, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, LinearEncoding = 3e3, sRGBEncoding = 3001, GammaEncoding = 3007, RGBEEncoding = 3002, RGBM7Encoding = 3004, RGBM16Encoding = 3005, RGBDEncoding = 3006, BasicDepthPacking = 3200, RGBADepthPacking = 3201, _Math = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            var r, chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), uuid = new Array(36), rnd = 0;
            return function() {
                for (var i = 0; i < 36; i++) 8 === i || 13 === i || 18 === i || 23 === i ? uuid[i] = "-" : 14 === i ? uuid[i] = "4" : (rnd <= 2 && (rnd = 33554432 + 16777216 * Math.random() | 0), 
                r = 15 & rnd, rnd >>= 4, uuid[i] = chars[19 === i ? 3 & r | 8 : r]);
                return uuid.join("");
            };
        }(),
        clamp: function(value, min, max) {
            return Math.max(min, Math.min(max, value));
        },
        euclideanModulo: function(n, m) {
            return (n % m + m) % m;
        },
        mapLinear: function(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        lerp: function(x, y, t) {
            return (1 - t) * x + t * y;
        },
        smoothstep: function(x, min, max) {
            return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min)) * x * (3 - 2 * x);
        },
        smootherstep: function(x, min, max) {
            return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min)) * x * x * (x * (6 * x - 15) + 10);
        },
        randInt: function(low, high) {
            return low + Math.floor(Math.random() * (high - low + 1));
        },
        randFloat: function(low, high) {
            return low + Math.random() * (high - low);
        },
        randFloatSpread: function(range) {
            return range * (.5 - Math.random());
        },
        degToRad: function(degrees) {
            return degrees * _Math.DEG2RAD;
        },
        radToDeg: function(radians) {
            return radians * _Math.RAD2DEG;
        },
        isPowerOfTwo: function(value) {
            return 0 == (value & value - 1) && 0 !== value;
        },
        nearestPowerOfTwo: function(value) {
            return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
        },
        nextPowerOfTwo: function(value) {
            return value--, value |= value >> 1, value |= value >> 2, value |= value >> 4, value |= value >> 8, 
            value |= value >> 16, ++value;
        }
    };
    Object.defineProperties(Vector2.prototype, {
        width: {
            get: function() {
                return this.x;
            },
            set: function(value) {
                this.x = value;
            }
        },
        height: {
            get: function() {
                return this.y;
            },
            set: function(value) {
                this.y = value;
            }
        }
    }), Object.assign(Vector2.prototype, {
        isVector2: !0,
        set: function(x, y) {
            return this.x = x, this.y = y, this;
        },
        setScalar: function(scalar) {
            return this.x = scalar, this.y = scalar, this;
        },
        setX: function(x) {
            return this.x = x, this;
        },
        setY: function(y) {
            return this.y = y, this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y);
        },
        copy: function(v) {
            return this.x = v.x, this.y = v.y, this;
        },
        add: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
            this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this);
        },
        addScalar: function(s) {
            return this.x += s, this.y += s, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this;
        },
        addScaledVector: function(v, s) {
            return this.x += v.x * s, this.y += v.y * s, this;
        },
        sub: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
            this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this);
        },
        subScalar: function(s) {
            return this.x -= s, this.y -= s, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this;
        },
        multiply: function(v) {
            return this.x *= v.x, this.y *= v.y, this;
        },
        multiplyScalar: function(scalar) {
            return this.x *= scalar, this.y *= scalar, this;
        },
        divide: function(v) {
            return this.x /= v.x, this.y /= v.y, this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        min: function(v) {
            return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this;
        },
        max: function(v) {
            return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this;
        },
        clamp: function(min, max) {
            return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), 
            this;
        },
        clampScalar: function() {
            var min = new Vector2(), max = new Vector2();
            return function(minVal, maxVal) {
                return min.set(minVal, minVal), max.set(maxVal, maxVal), this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), 
            this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        angle: function() {
            var angle = Math.atan2(this.y, this.x);
            return angle < 0 && (angle += 2 * Math.PI), angle;
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
        },
        distanceToManhattan: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        },
        setLength: function(length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function(v, alpha) {
            return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1], 
            this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x, 
            array[offset + 1] = this.y, array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            return void 0 !== offset && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), 
            this.x = attribute.getX(index), this.y = attribute.getY(index), this;
        },
        rotateAround: function(center, angle) {
            var c = Math.cos(angle), s = Math.sin(angle), x = this.x - center.x, y = this.y - center.y;
            return this.x = x * c - y * s + center.x, this.y = x * s + y * c + center.y, this;
        }
    });
    var textureId = 0;
    Texture.DEFAULT_IMAGE = void 0, Texture.DEFAULT_MAPPING = 300, Object.defineProperty(Texture.prototype, "needsUpdate", {
        set: function(value) {
            !0 === value && this.version++;
        }
    }), Object.assign(Texture.prototype, EventDispatcher.prototype, {
        constructor: Texture,
        isTexture: !0,
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            return this.name = source.name, this.image = source.image, this.mipmaps = source.mipmaps.slice(0), 
            this.mapping = source.mapping, this.wrapS = source.wrapS, this.wrapT = source.wrapT, 
            this.magFilter = source.magFilter, this.minFilter = source.minFilter, this.anisotropy = source.anisotropy, 
            this.format = source.format, this.type = source.type, this.offset.copy(source.offset), 
            this.repeat.copy(source.repeat), this.generateMipmaps = source.generateMipmaps, 
            this.premultiplyAlpha = source.premultiplyAlpha, this.flipY = source.flipY, this.unpackAlignment = source.unpackAlignment, 
            this.encoding = source.encoding, this;
        },
        toJSON: function(meta) {
            if (void 0 !== meta.textures[this.uuid]) return meta.textures[this.uuid];
            var output = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [ this.repeat.x, this.repeat.y ],
                offset: [ this.offset.x, this.offset.y ],
                wrap: [ this.wrapS, this.wrapT ],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var image = this.image;
                void 0 === image.uuid && (image.uuid = _Math.generateUUID()), void 0 === meta.images[image.uuid] && (meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: function(image) {
                        var canvas;
                        if (image instanceof HTMLCanvasElement) canvas = image; else {
                            canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), canvas.width = image.width, 
                            canvas.height = image.height;
                            var context = canvas.getContext("2d");
                            image instanceof ImageData ? context.putImageData(image, 0, 0) : context.drawImage(image, 0, 0, image.width, image.height);
                        }
                        return canvas.width > 2048 || canvas.height > 2048 ? canvas.toDataURL("image/jpeg", .6) : canvas.toDataURL("image/png");
                    }(image)
                }), output.image = image.uuid;
            }
            return meta.textures[this.uuid] = output, output;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        },
        transformUv: function(uv) {
            if (300 === this.mapping) {
                if (uv.multiply(this.repeat), uv.add(this.offset), uv.x < 0 || uv.x > 1) switch (this.wrapS) {
                  case RepeatWrapping:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;

                  case ClampToEdgeWrapping:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;

                  case MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(uv.x) % 2) ? uv.x = Math.ceil(uv.x) - uv.x : uv.x = uv.x - Math.floor(uv.x);
                }
                if (uv.y < 0 || uv.y > 1) switch (this.wrapT) {
                  case RepeatWrapping:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;

                  case ClampToEdgeWrapping:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;

                  case MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(uv.y) % 2) ? uv.y = Math.ceil(uv.y) - uv.y : uv.y = uv.y - Math.floor(uv.y);
                }
                this.flipY && (uv.y = 1 - uv.y);
            }
        }
    }), Object.assign(Vector4.prototype, {
        isVector4: !0,
        set: function(x, y, z, w) {
            return this.x = x, this.y = y, this.z = z, this.w = w, this;
        },
        setScalar: function(scalar) {
            return this.x = scalar, this.y = scalar, this.z = scalar, this.w = scalar, this;
        },
        setX: function(x) {
            return this.x = x, this;
        },
        setY: function(y) {
            return this.y = y, this;
        },
        setZ: function(z) {
            return this.z = z, this;
        },
        setW: function(w) {
            return this.w = w, this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              case 2:
                this.z = value;
                break;

              case 3:
                this.w = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              case 3:
                return this.w;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function(v) {
            return this.x = v.x, this.y = v.y, this.z = v.z, this.w = void 0 !== v.w ? v.w : 1, 
            this;
        },
        add: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
            this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this.z += v.z, this.w += v.w, 
            this);
        },
        addScalar: function(s) {
            return this.x += s, this.y += s, this.z += s, this.w += s, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, 
            this;
        },
        addScaledVector: function(v, s) {
            return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this.w += v.w * s, 
            this;
        },
        sub: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
            this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this.z -= v.z, this.w -= v.w, 
            this);
        },
        subScalar: function(s) {
            return this.x -= s, this.y -= s, this.z -= s, this.w -= s, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, 
            this;
        },
        multiplyScalar: function(scalar) {
            return this.x *= scalar, this.y *= scalar, this.z *= scalar, this.w *= scalar, this;
        },
        applyMatrix4: function(m) {
            var x = this.x, y = this.y, z = this.z, w = this.w, e = m.elements;
            return this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w, this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w, 
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w, this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w, 
            this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        setAxisAngleFromQuaternion: function(q) {
            this.w = 2 * Math.acos(q.w);
            var s = Math.sqrt(1 - q.w * q.w);
            return s < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = q.x / s, this.y = q.y / s, 
            this.z = q.z / s), this;
        },
        setAxisAngleFromRotationMatrix: function(m) {
            var angle, x, y, z, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            if (Math.abs(m12 - m21) < .01 && Math.abs(m13 - m31) < .01 && Math.abs(m23 - m32) < .01) {
                if (Math.abs(m12 + m21) < .1 && Math.abs(m13 + m31) < .1 && Math.abs(m23 + m32) < .1 && Math.abs(m11 + m22 + m33 - 3) < .1) return this.set(1, 0, 0, 0), 
                this;
                angle = Math.PI;
                var xx = (m11 + 1) / 2, yy = (m22 + 1) / 2, zz = (m33 + 1) / 2, xy = (m12 + m21) / 4, xz = (m13 + m31) / 4, yz = (m23 + m32) / 4;
                return xx > yy && xx > zz ? xx < .01 ? (x = 0, y = .707106781, z = .707106781) : (x = Math.sqrt(xx), 
                y = xy / x, z = xz / x) : yy > zz ? yy < .01 ? (x = .707106781, y = 0, z = .707106781) : (y = Math.sqrt(yy), 
                x = xy / y, z = yz / y) : zz < .01 ? (x = .707106781, y = .707106781, z = 0) : (z = Math.sqrt(zz), 
                x = xz / z, y = yz / z), this.set(x, y, z, angle), this;
            }
            var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
            return Math.abs(s) < .001 && (s = 1), this.x = (m32 - m23) / s, this.y = (m13 - m31) / s, 
            this.z = (m21 - m12) / s, this.w = Math.acos((m11 + m22 + m33 - 1) / 2), this;
        },
        min: function(v) {
            return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), 
            this.w = Math.min(this.w, v.w), this;
        },
        max: function(v) {
            return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), 
            this.w = Math.max(this.w, v.w), this;
        },
        clamp: function(min, max) {
            return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), 
            this.z = Math.max(min.z, Math.min(max.z, this.z)), this.w = Math.max(min.w, Math.min(max.w, this.w)), 
            this;
        },
        clampScalar: function() {
            var min, max;
            return function(minVal, maxVal) {
                return void 0 === min && (min = new Vector4(), max = new Vector4()), min.set(minVal, minVal, minVal, minVal), 
                max.set(maxVal, maxVal, maxVal, maxVal), this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
            this.w = Math.floor(this.w), this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
            this.w = Math.ceil(this.w), this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
            this.w = Math.round(this.w), this;
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), 
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), 
            this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function(length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function(v, alpha) {
            return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha, 
            this.w += (v.w - this.w) * alpha, this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1], 
            this.z = array[offset + 2], this.w = array[offset + 3], this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x, 
            array[offset + 1] = this.y, array[offset + 2] = this.z, array[offset + 3] = this.w, 
            array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            return void 0 !== offset && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), 
            this.x = attribute.getX(index), this.y = attribute.getY(index), this.z = attribute.getZ(index), 
            this.w = attribute.getW(index), this;
        }
    }), Object.assign(WebGLRenderTarget.prototype, EventDispatcher.prototype, {
        isWebGLRenderTarget: !0,
        setSize: function(width, height) {
            this.width === width && this.height === height || (this.width = width, this.height = height, 
            this.dispose()), this.viewport.set(0, 0, width, height), this.scissor.set(0, 0, width, height);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            return this.width = source.width, this.height = source.height, this.viewport.copy(source.viewport), 
            this.texture = source.texture.clone(), this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, 
            this.depthTexture = source.depthTexture, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype), 
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube, WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = !0, 
    Object.assign(Quaternion, {
        slerp: function(qa, qb, qm, t) {
            return qm.copy(qa).slerp(qb, t);
        },
        slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
                if (sqrSin > Number.EPSILON) {
                    var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                    s = Math.sin(s * len) / sin, t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                if (x0 = x0 * s + x1 * tDir, y0 = y0 * s + y1 * tDir, z0 = z0 * s + z1 * tDir, w0 = w0 * s + w1 * tDir, 
                s === 1 - t) {
                    var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f, y0 *= f, z0 *= f, w0 *= f;
                }
            }
            dst[dstOffset] = x0, dst[dstOffset + 1] = y0, dst[dstOffset + 2] = z0, dst[dstOffset + 3] = w0;
        }
    }), Object.defineProperties(Quaternion.prototype, {
        x: {
            get: function() {
                return this._x;
            },
            set: function(value) {
                this._x = value, this.onChangeCallback();
            }
        },
        y: {
            get: function() {
                return this._y;
            },
            set: function(value) {
                this._y = value, this.onChangeCallback();
            }
        },
        z: {
            get: function() {
                return this._z;
            },
            set: function(value) {
                this._z = value, this.onChangeCallback();
            }
        },
        w: {
            get: function() {
                return this._w;
            },
            set: function(value) {
                this._w = value, this.onChangeCallback();
            }
        }
    }), Object.assign(Quaternion.prototype, {
        set: function(x, y, z, w) {
            return this._x = x, this._y = y, this._z = z, this._w = w, this.onChangeCallback(), 
            this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function(quaternion) {
            return this._x = quaternion.x, this._y = quaternion.y, this._z = quaternion.z, this._w = quaternion.w, 
            this.onChangeCallback(), this;
        },
        setFromEuler: function(euler, update) {
            if (!euler || !euler.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var x = euler._x, y = euler._y, z = euler._z, order = euler.order, cos = Math.cos, sin = Math.sin, c1 = cos(x / 2), c2 = cos(y / 2), c3 = cos(z / 2), s1 = sin(x / 2), s2 = sin(y / 2), s3 = sin(z / 2);
            return "XYZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, 
            this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "YXZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, 
            this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3) : "ZXY" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3, 
            this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "ZYX" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3, 
            this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3) : "YZX" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, 
            this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "XZY" === order && (this._x = s1 * c2 * c3 - c1 * s2 * s3, 
            this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3), 
            !1 !== update && this.onChangeCallback(), this;
        },
        setFromAxisAngle: function(axis, angle) {
            var halfAngle = angle / 2, s = Math.sin(halfAngle);
            return this._x = axis.x * s, this._y = axis.y * s, this._z = axis.z * s, this._w = Math.cos(halfAngle), 
            this.onChangeCallback(), this;
        },
        setFromRotationMatrix: function(m) {
            var s, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
            return trace > 0 ? (s = .5 / Math.sqrt(trace + 1), this._w = .25 / s, this._x = (m32 - m23) * s, 
            this._y = (m13 - m31) * s, this._z = (m21 - m12) * s) : m11 > m22 && m11 > m33 ? (s = 2 * Math.sqrt(1 + m11 - m22 - m33), 
            this._w = (m32 - m23) / s, this._x = .25 * s, this._y = (m12 + m21) / s, this._z = (m13 + m31) / s) : m22 > m33 ? (s = 2 * Math.sqrt(1 + m22 - m11 - m33), 
            this._w = (m13 - m31) / s, this._x = (m12 + m21) / s, this._y = .25 * s, this._z = (m23 + m32) / s) : (s = 2 * Math.sqrt(1 + m33 - m11 - m22), 
            this._w = (m21 - m12) / s, this._x = (m13 + m31) / s, this._y = (m23 + m32) / s, 
            this._z = .25 * s), this.onChangeCallback(), this;
        },
        setFromUnitVectors: function() {
            var r, v1 = new Vector3();
            return function(vFrom, vTo) {
                return void 0 === v1 && (v1 = new Vector3()), r = vFrom.dot(vTo) + 1, r < 1e-6 ? (r = 0, 
                Math.abs(vFrom.x) > Math.abs(vFrom.z) ? v1.set(-vFrom.y, vFrom.x, 0) : v1.set(0, -vFrom.z, vFrom.y)) : v1.crossVectors(vFrom, vTo), 
                this._x = v1.x, this._y = v1.y, this._z = v1.z, this._w = r, this.normalize();
            };
        }(),
        inverse: function() {
            return this.conjugate().normalize();
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
        },
        dot: function(v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        },
        normalize: function() {
            var l = this.length();
            return 0 === l ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (l = 1 / l, 
            this._x = this._x * l, this._y = this._y * l, this._z = this._z * l, this._w = this._w * l), 
            this.onChangeCallback(), this;
        },
        multiply: function(q, p) {
            return void 0 !== p ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), 
            this.multiplyQuaternions(q, p)) : this.multiplyQuaternions(this, q);
        },
        premultiply: function(q) {
            return this.multiplyQuaternions(q, this);
        },
        multiplyQuaternions: function(a, b) {
            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w, qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
            return this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby, this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz, 
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx, this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz, 
            this.onChangeCallback(), this;
        },
        slerp: function(qb, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(qb);
            var x = this._x, y = this._y, z = this._z, w = this._w, cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0 ? (this._w = -qb._w, this._x = -qb._x, this._y = -qb._y, this._z = -qb._z, 
            cosHalfTheta = -cosHalfTheta) : this.copy(qb), cosHalfTheta >= 1) return this._w = w, 
            this._x = x, this._y = y, this._z = z, this;
            var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < .001) return this._w = .5 * (w + this._w), this._x = .5 * (x + this._x), 
            this._y = .5 * (y + this._y), this._z = .5 * (z + this._z), this;
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta), ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            return this._w = w * ratioA + this._w * ratioB, this._x = x * ratioA + this._x * ratioB, 
            this._y = y * ratioA + this._y * ratioB, this._z = z * ratioA + this._z * ratioB, 
            this.onChangeCallback(), this;
        },
        equals: function(quaternion) {
            return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this._x = array[offset], this._y = array[offset + 1], 
            this._z = array[offset + 2], this._w = array[offset + 3], this.onChangeCallback(), 
            this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this._x, 
            array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._w, 
            array;
        },
        onChange: function(callback) {
            return this.onChangeCallback = callback, this;
        },
        onChangeCallback: function() {}
    }), Object.assign(Vector3.prototype, {
        isVector3: !0,
        set: function(x, y, z) {
            return this.x = x, this.y = y, this.z = z, this;
        },
        setScalar: function(scalar) {
            return this.x = scalar, this.y = scalar, this.z = scalar, this;
        },
        setX: function(x) {
            return this.x = x, this;
        },
        setY: function(y) {
            return this.y = y, this;
        },
        setZ: function(z) {
            return this.z = z, this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              case 2:
                this.z = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z);
        },
        copy: function(v) {
            return this.x = v.x, this.y = v.y, this.z = v.z, this;
        },
        add: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
            this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this.z += v.z, this);
        },
        addScalar: function(s) {
            return this.x += s, this.y += s, this.z += s, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
        },
        addScaledVector: function(v, s) {
            return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this;
        },
        sub: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
            this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this.z -= v.z, this);
        },
        subScalar: function(s) {
            return this.x -= s, this.y -= s, this.z -= s, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;
        },
        multiply: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), 
            this.multiplyVectors(v, w)) : (this.x *= v.x, this.y *= v.y, this.z *= v.z, this);
        },
        multiplyScalar: function(scalar) {
            return this.x *= scalar, this.y *= scalar, this.z *= scalar, this;
        },
        multiplyVectors: function(a, b) {
            return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;
        },
        applyEuler: function() {
            var quaternion = new Quaternion();
            return function(euler) {
                return euler && euler.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), 
                this.applyQuaternion(quaternion.setFromEuler(euler));
            };
        }(),
        applyAxisAngle: function() {
            var quaternion = new Quaternion();
            return function(axis, angle) {
                return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
            };
        }(),
        applyMatrix3: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements;
            return this.x = e[0] * x + e[3] * y + e[6] * z, this.y = e[1] * x + e[4] * y + e[7] * z, 
            this.z = e[2] * x + e[5] * y + e[8] * z, this;
        },
        applyMatrix4: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements, w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
            return this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w, this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w, 
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w, this;
        },
        applyQuaternion: function(q) {
            var x = this.x, y = this.y, z = this.z, qx = q.x, qy = q.y, qz = q.z, qw = q.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            return this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, 
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, this;
        },
        project: function() {
            var matrix = new Matrix4();
            return function(camera) {
                return matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld)), 
                this.applyMatrix4(matrix);
            };
        }(),
        unproject: function() {
            var matrix = new Matrix4();
            return function(camera) {
                return matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix)), 
                this.applyMatrix4(matrix);
            };
        }(),
        transformDirection: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements;
            return this.x = e[0] * x + e[4] * y + e[8] * z, this.y = e[1] * x + e[5] * y + e[9] * z, 
            this.z = e[2] * x + e[6] * y + e[10] * z, this.normalize();
        },
        divide: function(v) {
            return this.x /= v.x, this.y /= v.y, this.z /= v.z, this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        min: function(v) {
            return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), 
            this;
        },
        max: function(v) {
            return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), 
            this;
        },
        clamp: function(min, max) {
            return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), 
            this.z = Math.max(min.z, Math.min(max.z, this.z)), this;
        },
        clampScalar: function() {
            var min = new Vector3(), max = new Vector3();
            return function(minVal, maxVal) {
                return min.set(minVal, minVal, minVal), max.set(maxVal, maxVal, maxVal), this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
            this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
            this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
            this;
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), 
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function(length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function(v, alpha) {
            return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha, 
            this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        cross: function(v, w) {
            if (void 0 !== w) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), 
            this.crossVectors(v, w);
            var x = this.x, y = this.y, z = this.z;
            return this.x = y * v.z - z * v.y, this.y = z * v.x - x * v.z, this.z = x * v.y - y * v.x, 
            this;
        },
        crossVectors: function(a, b) {
            var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
            return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
            this;
        },
        projectOnVector: function(vector) {
            var scalar = vector.dot(this) / vector.lengthSq();
            return this.copy(vector).multiplyScalar(scalar);
        },
        projectOnPlane: function() {
            var v1 = new Vector3();
            return function(planeNormal) {
                return v1.copy(this).projectOnVector(planeNormal), this.sub(v1);
            };
        }(),
        reflect: function() {
            var v1 = new Vector3();
            return function(normal) {
                return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
            };
        }(),
        angleTo: function(v) {
            var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
            return Math.acos(_Math.clamp(theta, -1, 1));
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        },
        distanceToManhattan: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        },
        setFromSpherical: function(s) {
            var sinPhiRadius = Math.sin(s.phi) * s.radius;
            return this.x = sinPhiRadius * Math.sin(s.theta), this.y = Math.cos(s.phi) * s.radius, 
            this.z = sinPhiRadius * Math.cos(s.theta), this;
        },
        setFromCylindrical: function(c) {
            return this.x = c.radius * Math.sin(c.theta), this.y = c.y, this.z = c.radius * Math.cos(c.theta), 
            this;
        },
        setFromMatrixPosition: function(m) {
            var e = m.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this;
        },
        setFromMatrixScale: function(m) {
            var sx = this.setFromMatrixColumn(m, 0).length(), sy = this.setFromMatrixColumn(m, 1).length(), sz = this.setFromMatrixColumn(m, 2).length();
            return this.x = sx, this.y = sy, this.z = sz, this;
        },
        setFromMatrixColumn: function(m, index) {
            return this.fromArray(m.elements, 4 * index);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1], 
            this.z = array[offset + 2], this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x, 
            array[offset + 1] = this.y, array[offset + 2] = this.z, array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            return void 0 !== offset && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), 
            this.x = attribute.getX(index), this.y = attribute.getY(index), this.z = attribute.getZ(index), 
            this;
        }
    }), Object.assign(Matrix4.prototype, {
        isMatrix4: !0,
        set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            return te[0] = n11, te[4] = n12, te[8] = n13, te[12] = n14, te[1] = n21, te[5] = n22, 
            te[9] = n23, te[13] = n24, te[2] = n31, te[6] = n32, te[10] = n33, te[14] = n34, 
            te[3] = n41, te[7] = n42, te[11] = n43, te[15] = n44, this;
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        },
        clone: function() {
            return new Matrix4().fromArray(this.elements);
        },
        copy: function(m) {
            var te = this.elements, me = m.elements;
            return te[0] = me[0], te[1] = me[1], te[2] = me[2], te[3] = me[3], te[4] = me[4], 
            te[5] = me[5], te[6] = me[6], te[7] = me[7], te[8] = me[8], te[9] = me[9], te[10] = me[10], 
            te[11] = me[11], te[12] = me[12], te[13] = me[13], te[14] = me[14], te[15] = me[15], 
            this;
        },
        copyPosition: function(m) {
            var te = this.elements, me = m.elements;
            return te[12] = me[12], te[13] = me[13], te[14] = me[14], this;
        },
        extractBasis: function(xAxis, yAxis, zAxis) {
            return xAxis.setFromMatrixColumn(this, 0), yAxis.setFromMatrixColumn(this, 1), zAxis.setFromMatrixColumn(this, 2), 
            this;
        },
        makeBasis: function(xAxis, yAxis, zAxis) {
            return this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1), 
            this;
        },
        extractRotation: function() {
            var v1 = new Vector3();
            return function(m) {
                var te = this.elements, me = m.elements, scaleX = 1 / v1.setFromMatrixColumn(m, 0).length(), scaleY = 1 / v1.setFromMatrixColumn(m, 1).length(), scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                return te[0] = me[0] * scaleX, te[1] = me[1] * scaleX, te[2] = me[2] * scaleX, te[4] = me[4] * scaleY, 
                te[5] = me[5] * scaleY, te[6] = me[6] * scaleY, te[8] = me[8] * scaleZ, te[9] = me[9] * scaleZ, 
                te[10] = me[10] * scaleZ, this;
            };
        }(),
        makeRotationFromEuler: function(euler) {
            euler && euler.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var te = this.elements, x = euler.x, y = euler.y, z = euler.z, a = Math.cos(x), b = Math.sin(x), c = Math.cos(y), d = Math.sin(y), e = Math.cos(z), f = Math.sin(z);
            if ("XYZ" === euler.order) {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e, te[4] = -c * f, te[8] = d, te[1] = af + be * d, te[5] = ae - bf * d, 
                te[9] = -b * c, te[2] = bf - ae * d, te[6] = be + af * d, te[10] = a * c;
            } else if ("YXZ" === euler.order) {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b, te[4] = de * b - cf, te[8] = a * d, te[1] = a * f, te[5] = a * e, 
                te[9] = -b, te[2] = cf * b - de, te[6] = df + ce * b, te[10] = a * c;
            } else if ("ZXY" === euler.order) {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b, te[4] = -a * f, te[8] = de + cf * b, te[1] = cf + de * b, te[5] = a * e, 
                te[9] = df - ce * b, te[2] = -a * d, te[6] = b, te[10] = a * c;
            } else if ("ZYX" === euler.order) {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e, te[4] = be * d - af, te[8] = ae * d + bf, te[1] = c * f, te[5] = bf * d + ae, 
                te[9] = af * d - be, te[2] = -d, te[6] = b * c, te[10] = a * c;
            } else if ("YZX" === euler.order) {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e, te[4] = bd - ac * f, te[8] = bc * f + ad, te[1] = f, te[5] = a * e, 
                te[9] = -b * e, te[2] = -d * e, te[6] = ad * f + bc, te[10] = ac - bd * f;
            } else if ("XZY" === euler.order) {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e, te[4] = -f, te[8] = d * e, te[1] = ac * f + bd, te[5] = a * e, te[9] = ad * f - bc, 
                te[2] = bc * f - ad, te[6] = b * e, te[10] = bd * f + ac;
            }
            return te[3] = 0, te[7] = 0, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1, 
            this;
        },
        makeRotationFromQuaternion: function(q) {
            var te = this.elements, x = q._x, y = q._y, z = q._z, w = q._w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return te[0] = 1 - (yy + zz), te[4] = xy - wz, te[8] = xz + wy, te[1] = xy + wz, 
            te[5] = 1 - (xx + zz), te[9] = yz - wx, te[2] = xz - wy, te[6] = yz + wx, te[10] = 1 - (xx + yy), 
            te[3] = 0, te[7] = 0, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1, 
            this;
        },
        lookAt: function() {
            var x = new Vector3(), y = new Vector3(), z = new Vector3();
            return function(eye, target, up) {
                var te = this.elements;
                return z.subVectors(eye, target), 0 === z.lengthSq() && (z.z = 1), z.normalize(), 
                x.crossVectors(up, z), 0 === x.lengthSq() && (1 === Math.abs(up.z) ? z.x += 1e-4 : z.z += 1e-4, 
                z.normalize(), x.crossVectors(up, z)), x.normalize(), y.crossVectors(z, x), te[0] = x.x, 
                te[4] = y.x, te[8] = z.x, te[1] = x.y, te[5] = y.y, te[9] = z.y, te[2] = x.z, te[6] = y.z, 
                te[10] = z.z, this;
            };
        }(),
        multiply: function(m, n) {
            return void 0 !== n ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), 
            this.multiplyMatrices(m, n)) : this.multiplyMatrices(this, m);
        },
        premultiply: function(m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function(a, b) {
            var ae = a.elements, be = b.elements, te = this.elements, a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12], a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13], a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14], a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15], b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12], b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13], b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14], b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            return te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, 
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, 
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, 
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, 
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, 
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, 
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, 
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44, 
            this;
        },
        multiplyScalar: function(s) {
            var te = this.elements;
            return te[0] *= s, te[4] *= s, te[8] *= s, te[12] *= s, te[1] *= s, te[5] *= s, 
            te[9] *= s, te[13] *= s, te[2] *= s, te[6] *= s, te[10] *= s, te[14] *= s, te[3] *= s, 
            te[7] *= s, te[11] *= s, te[15] *= s, this;
        },
        applyToBufferAttribute: function() {
            var v1 = new Vector3();
            return function(attribute) {
                for (var i = 0, l = attribute.count; i < l; i++) v1.x = attribute.getX(i), v1.y = attribute.getY(i), 
                v1.z = attribute.getZ(i), v1.applyMatrix4(this), attribute.setXYZ(i, v1.x, v1.y, v1.z);
                return attribute;
            };
        }(),
        determinant: function() {
            var te = this.elements, n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12], n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13], n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            return te[3] * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + te[7] * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + te[11] * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + te[15] * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        },
        transpose: function() {
            var tmp, te = this.elements;
            return tmp = te[1], te[1] = te[4], te[4] = tmp, tmp = te[2], te[2] = te[8], te[8] = tmp, 
            tmp = te[6], te[6] = te[9], te[9] = tmp, tmp = te[3], te[3] = te[12], te[12] = tmp, 
            tmp = te[7], te[7] = te[13], te[13] = tmp, tmp = te[11], te[11] = te[14], te[14] = tmp, 
            this;
        },
        setPosition: function(v) {
            var te = this.elements;
            return te[12] = v.x, te[13] = v.y, te[14] = v.z, this;
        },
        getInverse: function(m, throwOnDegenerate) {
            var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34, det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (0 === det) {
                var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === throwOnDegenerate) throw new Error(msg);
                return console.warn(msg), this.identity();
            }
            var detInv = 1 / det;
            return te[0] = t11 * detInv, te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv, 
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv, 
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv, 
            te[4] = t12 * detInv, te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv, 
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv, 
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv, 
            te[8] = t13 * detInv, te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv, 
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv, 
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv, 
            te[12] = t14 * detInv, te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv, 
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv, 
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv, 
            this;
        },
        scale: function(v) {
            var te = this.elements, x = v.x, y = v.y, z = v.z;
            return te[0] *= x, te[4] *= y, te[8] *= z, te[1] *= x, te[5] *= y, te[9] *= z, te[2] *= x, 
            te[6] *= y, te[10] *= z, te[3] *= x, te[7] *= y, te[11] *= z, this;
        },
        getMaxScaleOnAxis: function() {
            var te = this.elements, scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2], scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6], scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        },
        makeTranslation: function(x, y, z) {
            return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1), this;
        },
        makeRotationX: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1), this;
        },
        makeRotationY: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1), this;
        },
        makeRotationZ: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        },
        makeRotationAxis: function(axis, angle) {
            var c = Math.cos(angle), s = Math.sin(angle), t = 1 - c, x = axis.x, y = axis.y, z = axis.z, tx = t * x, ty = t * y;
            return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1), 
            this;
        },
        makeScale: function(x, y, z) {
            return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1), this;
        },
        makeShear: function(x, y, z) {
            return this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1), this;
        },
        compose: function(position, quaternion, scale) {
            return this.makeRotationFromQuaternion(quaternion), this.scale(scale), this.setPosition(position), 
            this;
        },
        decompose: function() {
            var vector = new Vector3(), matrix = new Matrix4();
            return function(position, quaternion, scale) {
                var te = this.elements, sx = vector.set(te[0], te[1], te[2]).length(), sy = vector.set(te[4], te[5], te[6]).length(), sz = vector.set(te[8], te[9], te[10]).length();
                this.determinant() < 0 && (sx = -sx), position.x = te[12], position.y = te[13], 
                position.z = te[14], matrix.copy(this);
                var invSX = 1 / sx, invSY = 1 / sy, invSZ = 1 / sz;
                return matrix.elements[0] *= invSX, matrix.elements[1] *= invSX, matrix.elements[2] *= invSX, 
                matrix.elements[4] *= invSY, matrix.elements[5] *= invSY, matrix.elements[6] *= invSY, 
                matrix.elements[8] *= invSZ, matrix.elements[9] *= invSZ, matrix.elements[10] *= invSZ, 
                quaternion.setFromRotationMatrix(matrix), scale.x = sx, scale.y = sy, scale.z = sz, 
                this;
            };
        }(),
        makePerspective: function(left, right, top, bottom, near, far) {
            void 0 === far && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var te = this.elements, x = 2 * near / (right - left), y = 2 * near / (top - bottom), a = (right + left) / (right - left), b = (top + bottom) / (top - bottom), c = -(far + near) / (far - near), d = -2 * far * near / (far - near);
            return te[0] = x, te[4] = 0, te[8] = a, te[12] = 0, te[1] = 0, te[5] = y, te[9] = b, 
            te[13] = 0, te[2] = 0, te[6] = 0, te[10] = c, te[14] = d, te[3] = 0, te[7] = 0, 
            te[11] = -1, te[15] = 0, this;
        },
        makeOrthographic: function(left, right, top, bottom, near, far) {
            var te = this.elements, w = 1 / (right - left), h = 1 / (top - bottom), p = 1 / (far - near), x = (right + left) * w, y = (top + bottom) * h, z = (far + near) * p;
            return te[0] = 2 * w, te[4] = 0, te[8] = 0, te[12] = -x, te[1] = 0, te[5] = 2 * h, 
            te[9] = 0, te[13] = -y, te[2] = 0, te[6] = 0, te[10] = -2 * p, te[14] = -z, te[3] = 0, 
            te[7] = 0, te[11] = 0, te[15] = 1, this;
        },
        equals: function(matrix) {
            for (var te = this.elements, me = matrix.elements, i = 0; i < 16; i++) if (te[i] !== me[i]) return !1;
            return !0;
        },
        fromArray: function(array, offset) {
            void 0 === offset && (offset = 0);
            for (var i = 0; i < 16; i++) this.elements[i] = array[i + offset];
            return this;
        },
        toArray: function(array, offset) {
            void 0 === array && (array = []), void 0 === offset && (offset = 0);
            var te = this.elements;
            return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2], 
            array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5], 
            array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8], 
            array[offset + 9] = te[9], array[offset + 10] = te[10], array[offset + 11] = te[11], 
            array[offset + 12] = te[12], array[offset + 13] = te[13], array[offset + 14] = te[14], 
            array[offset + 15] = te[15], array;
        }
    }), DataTexture.prototype = Object.create(Texture.prototype), DataTexture.prototype.constructor = DataTexture, 
    DataTexture.prototype.isDataTexture = !0, CubeTexture.prototype = Object.create(Texture.prototype), 
    CubeTexture.prototype.constructor = CubeTexture, CubeTexture.prototype.isCubeTexture = !0, 
    Object.defineProperty(CubeTexture.prototype, "images", {
        get: function() {
            return this.image;
        },
        set: function(value) {
            this.image = value;
        }
    });
    var emptyTexture = new Texture(), emptyCubeTexture = new CubeTexture(), arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9);
    StructuredUniform.prototype.setValue = function(gl, value) {
        for (var seq = this.seq, i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.setValue(gl, value[u.id]);
        }
    };
    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    WebGLUniforms.prototype.setValue = function(gl, name, value) {
        var u = this.map[name];
        void 0 !== u && u.setValue(gl, value, this.renderer);
    }, WebGLUniforms.prototype.setOptional = function(gl, object, name) {
        var v = object[name];
        void 0 !== v && this.setValue(gl, name, v);
    }, WebGLUniforms.upload = function(gl, seq, values, renderer) {
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i], v = values[u.id];
            !1 !== v.needsUpdate && u.setValue(gl, v.value, renderer);
        }
    }, WebGLUniforms.seqWithValue = function(seq, values) {
        for (var r = [], i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.id in values && r.push(u);
        }
        return r;
    };
    var ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Object.assign(Color.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(value) {
            return value && value.isColor ? this.copy(value) : "number" == typeof value ? this.setHex(value) : "string" == typeof value && this.setStyle(value), 
            this;
        },
        setScalar: function(scalar) {
            return this.r = scalar, this.g = scalar, this.b = scalar, this;
        },
        setHex: function(hex) {
            return hex = Math.floor(hex), this.r = (hex >> 16 & 255) / 255, this.g = (hex >> 8 & 255) / 255, 
            this.b = (255 & hex) / 255, this;
        },
        setRGB: function(r, g, b) {
            return this.r = r, this.g = g, this.b = b, this;
        },
        setHSL: function() {
            function hue2rgb(p, q, t) {
                return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + 6 * (q - p) * (2 / 3 - t) : p;
            }
            return function(h, s, l) {
                if (h = _Math.euclideanModulo(h, 1), s = _Math.clamp(s, 0, 1), l = _Math.clamp(l, 0, 1), 
                0 === s) this.r = this.g = this.b = l; else {
                    var p = l <= .5 ? l * (1 + s) : l + s - l * s, q = 2 * l - p;
                    this.r = hue2rgb(q, p, h + 1 / 3), this.g = hue2rgb(q, p, h), this.b = hue2rgb(q, p, h - 1 / 3);
                }
                return this;
            };
        }(),
        setStyle: function(style) {
            function handleAlpha(string) {
                void 0 !== string && parseFloat(string) < 1 && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
            var m;
            if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                var color, name = m[1], components = m[2];
                switch (name) {
                  case "rgb":
                  case "rgba":
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) return this.r = Math.min(255, parseInt(color[1], 10)) / 255, 
                    this.g = Math.min(255, parseInt(color[2], 10)) / 255, this.b = Math.min(255, parseInt(color[3], 10)) / 255, 
                    handleAlpha(color[5]), this;
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) return this.r = Math.min(100, parseInt(color[1], 10)) / 100, 
                    this.g = Math.min(100, parseInt(color[2], 10)) / 100, this.b = Math.min(100, parseInt(color[3], 10)) / 100, 
                    handleAlpha(color[5]), this;
                    break;

                  case "hsl":
                  case "hsla":
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        var h = parseFloat(color[1]) / 360, s = parseInt(color[2], 10) / 100, l = parseInt(color[3], 10) / 100;
                        return handleAlpha(color[5]), this.setHSL(h, s, l);
                    }
                }
            } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                var hex = m[1], size = hex.length;
                if (3 === size) return this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255, 
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255, this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255, 
                this;
                if (6 === size) return this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255, 
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255, this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255, 
                this;
            }
            if (style && style.length > 0) {
                var hex = ColorKeywords[style];
                void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + style);
            }
            return this;
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b);
        },
        copy: function(color) {
            return this.r = color.r, this.g = color.g, this.b = color.b, this;
        },
        copyGammaToLinear: function(color, gammaFactor) {
            return void 0 === gammaFactor && (gammaFactor = 2), this.r = Math.pow(color.r, gammaFactor), 
            this.g = Math.pow(color.g, gammaFactor), this.b = Math.pow(color.b, gammaFactor), 
            this;
        },
        copyLinearToGamma: function(color, gammaFactor) {
            void 0 === gammaFactor && (gammaFactor = 2);
            var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
            return this.r = Math.pow(color.r, safeInverse), this.g = Math.pow(color.g, safeInverse), 
            this.b = Math.pow(color.b, safeInverse), this;
        },
        convertGammaToLinear: function() {
            var r = this.r, g = this.g, b = this.b;
            return this.r = r * r, this.g = g * g, this.b = b * b, this;
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), 
            this;
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function(optionalTarget) {
            var hue, saturation, hsl = optionalTarget || {
                h: 0,
                s: 0,
                l: 0
            }, r = this.r, g = this.g, b = this.b, max = Math.max(r, g, b), min = Math.min(r, g, b), lightness = (min + max) / 2;
            if (min === max) hue = 0, saturation = 0; else {
                var delta = max - min;
                switch (saturation = lightness <= .5 ? delta / (max + min) : delta / (2 - max - min), 
                max) {
                  case r:
                    hue = (g - b) / delta + (g < b ? 6 : 0);
                    break;

                  case g:
                    hue = (b - r) / delta + 2;
                    break;

                  case b:
                    hue = (r - g) / delta + 4;
                }
                hue /= 6;
            }
            return hsl.h = hue, hsl.s = saturation, hsl.l = lightness, hsl;
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
        },
        offsetHSL: function(h, s, l) {
            var hsl = this.getHSL();
            return hsl.h += h, hsl.s += s, hsl.l += l, this.setHSL(hsl.h, hsl.s, hsl.l), this;
        },
        add: function(color) {
            return this.r += color.r, this.g += color.g, this.b += color.b, this;
        },
        addColors: function(color1, color2) {
            return this.r = color1.r + color2.r, this.g = color1.g + color2.g, this.b = color1.b + color2.b, 
            this;
        },
        addScalar: function(s) {
            return this.r += s, this.g += s, this.b += s, this;
        },
        sub: function(color) {
            return this.r = Math.max(0, this.r - color.r), this.g = Math.max(0, this.g - color.g), 
            this.b = Math.max(0, this.b - color.b), this;
        },
        multiply: function(color) {
            return this.r *= color.r, this.g *= color.g, this.b *= color.b, this;
        },
        multiplyScalar: function(s) {
            return this.r *= s, this.g *= s, this.b *= s, this;
        },
        lerp: function(color, alpha) {
            return this.r += (color.r - this.r) * alpha, this.g += (color.g - this.g) * alpha, 
            this.b += (color.b - this.b) * alpha, this;
        },
        equals: function(c) {
            return c.r === this.r && c.g === this.g && c.b === this.b;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.r = array[offset], this.g = array[offset + 1], 
            this.b = array[offset + 2], this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.r, 
            array[offset + 1] = this.g, array[offset + 2] = this.b, array;
        },
        toJSON: function() {
            return this.getHex();
        }
    });
    var UniformsLib = {
        common: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            offsetRepeat: {
                value: new Vector4(0, 0, 1, 1)
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            offsetRepeat: {
                value: new Vector4(0, 0, 1, 1)
            }
        }
    }, UniformsUtils = {
        merge: function(uniforms) {
            for (var merged = {}, u = 0; u < uniforms.length; u++) {
                var tmp = this.clone(uniforms[u]);
                for (var p in tmp) merged[p] = tmp[p];
            }
            return merged;
        },
        clone: function(uniforms_src) {
            var uniforms_dst = {};
            for (var u in uniforms_src) {
                uniforms_dst[u] = {};
                for (var p in uniforms_src[u]) {
                    var parameter_src = uniforms_src[u][p];
                    parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture) ? uniforms_dst[u][p] = parameter_src.clone() : Array.isArray(parameter_src) ? uniforms_dst[u][p] = parameter_src.slice() : uniforms_dst[u][p] = parameter_src;
                }
            }
            return uniforms_dst;
        }
    }, ShaderChunk = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "\nvec3 transformed = vec3( position );\n",
        beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
        bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
        dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
        tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
        cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
        equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
        shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
    }, ShaderLib = {
        basic: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog ]),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                }
            } ]),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                },
                specular: {
                    value: new Color(1118481)
                },
                shininess: {
                    value: 30
                }
            } ]),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        },
        points: {
            uniforms: UniformsUtils.merge([ UniformsLib.points, UniformsLib.fog ]),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            } ]),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.displacementmap ]),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                opacity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.normal_vert,
            fragmentShader: ShaderChunk.normal_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.displacementmap, {
                referencePosition: {
                    value: new Vector3()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            } ]),
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
            uniforms: UniformsUtils.merge([ UniformsLib.lights, {
                color: {
                    value: new Color(0)
                },
                opacity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
        }
    };
    ShaderLib.physical = {
        uniforms: UniformsUtils.merge([ ShaderLib.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        } ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    }, Object.assign(Box2.prototype, {
        set: function(min, max) {
            return this.min.copy(min), this.max.copy(max), this;
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) this.expandByPoint(points[i]);
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector2();
            return function(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(.5);
                return this.min.copy(center).sub(halfSize), this.max.copy(center).add(halfSize), 
                this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            return this.min.copy(box.min), this.max.copy(box.max), this;
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            return this.min.min(point), this.max.max(point), this;
        },
        expandByVector: function(vector) {
            return this.min.sub(vector), this.max.add(vector), this;
        },
        expandByScalar: function(scalar) {
            return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
        },
        containsPoint: function(point) {
            return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y);
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        },
        getParameter: function(point, optionalTarget) {
            return (optionalTarget || new Vector2()).set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        },
        intersectsBox: function(box) {
            return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y);
        },
        clampPoint: function(point, optionalTarget) {
            return (optionalTarget || new Vector2()).copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector2();
            return function(point) {
                return v1.copy(point).clamp(this.min, this.max).sub(point).length();
            };
        }(),
        intersect: function(box) {
            return this.min.max(box.min), this.max.min(box.max), this;
        },
        union: function(box) {
            return this.min.min(box.min), this.max.max(box.max), this;
        },
        translate: function(offset) {
            return this.min.add(offset), this.max.add(offset), this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    }), CanvasTexture.prototype = Object.create(Texture.prototype), CanvasTexture.prototype.constructor = CanvasTexture;
    var materialId = 0;
    Object.assign(Material.prototype, EventDispatcher.prototype, {
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(values) {
            if (void 0 !== values) for (var key in values) {
                var newValue = values[key];
                if (void 0 !== newValue) if ("shading" !== key) {
                    var currentValue = this[key];
                    void 0 !== currentValue ? currentValue && currentValue.isColor ? currentValue.set(newValue) : currentValue && currentValue.isVector3 && newValue && newValue.isVector3 ? currentValue.copy(newValue) : this[key] = "overdraw" === key ? Number(newValue) : newValue : console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), 
                this.flatShading = 1 === newValue; else console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            }
        },
        toJSON: function(meta) {
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata, values.push(data);
                }
                return values;
            }
            var isRoot = void 0 === meta;
            isRoot && (meta = {
                textures: {},
                images: {}
            });
            var data = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), 
            this.color && this.color.isColor && (data.color = this.color.getHex()), void 0 !== this.roughness && (data.roughness = this.roughness), 
            void 0 !== this.metalness && (data.metalness = this.metalness), this.emissive && this.emissive.isColor && (data.emissive = this.emissive.getHex()), 
            this.specular && this.specular.isColor && (data.specular = this.specular.getHex()), 
            void 0 !== this.shininess && (data.shininess = this.shininess), void 0 !== this.clearCoat && (data.clearCoat = this.clearCoat), 
            void 0 !== this.clearCoatRoughness && (data.clearCoatRoughness = this.clearCoatRoughness), 
            this.map && this.map.isTexture && (data.map = this.map.toJSON(meta).uuid), this.alphaMap && this.alphaMap.isTexture && (data.alphaMap = this.alphaMap.toJSON(meta).uuid), 
            this.lightMap && this.lightMap.isTexture && (data.lightMap = this.lightMap.toJSON(meta).uuid), 
            this.bumpMap && this.bumpMap.isTexture && (data.bumpMap = this.bumpMap.toJSON(meta).uuid, 
            data.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (data.normalMap = this.normalMap.toJSON(meta).uuid, 
            data.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (data.displacementMap = this.displacementMap.toJSON(meta).uuid, 
            data.displacementScale = this.displacementScale, data.displacementBias = this.displacementBias), 
            this.roughnessMap && this.roughnessMap.isTexture && (data.roughnessMap = this.roughnessMap.toJSON(meta).uuid), 
            this.metalnessMap && this.metalnessMap.isTexture && (data.metalnessMap = this.metalnessMap.toJSON(meta).uuid), 
            this.emissiveMap && this.emissiveMap.isTexture && (data.emissiveMap = this.emissiveMap.toJSON(meta).uuid), 
            this.specularMap && this.specularMap.isTexture && (data.specularMap = this.specularMap.toJSON(meta).uuid), 
            this.envMap && this.envMap.isTexture && (data.envMap = this.envMap.toJSON(meta).uuid, 
            data.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (data.gradientMap = this.gradientMap.toJSON(meta).uuid), 
            void 0 !== this.size && (data.size = this.size), void 0 !== this.sizeAttenuation && (data.sizeAttenuation = this.sizeAttenuation), 
            this.blending !== NormalBlending && (data.blending = this.blending), !0 === this.flatShading && (data.flatShading = this.flatShading), 
            this.side !== FrontSide && (data.side = this.side), this.vertexColors !== NoColors && (data.vertexColors = this.vertexColors), 
            this.opacity < 1 && (data.opacity = this.opacity), !0 === this.transparent && (data.transparent = this.transparent), 
            data.depthFunc = this.depthFunc, data.depthTest = this.depthTest, data.depthWrite = this.depthWrite, 
            !0 === this.dithering && (data.dithering = !0), this.alphaTest > 0 && (data.alphaTest = this.alphaTest), 
            !0 === this.premultipliedAlpha && (data.premultipliedAlpha = this.premultipliedAlpha), 
            !0 === this.wireframe && (data.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (data.wireframeLinewidth = this.wireframeLinewidth), 
            "round" !== this.wireframeLinecap && (data.wireframeLinecap = this.wireframeLinecap), 
            "round" !== this.wireframeLinejoin && (data.wireframeLinejoin = this.wireframeLinejoin), 
            !0 === this.morphTargets && (data.morphTargets = !0), !0 === this.skinning && (data.skinning = !0), 
            !1 === this.visible && (data.visible = !1), "{}" !== JSON.stringify(this.userData) && (data.userData = this.userData), 
            isRoot) {
                var textures = extractFromCache(meta.textures), images = extractFromCache(meta.images);
                textures.length > 0 && (data.textures = textures), images.length > 0 && (data.images = images);
            }
            return data;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.name = source.name, this.fog = source.fog, this.lights = source.lights, this.blending = source.blending, 
            this.side = source.side, this.flatShading = source.flatShading, this.vertexColors = source.vertexColors, 
            this.opacity = source.opacity, this.transparent = source.transparent, this.blendSrc = source.blendSrc, 
            this.blendDst = source.blendDst, this.blendEquation = source.blendEquation, this.blendSrcAlpha = source.blendSrcAlpha, 
            this.blendDstAlpha = source.blendDstAlpha, this.blendEquationAlpha = source.blendEquationAlpha, 
            this.depthFunc = source.depthFunc, this.depthTest = source.depthTest, this.depthWrite = source.depthWrite, 
            this.colorWrite = source.colorWrite, this.precision = source.precision, this.polygonOffset = source.polygonOffset, 
            this.polygonOffsetFactor = source.polygonOffsetFactor, this.polygonOffsetUnits = source.polygonOffsetUnits, 
            this.dithering = source.dithering, this.alphaTest = source.alphaTest, this.premultipliedAlpha = source.premultipliedAlpha, 
            this.overdraw = source.overdraw, this.visible = source.visible, this.userData = JSON.parse(JSON.stringify(source.userData)), 
            this.clipShadows = source.clipShadows, this.clipIntersection = source.clipIntersection;
            var srcPlanes = source.clippingPlanes, dstPlanes = null;
            if (null !== srcPlanes) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
            }
            return this.clippingPlanes = dstPlanes, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), ShaderMaterial.prototype = Object.create(Material.prototype), ShaderMaterial.prototype.constructor = ShaderMaterial, 
    ShaderMaterial.prototype.isShaderMaterial = !0, ShaderMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.fragmentShader = source.fragmentShader, 
        this.vertexShader = source.vertexShader, this.uniforms = UniformsUtils.clone(source.uniforms), 
        this.defines = source.defines, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this.lights = source.lights, this.clipping = source.clipping, this.skinning = source.skinning, 
        this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, 
        this.extensions = source.extensions, this;
    }, ShaderMaterial.prototype.toJSON = function(meta) {
        var data = Material.prototype.toJSON.call(this, meta);
        return data.uniforms = this.uniforms, data.vertexShader = this.vertexShader, data.fragmentShader = this.fragmentShader, 
        data;
    }, MeshDepthMaterial.prototype = Object.create(Material.prototype), MeshDepthMaterial.prototype.constructor = MeshDepthMaterial, 
    MeshDepthMaterial.prototype.isMeshDepthMaterial = !0, MeshDepthMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.depthPacking = source.depthPacking, 
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.map = source.map, 
        this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, 
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, 
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this;
    }, MeshDistanceMaterial.prototype = Object.create(Material.prototype), MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial, 
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0, MeshDistanceMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.referencePosition.copy(source.referencePosition), 
        this.nearDistance = source.nearDistance, this.farDistance = source.farDistance, 
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.map = source.map, 
        this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, 
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, 
        this;
    }, Object.assign(Box3.prototype, {
        isBox3: !0,
        set: function(min, max) {
            return this.min.copy(min), this.max.copy(max), this;
        },
        setFromArray: function(array) {
            for (var minX = 1 / 0, minY = 1 / 0, minZ = 1 / 0, maxX = -1 / 0, maxY = -1 / 0, maxZ = -1 / 0, i = 0, l = array.length; i < l; i += 3) {
                var x = array[i], y = array[i + 1], z = array[i + 2];
                x < minX && (minX = x), y < minY && (minY = y), z < minZ && (minZ = z), x > maxX && (maxX = x), 
                y > maxY && (maxY = y), z > maxZ && (maxZ = z);
            }
            return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
        },
        setFromBufferAttribute: function(attribute) {
            for (var minX = 1 / 0, minY = 1 / 0, minZ = 1 / 0, maxX = -1 / 0, maxY = -1 / 0, maxZ = -1 / 0, i = 0, l = attribute.count; i < l; i++) {
                var x = attribute.getX(i), y = attribute.getY(i), z = attribute.getZ(i);
                x < minX && (minX = x), y < minY && (minY = y), z < minZ && (minZ = z), x > maxX && (maxX = x), 
                y > maxY && (maxY = y), z > maxZ && (maxZ = z);
            }
            return this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ), this;
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) this.expandByPoint(points[i]);
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector3();
            return function(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(.5);
                return this.min.copy(center).sub(halfSize), this.max.copy(center).add(halfSize), 
                this;
            };
        }(),
        setFromObject: function(object) {
            return this.makeEmpty(), this.expandByObject(object);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            return this.min.copy(box.min), this.max.copy(box.max), this;
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, 
            this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            return this.min.min(point), this.max.max(point), this;
        },
        expandByVector: function(vector) {
            return this.min.sub(vector), this.max.add(vector), this;
        },
        expandByScalar: function(scalar) {
            return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
        },
        expandByObject: function() {
            var v1 = new Vector3();
            return function(object) {
                var scope = this;
                return object.updateMatrixWorld(!0), object.traverse(function(node) {
                    var i, l, geometry = node.geometry;
                    if (void 0 !== geometry) if (geometry.isGeometry) {
                        var vertices = geometry.vertices;
                        for (i = 0, l = vertices.length; i < l; i++) v1.copy(vertices[i]), v1.applyMatrix4(node.matrixWorld), 
                        scope.expandByPoint(v1);
                    } else if (geometry.isBufferGeometry) {
                        var attribute = geometry.attributes.position;
                        if (void 0 !== attribute) for (i = 0, l = attribute.count; i < l; i++) v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld), 
                        scope.expandByPoint(v1);
                    }
                }), this;
            };
        }(),
        containsPoint: function(point) {
            return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z);
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        },
        getParameter: function(point, optionalTarget) {
            return (optionalTarget || new Vector3()).set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        },
        intersectsBox: function(box) {
            return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z);
        },
        intersectsSphere: function() {
            var closestPoint = new Vector3();
            return function(sphere) {
                return this.clampPoint(sphere.center, closestPoint), closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
            };
        }(),
        intersectsPlane: function(plane) {
            var min, max;
            return plane.normal.x > 0 ? (min = plane.normal.x * this.min.x, max = plane.normal.x * this.max.x) : (min = plane.normal.x * this.max.x, 
            max = plane.normal.x * this.min.x), plane.normal.y > 0 ? (min += plane.normal.y * this.min.y, 
            max += plane.normal.y * this.max.y) : (min += plane.normal.y * this.max.y, max += plane.normal.y * this.min.y), 
            plane.normal.z > 0 ? (min += plane.normal.z * this.min.z, max += plane.normal.z * this.max.z) : (min += plane.normal.z * this.max.z, 
            max += plane.normal.z * this.min.z), min <= plane.constant && max >= plane.constant;
        },
        clampPoint: function(point, optionalTarget) {
            return (optionalTarget || new Vector3()).copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector3();
            return function(point) {
                return v1.copy(point).clamp(this.min, this.max).sub(point).length();
            };
        }(),
        getBoundingSphere: function() {
            var v1 = new Vector3();
            return function(optionalTarget) {
                var result = optionalTarget || new Sphere();
                return this.getCenter(result.center), result.radius = .5 * this.getSize(v1).length(), 
                result;
            };
        }(),
        intersect: function(box) {
            return this.min.max(box.min), this.max.min(box.max), this.isEmpty() && this.makeEmpty(), 
            this;
        },
        union: function(box) {
            return this.min.min(box.min), this.max.max(box.max), this;
        },
        applyMatrix4: function() {
            var points = [ new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3() ];
            return function(matrix) {
                return this.isEmpty() ? this : (points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix), 
                points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix), points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix), 
                points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix), points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix), 
                points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix), points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix), 
                points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix), this.setFromPoints(points), 
                this);
            };
        }(),
        translate: function(offset) {
            return this.min.add(offset), this.max.add(offset), this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    }), Object.assign(Sphere.prototype, {
        set: function(center, radius) {
            return this.center.copy(center), this.radius = radius, this;
        },
        setFromPoints: function() {
            var box = new Box3();
            return function(points, optionalCenter) {
                var center = this.center;
                void 0 !== optionalCenter ? center.copy(optionalCenter) : box.setFromPoints(points).getCenter(center);
                for (var maxRadiusSq = 0, i = 0, il = points.length; i < il; i++) maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                return this.radius = Math.sqrt(maxRadiusSq), this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(sphere) {
            return this.center.copy(sphere.center), this.radius = sphere.radius, this;
        },
        empty: function() {
            return this.radius <= 0;
        },
        containsPoint: function(point) {
            return point.distanceToSquared(this.center) <= this.radius * this.radius;
        },
        distanceToPoint: function(point) {
            return point.distanceTo(this.center) - this.radius;
        },
        intersectsSphere: function(sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        },
        intersectsBox: function(box) {
            return box.intersectsSphere(this);
        },
        intersectsPlane: function(plane) {
            return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        },
        clampPoint: function(point, optionalTarget) {
            var deltaLengthSq = this.center.distanceToSquared(point), result = optionalTarget || new Vector3();
            return result.copy(point), deltaLengthSq > this.radius * this.radius && (result.sub(this.center).normalize(), 
            result.multiplyScalar(this.radius).add(this.center)), result;
        },
        getBoundingBox: function(optionalTarget) {
            var box = optionalTarget || new Box3();
            return box.set(this.center, this.center), box.expandByScalar(this.radius), box;
        },
        applyMatrix4: function(matrix) {
            return this.center.applyMatrix4(matrix), this.radius = this.radius * matrix.getMaxScaleOnAxis(), 
            this;
        },
        translate: function(offset) {
            return this.center.add(offset), this;
        },
        equals: function(sphere) {
            return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
    }), Object.assign(Matrix3.prototype, {
        isMatrix3: !0,
        set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            return te[0] = n11, te[1] = n21, te[2] = n31, te[3] = n12, te[4] = n22, te[5] = n32, 
            te[6] = n13, te[7] = n23, te[8] = n33, this;
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        },
        clone: function() {
            return new this.constructor().fromArray(this.elements);
        },
        copy: function(m) {
            var te = this.elements, me = m.elements;
            return te[0] = me[0], te[1] = me[1], te[2] = me[2], te[3] = me[3], te[4] = me[4], 
            te[5] = me[5], te[6] = me[6], te[7] = me[7], te[8] = me[8], this;
        },
        setFromMatrix4: function(m) {
            var me = m.elements;
            return this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]), 
            this;
        },
        applyToBufferAttribute: function() {
            var v1 = new Vector3();
            return function(attribute) {
                for (var i = 0, l = attribute.count; i < l; i++) v1.x = attribute.getX(i), v1.y = attribute.getY(i), 
                v1.z = attribute.getZ(i), v1.applyMatrix3(this), attribute.setXYZ(i, v1.x, v1.y, v1.z);
                return attribute;
            };
        }(),
        multiply: function(m) {
            return this.multiplyMatrices(this, m);
        },
        premultiply: function(m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function(a, b) {
            var ae = a.elements, be = b.elements, te = this.elements, a11 = ae[0], a12 = ae[3], a13 = ae[6], a21 = ae[1], a22 = ae[4], a23 = ae[7], a31 = ae[2], a32 = ae[5], a33 = ae[8], b11 = be[0], b12 = be[3], b13 = be[6], b21 = be[1], b22 = be[4], b23 = be[7], b31 = be[2], b32 = be[5], b33 = be[8];
            return te[0] = a11 * b11 + a12 * b21 + a13 * b31, te[3] = a11 * b12 + a12 * b22 + a13 * b32, 
            te[6] = a11 * b13 + a12 * b23 + a13 * b33, te[1] = a21 * b11 + a22 * b21 + a23 * b31, 
            te[4] = a21 * b12 + a22 * b22 + a23 * b32, te[7] = a21 * b13 + a22 * b23 + a23 * b33, 
            te[2] = a31 * b11 + a32 * b21 + a33 * b31, te[5] = a31 * b12 + a32 * b22 + a33 * b32, 
            te[8] = a31 * b13 + a32 * b23 + a33 * b33, this;
        },
        multiplyScalar: function(s) {
            var te = this.elements;
            return te[0] *= s, te[3] *= s, te[6] *= s, te[1] *= s, te[4] *= s, te[7] *= s, te[2] *= s, 
            te[5] *= s, te[8] *= s, this;
        },
        determinant: function() {
            var te = this.elements, a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        },
        getInverse: function(matrix, throwOnDegenerate) {
            matrix && matrix.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (0 === det) {
                var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === throwOnDegenerate) throw new Error(msg);
                return console.warn(msg), this.identity();
            }
            var detInv = 1 / det;
            return te[0] = t11 * detInv, te[1] = (n31 * n23 - n33 * n21) * detInv, te[2] = (n32 * n21 - n31 * n22) * detInv, 
            te[3] = t12 * detInv, te[4] = (n33 * n11 - n31 * n13) * detInv, te[5] = (n31 * n12 - n32 * n11) * detInv, 
            te[6] = t13 * detInv, te[7] = (n21 * n13 - n23 * n11) * detInv, te[8] = (n22 * n11 - n21 * n12) * detInv, 
            this;
        },
        transpose: function() {
            var tmp, m = this.elements;
            return tmp = m[1], m[1] = m[3], m[3] = tmp, tmp = m[2], m[2] = m[6], m[6] = tmp, 
            tmp = m[5], m[5] = m[7], m[7] = tmp, this;
        },
        getNormalMatrix: function(matrix4) {
            return this.setFromMatrix4(matrix4).getInverse(this).transpose();
        },
        transposeIntoArray: function(r) {
            var m = this.elements;
            return r[0] = m[0], r[1] = m[3], r[2] = m[6], r[3] = m[1], r[4] = m[4], r[5] = m[7], 
            r[6] = m[2], r[7] = m[5], r[8] = m[8], this;
        },
        equals: function(matrix) {
            for (var te = this.elements, me = matrix.elements, i = 0; i < 9; i++) if (te[i] !== me[i]) return !1;
            return !0;
        },
        fromArray: function(array, offset) {
            void 0 === offset && (offset = 0);
            for (var i = 0; i < 9; i++) this.elements[i] = array[i + offset];
            return this;
        },
        toArray: function(array, offset) {
            void 0 === array && (array = []), void 0 === offset && (offset = 0);
            var te = this.elements;
            return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2], 
            array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5], 
            array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8], 
            array;
        }
    }), Object.assign(Plane.prototype, {
        set: function(normal, constant) {
            return this.normal.copy(normal), this.constant = constant, this;
        },
        setComponents: function(x, y, z, w) {
            return this.normal.set(x, y, z), this.constant = w, this;
        },
        setFromNormalAndCoplanarPoint: function(normal, point) {
            return this.normal.copy(normal), this.constant = -point.dot(this.normal), this;
        },
        setFromCoplanarPoints: function() {
            var v1 = new Vector3(), v2 = new Vector3();
            return function(a, b, c) {
                var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                return this.setFromNormalAndCoplanarPoint(normal, a), this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(plane) {
            return this.normal.copy(plane.normal), this.constant = plane.constant, this;
        },
        normalize: function() {
            var inverseNormalLength = 1 / this.normal.length();
            return this.normal.multiplyScalar(inverseNormalLength), this.constant *= inverseNormalLength, 
            this;
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this;
        },
        distanceToPoint: function(point) {
            return this.normal.dot(point) + this.constant;
        },
        distanceToSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        },
        projectPoint: function(point, optionalTarget) {
            return (optionalTarget || new Vector3()).copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        },
        intersectLine: function() {
            var v1 = new Vector3();
            return function(line, optionalTarget) {
                var result = optionalTarget || new Vector3(), direction = line.delta(v1), denominator = this.normal.dot(direction);
                if (0 !== denominator) {
                    var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                    if (!(t < 0 || t > 1)) return result.copy(direction).multiplyScalar(t).add(line.start);
                } else if (0 === this.distanceToPoint(line.start)) return result.copy(line.start);
            };
        }(),
        intersectsLine: function(line) {
            var startSign = this.distanceToPoint(line.start), endSign = this.distanceToPoint(line.end);
            return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
        },
        intersectsBox: function(box) {
            return box.intersectsPlane(this);
        },
        intersectsSphere: function(sphere) {
            return sphere.intersectsPlane(this);
        },
        coplanarPoint: function(optionalTarget) {
            return (optionalTarget || new Vector3()).copy(this.normal).multiplyScalar(-this.constant);
        },
        applyMatrix4: function() {
            var v1 = new Vector3(), m1 = new Matrix3();
            return function(matrix, optionalNormalMatrix) {
                var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix), referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix), normal = this.normal.applyMatrix3(normalMatrix).normalize();
                return this.constant = -referencePoint.dot(normal), this;
            };
        }(),
        translate: function(offset) {
            return this.constant -= offset.dot(this.normal), this;
        },
        equals: function(plane) {
            return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
    }), Object.assign(Frustum.prototype, {
        set: function(p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            return planes[0].copy(p0), planes[1].copy(p1), planes[2].copy(p2), planes[3].copy(p3), 
            planes[4].copy(p4), planes[5].copy(p5), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(frustum) {
            for (var planes = this.planes, i = 0; i < 6; i++) planes[i].copy(frustum.planes[i]);
            return this;
        },
        setFromMatrix: function(m) {
            var planes = this.planes, me = m.elements, me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3], me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7], me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11], me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            return planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize(), 
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize(), 
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize(), 
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize(), 
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize(), 
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize(), 
            this;
        },
        intersectsObject: function() {
            var sphere = new Sphere();
            return function(object) {
                var geometry = object.geometry;
                return null === geometry.boundingSphere && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld), 
                this.intersectsSphere(sphere);
            };
        }(),
        intersectsSprite: function() {
            var sphere = new Sphere();
            return function(sprite) {
                return sphere.center.set(0, 0, 0), sphere.radius = .7071067811865476, sphere.applyMatrix4(sprite.matrixWorld), 
                this.intersectsSphere(sphere);
            };
        }(),
        intersectsSphere: function(sphere) {
            for (var planes = this.planes, center = sphere.center, negRadius = -sphere.radius, i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(center) < negRadius) return !1;
            }
            return !0;
        },
        intersectsBox: function() {
            var p1 = new Vector3(), p2 = new Vector3();
            return function(box) {
                for (var planes = this.planes, i = 0; i < 6; i++) {
                    var plane = planes[i];
                    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x, p2.x = plane.normal.x > 0 ? box.max.x : box.min.x, 
                    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y, p2.y = plane.normal.y > 0 ? box.max.y : box.min.y, 
                    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z, p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                    var d1 = plane.distanceToPoint(p1), d2 = plane.distanceToPoint(p2);
                    if (d1 < 0 && d2 < 0) return !1;
                }
                return !0;
            };
        }(),
        containsPoint: function(point) {
            for (var planes = this.planes, i = 0; i < 6; i++) if (planes[i].distanceToPoint(point) < 0) return !1;
            return !0;
        }
    }), Euler.RotationOrders = [ "XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX" ], Euler.DefaultOrder = "XYZ", 
    Object.defineProperties(Euler.prototype, {
        x: {
            get: function() {
                return this._x;
            },
            set: function(value) {
                this._x = value, this.onChangeCallback();
            }
        },
        y: {
            get: function() {
                return this._y;
            },
            set: function(value) {
                this._y = value, this.onChangeCallback();
            }
        },
        z: {
            get: function() {
                return this._z;
            },
            set: function(value) {
                this._z = value, this.onChangeCallback();
            }
        },
        order: {
            get: function() {
                return this._order;
            },
            set: function(value) {
                this._order = value, this.onChangeCallback();
            }
        }
    }), Object.assign(Euler.prototype, {
        isEuler: !0,
        set: function(x, y, z, order) {
            return this._x = x, this._y = y, this._z = z, this._order = order || this._order, 
            this.onChangeCallback(), this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function(euler) {
            return this._x = euler._x, this._y = euler._y, this._z = euler._z, this._order = euler._order, 
            this.onChangeCallback(), this;
        },
        setFromRotationMatrix: function(m, order, update) {
            var clamp = _Math.clamp, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            return order = order || this._order, "XYZ" === order ? (this._y = Math.asin(clamp(m13, -1, 1)), 
            Math.abs(m13) < .99999 ? (this._x = Math.atan2(-m23, m33), this._z = Math.atan2(-m12, m11)) : (this._x = Math.atan2(m32, m22), 
            this._z = 0)) : "YXZ" === order ? (this._x = Math.asin(-clamp(m23, -1, 1)), Math.abs(m23) < .99999 ? (this._y = Math.atan2(m13, m33), 
            this._z = Math.atan2(m21, m22)) : (this._y = Math.atan2(-m31, m11), this._z = 0)) : "ZXY" === order ? (this._x = Math.asin(clamp(m32, -1, 1)), 
            Math.abs(m32) < .99999 ? (this._y = Math.atan2(-m31, m33), this._z = Math.atan2(-m12, m22)) : (this._y = 0, 
            this._z = Math.atan2(m21, m11))) : "ZYX" === order ? (this._y = Math.asin(-clamp(m31, -1, 1)), 
            Math.abs(m31) < .99999 ? (this._x = Math.atan2(m32, m33), this._z = Math.atan2(m21, m11)) : (this._x = 0, 
            this._z = Math.atan2(-m12, m22))) : "YZX" === order ? (this._z = Math.asin(clamp(m21, -1, 1)), 
            Math.abs(m21) < .99999 ? (this._x = Math.atan2(-m23, m22), this._y = Math.atan2(-m31, m11)) : (this._x = 0, 
            this._y = Math.atan2(m13, m33))) : "XZY" === order ? (this._z = Math.asin(-clamp(m12, -1, 1)), 
            Math.abs(m12) < .99999 ? (this._x = Math.atan2(m32, m22), this._y = Math.atan2(m13, m11)) : (this._x = Math.atan2(-m23, m33), 
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order), 
            this._order = order, !1 !== update && this.onChangeCallback(), this;
        },
        setFromQuaternion: function() {
            var matrix = new Matrix4();
            return function(q, order, update) {
                return matrix.makeRotationFromQuaternion(q), this.setFromRotationMatrix(matrix, order, update);
            };
        }(),
        setFromVector3: function(v, order) {
            return this.set(v.x, v.y, v.z, order || this._order);
        },
        reorder: function() {
            var q = new Quaternion();
            return function(newOrder) {
                return q.setFromEuler(this), this.setFromQuaternion(q, newOrder);
            };
        }(),
        equals: function(euler) {
            return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        },
        fromArray: function(array) {
            return this._x = array[0], this._y = array[1], this._z = array[2], void 0 !== array[3] && (this._order = array[3]), 
            this.onChangeCallback(), this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this._x, 
            array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._order, 
            array;
        },
        toVector3: function(optionalResult) {
            return optionalResult ? optionalResult.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z);
        },
        onChange: function(callback) {
            return this.onChangeCallback = callback, this;
        },
        onChangeCallback: function() {}
    }), Object.assign(Layers.prototype, {
        set: function(channel) {
            this.mask = 1 << channel | 0;
        },
        enable: function(channel) {
            this.mask |= 1 << channel | 0;
        },
        toggle: function(channel) {
            this.mask ^= 1 << channel | 0;
        },
        disable: function(channel) {
            this.mask &= ~(1 << channel | 0);
        },
        test: function(layers) {
            return 0 != (this.mask & layers.mask);
        }
    });
    var object3DId = 0;
    Object3D.DefaultUp = new Vector3(0, 1, 0), Object3D.DefaultMatrixAutoUpdate = !0, 
    Object.assign(Object3D.prototype, EventDispatcher.prototype, {
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(matrix) {
            this.matrix.multiplyMatrices(matrix, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function(q) {
            return this.quaternion.premultiply(q), this;
        },
        setRotationFromAxisAngle: function(axis, angle) {
            this.quaternion.setFromAxisAngle(axis, angle);
        },
        setRotationFromEuler: function(euler) {
            this.quaternion.setFromEuler(euler, !0);
        },
        setRotationFromMatrix: function(m) {
            this.quaternion.setFromRotationMatrix(m);
        },
        setRotationFromQuaternion: function(q) {
            this.quaternion.copy(q);
        },
        rotateOnAxis: function() {
            var q1 = new Quaternion();
            return function(axis, angle) {
                return q1.setFromAxisAngle(axis, angle), this.quaternion.multiply(q1), this;
            };
        }(),
        rotateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        translateOnAxis: function() {
            var v1 = new Vector3();
            return function(axis, distance) {
                return v1.copy(axis).applyQuaternion(this.quaternion), this.position.add(v1.multiplyScalar(distance)), 
                this;
            };
        }(),
        translateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        localToWorld: function(vector) {
            return vector.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function() {
            var m1 = new Matrix4();
            return function(vector) {
                return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
            };
        }(),
        lookAt: function() {
            var m1 = new Matrix4();
            return function(vector) {
                this.isCamera ? m1.lookAt(this.position, vector, this.up) : m1.lookAt(vector, this.position, this.up), 
                this.quaternion.setFromRotationMatrix(m1);
            };
        }(),
        add: function(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) this.add(arguments[i]);
                return this;
            }
            return object === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", object), 
            this) : (object && object.isObject3D ? (null !== object.parent && object.parent.remove(object), 
            object.parent = this, object.dispatchEvent({
                type: "added"
            }), this.children.push(object)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object), 
            this);
        },
        remove: function(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) this.remove(arguments[i]);
                return this;
            }
            var index = this.children.indexOf(object);
            return -1 !== index && (object.parent = null, object.dispatchEvent({
                type: "removed"
            }), this.children.splice(index, 1)), this;
        },
        getObjectById: function(id) {
            return this.getObjectByProperty("id", id);
        },
        getObjectByName: function(name) {
            return this.getObjectByProperty("name", name);
        },
        getObjectByProperty: function(name, value) {
            if (this[name] === value) return this;
            for (var i = 0, l = this.children.length; i < l; i++) {
                var child = this.children[i], object = child.getObjectByProperty(name, value);
                if (void 0 !== object) return object;
            }
        },
        getWorldPosition: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.updateMatrixWorld(!0), result.setFromMatrixPosition(this.matrixWorld);
        },
        getWorldQuaternion: function() {
            var position = new Vector3(), scale = new Vector3();
            return function(optionalTarget) {
                var result = optionalTarget || new Quaternion();
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(position, result, scale), 
                result;
            };
        }(),
        getWorldRotation: function() {
            var quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Euler();
                return this.getWorldQuaternion(quaternion), result.setFromQuaternion(quaternion, this.rotation.order, !1);
            };
        }(),
        getWorldScale: function() {
            var position = new Vector3(), quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Vector3();
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(position, quaternion, result), 
                result;
            };
        }(),
        getWorldDirection: function() {
            var quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Vector3();
                return this.getWorldQuaternion(quaternion), result.set(0, 0, 1).applyQuaternion(quaternion);
            };
        }(),
        raycast: function() {},
        traverse: function(callback) {
            callback(this);
            for (var children = this.children, i = 0, l = children.length; i < l; i++) children[i].traverse(callback);
        },
        traverseVisible: function(callback) {
            if (!1 !== this.visible) {
                callback(this);
                for (var children = this.children, i = 0, l = children.length; i < l; i++) children[i].traverseVisible(callback);
            }
        },
        traverseAncestors: function(callback) {
            var parent = this.parent;
            null !== parent && (callback(parent), parent.traverseAncestors(callback));
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
        },
        updateMatrixWorld: function(force) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || force) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
            this.matrixWorldNeedsUpdate = !1, force = !0);
            for (var children = this.children, i = 0, l = children.length; i < l; i++) children[i].updateMatrixWorld(force);
        },
        toJSON: function(meta) {
            function serialize(library, element) {
                return void 0 === library[element.uuid] && (library[element.uuid] = element.toJSON(meta)), 
                element.uuid;
            }
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata, values.push(data);
                }
                return values;
            }
            var isRootObject = void 0 === meta || "" === meta, output = {};
            isRootObject && (meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            }, output.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var object = {};
            if (object.uuid = this.uuid, object.type = this.type, "" !== this.name && (object.name = this.name), 
            !0 === this.castShadow && (object.castShadow = !0), !0 === this.receiveShadow && (object.receiveShadow = !0), 
            !1 === this.visible && (object.visible = !1), "{}" !== JSON.stringify(this.userData) && (object.userData = this.userData), 
            object.matrix = this.matrix.toArray(), void 0 !== this.geometry && (object.geometry = serialize(meta.geometries, this.geometry)), 
            void 0 !== this.material) if (Array.isArray(this.material)) {
                for (var uuids = [], i = 0, l = this.material.length; i < l; i++) uuids.push(serialize(meta.materials, this.material[i]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
            if (this.children.length > 0) {
                object.children = [];
                for (var i = 0; i < this.children.length; i++) object.children.push(this.children[i].toJSON(meta).object);
            }
            if (isRootObject) {
                var geometries = extractFromCache(meta.geometries), materials = extractFromCache(meta.materials), textures = extractFromCache(meta.textures), images = extractFromCache(meta.images);
                geometries.length > 0 && (output.geometries = geometries), materials.length > 0 && (output.materials = materials), 
                textures.length > 0 && (output.textures = textures), images.length > 0 && (output.images = images);
            }
            return output.object = object, output;
        },
        clone: function(recursive) {
            return new this.constructor().copy(this, recursive);
        },
        copy: function(source, recursive) {
            if (void 0 === recursive && (recursive = !0), this.name = source.name, this.up.copy(source.up), 
            this.position.copy(source.position), this.quaternion.copy(source.quaternion), this.scale.copy(source.scale), 
            this.matrix.copy(source.matrix), this.matrixWorld.copy(source.matrixWorld), this.matrixAutoUpdate = source.matrixAutoUpdate, 
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate, this.layers.mask = source.layers.mask, 
            this.visible = source.visible, this.castShadow = source.castShadow, this.receiveShadow = source.receiveShadow, 
            this.frustumCulled = source.frustumCulled, this.renderOrder = source.renderOrder, 
            this.userData = JSON.parse(JSON.stringify(source.userData)), !0 === recursive) for (var i = 0; i < source.children.length; i++) {
                var child = source.children[i];
                this.add(child.clone());
            }
            return this;
        }
    }), Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Camera,
        isCamera: !0,
        copy: function(source, recursive) {
            return Object3D.prototype.copy.call(this, source, recursive), this.matrixWorldInverse.copy(source.matrixWorldInverse), 
            this.projectionMatrix.copy(source.projectionMatrix), this;
        },
        getWorldDirection: function() {
            var quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Vector3();
                return this.getWorldQuaternion(quaternion), result.set(0, 0, -1).applyQuaternion(quaternion);
            };
        }(),
        updateMatrixWorld: function(force) {
            Object3D.prototype.updateMatrixWorld.call(this, force), this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function() {
            return new this.constructor().copy(this);
        }
    }), OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: OrthographicCamera,
        isOrthographicCamera: !0,
        copy: function(source, recursive) {
            return Camera.prototype.copy.call(this, source, recursive), this.left = source.left, 
            this.right = source.right, this.top = source.top, this.bottom = source.bottom, this.near = source.near, 
            this.far = source.far, this.zoom = source.zoom, this.view = null === source.view ? null : Object.assign({}, source.view), 
            this;
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            }, this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            this.view = null, this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var dx = (this.right - this.left) / (2 * this.zoom), dy = (this.top - this.bottom) / (2 * this.zoom), cx = (this.right + this.left) / 2, cy = (this.top + this.bottom) / 2, left = cx - dx, right = cx + dx, top = cy + dy, bottom = cy - dy;
            if (null !== this.view) {
                var zoomW = this.zoom / (this.view.width / this.view.fullWidth), zoomH = this.zoom / (this.view.height / this.view.fullHeight), scaleW = (this.right - this.left) / this.view.width, scaleH = (this.top - this.bottom) / this.view.height;
                left += scaleW * (this.view.offsetX / zoomW), right = left + scaleW * (this.view.width / zoomW), 
                top -= scaleH * (this.view.offsetY / zoomH), bottom = top - scaleH * (this.view.height / zoomH);
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return data.object.zoom = this.zoom, data.object.left = this.left, data.object.right = this.right, 
            data.object.top = this.top, data.object.bottom = this.bottom, data.object.near = this.near, 
            data.object.far = this.far, null !== this.view && (data.object.view = Object.assign({}, this.view)), 
            data;
        }
    }), PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: PerspectiveCamera,
        isPerspectiveCamera: !0,
        copy: function(source, recursive) {
            return Camera.prototype.copy.call(this, source, recursive), this.fov = source.fov, 
            this.zoom = source.zoom, this.near = source.near, this.far = source.far, this.focus = source.focus, 
            this.aspect = source.aspect, this.view = null === source.view ? null : Object.assign({}, source.view), 
            this.filmGauge = source.filmGauge, this.filmOffset = source.filmOffset, this;
        },
        setFocalLength: function(focalLength) {
            var vExtentSlope = .5 * this.getFilmHeight() / focalLength;
            this.fov = 2 * _Math.RAD2DEG * Math.atan(vExtentSlope), this.updateProjectionMatrix();
        },
        getFocalLength: function() {
            var vExtentSlope = Math.tan(.5 * _Math.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / vExtentSlope;
        },
        getEffectiveFOV: function() {
            return 2 * _Math.RAD2DEG * Math.atan(Math.tan(.5 * _Math.DEG2RAD * this.fov) / this.zoom);
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight, this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            }, this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            this.view = null, this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var near = this.near, top = near * Math.tan(.5 * _Math.DEG2RAD * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -.5 * width, view = this.view;
            if (null !== view) {
                var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth, top -= view.offsetY * height / fullHeight, 
                width *= view.width / fullWidth, height *= view.height / fullHeight;
            }
            var skew = this.filmOffset;
            0 !== skew && (left += near * skew / this.getFilmWidth()), this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return data.object.fov = this.fov, data.object.zoom = this.zoom, data.object.near = this.near, 
            data.object.far = this.far, data.object.focus = this.focus, data.object.aspect = this.aspect, 
            null !== this.view && (data.object.view = Object.assign({}, this.view)), data.object.filmGauge = this.filmGauge, 
            data.object.filmOffset = this.filmOffset, data;
        }
    }), Object.assign(Face3.prototype, {
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.a = source.a, this.b = source.b, this.c = source.c, this.normal.copy(source.normal), 
            this.color.copy(source.color), this.materialIndex = source.materialIndex;
            for (var i = 0, il = source.vertexNormals.length; i < il; i++) this.vertexNormals[i] = source.vertexNormals[i].clone();
            for (var i = 0, il = source.vertexColors.length; i < il; i++) this.vertexColors[i] = source.vertexColors[i].clone();
            return this;
        }
    });
    var count = 0;
    Object.assign(Geometry.prototype, EventDispatcher.prototype, {
        isGeometry: !0,
        applyMatrix: function(matrix) {
            for (var normalMatrix = new Matrix3().getNormalMatrix(matrix), i = 0, il = this.vertices.length; i < il; i++) {
                this.vertices[i].applyMatrix4(matrix);
            }
            for (var i = 0, il = this.faces.length; i < il; i++) {
                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
            this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
        },
        rotateX: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationX(angle), this.applyMatrix(m1), this;
            };
        }(),
        rotateY: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationY(angle), this.applyMatrix(m1), this;
            };
        }(),
        rotateZ: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationZ(angle), this.applyMatrix(m1), this;
            };
        }(),
        translate: function() {
            var m1 = new Matrix4();
            return function(x, y, z) {
                return m1.makeTranslation(x, y, z), this.applyMatrix(m1), this;
            };
        }(),
        scale: function() {
            var m1 = new Matrix4();
            return function(x, y, z) {
                return m1.makeScale(x, y, z), this.applyMatrix(m1), this;
            };
        }(),
        lookAt: function() {
            var obj = new Object3D();
            return function(vector) {
                obj.lookAt(vector), obj.updateMatrix(), this.applyMatrix(obj.matrix);
            };
        }(),
        fromBufferGeometry: function(geometry) {
            function addFace(a, b, c, materialIndex) {
                var vertexNormals = void 0 !== normals ? [ tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone() ] : [], vertexColors = void 0 !== colors ? [ scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone() ] : [], face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face), void 0 !== uvs && scope.faceVertexUvs[0].push([ tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone() ]), 
                void 0 !== uvs2 && scope.faceVertexUvs[1].push([ tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone() ]);
            }
            var scope = this, indices = null !== geometry.index ? geometry.index.array : void 0, attributes = geometry.attributes, positions = attributes.position.array, normals = void 0 !== attributes.normal ? attributes.normal.array : void 0, colors = void 0 !== attributes.color ? attributes.color.array : void 0, uvs = void 0 !== attributes.uv ? attributes.uv.array : void 0, uvs2 = void 0 !== attributes.uv2 ? attributes.uv2.array : void 0;
            void 0 !== uvs2 && (this.faceVertexUvs[1] = []);
            for (var tempNormals = [], tempUVs = [], tempUVs2 = [], i = 0, j = 0; i < positions.length; i += 3, 
            j += 2) scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2])), 
            void 0 !== normals && tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2])), 
            void 0 !== colors && scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2])), 
            void 0 !== uvs && tempUVs.push(new Vector2(uvs[j], uvs[j + 1])), void 0 !== uvs2 && tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
            var groups = geometry.groups;
            if (groups.length > 0) for (var i = 0; i < groups.length; i++) for (var group = groups[i], start = group.start, count = group.count, j = start, jl = start + count; j < jl; j += 3) void 0 !== indices ? addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex) : addFace(j, j + 1, j + 2, group.materialIndex); else if (void 0 !== indices) for (var i = 0; i < indices.length; i += 3) addFace(indices[i], indices[i + 1], indices[i + 2]); else for (var i = 0; i < positions.length / 3; i += 3) addFace(i, i + 1, i + 2);
            return this.computeFaceNormals(), null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone()), 
            null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()), 
            this;
        },
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            return this.translate(offset.x, offset.y, offset.z), offset;
        },
        normalize: function() {
            this.computeBoundingSphere();
            var center = this.boundingSphere.center, radius = this.boundingSphere.radius, s = 0 === radius ? 1 : 1 / radius, matrix = new Matrix4();
            return matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1), 
            this.applyMatrix(matrix), this;
        },
        computeFaceNormals: function() {
            for (var cb = new Vector3(), ab = new Vector3(), f = 0, fl = this.faces.length; f < fl; f++) {
                var face = this.faces[f], vA = this.vertices[face.a], vB = this.vertices[face.b], vC = this.vertices[face.c];
                cb.subVectors(vC, vB), ab.subVectors(vA, vB), cb.cross(ab), cb.normalize(), face.normal.copy(cb);
            }
        },
        computeVertexNormals: function(areaWeighted) {
            void 0 === areaWeighted && (areaWeighted = !0);
            var v, vl, f, fl, face, vertices;
            for (vertices = new Array(this.vertices.length), v = 0, vl = this.vertices.length; v < vl; v++) vertices[v] = new Vector3();
            if (areaWeighted) {
                var vA, vB, vC, cb = new Vector3(), ab = new Vector3();
                for (f = 0, fl = this.faces.length; f < fl; f++) face = this.faces[f], vA = this.vertices[face.a], 
                vB = this.vertices[face.b], vC = this.vertices[face.c], cb.subVectors(vC, vB), ab.subVectors(vA, vB), 
                cb.cross(ab), vertices[face.a].add(cb), vertices[face.b].add(cb), vertices[face.c].add(cb);
            } else for (this.computeFaceNormals(), f = 0, fl = this.faces.length; f < fl; f++) face = this.faces[f], 
            vertices[face.a].add(face.normal), vertices[face.b].add(face.normal), vertices[face.c].add(face.normal);
            for (v = 0, vl = this.vertices.length; v < vl; v++) vertices[v].normalize();
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                3 === vertexNormals.length ? (vertexNormals[0].copy(vertices[face.a]), vertexNormals[1].copy(vertices[face.b]), 
                vertexNormals[2].copy(vertices[face.c])) : (vertexNormals[0] = vertices[face.a].clone(), 
                vertexNormals[1] = vertices[face.b].clone(), vertexNormals[2] = vertices[face.c].clone());
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeFlatVertexNormals: function() {
            var f, fl, face;
            for (this.computeFaceNormals(), f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                3 === vertexNormals.length ? (vertexNormals[0].copy(face.normal), vertexNormals[1].copy(face.normal), 
                vertexNormals[2].copy(face.normal)) : (vertexNormals[0] = face.normal.clone(), vertexNormals[1] = face.normal.clone(), 
                vertexNormals[2] = face.normal.clone());
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeMorphNormals: function() {
            var i, il, f, fl, face;
            for (f = 0, fl = this.faces.length; f < fl; f++) for (face = this.faces[f], face.__originalFaceNormal ? face.__originalFaceNormal.copy(face.normal) : face.__originalFaceNormal = face.normal.clone(), 
            face.__originalVertexNormals || (face.__originalVertexNormals = []), i = 0, il = face.vertexNormals.length; i < il; i++) face.__originalVertexNormals[i] ? face.__originalVertexNormals[i].copy(face.vertexNormals[i]) : face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
            var tmpGeo = new Geometry();
            for (tmpGeo.faces = this.faces, i = 0, il = this.morphTargets.length; i < il; i++) {
                if (!this.morphNormals[i]) {
                    this.morphNormals[i] = {}, this.morphNormals[i].faceNormals = [], this.morphNormals[i].vertexNormals = [];
                    var faceNormal, vertexNormals, dstNormalsFace = this.morphNormals[i].faceNormals, dstNormalsVertex = this.morphNormals[i].vertexNormals;
                    for (f = 0, fl = this.faces.length; f < fl; f++) faceNormal = new Vector3(), vertexNormals = {
                        a: new Vector3(),
                        b: new Vector3(),
                        c: new Vector3()
                    }, dstNormalsFace.push(faceNormal), dstNormalsVertex.push(vertexNormals);
                }
                var morphNormals = this.morphNormals[i];
                tmpGeo.vertices = this.morphTargets[i].vertices, tmpGeo.computeFaceNormals(), tmpGeo.computeVertexNormals();
                var faceNormal, vertexNormals;
                for (f = 0, fl = this.faces.length; f < fl; f++) face = this.faces[f], faceNormal = morphNormals.faceNormals[f], 
                vertexNormals = morphNormals.vertexNormals[f], faceNormal.copy(face.normal), vertexNormals.a.copy(face.vertexNormals[0]), 
                vertexNormals.b.copy(face.vertexNormals[1]), vertexNormals.c.copy(face.vertexNormals[2]);
            }
            for (f = 0, fl = this.faces.length; f < fl; f++) face = this.faces[f], face.normal = face.__originalFaceNormal, 
            face.vertexNormals = face.__originalVertexNormals;
        },
        computeLineDistances: function() {
            for (var d = 0, vertices = this.vertices, i = 0, il = vertices.length; i < il; i++) i > 0 && (d += vertices[i].distanceTo(vertices[i - 1])), 
            this.lineDistances[i] = d;
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Box3()), this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Sphere()), this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function(geometry, matrix, materialIndexOffset) {
            if (!geometry || !geometry.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
            var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
            void 0 === materialIndexOffset && (materialIndexOffset = 0), void 0 !== matrix && (normalMatrix = new Matrix3().getNormalMatrix(matrix));
            for (var i = 0, il = vertices2.length; i < il; i++) {
                var vertex = vertices2[i], vertexCopy = vertex.clone();
                void 0 !== matrix && vertexCopy.applyMatrix4(matrix), vertices1.push(vertexCopy);
            }
            for (var i = 0, il = colors2.length; i < il; i++) colors1.push(colors2[i].clone());
            for (i = 0, il = faces2.length; i < il; i++) {
                var faceCopy, normal, color, face = faces2[i], faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset), 
                faceCopy.normal.copy(face.normal), void 0 !== normalMatrix && faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) normal = faceVertexNormals[j].clone(), 
                void 0 !== normalMatrix && normal.applyMatrix3(normalMatrix).normalize(), faceCopy.vertexNormals.push(normal);
                faceCopy.color.copy(face.color);
                for (var j = 0, jl = faceVertexColors.length; j < jl; j++) color = faceVertexColors[j], 
                faceCopy.vertexColors.push(color.clone());
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset, faces1.push(faceCopy);
            }
            for (i = 0, il = uvs2.length; i < il; i++) {
                var uv = uvs2[i], uvCopy = [];
                if (void 0 !== uv) {
                    for (var j = 0, jl = uv.length; j < jl; j++) uvCopy.push(uv[j].clone());
                    uvs1.push(uvCopy);
                }
            }
        },
        mergeMesh: function(mesh) {
            if (!mesh || !mesh.isMesh) return void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
            mesh.matrixAutoUpdate && mesh.updateMatrix(), this.merge(mesh.geometry, mesh.matrix);
        },
        mergeVertices: function() {
            var v, key, i, il, face, indices, j, jl, verticesMap = {}, unique = [], changes = [], precision = Math.pow(10, 4);
            for (i = 0, il = this.vertices.length; i < il; i++) v = this.vertices[i], key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision), 
            void 0 === verticesMap[key] ? (verticesMap[key] = i, unique.push(this.vertices[i]), 
            changes[i] = unique.length - 1) : changes[i] = changes[verticesMap[key]];
            var faceIndicesToRemove = [];
            for (i = 0, il = this.faces.length; i < il; i++) {
                face = this.faces[i], face.a = changes[face.a], face.b = changes[face.b], face.c = changes[face.c], 
                indices = [ face.a, face.b, face.c ];
                for (var n = 0; n < 3; n++) if (indices[n] === indices[(n + 1) % 3]) {
                    faceIndicesToRemove.push(i);
                    break;
                }
            }
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                for (this.faces.splice(idx, 1), j = 0, jl = this.faceVertexUvs.length; j < jl; j++) this.faceVertexUvs[j].splice(idx, 1);
            }
            var diff = this.vertices.length - unique.length;
            return this.vertices = unique, diff;
        },
        sortFacesByMaterialIndex: function() {
            function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
            }
            for (var faces = this.faces, length = faces.length, i = 0; i < length; i++) faces[i]._id = i;
            faces.sort(materialIndexSort);
            var newUvs1, newUvs2, uvs1 = this.faceVertexUvs[0], uvs2 = this.faceVertexUvs[1];
            uvs1 && uvs1.length === length && (newUvs1 = []), uvs2 && uvs2.length === length && (newUvs2 = []);
            for (var i = 0; i < length; i++) {
                var id = faces[i]._id;
                newUvs1 && newUvs1.push(uvs1[id]), newUvs2 && newUvs2.push(uvs2[id]);
            }
            newUvs1 && (this.faceVertexUvs[0] = newUvs1), newUvs2 && (this.faceVertexUvs[1] = newUvs2);
        },
        toJSON: function() {
            function setBit(value, position, enabled) {
                return enabled ? value | 1 << position : value & ~(1 << position);
            }
            function getNormalIndex(normal) {
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                return void 0 !== normalsHash[hash] ? normalsHash[hash] : (normalsHash[hash] = normals.length / 3, 
                normals.push(normal.x, normal.y, normal.z), normalsHash[hash]);
            }
            function getColorIndex(color) {
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
                return void 0 !== colorsHash[hash] ? colorsHash[hash] : (colorsHash[hash] = colors.length, 
                colors.push(color.getHex()), colorsHash[hash]);
            }
            function getUvIndex(uv) {
                var hash = uv.x.toString() + uv.y.toString();
                return void 0 !== uvsHash[hash] ? uvsHash[hash] : (uvsHash[hash] = uvs.length / 2, 
                uvs.push(uv.x, uv.y), uvsHash[hash]);
            }
            var data = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), 
            void 0 !== this.parameters) {
                var parameters = this.parameters;
                for (var key in parameters) void 0 !== parameters[key] && (data[key] = parameters[key]);
                return data;
            }
            for (var vertices = [], i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
            for (var faces = [], normals = [], normalsHash = {}, colors = [], colorsHash = {}, uvs = [], uvsHash = {}, i = 0; i < this.faces.length; i++) {
                var face = this.faces[i], hasFaceVertexUv = void 0 !== this.faceVertexUvs[0][i], hasFaceNormal = face.normal.length() > 0, hasFaceVertexNormal = face.vertexNormals.length > 0, hasFaceColor = 1 !== face.color.r || 1 !== face.color.g || 1 !== face.color.b, hasFaceVertexColor = face.vertexColors.length > 0, faceType = 0;
                if (faceType = setBit(faceType, 0, 0), faceType = setBit(faceType, 1, !0), faceType = setBit(faceType, 2, !1), 
                faceType = setBit(faceType, 3, hasFaceVertexUv), faceType = setBit(faceType, 4, hasFaceNormal), 
                faceType = setBit(faceType, 5, hasFaceVertexNormal), faceType = setBit(faceType, 6, hasFaceColor), 
                faceType = setBit(faceType, 7, hasFaceVertexColor), faces.push(faceType), faces.push(face.a, face.b, face.c), 
                faces.push(face.materialIndex), hasFaceVertexUv) {
                    var faceVertexUvs = this.faceVertexUvs[0][i];
                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }
                if (hasFaceNormal && faces.push(getNormalIndex(face.normal)), hasFaceVertexNormal) {
                    var vertexNormals = face.vertexNormals;
                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }
                if (hasFaceColor && faces.push(getColorIndex(face.color)), hasFaceVertexColor) {
                    var vertexColors = face.vertexColors;
                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }
            return data.data = {}, data.data.vertices = vertices, data.data.normals = normals, 
            colors.length > 0 && (data.data.colors = colors), uvs.length > 0 && (data.data.uvs = [ uvs ]), 
            data.data.faces = faces, data;
        },
        clone: function() {
            return new Geometry().copy(this);
        },
        copy: function(source) {
            var i, il, j, jl, k, kl;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], 
            this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], 
            this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = source.name;
            var vertices = source.vertices;
            for (i = 0, il = vertices.length; i < il; i++) this.vertices.push(vertices[i].clone());
            var colors = source.colors;
            for (i = 0, il = colors.length; i < il; i++) this.colors.push(colors[i].clone());
            var faces = source.faces;
            for (i = 0, il = faces.length; i < il; i++) this.faces.push(faces[i].clone());
            for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                var faceVertexUvs = source.faceVertexUvs[i];
                for (void 0 === this.faceVertexUvs[i] && (this.faceVertexUvs[i] = []), j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                    var uvs = faceVertexUvs[j], uvsCopy = [];
                    for (k = 0, kl = uvs.length; k < kl; k++) {
                        var uv = uvs[k];
                        uvsCopy.push(uv.clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
            var morphTargets = source.morphTargets;
            for (i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = {};
                if (morphTarget.name = morphTargets[i].name, void 0 !== morphTargets[i].vertices) for (morphTarget.vertices = [], 
                j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                if (void 0 !== morphTargets[i].normals) for (morphTarget.normals = [], j = 0, jl = morphTargets[i].normals.length; j < jl; j++) morphTarget.normals.push(morphTargets[i].normals[j].clone());
                this.morphTargets.push(morphTarget);
            }
            var morphNormals = source.morphNormals;
            for (i = 0, il = morphNormals.length; i < il; i++) {
                var morphNormal = {};
                if (void 0 !== morphNormals[i].vertexNormals) for (morphNormal.vertexNormals = [], 
                j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
                    var srcVertexNormal = morphNormals[i].vertexNormals[j], destVertexNormal = {};
                    destVertexNormal.a = srcVertexNormal.a.clone(), destVertexNormal.b = srcVertexNormal.b.clone(), 
                    destVertexNormal.c = srcVertexNormal.c.clone(), morphNormal.vertexNormals.push(destVertexNormal);
                }
                if (void 0 !== morphNormals[i].faceNormals) for (morphNormal.faceNormals = [], j = 0, 
                jl = morphNormals[i].faceNormals.length; j < jl; j++) morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                this.morphNormals.push(morphNormal);
            }
            var skinWeights = source.skinWeights;
            for (i = 0, il = skinWeights.length; i < il; i++) this.skinWeights.push(skinWeights[i].clone());
            var skinIndices = source.skinIndices;
            for (i = 0, il = skinIndices.length; i < il; i++) this.skinIndices.push(skinIndices[i].clone());
            var lineDistances = source.lineDistances;
            for (i = 0, il = lineDistances.length; i < il; i++) this.lineDistances.push(lineDistances[i]);
            var boundingBox = source.boundingBox;
            null !== boundingBox && (this.boundingBox = boundingBox.clone());
            var boundingSphere = source.boundingSphere;
            return null !== boundingSphere && (this.boundingSphere = boundingSphere.clone()), 
            this.elementsNeedUpdate = source.elementsNeedUpdate, this.verticesNeedUpdate = source.verticesNeedUpdate, 
            this.uvsNeedUpdate = source.uvsNeedUpdate, this.normalsNeedUpdate = source.normalsNeedUpdate, 
            this.colorsNeedUpdate = source.colorsNeedUpdate, this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate, 
            this.groupsNeedUpdate = source.groupsNeedUpdate, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
        set: function(value) {
            !0 === value && this.version++;
        }
    }), Object.assign(BufferAttribute.prototype, {
        isBufferAttribute: !0,
        setArray: function(array) {
            if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== array ? array.length / this.itemSize : 0, this.array = array;
        },
        setDynamic: function(value) {
            return this.dynamic = value, this;
        },
        copy: function(source) {
            return this.array = new source.array.constructor(source.array), this.itemSize = source.itemSize, 
            this.count = source.count, this.normalized = source.normalized, this.dynamic = source.dynamic, 
            this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.itemSize, index2 *= attribute.itemSize;
            for (var i = 0, l = this.itemSize; i < l; i++) this.array[index1 + i] = attribute.array[index2 + i];
            return this;
        },
        copyArray: function(array) {
            return this.array.set(array), this;
        },
        copyColorsArray: function(colors) {
            for (var array = this.array, offset = 0, i = 0, l = colors.length; i < l; i++) {
                var color = colors[i];
                void 0 === color && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), 
                color = new Color()), array[offset++] = color.r, array[offset++] = color.g, array[offset++] = color.b;
            }
            return this;
        },
        copyIndicesArray: function(indices) {
            for (var array = this.array, offset = 0, i = 0, l = indices.length; i < l; i++) {
                var index = indices[i];
                array[offset++] = index.a, array[offset++] = index.b, array[offset++] = index.c;
            }
            return this;
        },
        copyVector2sArray: function(vectors) {
            for (var array = this.array, offset = 0, i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), 
                vector = new Vector2()), array[offset++] = vector.x, array[offset++] = vector.y;
            }
            return this;
        },
        copyVector3sArray: function(vectors) {
            for (var array = this.array, offset = 0, i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), 
                vector = new Vector3()), array[offset++] = vector.x, array[offset++] = vector.y, 
                array[offset++] = vector.z;
            }
            return this;
        },
        copyVector4sArray: function(vectors) {
            for (var array = this.array, offset = 0, i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), 
                vector = new Vector4()), array[offset++] = vector.x, array[offset++] = vector.y, 
                array[offset++] = vector.z, array[offset++] = vector.w;
            }
            return this;
        },
        set: function(value, offset) {
            return void 0 === offset && (offset = 0), this.array.set(value, offset), this;
        },
        getX: function(index) {
            return this.array[index * this.itemSize];
        },
        setX: function(index, x) {
            return this.array[index * this.itemSize] = x, this;
        },
        getY: function(index) {
            return this.array[index * this.itemSize + 1];
        },
        setY: function(index, y) {
            return this.array[index * this.itemSize + 1] = y, this;
        },
        getZ: function(index) {
            return this.array[index * this.itemSize + 2];
        },
        setZ: function(index, z) {
            return this.array[index * this.itemSize + 2] = z, this;
        },
        getW: function(index) {
            return this.array[index * this.itemSize + 3];
        },
        setW: function(index, w) {
            return this.array[index * this.itemSize + 3] = w, this;
        },
        setXY: function(index, x, y) {
            return index *= this.itemSize, this.array[index + 0] = x, this.array[index + 1] = y, 
            this;
        },
        setXYZ: function(index, x, y, z) {
            return index *= this.itemSize, this.array[index + 0] = x, this.array[index + 1] = y, 
            this.array[index + 2] = z, this;
        },
        setXYZW: function(index, x, y, z, w) {
            return index *= this.itemSize, this.array[index + 0] = x, this.array[index + 1] = y, 
            this.array[index + 2] = z, this.array[index + 3] = w, this;
        },
        onUpload: function(callback) {
            return this.onUploadCallback = callback, this;
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
    }), Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int8BufferAttribute.prototype.constructor = Int8BufferAttribute, 
    Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute, 
    Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype), 
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute, 
    Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int16BufferAttribute.prototype.constructor = Int16BufferAttribute, 
    Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute, 
    Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int32BufferAttribute.prototype.constructor = Int32BufferAttribute, 
    Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute, 
    Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float32BufferAttribute.prototype.constructor = Float32BufferAttribute, 
    Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float64BufferAttribute.prototype.constructor = Float64BufferAttribute, 
    Object.assign(DirectGeometry.prototype, {
        computeGroups: function(geometry) {
            for (var group, groups = [], materialIndex = void 0, faces = geometry.faces, i = 0; i < faces.length; i++) {
                var face = faces[i];
                face.materialIndex !== materialIndex && (materialIndex = face.materialIndex, void 0 !== group && (group.count = 3 * i - group.start, 
                groups.push(group)), group = {
                    start: 3 * i,
                    materialIndex: materialIndex
                });
            }
            void 0 !== group && (group.count = 3 * i - group.start, groups.push(group)), this.groups = groups;
        },
        fromGeometry: function(geometry) {
            var morphTargetsPosition, faces = geometry.faces, vertices = geometry.vertices, faceVertexUvs = geometry.faceVertexUvs, hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0, hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0, morphTargets = geometry.morphTargets, morphTargetsLength = morphTargets.length;
            if (morphTargetsLength > 0) {
                morphTargetsPosition = [];
                for (var i = 0; i < morphTargetsLength; i++) morphTargetsPosition[i] = [];
                this.morphTargets.position = morphTargetsPosition;
            }
            var morphTargetsNormal, morphNormals = geometry.morphNormals, morphNormalsLength = morphNormals.length;
            if (morphNormalsLength > 0) {
                morphTargetsNormal = [];
                for (var i = 0; i < morphNormalsLength; i++) morphTargetsNormal[i] = [];
                this.morphTargets.normal = morphTargetsNormal;
            }
            for (var skinIndices = geometry.skinIndices, skinWeights = geometry.skinWeights, hasSkinIndices = skinIndices.length === vertices.length, hasSkinWeights = skinWeights.length === vertices.length, i = 0; i < faces.length; i++) {
                var face = faces[i];
                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                var vertexNormals = face.vertexNormals;
                if (3 === vertexNormals.length) this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]); else {
                    var normal = face.normal;
                    this.normals.push(normal, normal, normal);
                }
                var vertexColors = face.vertexColors;
                if (3 === vertexColors.length) this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]); else {
                    var color = face.color;
                    this.colors.push(color, color, color);
                }
                if (!0 === hasFaceVertexUv) {
                    var vertexUvs = faceVertexUvs[0][i];
                    void 0 !== vertexUvs ? this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i), 
                    this.uvs.push(new Vector2(), new Vector2(), new Vector2()));
                }
                if (!0 === hasFaceVertexUv2) {
                    var vertexUvs = faceVertexUvs[1][i];
                    void 0 !== vertexUvs ? this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i), 
                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2()));
                }
                for (var j = 0; j < morphTargetsLength; j++) {
                    var morphTarget = morphTargets[j].vertices;
                    morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }
                for (var j = 0; j < morphNormalsLength; j++) {
                    var morphNormal = morphNormals[j].vertexNormals[i];
                    morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }
                hasSkinIndices && this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]), 
                hasSkinWeights && this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
            }
            return this.computeGroups(geometry), this.verticesNeedUpdate = geometry.verticesNeedUpdate, 
            this.normalsNeedUpdate = geometry.normalsNeedUpdate, this.colorsNeedUpdate = geometry.colorsNeedUpdate, 
            this.uvsNeedUpdate = geometry.uvsNeedUpdate, this.groupsNeedUpdate = geometry.groupsNeedUpdate, 
            this;
        }
    }), BufferGeometry.MaxIndex = 65535, Object.assign(BufferGeometry.prototype, EventDispatcher.prototype, {
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index;
        },
        setIndex: function(index) {
            Array.isArray(index) ? this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1) : this.index = index;
        },
        addAttribute: function(name, attribute) {
            return attribute && attribute.isBufferAttribute || attribute && attribute.isInterleavedBufferAttribute ? "index" === name ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), 
            void this.setIndex(attribute)) : (this.attributes[name] = attribute, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), 
            void this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2])));
        },
        getAttribute: function(name) {
            return this.attributes[name];
        },
        removeAttribute: function(name) {
            return delete this.attributes[name], this;
        },
        addGroup: function(start, count, materialIndex) {
            this.groups.push({
                start: start,
                count: count,
                materialIndex: void 0 !== materialIndex ? materialIndex : 0
            });
        },
        clearGroups: function() {
            this.groups = [];
        },
        setDrawRange: function(start, count) {
            this.drawRange.start = start, this.drawRange.count = count;
        },
        applyMatrix: function(matrix) {
            var position = this.attributes.position;
            void 0 !== position && (matrix.applyToBufferAttribute(position), position.needsUpdate = !0);
            var normal = this.attributes.normal;
            if (void 0 !== normal) {
                new Matrix3().getNormalMatrix(matrix).applyToBufferAttribute(normal), normal.needsUpdate = !0;
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
            this;
        },
        rotateX: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationX(angle), this.applyMatrix(m1), this;
            };
        }(),
        rotateY: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationY(angle), this.applyMatrix(m1), this;
            };
        }(),
        rotateZ: function() {
            var m1 = new Matrix4();
            return function(angle) {
                return m1.makeRotationZ(angle), this.applyMatrix(m1), this;
            };
        }(),
        translate: function() {
            var m1 = new Matrix4();
            return function(x, y, z) {
                return m1.makeTranslation(x, y, z), this.applyMatrix(m1), this;
            };
        }(),
        scale: function() {
            var m1 = new Matrix4();
            return function(x, y, z) {
                return m1.makeScale(x, y, z), this.applyMatrix(m1), this;
            };
        }(),
        lookAt: function() {
            var obj = new Object3D();
            return function(vector) {
                obj.lookAt(vector), obj.updateMatrix(), this.applyMatrix(obj.matrix);
            };
        }(),
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            return this.translate(offset.x, offset.y, offset.z), offset;
        },
        setFromObject: function(object) {
            var geometry = object.geometry;
            if (object.isPoints || object.isLine) {
                var positions = new Float32BufferAttribute(3 * geometry.vertices.length, 3), colors = new Float32BufferAttribute(3 * geometry.colors.length, 3);
                if (this.addAttribute("position", positions.copyVector3sArray(geometry.vertices)), 
                this.addAttribute("color", colors.copyColorsArray(geometry.colors)), geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                    var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                    this.addAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
                }
                null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()), 
                null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone());
            } else object.isMesh && geometry && geometry.isGeometry && this.fromGeometry(geometry);
            return this;
        },
        updateFromObject: function(object) {
            var geometry = object.geometry;
            if (object.isMesh) {
                var direct = geometry.__directGeometry;
                if (!0 === geometry.elementsNeedUpdate && (direct = void 0, geometry.elementsNeedUpdate = !1), 
                void 0 === direct) return this.fromGeometry(geometry);
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate, direct.normalsNeedUpdate = geometry.normalsNeedUpdate, 
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate, direct.uvsNeedUpdate = geometry.uvsNeedUpdate, 
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate, geometry.verticesNeedUpdate = !1, 
                geometry.normalsNeedUpdate = !1, geometry.colorsNeedUpdate = !1, geometry.uvsNeedUpdate = !1, 
                geometry.groupsNeedUpdate = !1, geometry = direct;
            }
            var attribute;
            return !0 === geometry.verticesNeedUpdate && (attribute = this.attributes.position, 
            void 0 !== attribute && (attribute.copyVector3sArray(geometry.vertices), attribute.needsUpdate = !0), 
            geometry.verticesNeedUpdate = !1), !0 === geometry.normalsNeedUpdate && (attribute = this.attributes.normal, 
            void 0 !== attribute && (attribute.copyVector3sArray(geometry.normals), attribute.needsUpdate = !0), 
            geometry.normalsNeedUpdate = !1), !0 === geometry.colorsNeedUpdate && (attribute = this.attributes.color, 
            void 0 !== attribute && (attribute.copyColorsArray(geometry.colors), attribute.needsUpdate = !0), 
            geometry.colorsNeedUpdate = !1), geometry.uvsNeedUpdate && (attribute = this.attributes.uv, 
            void 0 !== attribute && (attribute.copyVector2sArray(geometry.uvs), attribute.needsUpdate = !0), 
            geometry.uvsNeedUpdate = !1), geometry.lineDistancesNeedUpdate && (attribute = this.attributes.lineDistance, 
            void 0 !== attribute && (attribute.copyArray(geometry.lineDistances), attribute.needsUpdate = !0), 
            geometry.lineDistancesNeedUpdate = !1), geometry.groupsNeedUpdate && (geometry.computeGroups(object.geometry), 
            this.groups = geometry.groups, geometry.groupsNeedUpdate = !1), this;
        },
        fromGeometry: function(geometry) {
            return geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry), 
            this.fromDirectGeometry(geometry.__directGeometry);
        },
        fromDirectGeometry: function(geometry) {
            var positions = new Float32Array(3 * geometry.vertices.length);
            if (this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices)), 
            geometry.normals.length > 0) {
                var normals = new Float32Array(3 * geometry.normals.length);
                this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
            }
            if (geometry.colors.length > 0) {
                var colors = new Float32Array(3 * geometry.colors.length);
                this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
            }
            if (geometry.uvs.length > 0) {
                var uvs = new Float32Array(2 * geometry.uvs.length);
                this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
            }
            if (geometry.uvs2.length > 0) {
                var uvs2 = new Float32Array(2 * geometry.uvs2.length);
                this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
            }
            if (geometry.indices.length > 0) {
                var TypeArray = arrayMax(geometry.indices) > 65535 ? Uint32Array : Uint16Array, indices = new TypeArray(3 * geometry.indices.length);
                this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
            }
            this.groups = geometry.groups;
            for (var name in geometry.morphTargets) {
                for (var array = [], morphTargets = geometry.morphTargets[name], i = 0, l = morphTargets.length; i < l; i++) {
                    var morphTarget = morphTargets[i], attribute = new Float32BufferAttribute(3 * morphTarget.length, 3);
                    array.push(attribute.copyVector3sArray(morphTarget));
                }
                this.morphAttributes[name] = array;
            }
            if (geometry.skinIndices.length > 0) {
                var skinIndices = new Float32BufferAttribute(4 * geometry.skinIndices.length, 4);
                this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
            }
            if (geometry.skinWeights.length > 0) {
                var skinWeights = new Float32BufferAttribute(4 * geometry.skinWeights.length, 4);
                this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
            }
            return null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()), 
            null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone()), 
            this;
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Box3());
            var position = this.attributes.position;
            void 0 !== position ? this.boundingBox.setFromBufferAttribute(position) : this.boundingBox.makeEmpty(), 
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        },
        computeBoundingSphere: function() {
            var box = new Box3(), vector = new Vector3();
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new Sphere());
                var position = this.attributes.position;
                if (position) {
                    var center = this.boundingSphere.center;
                    box.setFromBufferAttribute(position), box.getCenter(center);
                    for (var maxRadiusSq = 0, i = 0, il = position.count; i < il; i++) vector.x = position.getX(i), 
                    vector.y = position.getY(i), vector.z = position.getZ(i), maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            };
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var index = this.index, attributes = this.attributes, groups = this.groups;
            if (attributes.position) {
                var positions = attributes.position.array;
                if (void 0 === attributes.normal) this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3)); else for (var array = attributes.normal.array, i = 0, il = array.length; i < il; i++) array[i] = 0;
                var vA, vB, vC, normals = attributes.normal.array, pA = new Vector3(), pB = new Vector3(), pC = new Vector3(), cb = new Vector3(), ab = new Vector3();
                if (index) {
                    var indices = index.array;
                    0 === groups.length && this.addGroup(0, indices.length);
                    for (var j = 0, jl = groups.length; j < jl; ++j) for (var group = groups[j], start = group.start, count = group.count, i = start, il = start + count; i < il; i += 3) vA = 3 * indices[i + 0], 
                    vB = 3 * indices[i + 1], vC = 3 * indices[i + 2], pA.fromArray(positions, vA), pB.fromArray(positions, vB), 
                    pC.fromArray(positions, vC), cb.subVectors(pC, pB), ab.subVectors(pA, pB), cb.cross(ab), 
                    normals[vA] += cb.x, normals[vA + 1] += cb.y, normals[vA + 2] += cb.z, normals[vB] += cb.x, 
                    normals[vB + 1] += cb.y, normals[vB + 2] += cb.z, normals[vC] += cb.x, normals[vC + 1] += cb.y, 
                    normals[vC + 2] += cb.z;
                } else for (var i = 0, il = positions.length; i < il; i += 9) pA.fromArray(positions, i), 
                pB.fromArray(positions, i + 3), pC.fromArray(positions, i + 6), cb.subVectors(pC, pB), 
                ab.subVectors(pA, pB), cb.cross(ab), normals[i] = cb.x, normals[i + 1] = cb.y, normals[i + 2] = cb.z, 
                normals[i + 3] = cb.x, normals[i + 4] = cb.y, normals[i + 5] = cb.z, normals[i + 6] = cb.x, 
                normals[i + 7] = cb.y, normals[i + 8] = cb.z;
                this.normalizeNormals(), attributes.normal.needsUpdate = !0;
            }
        },
        merge: function(geometry, offset) {
            if (!geometry || !geometry.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            void 0 === offset && (offset = 0);
            var attributes = this.attributes;
            for (var key in attributes) if (void 0 !== geometry.attributes[key]) for (var attribute1 = attributes[key], attributeArray1 = attribute1.array, attribute2 = geometry.attributes[key], attributeArray2 = attribute2.array, attributeSize = attribute2.itemSize, i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, 
            j++) attributeArray1[j] = attributeArray2[i];
            return this;
        },
        normalizeNormals: function() {
            var vector = new Vector3();
            return function() {
                for (var normals = this.attributes.normal, i = 0, il = normals.count; i < il; i++) vector.x = normals.getX(i), 
                vector.y = normals.getY(i), vector.z = normals.getZ(i), vector.normalize(), normals.setXYZ(i, vector.x, vector.y, vector.z);
            };
        }(),
        toNonIndexed: function() {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), 
            this;
            var geometry2 = new BufferGeometry(), indices = this.index.array, attributes = this.attributes;
            for (var name in attributes) {
                for (var attribute = attributes[name], array = attribute.array, itemSize = attribute.itemSize, array2 = new array.constructor(indices.length * itemSize), index = 0, index2 = 0, i = 0, l = indices.length; i < l; i++) {
                    index = indices[i] * itemSize;
                    for (var j = 0; j < itemSize; j++) array2[index2++] = array[index++];
                }
                geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
            }
            return geometry2;
        },
        toJSON: function() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), 
            void 0 !== this.parameters) {
                var parameters = this.parameters;
                for (var key in parameters) void 0 !== parameters[key] && (data[key] = parameters[key]);
                return data;
            }
            data.data = {
                attributes: {}
            };
            var index = this.index;
            if (null !== index) {
                var array = Array.prototype.slice.call(index.array);
                data.data.index = {
                    type: index.array.constructor.name,
                    array: array
                };
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                var attribute = attributes[key], array = Array.prototype.slice.call(attribute.array);
                data.data.attributes[key] = {
                    itemSize: attribute.itemSize,
                    type: attribute.array.constructor.name,
                    array: array,
                    normalized: attribute.normalized
                };
            }
            var groups = this.groups;
            groups.length > 0 && (data.data.groups = JSON.parse(JSON.stringify(groups)));
            var boundingSphere = this.boundingSphere;
            return null !== boundingSphere && (data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            }), data;
        },
        clone: function() {
            return new BufferGeometry().copy(this);
        },
        copy: function(source) {
            var name, i, l;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], 
            this.boundingBox = null, this.boundingSphere = null, this.name = source.name;
            var index = source.index;
            null !== index && this.setIndex(index.clone());
            var attributes = source.attributes;
            for (name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            var morphAttributes = source.morphAttributes;
            for (name in morphAttributes) {
                var array = [], morphAttribute = morphAttributes[name];
                for (i = 0, l = morphAttribute.length; i < l; i++) array.push(morphAttribute[i].clone());
                this.morphAttributes[name] = array;
            }
            var groups = source.groups;
            for (i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            var boundingBox = source.boundingBox;
            null !== boundingBox && (this.boundingBox = boundingBox.clone());
            var boundingSphere = source.boundingSphere;
            return null !== boundingSphere && (this.boundingSphere = boundingSphere.clone()), 
            this.drawRange.start = source.drawRange.start, this.drawRange.count = source.drawRange.count, 
            this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), BoxGeometry.prototype = Object.create(Geometry.prototype), BoxGeometry.prototype.constructor = BoxGeometry, 
    BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype), BoxBufferGeometry.prototype.constructor = BoxBufferGeometry, 
    PlaneGeometry.prototype = Object.create(Geometry.prototype), PlaneGeometry.prototype.constructor = PlaneGeometry, 
    PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype), PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry, 
    MeshBasicMaterial.prototype = Object.create(Material.prototype), MeshBasicMaterial.prototype.constructor = MeshBasicMaterial, 
    MeshBasicMaterial.prototype.isMeshBasicMaterial = !0, MeshBasicMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, 
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.specularMap = source.specularMap, 
        this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, 
        this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, 
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, 
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this;
    }, Object.assign(Ray.prototype, {
        set: function(origin, direction) {
            return this.origin.copy(origin), this.direction.copy(direction), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(ray) {
            return this.origin.copy(ray.origin), this.direction.copy(ray.direction), this;
        },
        at: function(t, optionalTarget) {
            return (optionalTarget || new Vector3()).copy(this.direction).multiplyScalar(t).add(this.origin);
        },
        lookAt: function(v) {
            return this.direction.copy(v).sub(this.origin).normalize(), this;
        },
        recast: function() {
            var v1 = new Vector3();
            return function(t) {
                return this.origin.copy(this.at(t, v1)), this;
            };
        }(),
        closestPointToPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            result.subVectors(point, this.origin);
            var directionDistance = result.dot(this.direction);
            return directionDistance < 0 ? result.copy(this.origin) : result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        },
        distanceToPoint: function(point) {
            return Math.sqrt(this.distanceSqToPoint(point));
        },
        distanceSqToPoint: function() {
            var v1 = new Vector3();
            return function(point) {
                var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                return directionDistance < 0 ? this.origin.distanceToSquared(point) : (v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin), 
                v1.distanceToSquared(point));
            };
        }(),
        distanceSqToSegment: function() {
            var segCenter = new Vector3(), segDir = new Vector3(), diff = new Vector3();
            return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                segCenter.copy(v0).add(v1).multiplyScalar(.5), segDir.copy(v1).sub(v0).normalize(), 
                diff.copy(this.origin).sub(segCenter);
                var s0, s1, sqrDist, extDet, segExtent = .5 * v0.distanceTo(v1), a01 = -this.direction.dot(segDir), b0 = diff.dot(this.direction), b1 = -diff.dot(segDir), c = diff.lengthSq(), det = Math.abs(1 - a01 * a01);
                if (det > 0) if (s0 = a01 * b1 - b0, s1 = a01 * b0 - b1, extDet = segExtent * det, 
                s0 >= 0) if (s1 >= -extDet) if (s1 <= extDet) {
                    var invDet = 1 / det;
                    s0 *= invDet, s1 *= invDet, sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else s1 = segExtent, s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c; else s1 = -segExtent, 
                s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c; else s1 <= -extDet ? (s0 = Math.max(0, -(-a01 * segExtent + b0)), 
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c) : s1 <= extDet ? (s0 = 0, 
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = s1 * (s1 + 2 * b1) + c) : (s0 = Math.max(0, -(a01 * segExtent + b0)), 
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c); else s1 = a01 > 0 ? -segExtent : segExtent, 
                s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                return optionalPointOnRay && optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin), 
                optionalPointOnSegment && optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter), 
                sqrDist;
            };
        }(),
        intersectSphere: function() {
            var v1 = new Vector3();
            return function(sphere, optionalTarget) {
                v1.subVectors(sphere.center, this.origin);
                var tca = v1.dot(this.direction), d2 = v1.dot(v1) - tca * tca, radius2 = sphere.radius * sphere.radius;
                if (d2 > radius2) return null;
                var thc = Math.sqrt(radius2 - d2), t0 = tca - thc, t1 = tca + thc;
                return t0 < 0 && t1 < 0 ? null : t0 < 0 ? this.at(t1, optionalTarget) : this.at(t0, optionalTarget);
            };
        }(),
        intersectsSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) <= sphere.radius;
        },
        distanceToPlane: function(plane) {
            var denominator = plane.normal.dot(this.direction);
            if (0 === denominator) return 0 === plane.distanceToPoint(this.origin) ? 0 : null;
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
            return t >= 0 ? t : null;
        },
        intersectPlane: function(plane, optionalTarget) {
            var t = this.distanceToPlane(plane);
            return null === t ? null : this.at(t, optionalTarget);
        },
        intersectsPlane: function(plane) {
            var distToPoint = plane.distanceToPoint(this.origin);
            return 0 === distToPoint || plane.normal.dot(this.direction) * distToPoint < 0;
        },
        intersectBox: function(box, optionalTarget) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax, invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z, origin = this.origin;
            return invdirx >= 0 ? (tmin = (box.min.x - origin.x) * invdirx, tmax = (box.max.x - origin.x) * invdirx) : (tmin = (box.max.x - origin.x) * invdirx, 
            tmax = (box.min.x - origin.x) * invdirx), invdiry >= 0 ? (tymin = (box.min.y - origin.y) * invdiry, 
            tymax = (box.max.y - origin.y) * invdiry) : (tymin = (box.max.y - origin.y) * invdiry, 
            tymax = (box.min.y - origin.y) * invdiry), tmin > tymax || tymin > tmax ? null : ((tymin > tmin || tmin !== tmin) && (tmin = tymin), 
            (tymax < tmax || tmax !== tmax) && (tmax = tymax), invdirz >= 0 ? (tzmin = (box.min.z - origin.z) * invdirz, 
            tzmax = (box.max.z - origin.z) * invdirz) : (tzmin = (box.max.z - origin.z) * invdirz, 
            tzmax = (box.min.z - origin.z) * invdirz), tmin > tzmax || tzmin > tmax ? null : ((tzmin > tmin || tmin !== tmin) && (tmin = tzmin), 
            (tzmax < tmax || tmax !== tmax) && (tmax = tzmax), tmax < 0 ? null : this.at(tmin >= 0 ? tmin : tmax, optionalTarget)));
        },
        intersectsBox: function() {
            var v = new Vector3();
            return function(box) {
                return null !== this.intersectBox(box, v);
            };
        }(),
        intersectTriangle: function() {
            var diff = new Vector3(), edge1 = new Vector3(), edge2 = new Vector3(), normal = new Vector3();
            return function(a, b, c, backfaceCulling, optionalTarget) {
                edge1.subVectors(b, a), edge2.subVectors(c, a), normal.crossVectors(edge1, edge2);
                var sign, DdN = this.direction.dot(normal);
                if (DdN > 0) {
                    if (backfaceCulling) return null;
                    sign = 1;
                } else {
                    if (!(DdN < 0)) return null;
                    sign = -1, DdN = -DdN;
                }
                diff.subVectors(this.origin, a);
                var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                if (DdQxE2 < 0) return null;
                var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                if (DdE1xQ < 0) return null;
                if (DdQxE2 + DdE1xQ > DdN) return null;
                var QdN = -sign * diff.dot(normal);
                return QdN < 0 ? null : this.at(QdN / DdN, optionalTarget);
            };
        }(),
        applyMatrix4: function(matrix4) {
            return this.origin.applyMatrix4(matrix4), this.direction.transformDirection(matrix4), 
            this;
        },
        equals: function(ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
    }), Object.assign(Line3.prototype, {
        set: function(start, end) {
            return this.start.copy(start), this.end.copy(end), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(line) {
            return this.start.copy(line.start), this.end.copy(line.end), this;
        },
        getCenter: function(optionalTarget) {
            return (optionalTarget || new Vector3()).addVectors(this.start, this.end).multiplyScalar(.5);
        },
        delta: function(optionalTarget) {
            return (optionalTarget || new Vector3()).subVectors(this.end, this.start);
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end);
        },
        distance: function() {
            return this.start.distanceTo(this.end);
        },
        at: function(t, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        closestPointToPointParameter: function() {
            var startP = new Vector3(), startEnd = new Vector3();
            return function(point, clampToLine) {
                startP.subVectors(point, this.start), startEnd.subVectors(this.end, this.start);
                var startEnd2 = startEnd.dot(startEnd), startEnd_startP = startEnd.dot(startP), t = startEnd_startP / startEnd2;
                return clampToLine && (t = _Math.clamp(t, 0, 1)), t;
            };
        }(),
        closestPointToPoint: function(point, clampToLine, optionalTarget) {
            var t = this.closestPointToPointParameter(point, clampToLine), result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        applyMatrix4: function(matrix) {
            return this.start.applyMatrix4(matrix), this.end.applyMatrix4(matrix), this;
        },
        equals: function(line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        }
    }), Object.assign(Triangle, {
        normal: function() {
            var v0 = new Vector3();
            return function(a, b, c, optionalTarget) {
                var result = optionalTarget || new Vector3();
                result.subVectors(c, b), v0.subVectors(a, b), result.cross(v0);
                var resultLengthSq = result.lengthSq();
                return resultLengthSq > 0 ? result.multiplyScalar(1 / Math.sqrt(resultLengthSq)) : result.set(0, 0, 0);
            };
        }(),
        barycoordFromPoint: function() {
            var v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3();
            return function(point, a, b, c, optionalTarget) {
                v0.subVectors(c, a), v1.subVectors(b, a), v2.subVectors(point, a);
                var dot00 = v0.dot(v0), dot01 = v0.dot(v1), dot02 = v0.dot(v2), dot11 = v1.dot(v1), dot12 = v1.dot(v2), denom = dot00 * dot11 - dot01 * dot01, result = optionalTarget || new Vector3();
                if (0 === denom) return result.set(-2, -1, -1);
                var invDenom = 1 / denom, u = (dot11 * dot02 - dot01 * dot12) * invDenom, v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                return result.set(1 - u - v, v, u);
            };
        }(),
        containsPoint: function() {
            var v1 = new Vector3();
            return function(point, a, b, c) {
                var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
                return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
            };
        }()
    }), Object.assign(Triangle.prototype, {
        set: function(a, b, c) {
            return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
        },
        setFromPointsAndIndices: function(points, i0, i1, i2) {
            return this.a.copy(points[i0]), this.b.copy(points[i1]), this.c.copy(points[i2]), 
            this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(triangle) {
            return this.a.copy(triangle.a), this.b.copy(triangle.b), this.c.copy(triangle.c), 
            this;
        },
        area: function() {
            var v0 = new Vector3(), v1 = new Vector3();
            return function() {
                return v0.subVectors(this.c, this.b), v1.subVectors(this.a, this.b), .5 * v0.cross(v1).length();
            };
        }(),
        midpoint: function(optionalTarget) {
            return (optionalTarget || new Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        },
        normal: function(optionalTarget) {
            return Triangle.normal(this.a, this.b, this.c, optionalTarget);
        },
        plane: function(optionalTarget) {
            return (optionalTarget || new Plane()).setFromCoplanarPoints(this.a, this.b, this.c);
        },
        barycoordFromPoint: function(point, optionalTarget) {
            return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
        },
        containsPoint: function(point) {
            return Triangle.containsPoint(point, this.a, this.b, this.c);
        },
        closestPointToPoint: function() {
            var plane = new Plane(), edgeList = [ new Line3(), new Line3(), new Line3() ], projectedPoint = new Vector3(), closestPoint = new Vector3();
            return function(point, optionalTarget) {
                var result = optionalTarget || new Vector3(), minDistance = 1 / 0;
                if (plane.setFromCoplanarPoints(this.a, this.b, this.c), plane.projectPoint(point, projectedPoint), 
                !0 === this.containsPoint(projectedPoint)) result.copy(projectedPoint); else {
                    edgeList[0].set(this.a, this.b), edgeList[1].set(this.b, this.c), edgeList[2].set(this.c, this.a);
                    for (var i = 0; i < edgeList.length; i++) {
                        edgeList[i].closestPointToPoint(projectedPoint, !0, closestPoint);
                        var distance = projectedPoint.distanceToSquared(closestPoint);
                        distance < minDistance && (minDistance = distance, result.copy(closestPoint));
                    }
                }
                return result;
            };
        }(),
        equals: function(triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
    }), Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Mesh,
        isMesh: !0,
        setDrawMode: function(value) {
            this.drawMode = value;
        },
        copy: function(source) {
            return Object3D.prototype.copy.call(this, source), this.drawMode = source.drawMode, 
            this;
        },
        updateMorphTargets: function() {
            var m, ml, name, geometry = this.geometry;
            if (geometry.isBufferGeometry) {
                var morphAttributes = geometry.morphAttributes, keys = Object.keys(morphAttributes);
                if (keys.length > 0) {
                    var morphAttribute = morphAttributes[keys[0]];
                    if (void 0 !== morphAttribute) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, 
                    m = 0, ml = morphAttribute.length; m < ml; m++) name = morphAttribute[m].name || String(m), 
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m;
                }
            } else {
                var morphTargets = geometry.morphTargets;
                if (void 0 !== morphTargets && morphTargets.length > 0) for (this.morphTargetInfluences = [], 
                this.morphTargetDictionary = {}, m = 0, ml = morphTargets.length; m < ml; m++) name = morphTargets[m].name || String(m), 
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m;
            }
        },
        raycast: function() {
            function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                return Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord), uv1.multiplyScalar(barycoord.x), 
                uv2.multiplyScalar(barycoord.y), uv3.multiplyScalar(barycoord.z), uv1.add(uv2).add(uv3), 
                uv1.clone();
            }
            function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
                if (null === (material.side === BackSide ? ray.intersectTriangle(pC, pB, pA, !0, point) : ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point))) return null;
                intersectionPointWorld.copy(point), intersectionPointWorld.applyMatrix4(object.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                return distance < raycaster.near || distance > raycaster.far ? null : {
                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    object: object
                };
            }
            function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
                vA.fromBufferAttribute(position, a), vB.fromBufferAttribute(position, b), vC.fromBufferAttribute(position, c);
                var intersection = checkIntersection(object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint);
                return intersection && (uv && (uvA.fromBufferAttribute(uv, a), uvB.fromBufferAttribute(uv, b), 
                uvC.fromBufferAttribute(uv, c), intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC)), 
                intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC)), intersection.faceIndex = a), 
                intersection;
            }
            var inverseMatrix = new Matrix4(), ray = new Ray(), sphere = new Sphere(), vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), tempA = new Vector3(), tempB = new Vector3(), tempC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), barycoord = new Vector3(), intersectionPoint = new Vector3(), intersectionPointWorld = new Vector3();
            return function(raycaster, intersects) {
                var geometry = this.geometry, material = this.material, matrixWorld = this.matrixWorld;
                if (void 0 !== material && (null === geometry.boundingSphere && geometry.computeBoundingSphere(), 
                sphere.copy(geometry.boundingSphere), sphere.applyMatrix4(matrixWorld), !1 !== raycaster.ray.intersectsSphere(sphere) && (inverseMatrix.getInverse(matrixWorld), 
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix), null === geometry.boundingBox || !1 !== ray.intersectsBox(geometry.boundingBox)))) {
                    var intersection;
                    if (geometry.isBufferGeometry) {
                        var a, b, c, i, l, index = geometry.index, position = geometry.attributes.position, uv = geometry.attributes.uv;
                        if (null !== index) for (i = 0, l = index.count; i < l; i += 3) a = index.getX(i), 
                        b = index.getX(i + 1), c = index.getX(i + 2), (intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c)) && (intersection.faceIndex = Math.floor(i / 3), 
                        intersects.push(intersection)); else for (i = 0, l = position.count; i < l; i += 3) a = i, 
                        b = i + 1, c = i + 2, (intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c)) && (intersection.index = a, 
                        intersects.push(intersection));
                    } else if (geometry.isGeometry) {
                        var fvA, fvB, fvC, uvs, isMultiMaterial = Array.isArray(material), vertices = geometry.vertices, faces = geometry.faces, faceVertexUvs = geometry.faceVertexUvs[0];
                        faceVertexUvs.length > 0 && (uvs = faceVertexUvs);
                        for (var f = 0, fl = faces.length; f < fl; f++) {
                            var face = faces[f], faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                            if (void 0 !== faceMaterial) {
                                if (fvA = vertices[face.a], fvB = vertices[face.b], fvC = vertices[face.c], !0 === faceMaterial.morphTargets) {
                                    var morphTargets = geometry.morphTargets, morphInfluences = this.morphTargetInfluences;
                                    vA.set(0, 0, 0), vB.set(0, 0, 0), vC.set(0, 0, 0);
                                    for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                        var influence = morphInfluences[t];
                                        if (0 !== influence) {
                                            var targets = morphTargets[t].vertices;
                                            vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence), vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence), 
                                            vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                                        }
                                    }
                                    vA.add(fvA), vB.add(fvB), vC.add(fvC), fvA = vA, fvB = vB, fvC = vC;
                                }
                                if (intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint)) {
                                    if (uvs && uvs[f]) {
                                        var uvs_f = uvs[f];
                                        uvA.copy(uvs_f[0]), uvB.copy(uvs_f[1]), uvC.copy(uvs_f[2]), intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                                    }
                                    intersection.face = face, intersection.faceIndex = f, intersects.push(intersection);
                                }
                            }
                        }
                    }
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });
    var programIdCount = 0;
    ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
        constructor: ArrayCamera,
        isArrayCamera: !0
    }), FogExp2.prototype.isFogExp2 = !0, FogExp2.prototype.clone = function() {
        return new FogExp2(this.color.getHex(), this.density);
    }, FogExp2.prototype.toJSON = function(meta) {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        };
    }, Fog.prototype.isFog = !0, Fog.prototype.clone = function() {
        return new Fog(this.color.getHex(), this.near, this.far);
    }, Fog.prototype.toJSON = function(meta) {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }, Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Scene,
        copy: function(source, recursive) {
            return Object3D.prototype.copy.call(this, source, recursive), null !== source.background && (this.background = source.background.clone()), 
            null !== source.fog && (this.fog = source.fog.clone()), null !== source.overrideMaterial && (this.overrideMaterial = source.overrideMaterial.clone()), 
            this.autoUpdate = source.autoUpdate, this.matrixAutoUpdate = source.matrixAutoUpdate, 
            this;
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return null !== this.background && (data.object.background = this.background.toJSON(meta)), 
            null !== this.fog && (data.object.fog = this.fog.toJSON()), data;
        }
    }), LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LensFlare,
        isLensFlare: !0,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source), this.positionScreen.copy(source.positionScreen), 
            this.customUpdateCallback = source.customUpdateCallback;
            for (var i = 0, l = source.lensFlares.length; i < l; i++) this.lensFlares.push(source.lensFlares[i]);
            return this;
        },
        add: function(texture, size, distance, blending, color, opacity) {
            void 0 === size && (size = -1), void 0 === distance && (distance = 0), void 0 === opacity && (opacity = 1), 
            void 0 === color && (color = new Color(16777215)), void 0 === blending && (blending = NormalBlending), 
            distance = Math.min(distance, Math.max(0, distance)), this.lensFlares.push({
                texture: texture,
                size: size,
                distance: distance,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: opacity,
                color: color,
                blending: blending
            });
        },
        updateLensFlares: function() {
            var f, flare, fl = this.lensFlares.length, vecX = 2 * -this.positionScreen.x, vecY = 2 * -this.positionScreen.y;
            for (f = 0; f < fl; f++) flare = this.lensFlares[f], flare.x = this.positionScreen.x + vecX * flare.distance, 
            flare.y = this.positionScreen.y + vecY * flare.distance, flare.wantedRotation = flare.x * Math.PI * .25, 
            flare.rotation += .25 * (flare.wantedRotation - flare.rotation);
        }
    }), SpriteMaterial.prototype = Object.create(Material.prototype), SpriteMaterial.prototype.constructor = SpriteMaterial, 
    SpriteMaterial.prototype.isSpriteMaterial = !0, SpriteMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.map = source.map, this.rotation = source.rotation, this;
    }, Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Sprite,
        isSprite: !0,
        raycast: function() {
            var intersectPoint = new Vector3(), worldPosition = new Vector3(), worldScale = new Vector3();
            return function(raycaster, intersects) {
                worldPosition.setFromMatrixPosition(this.matrixWorld), raycaster.ray.closestPointToPoint(worldPosition, intersectPoint), 
                worldScale.setFromMatrixScale(this.matrixWorld);
                var guessSizeSq = worldScale.x * worldScale.y / 4;
                if (!(worldPosition.distanceToSquared(intersectPoint) > guessSizeSq)) {
                    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                    distance < raycaster.near || distance > raycaster.far || intersects.push({
                        distance: distance,
                        point: intersectPoint.clone(),
                        face: null,
                        object: this
                    });
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this);
        }
    }), LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LOD,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source, !1);
            for (var levels = source.levels, i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance);
            }
            return this;
        },
        addLevel: function(object, distance) {
            void 0 === distance && (distance = 0), distance = Math.abs(distance);
            for (var levels = this.levels, l = 0; l < levels.length && !(distance < levels[l].distance); l++) ;
            levels.splice(l, 0, {
                distance: distance,
                object: object
            }), this.add(object);
        },
        getObjectForDistance: function(distance) {
            for (var levels = this.levels, i = 1, l = levels.length; i < l && !(distance < levels[i].distance); i++) ;
            return levels[i - 1].object;
        },
        raycast: function() {
            var matrixPosition = new Vector3();
            return function(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(matrixPosition);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
            };
        }(),
        update: function() {
            var v1 = new Vector3(), v2 = new Vector3();
            return function(camera) {
                var levels = this.levels;
                if (levels.length > 1) {
                    v1.setFromMatrixPosition(camera.matrixWorld), v2.setFromMatrixPosition(this.matrixWorld);
                    var distance = v1.distanceTo(v2);
                    levels[0].object.visible = !0;
                    for (var i = 1, l = levels.length; i < l && distance >= levels[i].distance; i++) levels[i - 1].object.visible = !1, 
                    levels[i].object.visible = !0;
                    for (;i < l; i++) levels[i].object.visible = !1;
                }
            };
        }(),
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.levels = [];
            for (var levels = this.levels, i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }
            return data;
        }
    }), Object.assign(Skeleton.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var i = 0, il = this.bones.length; i < il; i++) {
                var inverse = new Matrix4();
                this.bones[i] && inverse.getInverse(this.bones[i].matrixWorld), this.boneInverses.push(inverse);
            }
        },
        pose: function() {
            var bone, i, il;
            for (i = 0, il = this.bones.length; i < il; i++) (bone = this.bones[i]) && bone.matrixWorld.getInverse(this.boneInverses[i]);
            for (i = 0, il = this.bones.length; i < il; i++) (bone = this.bones[i]) && (bone.parent && bone.parent.isBone ? (bone.matrix.getInverse(bone.parent.matrixWorld), 
            bone.matrix.multiply(bone.matrixWorld)) : bone.matrix.copy(bone.matrixWorld), bone.matrix.decompose(bone.position, bone.quaternion, bone.scale));
        },
        update: function() {
            var offsetMatrix = new Matrix4(), identityMatrix = new Matrix4();
            return function() {
                for (var bones = this.bones, boneInverses = this.boneInverses, boneMatrices = this.boneMatrices, boneTexture = this.boneTexture, i = 0, il = bones.length; i < il; i++) {
                    var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;
                    offsetMatrix.multiplyMatrices(matrix, boneInverses[i]), offsetMatrix.toArray(boneMatrices, 16 * i);
                }
                void 0 !== boneTexture && (boneTexture.needsUpdate = !0);
            };
        }(),
        clone: function() {
            return new Skeleton(this.bones, this.boneInverses);
        }
    }), Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Bone,
        isBone: !0
    }), SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
        constructor: SkinnedMesh,
        isSkinnedMesh: !0,
        initBones: function() {
            var bone, gbone, i, il, bones = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (i = 0, il = this.geometry.bones.length; i < il; i++) gbone = this.geometry.bones[i], 
                bone = new Bone(), bones.push(bone), bone.name = gbone.name, bone.position.fromArray(gbone.pos), 
                bone.quaternion.fromArray(gbone.rotq), void 0 !== gbone.scl && bone.scale.fromArray(gbone.scl);
                for (i = 0, il = this.geometry.bones.length; i < il; i++) gbone = this.geometry.bones[i], 
                -1 !== gbone.parent && null !== gbone.parent && void 0 !== bones[gbone.parent] ? bones[gbone.parent].add(bones[i]) : this.add(bones[i]);
            }
            return this.updateMatrixWorld(!0), bones;
        },
        bind: function(skeleton, bindMatrix) {
            this.skeleton = skeleton, void 0 === bindMatrix && (this.updateMatrixWorld(!0), 
            this.skeleton.calculateInverses(), bindMatrix = this.matrixWorld), this.bindMatrix.copy(bindMatrix), 
            this.bindMatrixInverse.getInverse(bindMatrix);
        },
        pose: function() {
            this.skeleton.pose();
        },
        normalizeSkinWeights: function() {
            var scale, i;
            if (this.geometry && this.geometry.isGeometry) for (i = 0; i < this.geometry.skinWeights.length; i++) {
                var sw = this.geometry.skinWeights[i];
                scale = 1 / sw.lengthManhattan(), scale !== 1 / 0 ? sw.multiplyScalar(scale) : sw.set(1, 0, 0, 0);
            } else if (this.geometry && this.geometry.isBufferGeometry) {
                var vec = new Vector4(), skinWeight = this.geometry.attributes.skinWeight;
                for (i = 0; i < skinWeight.count; i++) vec.x = skinWeight.getX(i), vec.y = skinWeight.getY(i), 
                vec.z = skinWeight.getZ(i), vec.w = skinWeight.getW(i), scale = 1 / vec.lengthManhattan(), 
                scale !== 1 / 0 ? vec.multiplyScalar(scale) : vec.set(1, 0, 0, 0), skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
            }
        },
        updateMatrixWorld: function(force) {
            Mesh.prototype.updateMatrixWorld.call(this, force), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), LineBasicMaterial.prototype = Object.create(Material.prototype), LineBasicMaterial.prototype.constructor = LineBasicMaterial, 
    LineBasicMaterial.prototype.isLineBasicMaterial = !0, LineBasicMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.linewidth = source.linewidth, this.linecap = source.linecap, this.linejoin = source.linejoin, 
        this;
    }, Line.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Line,
        isLine: !0,
        raycast: function() {
            var inverseMatrix = new Matrix4(), ray = new Ray(), sphere = new Sphere();
            return function(raycaster, intersects) {
                var precision = raycaster.linePrecision, precisionSq = precision * precision, geometry = this.geometry, matrixWorld = this.matrixWorld;
                if (null === geometry.boundingSphere && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere), 
                sphere.applyMatrix4(matrixWorld), !1 !== raycaster.ray.intersectsSphere(sphere)) {
                    inverseMatrix.getInverse(matrixWorld), ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                    var vStart = new Vector3(), vEnd = new Vector3(), interSegment = new Vector3(), interRay = new Vector3(), step = this && this.isLineSegments ? 2 : 1;
                    if (geometry.isBufferGeometry) {
                        var index = geometry.index, attributes = geometry.attributes, positions = attributes.position.array;
                        if (null !== index) for (var indices = index.array, i = 0, l = indices.length - 1; i < l; i += step) {
                            var a = indices[i], b = indices[i + 1];
                            vStart.fromArray(positions, 3 * a), vEnd.fromArray(positions, 3 * b);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (!(distSq > precisionSq)) {
                                interRay.applyMatrix4(this.matrixWorld);
                                var distance = raycaster.ray.origin.distanceTo(interRay);
                                distance < raycaster.near || distance > raycaster.far || intersects.push({
                                    distance: distance,
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                });
                            }
                        } else for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                            vStart.fromArray(positions, 3 * i), vEnd.fromArray(positions, 3 * i + 3);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (!(distSq > precisionSq)) {
                                interRay.applyMatrix4(this.matrixWorld);
                                var distance = raycaster.ray.origin.distanceTo(interRay);
                                distance < raycaster.near || distance > raycaster.far || intersects.push({
                                    distance: distance,
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                });
                            }
                        }
                    } else if (geometry.isGeometry) for (var vertices = geometry.vertices, nbVertices = vertices.length, i = 0; i < nbVertices - 1; i += step) {
                        var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                        if (!(distSq > precisionSq)) {
                            interRay.applyMatrix4(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            distance < raycaster.near || distance > raycaster.far || intersects.push({
                                distance: distance,
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    }
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineSegments,
        isLineSegments: !0
    }), LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineLoop,
        isLineLoop: !0
    }), PointsMaterial.prototype = Object.create(Material.prototype), PointsMaterial.prototype.constructor = PointsMaterial, 
    PointsMaterial.prototype.isPointsMaterial = !0, PointsMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.map = source.map, this.size = source.size, this.sizeAttenuation = source.sizeAttenuation, 
        this;
    }, Points.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Points,
        isPoints: !0,
        raycast: function() {
            var inverseMatrix = new Matrix4(), ray = new Ray(), sphere = new Sphere();
            return function(raycaster, intersects) {
                function testPoint(point, index) {
                    var rayPointDistanceSq = ray.distanceSqToPoint(point);
                    if (rayPointDistanceSq < localThresholdSq) {
                        var intersectPoint = ray.closestPointToPoint(point);
                        intersectPoint.applyMatrix4(matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far) return;
                        intersects.push({
                            distance: distance,
                            distanceToRay: Math.sqrt(rayPointDistanceSq),
                            point: intersectPoint.clone(),
                            index: index,
                            face: null,
                            object: object
                        });
                    }
                }
                var object = this, geometry = this.geometry, matrixWorld = this.matrixWorld, threshold = raycaster.params.Points.threshold;
                if (null === geometry.boundingSphere && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere), 
                sphere.applyMatrix4(matrixWorld), sphere.radius += threshold, !1 !== raycaster.ray.intersectsSphere(sphere)) {
                    inverseMatrix.getInverse(matrixWorld), ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3), localThresholdSq = localThreshold * localThreshold, position = new Vector3();
                    if (geometry.isBufferGeometry) {
                        var index = geometry.index, attributes = geometry.attributes, positions = attributes.position.array;
                        if (null !== index) for (var indices = index.array, i = 0, il = indices.length; i < il; i++) {
                            var a = indices[i];
                            position.fromArray(positions, 3 * a), testPoint(position, a);
                        } else for (var i = 0, l = positions.length / 3; i < l; i++) position.fromArray(positions, 3 * i), 
                        testPoint(position, i);
                    } else for (var vertices = geometry.vertices, i = 0, l = vertices.length; i < l; i++) testPoint(vertices[i], i);
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), Group.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Group
    }), VideoTexture.prototype = Object.create(Texture.prototype), VideoTexture.prototype.constructor = VideoTexture, 
    CompressedTexture.prototype = Object.create(Texture.prototype), CompressedTexture.prototype.constructor = CompressedTexture, 
    CompressedTexture.prototype.isCompressedTexture = !0, DepthTexture.prototype = Object.create(Texture.prototype), 
    DepthTexture.prototype.constructor = DepthTexture, DepthTexture.prototype.isDepthTexture = !0, 
    WireframeGeometry.prototype = Object.create(BufferGeometry.prototype), WireframeGeometry.prototype.constructor = WireframeGeometry, 
    ParametricGeometry.prototype = Object.create(Geometry.prototype), ParametricGeometry.prototype.constructor = ParametricGeometry, 
    ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype), ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry, 
    PolyhedronGeometry.prototype = Object.create(Geometry.prototype), PolyhedronGeometry.prototype.constructor = PolyhedronGeometry, 
    PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype), PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry, 
    TetrahedronGeometry.prototype = Object.create(Geometry.prototype), TetrahedronGeometry.prototype.constructor = TetrahedronGeometry, 
    TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype), 
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry, OctahedronGeometry.prototype = Object.create(Geometry.prototype), 
    OctahedronGeometry.prototype.constructor = OctahedronGeometry, OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype), 
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry, IcosahedronGeometry.prototype = Object.create(Geometry.prototype), 
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry, IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype), 
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry, DodecahedronGeometry.prototype = Object.create(Geometry.prototype), 
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry, DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype), 
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry, TubeGeometry.prototype = Object.create(Geometry.prototype), 
    TubeGeometry.prototype.constructor = TubeGeometry, TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype), 
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry, TorusKnotGeometry.prototype = Object.create(Geometry.prototype), 
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry, TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype), 
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry, TorusGeometry.prototype = Object.create(Geometry.prototype), 
    TorusGeometry.prototype.constructor = TorusGeometry, TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype), 
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
    var ShapeUtils = {
        area: function(contour) {
            for (var n = contour.length, a = 0, p = n - 1, q = 0; q < n; p = q++) a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            return .5 * a;
        },
        triangulate: function() {
            function snip(contour, u, v, w, n, verts) {
                var p, ax, ay, bx, by, cx, cy, px, py;
                if (ax = contour[verts[u]].x, ay = contour[verts[u]].y, bx = contour[verts[v]].x, 
                by = contour[verts[v]].y, cx = contour[verts[w]].x, cy = contour[verts[w]].y, (bx - ax) * (cy - ay) - (by - ay) * (cx - ax) <= 0) return !1;
                var aX, aY, bX, bY, cX, cY, apx, apy, bpx, bpy, cpx, cpy, cCROSSap, bCROSScp, aCROSSbp;
                for (aX = cx - bx, aY = cy - by, bX = ax - cx, bY = ay - cy, cX = bx - ax, cY = by - ay, 
                p = 0; p < n; p++) if (px = contour[verts[p]].x, py = contour[verts[p]].y, !(px === ax && py === ay || px === bx && py === by || px === cx && py === cy) && (apx = px - ax, 
                apy = py - ay, bpx = px - bx, bpy = py - by, cpx = px - cx, cpy = py - cy, aCROSSbp = aX * bpy - aY * bpx, 
                cCROSSap = cX * apy - cY * apx, bCROSScp = bX * cpy - bY * cpx, aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON)) return !1;
                return !0;
            }
            return function(contour, indices) {
                var n = contour.length;
                if (n < 3) return null;
                var u, v, w, result = [], verts = [], vertIndices = [];
                if (ShapeUtils.area(contour) > 0) for (v = 0; v < n; v++) verts[v] = v; else for (v = 0; v < n; v++) verts[v] = n - 1 - v;
                var nv = n, count = 2 * nv;
                for (v = nv - 1; nv > 2; ) {
                    if (count-- <= 0) return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"), 
                    indices ? vertIndices : result;
                    if (u = v, nv <= u && (u = 0), v = u + 1, nv <= v && (v = 0), w = v + 1, nv <= w && (w = 0), 
                    snip(contour, u, v, w, nv, verts)) {
                        var a, b, c, s, t;
                        for (a = verts[u], b = verts[v], c = verts[w], result.push([ contour[a], contour[b], contour[c] ]), 
                        vertIndices.push([ verts[u], verts[v], verts[w] ]), s = v, t = v + 1; t < nv; s++, 
                        t++) verts[s] = verts[t];
                        nv--, count = 2 * nv;
                    }
                }
                return indices ? vertIndices : result;
            };
        }(),
        triangulateShape: function(contour, holes) {
            function removeDupEndPts(points) {
                var l = points.length;
                l > 2 && points[l - 1].equals(points[0]) && points.pop();
            }
            function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
                return inSegPt1.x !== inSegPt2.x ? inSegPt1.x < inSegPt2.x ? inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x : inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x : inSegPt1.y < inSegPt2.y ? inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y : inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
            }
            function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
                var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y, seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y, seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x, seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y, limit = seg1dy * seg2dx - seg1dx * seg2dy, perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
                if (Math.abs(limit) > Number.EPSILON) {
                    var perpSeg2;
                    if (limit > 0) {
                        if (perpSeg1 < 0 || perpSeg1 > limit) return [];
                        if ((perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy) < 0 || perpSeg2 > limit) return [];
                    } else {
                        if (perpSeg1 > 0 || perpSeg1 < limit) return [];
                        if ((perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy) > 0 || perpSeg2 < limit) return [];
                    }
                    if (0 === perpSeg2) return !inExcludeAdjacentSegs || 0 !== perpSeg1 && perpSeg1 !== limit ? [ inSeg1Pt1 ] : [];
                    if (perpSeg2 === limit) return !inExcludeAdjacentSegs || 0 !== perpSeg1 && perpSeg1 !== limit ? [ inSeg1Pt2 ] : [];
                    if (0 === perpSeg1) return [ inSeg2Pt1 ];
                    if (perpSeg1 === limit) return [ inSeg2Pt2 ];
                    var factorSeg1 = perpSeg2 / limit;
                    return [ {
                        x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                        y: inSeg1Pt1.y + factorSeg1 * seg1dy
                    } ];
                }
                if (0 !== perpSeg1 || seg2dy * seg1seg2dx != seg2dx * seg1seg2dy) return [];
                var seg1Pt = 0 === seg1dx && 0 === seg1dy, seg2Pt = 0 === seg2dx && 0 === seg2dy;
                if (seg1Pt && seg2Pt) return inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y ? [] : [ inSeg1Pt1 ];
                if (seg1Pt) return point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1) ? [ inSeg1Pt1 ] : [];
                if (seg2Pt) return point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1) ? [ inSeg2Pt1 ] : [];
                var seg1min, seg1max, seg1minVal, seg1maxVal, seg2min, seg2max, seg2minVal, seg2maxVal;
                return 0 !== seg1dx ? (inSeg1Pt1.x < inSeg1Pt2.x ? (seg1min = inSeg1Pt1, seg1minVal = inSeg1Pt1.x, 
                seg1max = inSeg1Pt2, seg1maxVal = inSeg1Pt2.x) : (seg1min = inSeg1Pt2, seg1minVal = inSeg1Pt2.x, 
                seg1max = inSeg1Pt1, seg1maxVal = inSeg1Pt1.x), inSeg2Pt1.x < inSeg2Pt2.x ? (seg2min = inSeg2Pt1, 
                seg2minVal = inSeg2Pt1.x, seg2max = inSeg2Pt2, seg2maxVal = inSeg2Pt2.x) : (seg2min = inSeg2Pt2, 
                seg2minVal = inSeg2Pt2.x, seg2max = inSeg2Pt1, seg2maxVal = inSeg2Pt1.x)) : (inSeg1Pt1.y < inSeg1Pt2.y ? (seg1min = inSeg1Pt1, 
                seg1minVal = inSeg1Pt1.y, seg1max = inSeg1Pt2, seg1maxVal = inSeg1Pt2.y) : (seg1min = inSeg1Pt2, 
                seg1minVal = inSeg1Pt2.y, seg1max = inSeg1Pt1, seg1maxVal = inSeg1Pt1.y), inSeg2Pt1.y < inSeg2Pt2.y ? (seg2min = inSeg2Pt1, 
                seg2minVal = inSeg2Pt1.y, seg2max = inSeg2Pt2, seg2maxVal = inSeg2Pt2.y) : (seg2min = inSeg2Pt2, 
                seg2minVal = inSeg2Pt2.y, seg2max = inSeg2Pt1, seg2maxVal = inSeg2Pt1.y)), seg1minVal <= seg2minVal ? seg1maxVal < seg2minVal ? [] : seg1maxVal === seg2minVal ? inExcludeAdjacentSegs ? [] : [ seg2min ] : seg1maxVal <= seg2maxVal ? [ seg2min, seg1max ] : [ seg2min, seg2max ] : seg1minVal > seg2maxVal ? [] : seg1minVal === seg2maxVal ? inExcludeAdjacentSegs ? [] : [ seg1min ] : seg1maxVal <= seg2maxVal ? [ seg1min, seg1max ] : [ seg1min, seg2max ];
            }
            function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
                var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y, legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y, otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y, from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX, from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
                if (Math.abs(from2toAngle) > Number.EPSILON) {
                    var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                    return from2toAngle > 0 ? from2otherAngle >= 0 && other2toAngle >= 0 : from2otherAngle >= 0 || other2toAngle >= 0;
                }
                return from2otherAngle > 0;
            }
            removeDupEndPts(contour), holes.forEach(removeDupEndPts);
            for (var i, il, f, face, key, index, allPointsMap = {}, allpoints = contour.concat(), h = 0, hl = holes.length; h < hl; h++) Array.prototype.push.apply(allpoints, holes[h]);
            for (i = 0, il = allpoints.length; i < il; i++) key = allpoints[i].x + ":" + allpoints[i].y, 
            void 0 !== allPointsMap[key] && console.warn("THREE.ShapeUtils: Duplicate point", key, i), 
            allPointsMap[key] = i;
            var shapeWithoutHoles = function(contour, holes) {
                for (var hole, holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, tmpShape1, tmpShape2, tmpHole1, tmpHole2, shape = contour.concat(), indepHoles = [], failedCuts = [], h = 0, hl = holes.length; h < hl; h++) indepHoles.push(h);
                for (var minShapeIndex = 0, counter = 2 * indepHoles.length; indepHoles.length > 0; ) {
                    if (--counter < 0) {
                        console.log('THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!');
                        break;
                    }
                    for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                        shapePt = shape[shapeIndex], holeIndex = -1;
                        for (var h = 0; h < indepHoles.length; h++) if (holeIdx = indepHoles[h], cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx, 
                        void 0 === failedCuts[cutKey]) {
                            hole = holes[holeIdx];
                            for (var h2 = 0; h2 < hole.length; h2++) if (holePt = hole[h2], function(inShapeIdx, inHoleIdx) {
                                var lastShapeIdx = shape.length - 1, prevShapeIdx = inShapeIdx - 1;
                                prevShapeIdx < 0 && (prevShapeIdx = lastShapeIdx);
                                var nextShapeIdx = inShapeIdx + 1;
                                nextShapeIdx > lastShapeIdx && (nextShapeIdx = 0);
                                var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                                if (!insideAngle) return !1;
                                var lastHoleIdx = hole.length - 1, prevHoleIdx = inHoleIdx - 1;
                                prevHoleIdx < 0 && (prevHoleIdx = lastHoleIdx);
                                var nextHoleIdx = inHoleIdx + 1;
                                return nextHoleIdx > lastHoleIdx && (nextHoleIdx = 0), !!(insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]));
                            }(shapeIndex, h2) && !function(inShapePt, inHolePt) {
                                var sIdx, nextIdx, intersection;
                                for (sIdx = 0; sIdx < shape.length; sIdx++) if (nextIdx = sIdx + 1, nextIdx %= shape.length, 
                                intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], !0), 
                                intersection.length > 0) return !0;
                                return !1;
                            }(shapePt, holePt) && !function(inShapePt, inHolePt) {
                                var ihIdx, chkHole, hIdx, nextIdx, intersection;
                                for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) for (chkHole = holes[indepHoles[ihIdx]], 
                                hIdx = 0; hIdx < chkHole.length; hIdx++) if (nextIdx = hIdx + 1, nextIdx %= chkHole.length, 
                                intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], !0), 
                                intersection.length > 0) return !0;
                                return !1;
                            }(shapePt, holePt)) {
                                holeIndex = h2, indepHoles.splice(h, 1), tmpShape1 = shape.slice(0, shapeIndex + 1), 
                                tmpShape2 = shape.slice(shapeIndex), tmpHole1 = hole.slice(holeIndex), tmpHole2 = hole.slice(0, holeIndex + 1), 
                                shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2), minShapeIndex = shapeIndex;
                                break;
                            }
                            if (holeIndex >= 0) break;
                            failedCuts[cutKey] = !0;
                        }
                        if (holeIndex >= 0) break;
                    }
                }
                return shape;
            }(contour, holes), triangles = ShapeUtils.triangulate(shapeWithoutHoles, !1);
            for (i = 0, il = triangles.length; i < il; i++) for (face = triangles[i], f = 0; f < 3; f++) key = face[f].x + ":" + face[f].y, 
            void 0 !== (index = allPointsMap[key]) && (face[f] = index);
            return triangles.concat();
        },
        isClockWise: function(pts) {
            return ShapeUtils.area(pts) < 0;
        }
    };
    ExtrudeGeometry.prototype = Object.create(Geometry.prototype), ExtrudeGeometry.prototype.constructor = ExtrudeGeometry, 
    ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype), ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry, 
    ExtrudeBufferGeometry.prototype.getArrays = function() {
        var positionAttribute = this.getAttribute("position"), verticesArray = positionAttribute ? Array.prototype.slice.call(positionAttribute.array) : [], uvAttribute = this.getAttribute("uv"), uvArray = uvAttribute ? Array.prototype.slice.call(uvAttribute.array) : [], IndexAttribute = this.index;
        return {
            position: verticesArray,
            uv: uvArray,
            index: IndexAttribute ? Array.prototype.slice.call(IndexAttribute.array) : []
        };
    }, ExtrudeBufferGeometry.prototype.addShapeList = function(shapes, options) {
        var sl = shapes.length;
        options.arrays = this.getArrays();
        for (var s = 0; s < sl; s++) {
            var shape = shapes[s];
            this.addShape(shape, options);
        }
        this.setIndex(options.arrays.index), this.addAttribute("position", new Float32BufferAttribute(options.arrays.position, 3)), 
        this.addAttribute("uv", new Float32BufferAttribute(options.arrays.uv, 2));
    }, ExtrudeBufferGeometry.prototype.addShape = function(shape, options) {
        function scalePt2(pt, vec, size) {
            return vec || console.error("THREE.ExtrudeGeometry: vec does not exist"), vec.clone().multiplyScalar(size).add(pt);
        }
        function getBevelVec(inPt, inPrev, inNext) {
            var v_trans_x, v_trans_y, shrink_by, v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y, v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y, v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y, collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
                var v_prev_len = Math.sqrt(v_prev_lensq), v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y), ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len, ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len, ptNextShift_x = inNext.x - v_next_y / v_next_len, ptNextShift_y = inNext.y + v_next_x / v_next_len, sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x, v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (v_trans_lensq <= 2) return new Vector2(v_trans_x, v_trans_y);
                shrink_by = Math.sqrt(v_trans_lensq / 2);
            } else {
                var direction_eq = !1;
                v_prev_x > Number.EPSILON ? v_next_x > Number.EPSILON && (direction_eq = !0) : v_prev_x < -Number.EPSILON ? v_next_x < -Number.EPSILON && (direction_eq = !0) : Math.sign(v_prev_y) === Math.sign(v_next_y) && (direction_eq = !0), 
                direction_eq ? (v_trans_x = -v_prev_y, v_trans_y = v_prev_x, shrink_by = Math.sqrt(v_prev_lensq)) : (v_trans_x = v_prev_x, 
                v_trans_y = v_prev_y, shrink_by = Math.sqrt(v_prev_lensq / 2));
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        function sidewalls(contour, layeroffset) {
            var j, k;
            for (i = contour.length; --i >= 0; ) {
                j = i, k = i - 1, k < 0 && (k = contour.length - 1);
                var s = 0, sl = steps + 2 * bevelSegments;
                for (s = 0; s < sl; s++) {
                    var slen1 = vlen * s, slen2 = vlen * (s + 1);
                    f4(layeroffset + j + slen1, layeroffset + k + slen1, layeroffset + k + slen2, layeroffset + j + slen2, contour, s, sl, j, k);
                }
            }
        }
        function v(x, y, z) {
            placeholder.push(x), placeholder.push(y), placeholder.push(z);
        }
        function f3(a, b, c) {
            addVertex(a), addVertex(b), addVertex(c);
            var nextIndex = verticesArray.length / 3, uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]), addUV(uvs[1]), addUV(uvs[2]);
        }
        function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
            addVertex(a), addVertex(b), addVertex(d), addVertex(b), addVertex(c), addVertex(d);
            var nextIndex = verticesArray.length / 3, uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]), addUV(uvs[1]), addUV(uvs[3]), addUV(uvs[1]), addUV(uvs[2]), addUV(uvs[3]);
        }
        function addVertex(index) {
            indicesArray.push(verticesArray.length / 3), verticesArray.push(placeholder[3 * index + 0]), 
            verticesArray.push(placeholder[3 * index + 1]), verticesArray.push(placeholder[3 * index + 2]);
        }
        function addUV(vector2) {
            uvArray.push(vector2.x), uvArray.push(vector2.y);
        }
        var extrudePts, splineTube, binormal, normal, position2, arrays = options.arrays ? options.arrays : this.getArrays(), verticesArray = arrays.position, indicesArray = arrays.index, uvArray = arrays.uv, placeholder = [], amount = void 0 !== options.amount ? options.amount : 100, bevelThickness = void 0 !== options.bevelThickness ? options.bevelThickness : 6, bevelSize = void 0 !== options.bevelSize ? options.bevelSize : bevelThickness - 2, bevelSegments = void 0 !== options.bevelSegments ? options.bevelSegments : 3, bevelEnabled = void 0 === options.bevelEnabled || options.bevelEnabled, curveSegments = void 0 !== options.curveSegments ? options.curveSegments : 12, steps = void 0 !== options.steps ? options.steps : 1, extrudePath = options.extrudePath, extrudeByPath = !1, uvgen = void 0 !== options.UVGenerator ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
        extrudePath && (extrudePts = extrudePath.getSpacedPoints(steps), extrudeByPath = !0, 
        bevelEnabled = !1, splineTube = void 0 !== options.frames ? options.frames : extrudePath.computeFrenetFrames(steps, !1), 
        binormal = new Vector3(), normal = new Vector3(), position2 = new Vector3()), bevelEnabled || (bevelSegments = 0, 
        bevelThickness = 0, bevelSize = 0);
        var ahole, h, hl, scope = this, shapePoints = shape.extractPoints(curveSegments), vertices = shapePoints.shape, holes = shapePoints.holes;
        if (!ShapeUtils.isClockWise(vertices)) for (vertices = vertices.reverse(), h = 0, 
        hl = holes.length; h < hl; h++) ahole = holes[h], ShapeUtils.isClockWise(ahole) && (holes[h] = ahole.reverse());
        var faces = ShapeUtils.triangulateShape(vertices, holes), contour = vertices;
        for (h = 0, hl = holes.length; h < hl; h++) ahole = holes[h], vertices = vertices.concat(ahole);
        for (var b, bs, t, z, vert, face, vlen = vertices.length, flen = faces.length, contourMovements = [], i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, 
        j++, k++) j === il && (j = 0), k === il && (k = 0), contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        var oneHoleMovements, holesMovements = [], verticesMovements = contourMovements.concat();
        for (h = 0, hl = holes.length; h < hl; h++) {
            for (ahole = holes[h], oneHoleMovements = [], i = 0, il = ahole.length, j = il - 1, 
            k = i + 1; i < il; i++, j++, k++) j === il && (j = 0), k === il && (k = 0), oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
            holesMovements.push(oneHoleMovements), verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (b = 0; b < bevelSegments; b++) {
            for (t = b / bevelSegments, z = bevelThickness * Math.cos(t * Math.PI / 2), bs = bevelSize * Math.sin(t * Math.PI / 2), 
            i = 0, il = contour.length; i < il; i++) vert = scalePt2(contour[i], contourMovements[i], bs), 
            v(vert.x, vert.y, -z);
            for (h = 0, hl = holes.length; h < hl; h++) for (ahole = holes[h], oneHoleMovements = holesMovements[h], 
            i = 0, il = ahole.length; i < il; i++) vert = scalePt2(ahole[i], oneHoleMovements[i], bs), 
            v(vert.x, vert.y, -z);
        }
        for (bs = bevelSize, i = 0; i < vlen; i++) vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i], 
        extrudeByPath ? (normal.copy(splineTube.normals[0]).multiplyScalar(vert.x), binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y), 
        position2.copy(extrudePts[0]).add(normal).add(binormal), v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, 0);
        var s;
        for (s = 1; s <= steps; s++) for (i = 0; i < vlen; i++) vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i], 
        extrudeByPath ? (normal.copy(splineTube.normals[s]).multiplyScalar(vert.x), binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y), 
        position2.copy(extrudePts[s]).add(normal).add(binormal), v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, amount / steps * s);
        for (b = bevelSegments - 1; b >= 0; b--) {
            for (t = b / bevelSegments, z = bevelThickness * Math.cos(t * Math.PI / 2), bs = bevelSize * Math.sin(t * Math.PI / 2), 
            i = 0, il = contour.length; i < il; i++) vert = scalePt2(contour[i], contourMovements[i], bs), 
            v(vert.x, vert.y, amount + z);
            for (h = 0, hl = holes.length; h < hl; h++) for (ahole = holes[h], oneHoleMovements = holesMovements[h], 
            i = 0, il = ahole.length; i < il; i++) vert = scalePt2(ahole[i], oneHoleMovements[i], bs), 
            extrudeByPath ? v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z) : v(vert.x, vert.y, amount + z);
        }
        !function() {
            var start = verticesArray.length / 3;
            if (bevelEnabled) {
                var layer = 0, offset = vlen * layer;
                for (i = 0; i < flen; i++) face = faces[i], f3(face[2] + offset, face[1] + offset, face[0] + offset);
                for (layer = steps + 2 * bevelSegments, offset = vlen * layer, i = 0; i < flen; i++) face = faces[i], 
                f3(face[0] + offset, face[1] + offset, face[2] + offset);
            } else {
                for (i = 0; i < flen; i++) face = faces[i], f3(face[2], face[1], face[0]);
                for (i = 0; i < flen; i++) face = faces[i], f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
            scope.addGroup(start, verticesArray.length / 3 - start, void 0 !== options.material ? options.material : 0);
        }(), function() {
            var start = verticesArray.length / 3, layeroffset = 0;
            for (sidewalls(contour, layeroffset), layeroffset += contour.length, h = 0, hl = holes.length; h < hl; h++) ahole = holes[h], 
            sidewalls(ahole, layeroffset), layeroffset += ahole.length;
            scope.addGroup(start, verticesArray.length / 3 - start, void 0 !== options.extrudeMaterial ? options.extrudeMaterial : 1);
        }(), options.arrays || (this.setIndex(indicesArray), this.addAttribute("position", new Float32BufferAttribute(verticesArray, 3)), 
        this.addAttribute("uv", new Float32BufferAttribute(options.arrays.uv, 2)));
    }, ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
            var a_x = vertices[3 * indexA], a_y = vertices[3 * indexA + 1], b_x = vertices[3 * indexB], b_y = vertices[3 * indexB + 1], c_x = vertices[3 * indexC], c_y = vertices[3 * indexC + 1];
            return [ new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y) ];
        },
        generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
            var a_x = vertices[3 * indexA], a_y = vertices[3 * indexA + 1], a_z = vertices[3 * indexA + 2], b_x = vertices[3 * indexB], b_y = vertices[3 * indexB + 1], b_z = vertices[3 * indexB + 2], c_x = vertices[3 * indexC], c_y = vertices[3 * indexC + 1], c_z = vertices[3 * indexC + 2], d_x = vertices[3 * indexD], d_y = vertices[3 * indexD + 1], d_z = vertices[3 * indexD + 2];
            return Math.abs(a_y - b_y) < .01 ? [ new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z) ] : [ new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z) ];
        }
    }, TextGeometry.prototype = Object.create(Geometry.prototype), TextGeometry.prototype.constructor = TextGeometry, 
    TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype), TextBufferGeometry.prototype.constructor = TextBufferGeometry, 
    SphereGeometry.prototype = Object.create(Geometry.prototype), SphereGeometry.prototype.constructor = SphereGeometry, 
    SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype), SphereBufferGeometry.prototype.constructor = SphereBufferGeometry, 
    RingGeometry.prototype = Object.create(Geometry.prototype), RingGeometry.prototype.constructor = RingGeometry, 
    RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype), RingBufferGeometry.prototype.constructor = RingBufferGeometry, 
    LatheGeometry.prototype = Object.create(Geometry.prototype), LatheGeometry.prototype.constructor = LatheGeometry, 
    LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype), LatheBufferGeometry.prototype.constructor = LatheBufferGeometry, 
    ShapeGeometry.prototype = Object.create(Geometry.prototype), ShapeGeometry.prototype.constructor = ShapeGeometry, 
    ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype), ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry, 
    EdgesGeometry.prototype = Object.create(BufferGeometry.prototype), EdgesGeometry.prototype.constructor = EdgesGeometry, 
    CylinderGeometry.prototype = Object.create(Geometry.prototype), CylinderGeometry.prototype.constructor = CylinderGeometry, 
    CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype), CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry, 
    ConeGeometry.prototype = Object.create(CylinderGeometry.prototype), ConeGeometry.prototype.constructor = ConeGeometry, 
    ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype), 
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry, CircleGeometry.prototype = Object.create(Geometry.prototype), 
    CircleGeometry.prototype.constructor = CircleGeometry, CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype), 
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
    var Geometries = Object.freeze({
        WireframeGeometry: WireframeGeometry,
        ParametricGeometry: ParametricGeometry,
        ParametricBufferGeometry: ParametricBufferGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronBufferGeometry,
        OctahedronGeometry: OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronBufferGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronBufferGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronBufferGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronBufferGeometry,
        TubeGeometry: TubeGeometry,
        TubeBufferGeometry: TubeBufferGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotBufferGeometry,
        TorusGeometry: TorusGeometry,
        TorusBufferGeometry: TorusBufferGeometry,
        TextGeometry: TextGeometry,
        TextBufferGeometry: TextBufferGeometry,
        SphereGeometry: SphereGeometry,
        SphereBufferGeometry: SphereBufferGeometry,
        RingGeometry: RingGeometry,
        RingBufferGeometry: RingBufferGeometry,
        PlaneGeometry: PlaneGeometry,
        PlaneBufferGeometry: PlaneBufferGeometry,
        LatheGeometry: LatheGeometry,
        LatheBufferGeometry: LatheBufferGeometry,
        ShapeGeometry: ShapeGeometry,
        ShapeBufferGeometry: ShapeBufferGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        ExtrudeBufferGeometry: ExtrudeBufferGeometry,
        EdgesGeometry: EdgesGeometry,
        ConeGeometry: ConeGeometry,
        ConeBufferGeometry: ConeBufferGeometry,
        CylinderGeometry: CylinderGeometry,
        CylinderBufferGeometry: CylinderBufferGeometry,
        CircleGeometry: CircleGeometry,
        CircleBufferGeometry: CircleBufferGeometry,
        BoxGeometry: BoxGeometry,
        BoxBufferGeometry: BoxBufferGeometry
    });
    ShadowMaterial.prototype = Object.create(Material.prototype), ShadowMaterial.prototype.constructor = ShadowMaterial, 
    ShadowMaterial.prototype.isShadowMaterial = !0, RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype), 
    RawShaderMaterial.prototype.constructor = RawShaderMaterial, RawShaderMaterial.prototype.isRawShaderMaterial = !0, 
    MeshStandardMaterial.prototype = Object.create(Material.prototype), MeshStandardMaterial.prototype.constructor = MeshStandardMaterial, 
    MeshStandardMaterial.prototype.isMeshStandardMaterial = !0, MeshStandardMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.defines = {
            STANDARD: ""
        }, this.color.copy(source.color), this.roughness = source.roughness, this.metalness = source.metalness, 
        this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, 
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), 
        this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, 
        this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, 
        this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, 
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, 
        this.roughnessMap = source.roughnessMap, this.metalnessMap = source.metalnessMap, 
        this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapIntensity = source.envMapIntensity, 
        this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, 
        this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, 
        this.wireframeLinejoin = source.wireframeLinejoin, this.skinning = source.skinning, 
        this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, 
        this;
    }, MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype), 
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial, MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0, 
    MeshPhysicalMaterial.prototype.copy = function(source) {
        return MeshStandardMaterial.prototype.copy.call(this, source), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = source.reflectivity, this.clearCoat = source.clearCoat, this.clearCoatRoughness = source.clearCoatRoughness, 
        this;
    }, MeshPhongMaterial.prototype = Object.create(Material.prototype), MeshPhongMaterial.prototype.constructor = MeshPhongMaterial, 
    MeshPhongMaterial.prototype.isMeshPhongMaterial = !0, MeshPhongMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.specular.copy(source.specular), this.shininess = source.shininess, this.map = source.map, 
        this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, 
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), 
        this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, 
        this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, 
        this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, 
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, 
        this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, 
        this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, 
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, 
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, 
        this;
    }, MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype), MeshToonMaterial.prototype.constructor = MeshToonMaterial, 
    MeshToonMaterial.prototype.isMeshToonMaterial = !0, MeshToonMaterial.prototype.copy = function(source) {
        return MeshPhongMaterial.prototype.copy.call(this, source), this.gradientMap = source.gradientMap, 
        this;
    }, MeshNormalMaterial.prototype = Object.create(Material.prototype), MeshNormalMaterial.prototype.constructor = MeshNormalMaterial, 
    MeshNormalMaterial.prototype.isMeshNormalMaterial = !0, MeshNormalMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.bumpMap = source.bumpMap, 
        this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalScale.copy(source.normalScale), 
        this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, 
        this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, 
        this.wireframeLinewidth = source.wireframeLinewidth, this.skinning = source.skinning, 
        this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, 
        this;
    }, MeshLambertMaterial.prototype = Object.create(Material.prototype), MeshLambertMaterial.prototype.constructor = MeshLambertMaterial, 
    MeshLambertMaterial.prototype.isMeshLambertMaterial = !0, MeshLambertMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, 
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), 
        this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, 
        this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, 
        this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, 
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, 
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, 
        this;
    }, LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype), LineDashedMaterial.prototype.constructor = LineDashedMaterial, 
    LineDashedMaterial.prototype.isLineDashedMaterial = !0, LineDashedMaterial.prototype.copy = function(source) {
        return LineBasicMaterial.prototype.copy.call(this, source), this.scale = source.scale, 
        this.dashSize = source.dashSize, this.gapSize = source.gapSize, this;
    };
    var Materials = Object.freeze({
        ShadowMaterial: ShadowMaterial,
        SpriteMaterial: SpriteMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShaderMaterial: ShaderMaterial,
        PointsMaterial: PointsMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshToonMaterial: MeshToonMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshDistanceMaterial: MeshDistanceMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        LineDashedMaterial: LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial,
        Material: Material
    }), Cache = {
        enabled: !1,
        files: {},
        add: function(key, file) {
            !1 !== this.enabled && (this.files[key] = file);
        },
        get: function(key) {
            if (!1 !== this.enabled) return this.files[key];
        },
        remove: function(key) {
            delete this.files[key];
        },
        clear: function() {
            this.files = {};
        }
    }, DefaultLoadingManager = new LoadingManager();
    Object.assign(FileLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            void 0 === url && (url = ""), void 0 !== this.path && (url = this.path + url);
            var scope = this, cached = Cache.get(url);
            if (void 0 !== cached) return scope.manager.itemStart(url), setTimeout(function() {
                onLoad && onLoad(cached), scope.manager.itemEnd(url);
            }, 0), cached;
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/, dataUriRegexResult = url.match(dataUriRegex);
            if (dataUriRegexResult) {
                var mimeType = dataUriRegexResult[1], isBase64 = !!dataUriRegexResult[2], data = dataUriRegexResult[3];
                data = window.decodeURIComponent(data), isBase64 && (data = window.atob(data));
                try {
                    var response, responseType = (this.responseType || "").toLowerCase();
                    switch (responseType) {
                      case "arraybuffer":
                      case "blob":
                        response = new ArrayBuffer(data.length);
                        for (var view = new Uint8Array(response), i = 0; i < data.length; i++) view[i] = data.charCodeAt(i);
                        "blob" === responseType && (response = new Blob([ response ], {
                            type: mimeType
                        }));
                        break;

                      case "document":
                        var parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;

                      case "json":
                        response = JSON.parse(data);
                        break;

                      default:
                        response = data;
                    }
                    window.setTimeout(function() {
                        onLoad && onLoad(response), scope.manager.itemEnd(url);
                    }, 0);
                } catch (error) {
                    window.setTimeout(function() {
                        onError && onError(error), scope.manager.itemEnd(url), scope.manager.itemError(url);
                    }, 0);
                }
            } else {
                var request = new XMLHttpRequest();
                request.open("GET", url, !0), request.addEventListener("load", function(event) {
                    var response = event.target.response;
                    Cache.add(url, response), 200 === this.status ? (onLoad && onLoad(response), scope.manager.itemEnd(url)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), 
                    onLoad && onLoad(response), scope.manager.itemEnd(url)) : (onError && onError(event), 
                    scope.manager.itemEnd(url), scope.manager.itemError(url));
                }, !1), void 0 !== onProgress && request.addEventListener("progress", function(event) {
                    onProgress(event);
                }, !1), request.addEventListener("error", function(event) {
                    onError && onError(event), scope.manager.itemEnd(url), scope.manager.itemError(url);
                }, !1), void 0 !== this.responseType && (request.responseType = this.responseType), 
                void 0 !== this.withCredentials && (request.withCredentials = this.withCredentials), 
                request.overrideMimeType && request.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (var header in this.requestHeader) request.setRequestHeader(header, this.requestHeader[header]);
                request.send(null);
            }
            return scope.manager.itemStart(url), request;
        },
        setPath: function(value) {
            return this.path = value, this;
        },
        setResponseType: function(value) {
            return this.responseType = value, this;
        },
        setWithCredentials: function(value) {
            return this.withCredentials = value, this;
        },
        setMimeType: function(value) {
            return this.mimeType = value, this;
        },
        setRequestHeader: function(value) {
            return this.requestHeader = value, this;
        }
    }), Object.assign(CompressedTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, images = [], texture = new CompressedTexture();
            texture.image = images;
            var loader = new FileLoader(this.manager);
            if (loader.setPath(this.path), loader.setResponseType("arraybuffer"), Array.isArray(url)) for (var loaded = 0, i = 0, il = url.length; i < il; ++i) !function(i) {
                loader.load(url[i], function(buffer) {
                    var texDatas = scope._parser(buffer, !0);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    }, 6 === (loaded += 1) && (1 === texDatas.mipmapCount && (texture.minFilter = LinearFilter), 
                    texture.format = texDatas.format, texture.needsUpdate = !0, onLoad && onLoad(texture));
                }, onProgress, onError);
            }(i); else loader.load(url, function(buffer) {
                var texDatas = scope._parser(buffer, !0);
                if (texDatas.isCubemap) for (var faces = texDatas.mipmaps.length / texDatas.mipmapCount, f = 0; f < faces; f++) {
                    images[f] = {
                        mipmaps: []
                    };
                    for (var i = 0; i < texDatas.mipmapCount; i++) images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]), 
                    images[f].format = texDatas.format, images[f].width = texDatas.width, images[f].height = texDatas.height;
                } else texture.image.width = texDatas.width, texture.image.height = texDatas.height, 
                texture.mipmaps = texDatas.mipmaps;
                1 === texDatas.mipmapCount && (texture.minFilter = LinearFilter), texture.format = texDatas.format, 
                texture.needsUpdate = !0, onLoad && onLoad(texture);
            }, onProgress, onError);
            return texture;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Object.assign(DataTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, texture = new DataTexture(), loader = new FileLoader(this.manager);
            return loader.setResponseType("arraybuffer"), loader.load(url, function(buffer) {
                var texData = scope._parser(buffer);
                texData && (void 0 !== texData.image ? texture.image = texData.image : void 0 !== texData.data && (texture.image.width = texData.width, 
                texture.image.height = texData.height, texture.image.data = texData.data), texture.wrapS = void 0 !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping, 
                texture.wrapT = void 0 !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping, 
                texture.magFilter = void 0 !== texData.magFilter ? texData.magFilter : LinearFilter, 
                texture.minFilter = void 0 !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter, 
                texture.anisotropy = void 0 !== texData.anisotropy ? texData.anisotropy : 1, void 0 !== texData.format && (texture.format = texData.format), 
                void 0 !== texData.type && (texture.type = texData.type), void 0 !== texData.mipmaps && (texture.mipmaps = texData.mipmaps), 
                1 === texData.mipmapCount && (texture.minFilter = LinearFilter), texture.needsUpdate = !0, 
                onLoad && onLoad(texture, texData));
            }, onProgress, onError), texture;
        }
    }), Object.assign(ImageLoader.prototype, {
        crossOrigin: "Anonymous",
        load: function(url, onLoad, onProgress, onError) {
            void 0 === url && (url = ""), void 0 !== this.path && (url = this.path + url);
            var scope = this, cached = Cache.get(url);
            if (void 0 !== cached) return scope.manager.itemStart(url), setTimeout(function() {
                onLoad && onLoad(cached), scope.manager.itemEnd(url);
            }, 0), cached;
            var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return image.addEventListener("load", function() {
                Cache.add(url, this), onLoad && onLoad(this), scope.manager.itemEnd(url);
            }, !1), image.addEventListener("error", function(event) {
                onError && onError(event), scope.manager.itemEnd(url), scope.manager.itemError(url);
            }, !1), "data:" !== url.substr(0, 5) && void 0 !== this.crossOrigin && (image.crossOrigin = this.crossOrigin), 
            scope.manager.itemStart(url), image.src = url, image;
        },
        setCrossOrigin: function(value) {
            return this.crossOrigin = value, this;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Object.assign(CubeTextureLoader.prototype, {
        crossOrigin: "Anonymous",
        load: function(urls, onLoad, onProgress, onError) {
            var texture = new CubeTexture(), loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin), loader.setPath(this.path);
            for (var loaded = 0, i = 0; i < urls.length; ++i) !function(i) {
                loader.load(urls[i], function(image) {
                    texture.images[i] = image, 6 == ++loaded && (texture.needsUpdate = !0, onLoad && onLoad(texture));
                }, void 0, onError);
            }(i);
            return texture;
        },
        setCrossOrigin: function(value) {
            return this.crossOrigin = value, this;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Object.assign(TextureLoader.prototype, {
        crossOrigin: "Anonymous",
        load: function(url, onLoad, onProgress, onError) {
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin), loader.setPath(this.path);
            var texture = new Texture();
            return texture.image = loader.load(url, function() {
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || 0 === url.search(/^data\:image\/jpeg/);
                texture.format = isJPEG ? RGBFormat : RGBAFormat, texture.needsUpdate = !0, void 0 !== onLoad && onLoad(texture);
            }, onProgress, onError), texture;
        },
        setCrossOrigin: function(value) {
            return this.crossOrigin = value, this;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Light.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Light,
        isLight: !0,
        copy: function(source) {
            return Object3D.prototype.copy.call(this, source), this.color.copy(source.color), 
            this.intensity = source.intensity, this;
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return data.object.color = this.color.getHex(), data.object.intensity = this.intensity, 
            void 0 !== this.groundColor && (data.object.groundColor = this.groundColor.getHex()), 
            void 0 !== this.distance && (data.object.distance = this.distance), void 0 !== this.angle && (data.object.angle = this.angle), 
            void 0 !== this.decay && (data.object.decay = this.decay), void 0 !== this.penumbra && (data.object.penumbra = this.penumbra), 
            void 0 !== this.shadow && (data.object.shadow = this.shadow.toJSON()), data;
        }
    }), HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: HemisphereLight,
        isHemisphereLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.groundColor.copy(source.groundColor), 
            this;
        }
    }), Object.assign(LightShadow.prototype, {
        copy: function(source) {
            return this.camera = source.camera.clone(), this.bias = source.bias, this.radius = source.radius, 
            this.mapSize.copy(source.mapSize), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        toJSON: function() {
            var object = {};
            return 0 !== this.bias && (object.bias = this.bias), 1 !== this.radius && (object.radius = this.radius), 
            512 === this.mapSize.x && 512 === this.mapSize.y || (object.mapSize = this.mapSize.toArray()), 
            object.camera = this.camera.toJSON(!1).object, delete object.camera.matrix, object;
        }
    }), SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: SpotLightShadow,
        isSpotLightShadow: !0,
        update: function(light) {
            var camera = this.camera, fov = 2 * _Math.RAD2DEG * light.angle, aspect = this.mapSize.width / this.mapSize.height, far = light.distance || camera.far;
            fov === camera.fov && aspect === camera.aspect && far === camera.far || (camera.fov = fov, 
            camera.aspect = aspect, camera.far = far, camera.updateProjectionMatrix());
        }
    }), SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: SpotLight,
        isSpotLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.distance = source.distance, 
            this.angle = source.angle, this.penumbra = source.penumbra, this.decay = source.decay, 
            this.target = source.target.clone(), this.shadow = source.shadow.clone(), this;
        }
    }), PointLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: PointLight,
        isPointLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.distance = source.distance, 
            this.decay = source.decay, this.shadow = source.shadow.clone(), this;
        }
    }), DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: DirectionalLightShadow
    }), DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: DirectionalLight,
        isDirectionalLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.target = source.target.clone(), 
            this.shadow = source.shadow.clone(), this;
        }
    }), AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: AmbientLight,
        isAmbientLight: !0
    }), RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: RectAreaLight,
        isRectAreaLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.width = source.width, this.height = source.height, 
            this;
        },
        toJSON: function(meta) {
            var data = Light.prototype.toJSON.call(this, meta);
            return data.object.width = this.width, data.object.height = this.height, data;
        }
    });
    var AnimationUtils = {
        arraySlice: function(array, from, to) {
            return AnimationUtils.isTypedArray(array) ? new array.constructor(array.subarray(from, void 0 !== to ? to : array.length)) : array.slice(from, to);
        },
        convertArray: function(array, type, forceClone) {
            return !array || !forceClone && array.constructor === type ? array : "number" == typeof type.BYTES_PER_ELEMENT ? new type(array) : Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
            return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
            function compareTime(i, j) {
                return times[i] - times[j];
            }
            for (var n = times.length, result = new Array(n), i = 0; i !== n; ++i) result[i] = i;
            return result.sort(compareTime), result;
        },
        sortedArray: function(values, stride, order) {
            for (var nValues = values.length, result = new values.constructor(nValues), i = 0, dstOffset = 0; dstOffset !== nValues; ++i) for (var srcOffset = order[i] * stride, j = 0; j !== stride; ++j) result[dstOffset++] = values[srcOffset + j];
            return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
            for (var i = 1, key = jsonKeys[0]; void 0 !== key && void 0 === key[valuePropertyName]; ) key = jsonKeys[i++];
            if (void 0 !== key) {
                var value = key[valuePropertyName];
                if (void 0 !== value) if (Array.isArray(value)) do {
                    value = key[valuePropertyName], void 0 !== value && (times.push(key.time), values.push.apply(values, value)), 
                    key = jsonKeys[i++];
                } while (void 0 !== key); else if (void 0 !== value.toArray) do {
                    value = key[valuePropertyName], void 0 !== value && (times.push(key.time), value.toArray(values, values.length)), 
                    key = jsonKeys[i++];
                } while (void 0 !== key); else do {
                    value = key[valuePropertyName], void 0 !== value && (times.push(key.time), values.push(value)), 
                    key = jsonKeys[i++];
                } while (void 0 !== key);
            }
        }
    };
    Object.assign(Interpolant.prototype, {
        evaluate: function(t) {
            var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
            validate_interval: {
                seek: {
                    var right;
                    linear_scan: {
                        forward_scan: if (!(t < t1)) {
                            for (var giveUpAt = i1 + 2; ;) {
                                if (void 0 === t1) {
                                    if (t < t0) break forward_scan;
                                    return i1 = pp.length, this._cachedIndex = i1, this.afterEnd_(i1 - 1, t, t0);
                                }
                                if (i1 === giveUpAt) break;
                                if (t0 = t1, t1 = pp[++i1], t < t1) break seek;
                            }
                            right = pp.length;
                            break linear_scan;
                        }
                        {
                            if (t >= t0) break validate_interval;
                            var t1global = pp[1];
                            t < t1global && (i1 = 2, t0 = t1global);
                            for (var giveUpAt = i1 - 2; ;) {
                                if (void 0 === t0) return this._cachedIndex = 0, this.beforeStart_(0, t, t1);
                                if (i1 === giveUpAt) break;
                                if (t1 = t0, t0 = pp[--i1 - 1], t >= t0) break seek;
                            }
                            right = i1, i1 = 0;
                        }
                    }
                    for (;i1 < right; ) {
                        var mid = i1 + right >>> 1;
                        t < pp[mid] ? right = mid : i1 = mid + 1;
                    }
                    if (t1 = pp[i1], void 0 === (t0 = pp[i1 - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, t1);
                    if (void 0 === t1) return i1 = pp.length, this._cachedIndex = i1, this.afterEnd_(i1 - 1, t0, t);
                }
                this._cachedIndex = i1, this.intervalChanged_(i1, t0, t1);
            }
            return this.interpolate_(i1, t0, t, t1);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function(index) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride, i = 0; i !== stride; ++i) result[i] = values[offset + i];
            return result;
        },
        interpolate_: function(i1, t0, t, t1) {
            throw new Error("call to abstract method");
        },
        intervalChanged_: function(i1, t0, t1) {}
    }), Object.assign(Interpolant.prototype, {
        beforeStart_: Interpolant.prototype.copySampleValue_,
        afterEnd_: Interpolant.prototype.copySampleValue_
    }), CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: CubicInterpolant,
        DefaultSettings_: {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        },
        intervalChanged_: function(i1, t0, t1) {
            var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
            if (void 0 === tPrev) switch (this.getSettings_().endingStart) {
              case 2401:
                iPrev = i1, tPrev = 2 * t0 - t1;
                break;

              case 2402:
                iPrev = pp.length - 2, tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;

              default:
                iPrev = i1, tPrev = t1;
            }
            if (void 0 === tNext) switch (this.getSettings_().endingEnd) {
              case 2401:
                iNext = i1, tNext = 2 * t1 - t0;
                break;

              case 2402:
                iNext = 1, tNext = t1 + pp[1] - pp[0];
                break;

              default:
                iNext = i1 - 1, tNext = t0;
            }
            var halfDt = .5 * (t1 - t0), stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev), this._weightNext = halfDt / (tNext - t1), 
            this._offsetPrev = iPrev * stride, this._offsetNext = iNext * stride;
        },
        interpolate_: function(i1, t0, t, t1) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p, sP = -wP * ppp + 2 * wP * pp - wP * p, s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-.5 + wP) * p + 1, s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + .5 * p, sN = wN * ppp - wN * pp, i = 0; i !== stride; ++i) result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
            return result;
        }
    }), LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: LinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1, i = 0; i !== stride; ++i) result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
            return result;
        }
    }), DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: DiscreteInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            return this.copySampleValue_(i1 - 1);
        }
    });
    var KeyframeTrackPrototype;
    KeyframeTrackPrototype = {
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(result) {
            return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodLinear: function(result) {
            return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: function(result) {
            return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        setInterpolation: function(interpolation) {
            var factoryMethod;
            switch (interpolation) {
              case 2300:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;

              case 2301:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;

              case 2302:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === factoryMethod) {
                var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (interpolation === this.DefaultInterpolation) throw new Error(message);
                    this.setInterpolation(this.DefaultInterpolation);
                }
                return void console.warn("THREE.KeyframeTrackPrototype:", message);
            }
            this.createInterpolant = factoryMethod;
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return 2300;

              case this.InterpolantFactoryMethodLinear:
                return 2301;

              case this.InterpolantFactoryMethodSmooth:
                return 2302;
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length;
        },
        shift: function(timeOffset) {
            if (0 !== timeOffset) for (var times = this.times, i = 0, n = times.length; i !== n; ++i) times[i] += timeOffset;
            return this;
        },
        scale: function(timeScale) {
            if (1 !== timeScale) for (var times = this.times, i = 0, n = times.length; i !== n; ++i) times[i] *= timeScale;
            return this;
        },
        trim: function(startTime, endTime) {
            for (var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1; from !== nKeys && times[from] < startTime; ) ++from;
            for (;-1 !== to && times[to] > endTime; ) --to;
            if (++to, 0 !== from || to !== nKeys) {
                from >= to && (to = Math.max(to, 1), from = to - 1);
                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice(times, from, to), this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
            }
            return this;
        },
        validate: function() {
            var valid = !0, valueSize = this.getValueSize();
            valueSize - Math.floor(valueSize) != 0 && (console.error("THREE.KeyframeTrackPrototype: Invalid value size in track.", this), 
            valid = !1);
            var times = this.times, values = this.values, nKeys = times.length;
            0 === nKeys && (console.error("THREE.KeyframeTrackPrototype: Track is empty.", this), 
            valid = !1);
            for (var prevTime = null, i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if ("number" == typeof currTime && isNaN(currTime)) {
                    console.error("THREE.KeyframeTrackPrototype: Time is not a valid number.", this, i, currTime), 
                    valid = !1;
                    break;
                }
                if (null !== prevTime && prevTime > currTime) {
                    console.error("THREE.KeyframeTrackPrototype: Out of order keys.", this, i, currTime, prevTime), 
                    valid = !1;
                    break;
                }
                prevTime = currTime;
            }
            if (void 0 !== values && AnimationUtils.isTypedArray(values)) for (var i = 0, n = values.length; i !== n; ++i) {
                var value = values[i];
                if (isNaN(value)) {
                    console.error("THREE.KeyframeTrackPrototype: Value is not a valid number.", this, i, value), 
                    valid = !1;
                    break;
                }
            }
            return valid;
        },
        optimize: function() {
            for (var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = 2302 === this.getInterpolation(), writeIndex = 1, lastIndex = times.length - 1, i = 1; i < lastIndex; ++i) {
                var keep = !1, time = times[i];
                if (time !== times[i + 1] && (1 !== i || time !== time[0])) if (smoothInterpolation) keep = !0; else for (var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride, j = 0; j !== stride; ++j) {
                    var value = values[offset + j];
                    if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                        keep = !0;
                        break;
                    }
                }
                if (keep) {
                    if (i !== writeIndex) {
                        times[writeIndex] = times[i];
                        for (var readOffset = i * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
                    }
                    ++writeIndex;
                }
            }
            if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
                ++writeIndex;
            }
            return writeIndex !== times.length && (this.times = AnimationUtils.arraySlice(times, 0, writeIndex), 
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride)), this;
        }
    }, VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: VectorKeyframeTrack,
        ValueTypeName: "vector"
    }), QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: QuaternionLinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0), end = offset + stride; offset !== end; offset += 4) Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            return result;
        }
    }), QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: QuaternionKeyframeTrack,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(result) {
            return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: void 0
    }), NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: NumberKeyframeTrack,
        ValueTypeName: "number"
    }), StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: StringKeyframeTrack,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: BooleanKeyframeTrack,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: ColorKeyframeTrack,
        ValueTypeName: "color"
    }), KeyframeTrack.prototype = KeyframeTrackPrototype, KeyframeTrackPrototype.constructor = KeyframeTrack, 
    Object.assign(KeyframeTrack, {
        parse: function(json) {
            if (void 0 === json.type) throw new Error("track type undefined, can not parse");
            var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
            if (void 0 === json.times) {
                var times = [], values = [];
                AnimationUtils.flattenJSON(json.keys, times, values, "value"), json.times = times, 
                json.values = values;
            }
            return void 0 !== trackType.parse ? trackType.parse(json) : new trackType(json.name, json.times, json.values, json.interpolation);
        },
        toJSON: function(track) {
            var json, trackType = track.constructor;
            if (void 0 !== trackType.toJSON) json = trackType.toJSON(track); else {
                json = {
                    name: track.name,
                    times: AnimationUtils.convertArray(track.times, Array),
                    values: AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                interpolation !== track.DefaultInterpolation && (json.interpolation = interpolation);
            }
            return json.type = track.ValueTypeName, json;
        },
        _getTrackTypeForValueTypeName: function(typeName) {
            switch (typeName.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return NumberKeyframeTrack;

              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return VectorKeyframeTrack;

              case "color":
                return ColorKeyframeTrack;

              case "quaternion":
                return QuaternionKeyframeTrack;

              case "bool":
              case "boolean":
                return BooleanKeyframeTrack;

              case "string":
                return StringKeyframeTrack;
            }
            throw new Error("Unsupported typeName: " + typeName);
        }
    }), Object.assign(AnimationClip, {
        parse: function(json) {
            for (var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1), i = 0, n = jsonTracks.length; i !== n; ++i) tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
            return new AnimationClip(json.name, json.duration, tracks);
        },
        toJSON: function(clip) {
            for (var tracks = [], clipTracks = clip.tracks, json = {
                name: clip.name,
                duration: clip.duration,
                tracks: tracks
            }, i = 0, n = clipTracks.length; i !== n; ++i) tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
            return json;
        },
        CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
            for (var numMorphTargets = morphTargetSequence.length, tracks = [], i = 0; i < numMorphTargets; i++) {
                var times = [], values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets), 
                values.push(0, 1, 0);
                var order = AnimationUtils.getKeyframeOrder(times);
                times = AnimationUtils.sortedArray(times, 1, order), values = AnimationUtils.sortedArray(values, 1, order), 
                noLoop || 0 !== times[0] || (times.push(numMorphTargets), values.push(values[0])), 
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
            }
            return new AnimationClip(name, -1, tracks);
        },
        findByName: function(objectOrClipArray, name) {
            var clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for (var i = 0; i < clipArray.length; i++) if (clipArray[i].name === name) return clipArray[i];
            return null;
        },
        CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
            for (var animationToMorphTargets = {}, pattern = /^([\w-]*?)([\d]+)$/, i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = morphTargets[i], parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    var name = parts[1], animationMorphTargets = animationToMorphTargets[name];
                    animationMorphTargets || (animationToMorphTargets[name] = animationMorphTargets = []), 
                    animationMorphTargets.push(morphTarget);
                }
            }
            var clips = [];
            for (var name in animationToMorphTargets) clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
            return clips;
        },
        parseAnimation: function(animation, bones) {
            if (!animation) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), 
            null;
            for (var addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                if (0 !== animationKeys.length) {
                    var times = [], values = [];
                    AnimationUtils.flattenJSON(animationKeys, times, values, propertyName), 0 !== times.length && destTracks.push(new trackType(trackName, times, values));
                }
            }, tracks = [], clipName = animation.name || "default", duration = animation.length || -1, fps = animation.fps || 30, hierarchyTracks = animation.hierarchy || [], h = 0; h < hierarchyTracks.length; h++) {
                var animationKeys = hierarchyTracks[h].keys;
                if (animationKeys && 0 !== animationKeys.length) if (animationKeys[0].morphTargets) {
                    for (var morphTargetNames = {}, k = 0; k < animationKeys.length; k++) if (animationKeys[k].morphTargets) for (var m = 0; m < animationKeys[k].morphTargets.length; m++) morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                    for (var morphTargetName in morphTargetNames) {
                        for (var times = [], values = [], m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                            var animationKey = animationKeys[k];
                            times.push(animationKey.time), values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                        }
                        tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
                    }
                    duration = morphTargetNames.length * (fps || 1);
                } else {
                    var boneName = ".bones[" + bones[h].name + "]";
                    addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks), 
                    addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks), 
                    addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
                }
            }
            return 0 === tracks.length ? null : new AnimationClip(clipName, duration, tracks);
        }
    }), Object.assign(AnimationClip.prototype, {
        resetDuration: function() {
            for (var tracks = this.tracks, duration = 0, i = 0, n = tracks.length; i !== n; ++i) {
                var track = this.tracks[i];
                duration = Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
        },
        trim: function() {
            for (var i = 0; i < this.tracks.length; i++) this.tracks[i].trim(0, this.duration);
            return this;
        },
        optimize: function() {
            for (var i = 0; i < this.tracks.length; i++) this.tracks[i].optimize();
            return this;
        }
    }), Object.assign(MaterialLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            new FileLoader(scope.manager).load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        setTextures: function(value) {
            this.textures = value;
        },
        parse: function(json) {
            function getTexture(name) {
                return void 0 === textures[name] && console.warn("THREE.MaterialLoader: Undefined texture", name), 
                textures[name];
            }
            var textures = this.textures, material = new Materials[json.type]();
            if (void 0 !== json.uuid && (material.uuid = json.uuid), void 0 !== json.name && (material.name = json.name), 
            void 0 !== json.color && material.color.setHex(json.color), void 0 !== json.roughness && (material.roughness = json.roughness), 
            void 0 !== json.metalness && (material.metalness = json.metalness), void 0 !== json.emissive && material.emissive.setHex(json.emissive), 
            void 0 !== json.specular && material.specular.setHex(json.specular), void 0 !== json.shininess && (material.shininess = json.shininess), 
            void 0 !== json.clearCoat && (material.clearCoat = json.clearCoat), void 0 !== json.clearCoatRoughness && (material.clearCoatRoughness = json.clearCoatRoughness), 
            void 0 !== json.uniforms && (material.uniforms = json.uniforms), void 0 !== json.vertexShader && (material.vertexShader = json.vertexShader), 
            void 0 !== json.fragmentShader && (material.fragmentShader = json.fragmentShader), 
            void 0 !== json.vertexColors && (material.vertexColors = json.vertexColors), void 0 !== json.fog && (material.fog = json.fog), 
            void 0 !== json.flatShading && (material.flatShading = json.flatShading), void 0 !== json.blending && (material.blending = json.blending), 
            void 0 !== json.side && (material.side = json.side), void 0 !== json.opacity && (material.opacity = json.opacity), 
            void 0 !== json.transparent && (material.transparent = json.transparent), void 0 !== json.alphaTest && (material.alphaTest = json.alphaTest), 
            void 0 !== json.depthTest && (material.depthTest = json.depthTest), void 0 !== json.depthWrite && (material.depthWrite = json.depthWrite), 
            void 0 !== json.colorWrite && (material.colorWrite = json.colorWrite), void 0 !== json.wireframe && (material.wireframe = json.wireframe), 
            void 0 !== json.wireframeLinewidth && (material.wireframeLinewidth = json.wireframeLinewidth), 
            void 0 !== json.wireframeLinecap && (material.wireframeLinecap = json.wireframeLinecap), 
            void 0 !== json.wireframeLinejoin && (material.wireframeLinejoin = json.wireframeLinejoin), 
            void 0 !== json.skinning && (material.skinning = json.skinning), void 0 !== json.morphTargets && (material.morphTargets = json.morphTargets), 
            void 0 !== json.dithering && (material.dithering = json.dithering), void 0 !== json.visible && (material.visible = json.visible), 
            void 0 !== json.userData && (material.userData = json.userData), void 0 !== json.shading && (material.flatShading = 1 === json.shading), 
            void 0 !== json.size && (material.size = json.size), void 0 !== json.sizeAttenuation && (material.sizeAttenuation = json.sizeAttenuation), 
            void 0 !== json.map && (material.map = getTexture(json.map)), void 0 !== json.alphaMap && (material.alphaMap = getTexture(json.alphaMap), 
            material.transparent = !0), void 0 !== json.bumpMap && (material.bumpMap = getTexture(json.bumpMap)), 
            void 0 !== json.bumpScale && (material.bumpScale = json.bumpScale), void 0 !== json.normalMap && (material.normalMap = getTexture(json.normalMap)), 
            void 0 !== json.normalScale) {
                var normalScale = json.normalScale;
                !1 === Array.isArray(normalScale) && (normalScale = [ normalScale, normalScale ]), 
                material.normalScale = new Vector2().fromArray(normalScale);
            }
            return void 0 !== json.displacementMap && (material.displacementMap = getTexture(json.displacementMap)), 
            void 0 !== json.displacementScale && (material.displacementScale = json.displacementScale), 
            void 0 !== json.displacementBias && (material.displacementBias = json.displacementBias), 
            void 0 !== json.roughnessMap && (material.roughnessMap = getTexture(json.roughnessMap)), 
            void 0 !== json.metalnessMap && (material.metalnessMap = getTexture(json.metalnessMap)), 
            void 0 !== json.emissiveMap && (material.emissiveMap = getTexture(json.emissiveMap)), 
            void 0 !== json.emissiveIntensity && (material.emissiveIntensity = json.emissiveIntensity), 
            void 0 !== json.specularMap && (material.specularMap = getTexture(json.specularMap)), 
            void 0 !== json.envMap && (material.envMap = getTexture(json.envMap)), void 0 !== json.reflectivity && (material.reflectivity = json.reflectivity), 
            void 0 !== json.lightMap && (material.lightMap = getTexture(json.lightMap)), void 0 !== json.lightMapIntensity && (material.lightMapIntensity = json.lightMapIntensity), 
            void 0 !== json.aoMap && (material.aoMap = getTexture(json.aoMap)), void 0 !== json.aoMapIntensity && (material.aoMapIntensity = json.aoMapIntensity), 
            void 0 !== json.gradientMap && (material.gradientMap = getTexture(json.gradientMap)), 
            material;
        }
    }), Object.assign(BufferGeometryLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            new FileLoader(scope.manager).load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        parse: function(json) {
            var geometry = new BufferGeometry(), index = json.data.index;
            if (void 0 !== index) {
                var typedArray = new TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
            }
            var attributes = json.data.attributes;
            for (var key in attributes) {
                var attribute = attributes[key], typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
            }
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (void 0 !== groups) for (var i = 0, n = groups.length; i !== n; ++i) {
                var group = groups[i];
                geometry.addGroup(group.start, group.count, group.materialIndex);
            }
            var boundingSphere = json.data.boundingSphere;
            if (void 0 !== boundingSphere) {
                var center = new Vector3();
                void 0 !== boundingSphere.center && center.fromArray(boundingSphere.center), geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
            }
            return geometry;
        }
    });
    var TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    Loader.Handlers = {
        handlers: [],
        add: function(regex, loader) {
            this.handlers.push(regex, loader);
        },
        get: function(file) {
            for (var handlers = this.handlers, i = 0, l = handlers.length; i < l; i += 2) {
                var regex = handlers[i], loader = handlers[i + 1];
                if (regex.test(file)) return loader;
            }
            return null;
        }
    }, Object.assign(Loader.prototype, {
        crossOrigin: void 0,
        extractUrlBase: function(url) {
            var parts = url.split("/");
            return 1 === parts.length ? "./" : (parts.pop(), parts.join("/") + "/");
        },
        initMaterials: function(materials, texturePath, crossOrigin) {
            for (var array = [], i = 0; i < materials.length; ++i) array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
            return array;
        },
        createMaterial: function() {
            var BlendingMode = {
                NoBlending: NoBlending,
                NormalBlending: NormalBlending,
                AdditiveBlending: AdditiveBlending,
                SubtractiveBlending: SubtractiveBlending,
                MultiplyBlending: MultiplyBlending,
                CustomBlending: CustomBlending
            }, color = new Color(), textureLoader = new TextureLoader(), materialLoader = new MaterialLoader();
            return function(m, texturePath, crossOrigin) {
                function loadTexture(path, repeat, offset, wrap, anisotropy) {
                    var texture, fullPath = texturePath + path, loader = Loader.Handlers.get(fullPath);
                    null !== loader ? texture = loader.load(fullPath) : (textureLoader.setCrossOrigin(crossOrigin), 
                    texture = textureLoader.load(fullPath)), void 0 !== repeat && (texture.repeat.fromArray(repeat), 
                    1 !== repeat[0] && (texture.wrapS = RepeatWrapping), 1 !== repeat[1] && (texture.wrapT = RepeatWrapping)), 
                    void 0 !== offset && texture.offset.fromArray(offset), void 0 !== wrap && ("repeat" === wrap[0] && (texture.wrapS = RepeatWrapping), 
                    "mirror" === wrap[0] && (texture.wrapS = MirroredRepeatWrapping), "repeat" === wrap[1] && (texture.wrapT = RepeatWrapping), 
                    "mirror" === wrap[1] && (texture.wrapT = MirroredRepeatWrapping)), void 0 !== anisotropy && (texture.anisotropy = anisotropy);
                    var uuid = _Math.generateUUID();
                    return textures[uuid] = texture, uuid;
                }
                var textures = {}, json = {
                    uuid: _Math.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (var name in m) {
                    var value = m[name];
                    switch (name) {
                      case "DbgColor":
                      case "DbgIndex":
                      case "opticalDensity":
                      case "illumination":
                        break;

                      case "DbgName":
                        json.name = value;
                        break;

                      case "blending":
                        json.blending = BlendingMode[value];
                        break;

                      case "colorAmbient":
                      case "mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
                        break;

                      case "colorDiffuse":
                        json.color = color.fromArray(value).getHex();
                        break;

                      case "colorSpecular":
                        json.specular = color.fromArray(value).getHex();
                        break;

                      case "colorEmissive":
                        json.emissive = color.fromArray(value).getHex();
                        break;

                      case "specularCoef":
                        json.shininess = value;
                        break;

                      case "shading":
                        "basic" === value.toLowerCase() && (json.type = "MeshBasicMaterial"), "phong" === value.toLowerCase() && (json.type = "MeshPhongMaterial"), 
                        "standard" === value.toLowerCase() && (json.type = "MeshStandardMaterial");
                        break;

                      case "mapDiffuse":
                        json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                        break;

                      case "mapDiffuseRepeat":
                      case "mapDiffuseOffset":
                      case "mapDiffuseWrap":
                      case "mapDiffuseAnisotropy":
                        break;

                      case "mapEmissive":
                        json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                        break;

                      case "mapEmissiveRepeat":
                      case "mapEmissiveOffset":
                      case "mapEmissiveWrap":
                      case "mapEmissiveAnisotropy":
                        break;

                      case "mapLight":
                        json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                        break;

                      case "mapLightRepeat":
                      case "mapLightOffset":
                      case "mapLightWrap":
                      case "mapLightAnisotropy":
                        break;

                      case "mapAO":
                        json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                        break;

                      case "mapAORepeat":
                      case "mapAOOffset":
                      case "mapAOWrap":
                      case "mapAOAnisotropy":
                        break;

                      case "mapBump":
                        json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                        break;

                      case "mapBumpScale":
                        json.bumpScale = value;
                        break;

                      case "mapBumpRepeat":
                      case "mapBumpOffset":
                      case "mapBumpWrap":
                      case "mapBumpAnisotropy":
                        break;

                      case "mapNormal":
                        json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                        break;

                      case "mapNormalFactor":
                        json.normalScale = [ value, value ];
                        break;

                      case "mapNormalRepeat":
                      case "mapNormalOffset":
                      case "mapNormalWrap":
                      case "mapNormalAnisotropy":
                        break;

                      case "mapSpecular":
                        json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                        break;

                      case "mapSpecularRepeat":
                      case "mapSpecularOffset":
                      case "mapSpecularWrap":
                      case "mapSpecularAnisotropy":
                        break;

                      case "mapMetalness":
                        json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                        break;

                      case "mapMetalnessRepeat":
                      case "mapMetalnessOffset":
                      case "mapMetalnessWrap":
                      case "mapMetalnessAnisotropy":
                        break;

                      case "mapRoughness":
                        json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                        break;

                      case "mapRoughnessRepeat":
                      case "mapRoughnessOffset":
                      case "mapRoughnessWrap":
                      case "mapRoughnessAnisotropy":
                        break;

                      case "mapAlpha":
                        json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                        break;

                      case "mapAlphaRepeat":
                      case "mapAlphaOffset":
                      case "mapAlphaWrap":
                      case "mapAlphaAnisotropy":
                        break;

                      case "flipSided":
                        json.side = BackSide;
                        break;

                      case "doubleSided":
                        json.side = DoubleSide;
                        break;

                      case "transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), 
                        json.opacity = value;
                        break;

                      case "depthTest":
                      case "depthWrite":
                      case "colorWrite":
                      case "opacity":
                      case "reflectivity":
                      case "transparent":
                      case "visible":
                      case "wireframe":
                        json[name] = value;
                        break;

                      case "vertexColors":
                        !0 === value && (json.vertexColors = VertexColors), "face" === value && (json.vertexColors = FaceColors);
                        break;

                      default:
                        console.error("THREE.Loader.createMaterial: Unsupported", name, value);
                    }
                }
                return "MeshBasicMaterial" === json.type && delete json.emissive, "MeshPhongMaterial" !== json.type && delete json.specular, 
                json.opacity < 1 && (json.transparent = !0), materialLoader.setTextures(textures), 
                materialLoader.parse(json);
            };
        }()
    }), Object.assign(JSONLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, texturePath = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Loader.prototype.extractUrlBase(url), loader = new FileLoader(this.manager);
            loader.setWithCredentials(this.withCredentials), loader.load(url, function(text) {
                var json = JSON.parse(text), metadata = json.metadata;
                if (void 0 !== metadata) {
                    var type = metadata.type;
                    if (void 0 !== type) {
                        if ("object" === type.toLowerCase()) return void console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === type.toLowerCase()) return void console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.SceneLoader instead.");
                    }
                }
                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        parse: function() {
            function parseModel(json, geometry) {
                function isBitSet(value, position) {
                    return value & 1 << position;
                }
                var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, scale = json.scale, nUvLayers = 0;
                if (void 0 !== json.uvs) {
                    for (i = 0; i < json.uvs.length; i++) json.uvs[i].length && nUvLayers++;
                    for (i = 0; i < nUvLayers; i++) geometry.faceVertexUvs[i] = [];
                }
                for (offset = 0, zLength = vertices.length; offset < zLength; ) vertex = new Vector3(), 
                vertex.x = vertices[offset++] * scale, vertex.y = vertices[offset++] * scale, vertex.z = vertices[offset++] * scale, 
                geometry.vertices.push(vertex);
                for (offset = 0, zLength = faces.length; offset < zLength; ) if (type = faces[offset++], 
                isQuad = isBitSet(type, 0), hasMaterial = isBitSet(type, 1), hasFaceVertexUv = isBitSet(type, 3), 
                hasFaceNormal = isBitSet(type, 4), hasFaceVertexNormal = isBitSet(type, 5), hasFaceColor = isBitSet(type, 6), 
                hasFaceVertexColor = isBitSet(type, 7), isQuad) {
                    if (faceA = new Face3(), faceA.a = faces[offset], faceA.b = faces[offset + 1], faceA.c = faces[offset + 3], 
                    faceB = new Face3(), faceB.a = faces[offset + 1], faceB.b = faces[offset + 2], faceB.c = faces[offset + 3], 
                    offset += 4, hasMaterial && (materialIndex = faces[offset++], faceA.materialIndex = materialIndex, 
                    faceB.materialIndex = materialIndex), fi = geometry.faces.length, hasFaceVertexUv) for (i = 0; i < nUvLayers; i++) for (uvLayer = json.uvs[i], 
                    geometry.faceVertexUvs[i][fi] = [], geometry.faceVertexUvs[i][fi + 1] = [], j = 0; j < 4; j++) uvIndex = faces[offset++], 
                    u = uvLayer[2 * uvIndex], v = uvLayer[2 * uvIndex + 1], uv = new Vector2(u, v), 
                    2 !== j && geometry.faceVertexUvs[i][fi].push(uv), 0 !== j && geometry.faceVertexUvs[i][fi + 1].push(uv);
                    if (hasFaceNormal && (normalIndex = 3 * faces[offset++], faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]), 
                    faceB.normal.copy(faceA.normal)), hasFaceVertexNormal) for (i = 0; i < 4; i++) normalIndex = 3 * faces[offset++], 
                    normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]), 
                    2 !== i && faceA.vertexNormals.push(normal), 0 !== i && faceB.vertexNormals.push(normal);
                    if (hasFaceColor && (colorIndex = faces[offset++], hex = colors[colorIndex], faceA.color.setHex(hex), 
                    faceB.color.setHex(hex)), hasFaceVertexColor) for (i = 0; i < 4; i++) colorIndex = faces[offset++], 
                    hex = colors[colorIndex], 2 !== i && faceA.vertexColors.push(new Color(hex)), 0 !== i && faceB.vertexColors.push(new Color(hex));
                    geometry.faces.push(faceA), geometry.faces.push(faceB);
                } else {
                    if (face = new Face3(), face.a = faces[offset++], face.b = faces[offset++], face.c = faces[offset++], 
                    hasMaterial && (materialIndex = faces[offset++], face.materialIndex = materialIndex), 
                    fi = geometry.faces.length, hasFaceVertexUv) for (i = 0; i < nUvLayers; i++) for (uvLayer = json.uvs[i], 
                    geometry.faceVertexUvs[i][fi] = [], j = 0; j < 3; j++) uvIndex = faces[offset++], 
                    u = uvLayer[2 * uvIndex], v = uvLayer[2 * uvIndex + 1], uv = new Vector2(u, v), 
                    geometry.faceVertexUvs[i][fi].push(uv);
                    if (hasFaceNormal && (normalIndex = 3 * faces[offset++], face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex])), 
                    hasFaceVertexNormal) for (i = 0; i < 3; i++) normalIndex = 3 * faces[offset++], 
                    normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]), 
                    face.vertexNormals.push(normal);
                    if (hasFaceColor && (colorIndex = faces[offset++], face.color.setHex(colors[colorIndex])), 
                    hasFaceVertexColor) for (i = 0; i < 3; i++) colorIndex = faces[offset++], face.vertexColors.push(new Color(colors[colorIndex]));
                    geometry.faces.push(face);
                }
            }
            function parseSkin(json, geometry) {
                var influencesPerVertex = void 0 !== json.influencesPerVertex ? json.influencesPerVertex : 2;
                if (json.skinWeights) for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                    var x = json.skinWeights[i], y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0, z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0, w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
                    geometry.skinWeights.push(new Vector4(x, y, z, w));
                }
                if (json.skinIndices) for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                    var a = json.skinIndices[i], b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0, c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0, d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
                    geometry.skinIndices.push(new Vector4(a, b, c, d));
                }
                geometry.bones = json.bones, geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length) && console.warn("When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.");
            }
            function parseMorphing(json, geometry) {
                var scale = json.scale;
                if (void 0 !== json.morphTargets) for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                    geometry.morphTargets[i] = {}, geometry.morphTargets[i].name = json.morphTargets[i].name, 
                    geometry.morphTargets[i].vertices = [];
                    for (var dstVertices = geometry.morphTargets[i].vertices, srcVertices = json.morphTargets[i].vertices, v = 0, vl = srcVertices.length; v < vl; v += 3) {
                        var vertex = new Vector3();
                        vertex.x = srcVertices[v] * scale, vertex.y = srcVertices[v + 1] * scale, vertex.z = srcVertices[v + 2] * scale, 
                        dstVertices.push(vertex);
                    }
                }
                if (void 0 !== json.morphColors && json.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    for (var faces = geometry.faces, morphColors = json.morphColors[0].colors, i = 0, l = faces.length; i < l; i++) faces[i].color.fromArray(morphColors, 3 * i);
                }
            }
            function parseAnimations(json, geometry) {
                var outputAnimations = [], animations = [];
                void 0 !== json.animation && animations.push(json.animation), void 0 !== json.animations && (json.animations.length ? animations = animations.concat(json.animations) : animations.push(json.animations));
                for (var i = 0; i < animations.length; i++) {
                    var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                    clip && outputAnimations.push(clip);
                }
                if (geometry.morphTargets) {
                    var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                    outputAnimations = outputAnimations.concat(morphAnimationClips);
                }
                outputAnimations.length > 0 && (geometry.animations = outputAnimations);
            }
            return function(json, texturePath) {
                void 0 !== json.data && (json = json.data), void 0 !== json.scale ? json.scale = 1 / json.scale : json.scale = 1;
                var geometry = new Geometry();
                return parseModel(json, geometry), parseSkin(json, geometry), parseMorphing(json, geometry), 
                parseAnimations(json, geometry), geometry.computeFaceNormals(), geometry.computeBoundingSphere(), 
                void 0 === json.materials || 0 === json.materials.length ? {
                    geometry: geometry
                } : {
                    geometry: geometry,
                    materials: Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin)
                };
            };
        }()
    }), Object.assign(ObjectLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            "" === this.texturePath && (this.texturePath = url.substring(0, url.lastIndexOf("/") + 1));
            var scope = this;
            new FileLoader(scope.manager).load(url, function(text) {
                var json = null;
                try {
                    json = JSON.parse(text);
                } catch (error) {
                    return void 0 !== onError && onError(error), void console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
                }
                var metadata = json.metadata;
                if (void 0 === metadata || void 0 === metadata.type || "geometry" === metadata.type.toLowerCase()) return void console.error("THREE.ObjectLoader: Can't load " + url + ". Use THREE.JSONLoader instead.");
                scope.parse(json, onLoad);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
        },
        parse: function(json, onLoad) {
            var geometries = this.parseGeometries(json.geometries), images = this.parseImages(json.images, function() {
                void 0 !== onLoad && onLoad(object);
            }), textures = this.parseTextures(json.textures, images), materials = this.parseMaterials(json.materials, textures), object = this.parseObject(json.object, geometries, materials);
            return json.animations && (object.animations = this.parseAnimations(json.animations)), 
            void 0 !== json.images && 0 !== json.images.length || void 0 !== onLoad && onLoad(object), 
            object;
        },
        parseGeometries: function(json) {
            var geometries = {};
            if (void 0 !== json) for (var geometryLoader = new JSONLoader(), bufferGeometryLoader = new BufferGeometryLoader(), i = 0, l = json.length; i < l; i++) {
                var geometry, data = json[i];
                switch (data.type) {
                  case "PlaneGeometry":
                  case "PlaneBufferGeometry":
                    geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                    break;

                  case "BoxGeometry":
                  case "BoxBufferGeometry":
                  case "CubeGeometry":
                    geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                    break;

                  case "CircleGeometry":
                  case "CircleBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                    break;

                  case "CylinderGeometry":
                  case "CylinderBufferGeometry":
                    geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    break;

                  case "ConeGeometry":
                  case "ConeBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    break;

                  case "SphereGeometry":
                  case "SphereBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                    break;

                  case "DodecahedronGeometry":
                  case "IcosahedronGeometry":
                  case "OctahedronGeometry":
                  case "TetrahedronGeometry":
                    geometry = new Geometries[data.type](data.radius, data.detail);
                    break;

                  case "RingGeometry":
                  case "RingBufferGeometry":
                    geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                    break;

                  case "TorusGeometry":
                  case "TorusBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                    break;

                  case "TorusKnotGeometry":
                  case "TorusKnotBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                    break;

                  case "LatheGeometry":
                  case "LatheBufferGeometry":
                    geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                    break;

                  case "BufferGeometry":
                    geometry = bufferGeometryLoader.parse(data);
                    break;

                  case "Geometry":
                    geometry = geometryLoader.parse(data, this.texturePath).geometry;
                    break;

                  default:
                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                    continue;
                }
                geometry.uuid = data.uuid, void 0 !== data.name && (geometry.name = data.name), 
                geometries[data.uuid] = geometry;
            }
            return geometries;
        },
        parseMaterials: function(json, textures) {
            var materials = {};
            if (void 0 !== json) {
                var loader = new MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if ("MultiMaterial" === data.type) {
                        for (var array = [], j = 0; j < data.materials.length; j++) array.push(loader.parse(data.materials[j]));
                        materials[data.uuid] = array;
                    } else materials[data.uuid] = loader.parse(data);
                }
            }
            return materials;
        },
        parseAnimations: function(json) {
            for (var animations = [], i = 0; i < json.length; i++) {
                var clip = AnimationClip.parse(json[i]);
                animations.push(clip);
            }
            return animations;
        },
        parseImages: function(json, onLoad) {
            var scope = this, images = {};
            if (void 0 !== json && json.length > 0) {
                var manager = new LoadingManager(onLoad), loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, l = json.length; i < l; i++) {
                    var image = json[i], path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                    images[image.uuid] = function(url) {
                        return scope.manager.itemStart(url), loader.load(url, function() {
                            scope.manager.itemEnd(url);
                        }, void 0, function() {
                            scope.manager.itemEnd(url), scope.manager.itemError(url);
                        });
                    }(path);
                }
            }
            return images;
        },
        parseTextures: function(json, images) {
            function parseConstant(value, type) {
                return "number" == typeof value ? value : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value), 
                type[value]);
            }
            var textures = {};
            if (void 0 !== json) for (var i = 0, l = json.length; i < l; i++) {
                var data = json[i];
                void 0 === data.image && console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid), 
                void 0 === images[data.image] && console.warn("THREE.ObjectLoader: Undefined image", data.image);
                var texture = new Texture(images[data.image]);
                texture.needsUpdate = !0, texture.uuid = data.uuid, void 0 !== data.name && (texture.name = data.name), 
                void 0 !== data.mapping && (texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING)), 
                void 0 !== data.offset && texture.offset.fromArray(data.offset), void 0 !== data.repeat && texture.repeat.fromArray(data.repeat), 
                void 0 !== data.wrap && (texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING), 
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING)), void 0 !== data.minFilter && (texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER)), 
                void 0 !== data.magFilter && (texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER)), 
                void 0 !== data.anisotropy && (texture.anisotropy = data.anisotropy), void 0 !== data.flipY && (texture.flipY = data.flipY), 
                textures[data.uuid] = texture;
            }
            return textures;
        },
        parseObject: function() {
            var matrix = new Matrix4();
            return function(data, geometries, materials) {
                function getGeometry(name) {
                    return void 0 === geometries[name] && console.warn("THREE.ObjectLoader: Undefined geometry", name), 
                    geometries[name];
                }
                function getMaterial(name) {
                    if (void 0 !== name) {
                        if (Array.isArray(name)) {
                            for (var array = [], i = 0, l = name.length; i < l; i++) {
                                var uuid = name[i];
                                void 0 === materials[uuid] && console.warn("THREE.ObjectLoader: Undefined material", uuid), 
                                array.push(materials[uuid]);
                            }
                            return array;
                        }
                        return void 0 === materials[name] && console.warn("THREE.ObjectLoader: Undefined material", name), 
                        materials[name];
                    }
                }
                var object;
                switch (data.type) {
                  case "Scene":
                    object = new Scene(), void 0 !== data.background && Number.isInteger(data.background) && (object.background = new Color(data.background)), 
                    void 0 !== data.fog && ("Fog" === data.fog.type ? object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far) : "FogExp2" === data.fog.type && (object.fog = new FogExp2(data.fog.color, data.fog.density)));
                    break;

                  case "PerspectiveCamera":
                    object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far), void 0 !== data.focus && (object.focus = data.focus), 
                    void 0 !== data.zoom && (object.zoom = data.zoom), void 0 !== data.filmGauge && (object.filmGauge = data.filmGauge), 
                    void 0 !== data.filmOffset && (object.filmOffset = data.filmOffset), void 0 !== data.view && (object.view = Object.assign({}, data.view));
                    break;

                  case "OrthographicCamera":
                    object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    break;

                  case "AmbientLight":
                    object = new AmbientLight(data.color, data.intensity);
                    break;

                  case "DirectionalLight":
                    object = new DirectionalLight(data.color, data.intensity);
                    break;

                  case "PointLight":
                    object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;

                  case "RectAreaLight":
                    object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                    break;

                  case "SpotLight":
                    object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    break;

                  case "HemisphereLight":
                    object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;

                  case "SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");

                  case "Mesh":
                    var geometry = getGeometry(data.geometry), material = getMaterial(data.material);
                    object = geometry.bones && geometry.bones.length > 0 ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
                    break;

                  case "LOD":
                    object = new LOD();
                    break;

                  case "Line":
                    object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                    break;

                  case "LineLoop":
                    object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "LineSegments":
                    object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "PointCloud":
                  case "Points":
                    object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "Sprite":
                    object = new Sprite(getMaterial(data.material));
                    break;

                  case "Group":
                    object = new Group();
                    break;

                  default:
                    object = new Object3D();
                }
                if (object.uuid = data.uuid, void 0 !== data.name && (object.name = data.name), 
                void 0 !== data.matrix ? (matrix.fromArray(data.matrix), matrix.decompose(object.position, object.quaternion, object.scale)) : (void 0 !== data.position && object.position.fromArray(data.position), 
                void 0 !== data.rotation && object.rotation.fromArray(data.rotation), void 0 !== data.quaternion && object.quaternion.fromArray(data.quaternion), 
                void 0 !== data.scale && object.scale.fromArray(data.scale)), void 0 !== data.castShadow && (object.castShadow = data.castShadow), 
                void 0 !== data.receiveShadow && (object.receiveShadow = data.receiveShadow), data.shadow && (void 0 !== data.shadow.bias && (object.shadow.bias = data.shadow.bias), 
                void 0 !== data.shadow.radius && (object.shadow.radius = data.shadow.radius), void 0 !== data.shadow.mapSize && object.shadow.mapSize.fromArray(data.shadow.mapSize), 
                void 0 !== data.shadow.camera && (object.shadow.camera = this.parseObject(data.shadow.camera))), 
                void 0 !== data.visible && (object.visible = data.visible), void 0 !== data.userData && (object.userData = data.userData), 
                void 0 !== data.children) for (var children = data.children, i = 0; i < children.length; i++) object.add(this.parseObject(children[i], geometries, materials));
                if ("LOD" === data.type) for (var levels = data.levels, l = 0; l < levels.length; l++) {
                    var level = levels[l], child = object.getObjectByProperty("uuid", level.object);
                    void 0 !== child && object.addLevel(child, level.distance);
                }
                return object;
            };
        }()
    });
    var TEXTURE_MAPPING = {
        UVMapping: 300,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    }, TEXTURE_WRAPPING = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    }, TEXTURE_FILTER = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    };
    Object.assign(Curve.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null;
        },
        getPointAt: function(u) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t);
        },
        getPoints: function(divisions) {
            void 0 === divisions && (divisions = 5);
            for (var points = [], d = 0; d <= divisions; d++) points.push(this.getPoint(d / divisions));
            return points;
        },
        getSpacedPoints: function(divisions) {
            void 0 === divisions && (divisions = 5);
            for (var points = [], d = 0; d <= divisions; d++) points.push(this.getPointAt(d / divisions));
            return points;
        },
        getLength: function() {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        },
        getLengths: function(divisions) {
            if (void 0 === divisions && (divisions = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var current, p, cache = [], last = this.getPoint(0), sum = 0;
            for (cache.push(0), p = 1; p <= divisions; p++) current = this.getPoint(p / divisions), 
            sum += current.distanceTo(last), cache.push(sum), last = current;
            return this.cacheArcLengths = cache, cache;
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths();
        },
        getUtoTmapping: function(u, distance) {
            var targetArcLength, arcLengths = this.getLengths(), i = 0, il = arcLengths.length;
            targetArcLength = distance || u * arcLengths[il - 1];
            for (var comparison, low = 0, high = il - 1; low <= high; ) if (i = Math.floor(low + (high - low) / 2), 
            (comparison = arcLengths[i] - targetArcLength) < 0) low = i + 1; else {
                if (!(comparison > 0)) {
                    high = i;
                    break;
                }
                high = i - 1;
            }
            if (i = high, arcLengths[i] === targetArcLength) return i / (il - 1);
            var lengthBefore = arcLengths[i];
            return (i + (targetArcLength - lengthBefore) / (arcLengths[i + 1] - lengthBefore)) / (il - 1);
        },
        getTangent: function(t) {
            var t1 = t - 1e-4, t2 = t + 1e-4;
            t1 < 0 && (t1 = 0), t2 > 1 && (t2 = 1);
            var pt1 = this.getPoint(t1);
            return this.getPoint(t2).clone().sub(pt1).normalize();
        },
        getTangentAt: function(u) {
            var t = this.getUtoTmapping(u);
            return this.getTangent(t);
        },
        computeFrenetFrames: function(segments, closed) {
            var i, u, theta, normal = new Vector3(), tangents = [], normals = [], binormals = [], vec = new Vector3(), mat = new Matrix4();
            for (i = 0; i <= segments; i++) u = i / segments, tangents[i] = this.getTangentAt(u), 
            tangents[i].normalize();
            normals[0] = new Vector3(), binormals[0] = new Vector3();
            var min = Number.MAX_VALUE, tx = Math.abs(tangents[0].x), ty = Math.abs(tangents[0].y), tz = Math.abs(tangents[0].z);
            for (tx <= min && (min = tx, normal.set(1, 0, 0)), ty <= min && (min = ty, normal.set(0, 1, 0)), 
            tz <= min && normal.set(0, 0, 1), vec.crossVectors(tangents[0], normal).normalize(), 
            normals[0].crossVectors(tangents[0], vec), binormals[0].crossVectors(tangents[0], normals[0]), 
            i = 1; i <= segments; i++) normals[i] = normals[i - 1].clone(), binormals[i] = binormals[i - 1].clone(), 
            vec.crossVectors(tangents[i - 1], tangents[i]), vec.length() > Number.EPSILON && (vec.normalize(), 
            theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)), normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))), 
            binormals[i].crossVectors(tangents[i], normals[i]);
            if (!0 === closed) for (theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1)), 
            theta /= segments, tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0 && (theta = -theta), 
            i = 1; i <= segments; i++) normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i)), 
            binormals[i].crossVectors(tangents[i], normals[i]);
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        }
    }), LineCurve.prototype = Object.create(Curve.prototype), LineCurve.prototype.constructor = LineCurve, 
    LineCurve.prototype.isLineCurve = !0, LineCurve.prototype.getPoint = function(t) {
        if (1 === t) return this.v2.clone();
        var point = this.v2.clone().sub(this.v1);
        return point.multiplyScalar(t).add(this.v1), point;
    }, LineCurve.prototype.getPointAt = function(u) {
        return this.getPoint(u);
    }, LineCurve.prototype.getTangent = function(t) {
        return this.v2.clone().sub(this.v1).normalize();
    }, CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
        constructor: CurvePath,
        add: function(curve) {
            this.curves.push(curve);
        },
        closePath: function() {
            var startPoint = this.curves[0].getPoint(0), endPoint = this.curves[this.curves.length - 1].getPoint(1);
            startPoint.equals(endPoint) || this.curves.push(new LineCurve(endPoint, startPoint));
        },
        getPoint: function(t) {
            for (var d = t * this.getLength(), curveLengths = this.getCurveLengths(), i = 0; i < curveLengths.length; ) {
                if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d, curve = this.curves[i], segmentLength = curve.getLength(), u = 0 === segmentLength ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u);
                }
                i++;
            }
            return null;
        },
        getLength: function() {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var lengths = [], sums = 0, i = 0, l = this.curves.length; i < l; i++) sums += this.curves[i].getLength(), 
            lengths.push(sums);
            return this.cacheLengths = lengths, lengths;
        },
        getSpacedPoints: function(divisions) {
            void 0 === divisions && (divisions = 40);
            for (var points = [], i = 0; i <= divisions; i++) points.push(this.getPoint(i / divisions));
            return this.autoClose && points.push(points[0]), points;
        },
        getPoints: function(divisions) {
            divisions = divisions || 12;
            for (var last, points = [], i = 0, curves = this.curves; i < curves.length; i++) for (var curve = curves[i], resolution = curve && curve.isEllipseCurve ? 2 * divisions : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions, pts = curve.getPoints(resolution), j = 0; j < pts.length; j++) {
                var point = pts[j];
                last && last.equals(point) || (points.push(point), last = point);
            }
            return this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0]) && points.push(points[0]), 
            points;
        },
        createPointsGeometry: function(divisions) {
            var pts = this.getPoints(divisions);
            return this.createGeometry(pts);
        },
        createSpacedPointsGeometry: function(divisions) {
            var pts = this.getSpacedPoints(divisions);
            return this.createGeometry(pts);
        },
        createGeometry: function(points) {
            for (var geometry = new Geometry(), i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }
            return geometry;
        }
    }), EllipseCurve.prototype = Object.create(Curve.prototype), EllipseCurve.prototype.constructor = EllipseCurve, 
    EllipseCurve.prototype.isEllipseCurve = !0, EllipseCurve.prototype.getPoint = function(t) {
        for (var twoPi = 2 * Math.PI, deltaAngle = this.aEndAngle - this.aStartAngle, samePoints = Math.abs(deltaAngle) < Number.EPSILON; deltaAngle < 0; ) deltaAngle += twoPi;
        for (;deltaAngle > twoPi; ) deltaAngle -= twoPi;
        deltaAngle < Number.EPSILON && (deltaAngle = samePoints ? 0 : twoPi), !0 !== this.aClockwise || samePoints || (deltaAngle === twoPi ? deltaAngle = -twoPi : deltaAngle -= twoPi);
        var angle = this.aStartAngle + t * deltaAngle, x = this.aX + this.xRadius * Math.cos(angle), y = this.aY + this.yRadius * Math.sin(angle);
        if (0 !== this.aRotation) {
            var cos = Math.cos(this.aRotation), sin = Math.sin(this.aRotation), tx = x - this.aX, ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX, y = tx * sin + ty * cos + this.aY;
        }
        return new Vector2(x, y);
    }, SplineCurve.prototype = Object.create(Curve.prototype), SplineCurve.prototype.constructor = SplineCurve, 
    SplineCurve.prototype.isSplineCurve = !0, SplineCurve.prototype.getPoint = function(t) {
        var points = this.points, point = (points.length - 1) * t, intPoint = Math.floor(point), weight = point - intPoint, point0 = points[0 === intPoint ? intPoint : intPoint - 1], point1 = points[intPoint], point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1], point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        return new Vector2(CatmullRom(weight, point0.x, point1.x, point2.x, point3.x), CatmullRom(weight, point0.y, point1.y, point2.y, point3.y));
    }, CubicBezierCurve.prototype = Object.create(Curve.prototype), CubicBezierCurve.prototype.constructor = CubicBezierCurve, 
    CubicBezierCurve.prototype.getPoint = function(t) {
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        return new Vector2(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
    }, QuadraticBezierCurve.prototype = Object.create(Curve.prototype), QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve, 
    QuadraticBezierCurve.prototype.getPoint = function(t) {
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
        return new Vector2(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    };
    var PathPrototype = Object.assign(Object.create(CurvePath.prototype), {
        fromPoints: function(vectors) {
            this.moveTo(vectors[0].x, vectors[0].y);
            for (var i = 1, l = vectors.length; i < l; i++) this.lineTo(vectors[i].x, vectors[i].y);
        },
        moveTo: function(x, y) {
            this.currentPoint.set(x, y);
        },
        lineTo: function(x, y) {
            var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
            this.curves.push(curve), this.currentPoint.set(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
            this.curves.push(curve), this.currentPoint.set(aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
            this.curves.push(curve), this.currentPoint.set(aX, aY);
        },
        splineThru: function(pts) {
            var npts = [ this.currentPoint.clone() ].concat(pts), curve = new SplineCurve(npts);
            this.curves.push(curve), this.currentPoint.copy(pts[pts.length - 1]);
        },
        arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var x0 = this.currentPoint.x, y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var x0 = this.currentPoint.x, y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        },
        absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                var firstPoint = curve.getPoint(0);
                firstPoint.equals(this.currentPoint) || this.lineTo(firstPoint.x, firstPoint.y);
            }
            this.curves.push(curve);
            var lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
        }
    });
    Path.prototype = PathPrototype, PathPrototype.constructor = Path, Shape.prototype = Object.assign(Object.create(PathPrototype), {
        constructor: Shape,
        getPointsHoles: function(divisions) {
            for (var holesPts = [], i = 0, l = this.holes.length; i < l; i++) holesPts[i] = this.holes[i].getPoints(divisions);
            return holesPts;
        },
        extractAllPoints: function(divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        },
        extractPoints: function(divisions) {
            return this.extractAllPoints(divisions);
        }
    }), Object.assign(ShapePath.prototype, {
        moveTo: function(x, y) {
            this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(x, y);
        },
        lineTo: function(x, y) {
            this.currentPath.lineTo(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        },
        splineThru: function(pts) {
            this.currentPath.splineThru(pts);
        },
        toShapes: function(isCCW, noHoles) {
            function toShapesNoHoles(inSubpaths) {
                for (var shapes = [], i = 0, l = inSubpaths.length; i < l; i++) {
                    var tmpPath = inSubpaths[i], tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves, shapes.push(tmpShape);
                }
                return shapes;
            }
            var isClockWise = ShapeUtils.isClockWise, subPaths = this.subPaths;
            if (0 === subPaths.length) return [];
            if (!0 === noHoles) return toShapesNoHoles(subPaths);
            var solid, tmpPath, tmpShape, shapes = [];
            if (1 === subPaths.length) return tmpPath = subPaths[0], tmpShape = new Shape(), 
            tmpShape.curves = tmpPath.curves, shapes.push(tmpShape), shapes;
            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;
            var tmpPoints, betterShapeHoles = [], newShapes = [], newShapeHoles = [], mainIdx = 0;
            newShapes[mainIdx] = void 0, newShapeHoles[mainIdx] = [];
            for (var i = 0, l = subPaths.length; i < l; i++) tmpPath = subPaths[i], tmpPoints = tmpPath.getPoints(), 
            solid = isClockWise(tmpPoints), solid = isCCW ? !solid : solid, solid ? (!holesFirst && newShapes[mainIdx] && mainIdx++, 
            newShapes[mainIdx] = {
                s: new Shape(),
                p: tmpPoints
            }, newShapes[mainIdx].s.curves = tmpPath.curves, holesFirst && mainIdx++, newShapeHoles[mainIdx] = []) : newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
            if (!newShapes[0]) return toShapesNoHoles(subPaths);
            if (newShapes.length > 1) {
                for (var ambiguous = !1, toChange = [], sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) betterShapeHoles[sIdx] = [];
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) for (var sho = newShapeHoles[sIdx], hIdx = 0; hIdx < sho.length; hIdx++) {
                    for (var ho = sho[hIdx], hole_unassigned = !0, s2Idx = 0; s2Idx < newShapes.length; s2Idx++) (function(inPt, inPolygon) {
                        for (var polyLen = inPolygon.length, inside = !1, p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                            var edgeLowPt = inPolygon[p], edgeHighPt = inPolygon[q], edgeDx = edgeHighPt.x - edgeLowPt.x, edgeDy = edgeHighPt.y - edgeLowPt.y;
                            if (Math.abs(edgeDy) > Number.EPSILON) {
                                if (edgeDy < 0 && (edgeLowPt = inPolygon[q], edgeDx = -edgeDx, edgeHighPt = inPolygon[p], 
                                edgeDy = -edgeDy), inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                                if (inPt.y === edgeLowPt.y) {
                                    if (inPt.x === edgeLowPt.x) return !0;
                                } else {
                                    var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                                    if (0 === perpEdge) return !0;
                                    if (perpEdge < 0) continue;
                                    inside = !inside;
                                }
                            } else {
                                if (inPt.y !== edgeLowPt.y) continue;
                                if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return !0;
                            }
                        }
                        return inside;
                    })(ho.p, newShapes[s2Idx].p) && (sIdx !== s2Idx && toChange.push({
                        froms: sIdx,
                        tos: s2Idx,
                        hole: hIdx
                    }), hole_unassigned ? (hole_unassigned = !1, betterShapeHoles[s2Idx].push(ho)) : ambiguous = !0);
                    hole_unassigned && betterShapeHoles[sIdx].push(ho);
                }
                toChange.length > 0 && (ambiguous || (newShapeHoles = betterShapeHoles));
            }
            for (var tmpHoles, i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s, shapes.push(tmpShape), tmpHoles = newShapeHoles[i];
                for (var j = 0, jl = tmpHoles.length; j < jl; j++) tmpShape.holes.push(tmpHoles[j].h);
            }
            return shapes;
        }
    }), Object.assign(Font.prototype, {
        isFont: !0,
        generateShapes: function(text, size, divisions) {
            function createPath(c, scale, offsetX, offsetY) {
                var glyph = data.glyphs[c] || data.glyphs["?"];
                if (glyph) {
                    var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste, path = new ShapePath(), pts = [];
                    if (glyph.o) for (var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" ")), i = 0, l = outline.length; i < l; ) {
                        var action = outline[i++];
                        switch (action) {
                          case "m":
                            x = outline[i++] * scale + offsetX, y = outline[i++] * scale + offsetY, path.moveTo(x, y);
                            break;

                          case "l":
                            x = outline[i++] * scale + offsetX, y = outline[i++] * scale + offsetY, path.lineTo(x, y);
                            break;

                          case "q":
                            if (cpx = outline[i++] * scale + offsetX, cpy = outline[i++] * scale + offsetY, 
                            cpx1 = outline[i++] * scale + offsetX, cpy1 = outline[i++] * scale + offsetY, path.quadraticCurveTo(cpx1, cpy1, cpx, cpy), 
                            laste = pts[pts.length - 1]) {
                                cpx0 = laste.x, cpy0 = laste.y;
                                for (var i2 = 1; i2 <= divisions; i2++) {
                                    var t = i2 / divisions;
                                    QuadraticBezier(t, cpx0, cpx1, cpx), QuadraticBezier(t, cpy0, cpy1, cpy);
                                }
                            }
                            break;

                          case "b":
                            if (cpx = outline[i++] * scale + offsetX, cpy = outline[i++] * scale + offsetY, 
                            cpx1 = outline[i++] * scale + offsetX, cpy1 = outline[i++] * scale + offsetY, cpx2 = outline[i++] * scale + offsetX, 
                            cpy2 = outline[i++] * scale + offsetY, path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy), 
                            laste = pts[pts.length - 1]) {
                                cpx0 = laste.x, cpy0 = laste.y;
                                for (var i2 = 1; i2 <= divisions; i2++) {
                                    var t = i2 / divisions;
                                    CubicBezier(t, cpx0, cpx1, cpx2, cpx), CubicBezier(t, cpy0, cpy1, cpy2, cpy);
                                }
                            }
                        }
                    }
                    return {
                        offsetX: glyph.ha * scale,
                        path: path
                    };
                }
            }
            void 0 === size && (size = 100), void 0 === divisions && (divisions = 4);
            for (var data = this.data, paths = function(text) {
                for (var chars = String(text).split(""), scale = size / data.resolution, line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale, offsetX = 0, offsetY = 0, paths = [], i = 0; i < chars.length; i++) {
                    var char = chars[i];
                    if ("\n" === char) offsetX = 0, offsetY -= line_height; else {
                        var ret = createPath(char, scale, offsetX, offsetY);
                        offsetX += ret.offsetX, paths.push(ret.path);
                    }
                }
                return paths;
            }(text), shapes = [], p = 0, pl = paths.length; p < pl; p++) Array.prototype.push.apply(shapes, paths[p].toShapes());
            return shapes;
        }
    }), Object.assign(FontLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            new FileLoader(this.manager).load(url, function(text) {
                var json;
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), 
                    json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                onLoad && onLoad(font);
            }, onProgress, onError);
        },
        parse: function(json) {
            return new Font(json);
        }
    });
    var context, AudioContext = {
        getContext: function() {
            return void 0 === context && (context = new (window.AudioContext || window.webkitAudioContext)()), 
            context;
        },
        setContext: function(value) {
            context = value;
        }
    };
    Object.assign(AudioLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var loader = new FileLoader(this.manager);
            loader.setResponseType("arraybuffer"), loader.load(url, function(buffer) {
                AudioContext.getContext().decodeAudioData(buffer, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            }, onProgress, onError);
        }
    }), Object.assign(StereoCamera.prototype, {
        update: function() {
            var instance, focus, fov, aspect, near, far, zoom, eyeSep, eyeRight = new Matrix4(), eyeLeft = new Matrix4();
            return function(camera) {
                if (instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep) {
                    instance = this, focus = camera.focus, fov = camera.fov, aspect = camera.aspect * this.aspect, 
                    near = camera.near, far = camera.far, zoom = camera.zoom;
                    var projectionMatrix = camera.projectionMatrix.clone();
                    eyeSep = this.eyeSep / 2;
                    var xmin, xmax, eyeSepOnProjection = eyeSep * near / focus, ymax = near * Math.tan(_Math.DEG2RAD * fov * .5) / zoom;
                    eyeLeft.elements[12] = -eyeSep, eyeRight.elements[12] = eyeSep, xmin = -ymax * aspect + eyeSepOnProjection, 
                    xmax = ymax * aspect + eyeSepOnProjection, projectionMatrix.elements[0] = 2 * near / (xmax - xmin), 
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin), this.cameraL.projectionMatrix.copy(projectionMatrix), 
                    xmin = -ymax * aspect - eyeSepOnProjection, xmax = ymax * aspect - eyeSepOnProjection, 
                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin), projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin), 
                    this.cameraR.projectionMatrix.copy(projectionMatrix);
                }
                this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft), this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
            };
        }()
    }), CubeCamera.prototype = Object.create(Object3D.prototype), CubeCamera.prototype.constructor = CubeCamera, 
    AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: AudioListener,
        getInput: function() {
            return this.gain;
        },
        removeFilter: function() {
            null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), 
            this.gain.connect(this.context.destination), this.filter = null);
        },
        getFilter: function() {
            return this.filter;
        },
        setFilter: function(value) {
            null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), 
            this.filter = value, this.gain.connect(this.filter), this.filter.connect(this.context.destination);
        },
        getMasterVolume: function() {
            return this.gain.gain.value;
        },
        setMasterVolume: function(value) {
            this.gain.gain.value = value;
        },
        updateMatrixWorld: function() {
            var position = new Vector3(), quaternion = new Quaternion(), scale = new Vector3(), orientation = new Vector3();
            return function(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                var listener = this.context.listener, up = this.up;
                this.matrixWorld.decompose(position, quaternion, scale), orientation.set(0, 0, -1).applyQuaternion(quaternion), 
                listener.positionX ? (listener.positionX.setValueAtTime(position.x, this.context.currentTime), 
                listener.positionY.setValueAtTime(position.y, this.context.currentTime), listener.positionZ.setValueAtTime(position.z, this.context.currentTime), 
                listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime), listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime), 
                listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime), listener.upX.setValueAtTime(up.x, this.context.currentTime), 
                listener.upY.setValueAtTime(up.y, this.context.currentTime), listener.upZ.setValueAtTime(up.z, this.context.currentTime)) : (listener.setPosition(position.x, position.y, position.z), 
                listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z));
            };
        }()
    }), Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Audio,
        getOutput: function() {
            return this.gain;
        },
        setNodeSource: function(audioNode) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = audioNode, 
            this.connect(), this;
        },
        setBuffer: function(audioBuffer) {
            return this.buffer = audioBuffer, this.sourceType = "buffer", this.autoplay && this.play(), 
            this;
        },
        play: function() {
            if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
            if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
            var source = this.context.createBufferSource();
            return source.buffer = this.buffer, source.loop = this.loop, source.onended = this.onEnded.bind(this), 
            source.playbackRate.setValueAtTime(this.playbackRate, this.startTime), source.start(0, this.startTime), 
            this.isPlaying = !0, this.source = source, this.connect();
        },
        pause: function() {
            return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), 
            this.startTime = this.context.currentTime, this.isPlaying = !1, this);
        },
        stop: function() {
            return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), 
            this.startTime = 0, this.isPlaying = !1, this);
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) this.filters[i - 1].connect(this.filters[i]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return this;
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) this.filters[i - 1].disconnect(this.filters[i]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else this.source.disconnect(this.getOutput());
            return this;
        },
        getFilters: function() {
            return this.filters;
        },
        setFilters: function(value) {
            return value || (value = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = value, 
            this.connect()) : this.filters = value, this;
        },
        getFilter: function() {
            return this.getFilters()[0];
        },
        setFilter: function(filter) {
            return this.setFilters(filter ? [ filter ] : []);
        },
        setPlaybackRate: function(value) {
            return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = value, 
            !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), 
            this);
        },
        getPlaybackRate: function() {
            return this.playbackRate;
        },
        onEnded: function() {
            this.isPlaying = !1;
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), 
            !1) : this.loop;
        },
        setLoop: function(value) {
            return !1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.loop = value, 
            !0 === this.isPlaying && (this.source.loop = this.loop), this);
        },
        getVolume: function() {
            return this.gain.gain.value;
        },
        setVolume: function(value) {
            return this.gain.gain.value = value, this;
        }
    }), PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
        constructor: PositionalAudio,
        getOutput: function() {
            return this.panner;
        },
        getRefDistance: function() {
            return this.panner.refDistance;
        },
        setRefDistance: function(value) {
            this.panner.refDistance = value;
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor;
        },
        setRolloffFactor: function(value) {
            this.panner.rolloffFactor = value;
        },
        getDistanceModel: function() {
            return this.panner.distanceModel;
        },
        setDistanceModel: function(value) {
            this.panner.distanceModel = value;
        },
        getMaxDistance: function() {
            return this.panner.maxDistance;
        },
        setMaxDistance: function(value) {
            this.panner.maxDistance = value;
        },
        updateMatrixWorld: function() {
            var position = new Vector3();
            return function(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force), position.setFromMatrixPosition(this.matrixWorld), 
                this.panner.setPosition(position.x, position.y, position.z);
            };
        }()
    }), Object.assign(AudioAnalyser.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
        },
        getAverageFrequency: function() {
            for (var value = 0, data = this.getFrequencyData(), i = 0; i < data.length; i++) value += data[i];
            return value / data.length;
        }
    }), Object.assign(PropertyMixer.prototype, {
        accumulate: function(accuIndex, weight) {
            var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
            if (0 === currentWeight) {
                for (var i = 0; i !== stride; ++i) buffer[offset + i] = buffer[i];
                currentWeight = weight;
            } else {
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        },
        apply: function(accuIndex) {
            var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
            if (this.cumulativeWeight = 0, weight < 1) {
                var originalValueOffset = 3 * stride;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            for (var i = stride, e = stride + stride; i !== e; ++i) if (buffer[i] !== buffer[i + stride]) {
                binding.setValue(buffer, offset);
                break;
            }
        },
        saveOriginalState: function() {
            var binding = this.binding, buffer = this.buffer, stride = this.valueSize, originalValueOffset = 3 * stride;
            binding.getValue(buffer, originalValueOffset);
            for (var i = stride, e = originalValueOffset; i !== e; ++i) buffer[i] = buffer[originalValueOffset + i % stride];
            this.cumulativeWeight = 0;
        },
        restoreOriginalState: function() {
            var originalValueOffset = 3 * this.valueSize;
            this.binding.setValue(this.buffer, originalValueOffset);
        },
        _select: function(buffer, dstOffset, srcOffset, t, stride) {
            if (t >= .5) for (var i = 0; i !== stride; ++i) buffer[dstOffset + i] = buffer[srcOffset + i];
        },
        _slerp: function(buffer, dstOffset, srcOffset, t) {
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        },
        _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
            for (var s = 1 - t, i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        }
    }), Object.assign(Composite.prototype, {
        getValue: function(array, offset) {
            this.bind();
            var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
            void 0 !== binding && binding.getValue(array, offset);
        },
        setValue: function(array, offset) {
            for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].setValue(array, offset);
        },
        bind: function() {
            for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].bind();
        },
        unbind: function() {
            for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].unbind();
        }
    }), Object.assign(PropertyBinding, {
        Composite: Composite,
        create: function(root, path, parsedPath) {
            return root && root.isAnimationObjectGroup ? new PropertyBinding.Composite(root, path, parsedPath) : new PropertyBinding(root, path, parsedPath);
        },
        sanitizeNodeName: function(name) {
            return name.replace(/\s/g, "_").replace(/[^\w-]/g, "");
        },
        parseTrackName: function() {
            var directoryRe = /((?:[\w-]+[\/:])*)/, nodeRe = /([\w-\.]+)?/, objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/, propertyRe = /\.([\w-]+)(?:\[(.+)\])?/, trackRe = new RegExp("^" + directoryRe.source + nodeRe.source + objectRe.source + propertyRe.source + "$"), supportedObjectNames = [ "material", "materials", "bones" ];
            return function(trackName) {
                var matches = trackRe.exec(trackName);
                if (!matches) throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
                var results = {
                    nodeName: matches[2],
                    objectName: matches[3],
                    objectIndex: matches[4],
                    propertyName: matches[5],
                    propertyIndex: matches[6]
                }, lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
                if (void 0 !== lastDot && -1 !== lastDot) {
                    var objectName = results.nodeName.substring(lastDot + 1);
                    -1 !== supportedObjectNames.indexOf(objectName) && (results.nodeName = results.nodeName.substring(0, lastDot), 
                    results.objectName = objectName);
                }
                if (null === results.propertyName || 0 === results.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
                return results;
            };
        }(),
        findNode: function(root, nodeName) {
            if (!nodeName || "" === nodeName || "root" === nodeName || "." === nodeName || -1 === nodeName || nodeName === root.name || nodeName === root.uuid) return root;
            if (root.skeleton) {
                var bone = function(skeleton) {
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        var bone = skeleton.bones[i];
                        if (bone.name === nodeName) return bone;
                    }
                    return null;
                }(root.skeleton);
                if (bone) return bone;
            }
            if (root.children) {
                var searchNodeSubtree = function(children) {
                    for (var i = 0; i < children.length; i++) {
                        var childNode = children[i];
                        if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                        var result = searchNodeSubtree(childNode.children);
                        if (result) return result;
                    }
                    return null;
                }, subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode) return subTreeNode;
            }
            return null;
        }
    }), Object.assign(PropertyBinding.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [ function(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        }, function(buffer, offset) {
            for (var source = this.resolvedProperty, i = 0, n = source.length; i !== n; ++i) buffer[offset++] = source[i];
        }, function(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }, function(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        } ],
        SetterByBindingTypeAndVersioning: [ [ function(buffer, offset) {
            this.node[this.propertyName] = buffer[offset];
        }, function(buffer, offset) {
            this.node[this.propertyName] = buffer[offset], this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            this.node[this.propertyName] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(buffer, offset) {
            for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
        }, function(buffer, offset) {
            for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
            this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }, function(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
        }, function(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset), this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset), this.targetObject.matrixWorldNeedsUpdate = !0;
        } ] ],
        getValue: function(targetArray, offset) {
            this.bind(), this.getValue(targetArray, offset);
        },
        setValue: function(sourceArray, offset) {
            this.bind(), this.setValue(sourceArray, offset);
        },
        bind: function() {
            var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
            if (targetObject || (targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode, 
            this.node = targetObject), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, 
            !targetObject) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (objectName) {
                var objectIndex = parsedPath.objectIndex;
                switch (objectName) {
                  case "materials":
                    if (!targetObject.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!targetObject.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    targetObject = targetObject.material.materials;
                    break;

                  case "bones":
                    if (!targetObject.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    targetObject = targetObject.skeleton.bones;
                    for (var i = 0; i < targetObject.length; i++) if (targetObject[i].name === objectIndex) {
                        objectIndex = i;
                        break;
                    }
                    break;

                  default:
                    if (void 0 === targetObject[objectName]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    targetObject = targetObject[objectName];
                }
                if (void 0 !== objectIndex) {
                    if (void 0 === targetObject[objectIndex]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
                    targetObject = targetObject[objectIndex];
                }
            }
            var nodeProperty = targetObject[propertyName];
            if (void 0 === nodeProperty) {
                var nodeName = parsedPath.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            }
            var versioning = this.Versioning.None;
            void 0 !== targetObject.needsUpdate ? (versioning = this.Versioning.NeedsUpdate, 
            this.targetObject = targetObject) : void 0 !== targetObject.matrixWorldNeedsUpdate && (versioning = this.Versioning.MatrixWorldNeedsUpdate, 
            this.targetObject = targetObject);
            var bindingType = this.BindingType.Direct;
            if (void 0 !== propertyIndex) {
                if ("morphTargetInfluences" === propertyName) {
                    if (!targetObject.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (targetObject.geometry.isBufferGeometry) {
                        if (!targetObject.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                            propertyIndex = i;
                            break;
                        }
                    } else {
                        if (!targetObject.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                        for (var i = 0; i < this.node.geometry.morphTargets.length; i++) if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                            propertyIndex = i;
                            break;
                        }
                    }
                }
                bindingType = this.BindingType.ArrayElement, this.resolvedProperty = nodeProperty, 
                this.propertyIndex = propertyIndex;
            } else void 0 !== nodeProperty.fromArray && void 0 !== nodeProperty.toArray ? (bindingType = this.BindingType.HasFromToArray, 
            this.resolvedProperty = nodeProperty) : Array.isArray(nodeProperty) ? (bindingType = this.BindingType.EntireArray, 
            this.resolvedProperty = nodeProperty) : this.propertyName = propertyName;
            this.getValue = this.GetterByBindingType[bindingType], this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        },
        unbind: function() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
    }), Object.assign(PropertyBinding.prototype, {
        _getValue_unbound: PropertyBinding.prototype.getValue,
        _setValue_unbound: PropertyBinding.prototype.setValue
    }), Object.assign(AnimationObjectGroup.prototype, {
        isAnimationObjectGroup: !0,
        add: function(var_args) {
            for (var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid], knownObject = void 0;
                if (void 0 === index) {
                    index = nObjects++, indicesByUUID[uuid] = index, objects.push(object);
                    for (var j = 0, m = nBindings; j !== m; ++j) bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                } else if (index < nCachedObjects) {
                    knownObject = objects[index];
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index, objects[index] = lastCachedObject, 
                    indicesByUUID[uuid] = firstActiveIndex, objects[firstActiveIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached, void 0 === binding && (binding = new PropertyBinding(object, paths[j], parsedPaths[j])), 
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                } else objects[index] !== knownObject && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        remove: function(var_args) {
            for (var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (void 0 !== index && index >= nCachedObjects) {
                    var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index, objects[index] = firstActiveObject, 
                    indicesByUUID[uuid] = lastCachedIndex, objects[lastCachedIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive, bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        uncache: function(var_args) {
            for (var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (void 0 !== index) if (delete indicesByUUID[uuid], index < nCachedObjects) {
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastCachedObject.uuid] = index, objects[index] = lastCachedObject, 
                    indicesByUUID[lastObject.uuid] = firstActiveIndex, objects[firstActiveIndex] = lastObject, 
                    objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached, bindingsForPath[firstActiveIndex] = last, bindingsForPath.pop();
                    }
                } else {
                    var lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastObject.uuid] = index, objects[index] = lastObject, objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j];
                        bindingsForPath[index] = bindingsForPath[lastIndex], bindingsForPath.pop();
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        subscribe_: function(path, parsedPath) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
            if (void 0 !== index) return bindings[index];
            var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
            index = bindings.length, indicesByPath[path] = index, paths.push(path), parsedPaths.push(parsedPath), 
            bindings.push(bindingsForPath);
            for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        },
        unsubscribe_: function(path) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
            if (void 0 !== index) {
                var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex];
                indicesByPath[path[lastBindingsIndex]] = index, bindings[index] = lastBindings, 
                bindings.pop(), parsedPaths[index] = parsedPaths[lastBindingsIndex], parsedPaths.pop(), 
                paths[index] = paths[lastBindingsIndex], paths.pop();
            }
        }
    }), Object.assign(AnimationAction.prototype, {
        play: function() {
            return this._mixer._activateAction(this), this;
        },
        stop: function() {
            return this._mixer._deactivateAction(this), this.reset();
        },
        reset: function() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, 
            this._startTime = null, this.stopFading().stopWarping();
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this);
        },
        startAt: function(time) {
            return this._startTime = time, this;
        },
        setLoop: function(mode, repetitions) {
            return this.loop = mode, this.repetitions = repetitions, this;
        },
        setEffectiveWeight: function(weight) {
            return this.weight = weight, this._effectiveWeight = this.enabled ? weight : 0, 
            this.stopFading();
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight;
        },
        fadeIn: function(duration) {
            return this._scheduleFading(duration, 0, 1);
        },
        fadeOut: function(duration) {
            return this._scheduleFading(duration, 1, 0);
        },
        crossFadeFrom: function(fadeOutAction, duration, warp) {
            if (fadeOutAction.fadeOut(duration), this.fadeIn(duration), warp) {
                var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1, startEndRatio, duration), this.warp(endStartRatio, 1, duration);
            }
            return this;
        },
        crossFadeTo: function(fadeInAction, duration, warp) {
            return fadeInAction.crossFadeFrom(this, duration, warp);
        },
        stopFading: function() {
            var weightInterpolant = this._weightInterpolant;
            return null !== weightInterpolant && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(weightInterpolant)), 
            this;
        },
        setEffectiveTimeScale: function(timeScale) {
            return this.timeScale = timeScale, this._effectiveTimeScale = this.paused ? 0 : timeScale, 
            this.stopWarping();
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale;
        },
        setDuration: function(duration) {
            return this.timeScale = this._clip.duration / duration, this.stopWarping();
        },
        syncWith: function(action) {
            return this.time = action.time, this.timeScale = action.timeScale, this.stopWarping();
        },
        halt: function(duration) {
            return this.warp(this._effectiveTimeScale, 0, duration);
        },
        warp: function(startTimeScale, endTimeScale, duration) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
            null === interpolant && (interpolant = mixer._lendControlInterpolant(), this._timeScaleInterpolant = interpolant);
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            return times[0] = now, times[1] = now + duration, values[0] = startTimeScale / timeScale, 
            values[1] = endTimeScale / timeScale, this;
        },
        stopWarping: function() {
            var timeScaleInterpolant = this._timeScaleInterpolant;
            return null !== timeScaleInterpolant && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(timeScaleInterpolant)), 
            this;
        },
        getMixer: function() {
            return this._mixer;
        },
        getClip: function() {
            return this._clip;
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root;
        },
        _update: function(time, deltaTime, timeDirection, accuIndex) {
            if (!this.enabled) return void this._updateWeight(time);
            var startTime = this._startTime;
            if (null !== startTime) {
                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || 0 === timeDirection) return;
                this._startTime = null, deltaTime = timeDirection * timeRunning;
            }
            deltaTime *= this._updateTimeScale(time);
            var clipTime = this._updateTime(deltaTime), weight = this._updateWeight(time);
            if (weight > 0) for (var interpolants = this._interpolants, propertyMixers = this._propertyBindings, j = 0, m = interpolants.length; j !== m; ++j) interpolants[j].evaluate(clipTime), 
            propertyMixers[j].accumulate(accuIndex, weight);
        },
        _updateWeight: function(time) {
            var weight = 0;
            if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (null !== interpolant) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    weight *= interpolantValue, time > interpolant.parameterPositions[1] && (this.stopFading(), 
                    0 === interpolantValue && (this.enabled = !1));
                }
            }
            return this._effectiveWeight = weight, weight;
        },
        _updateTimeScale: function(time) {
            var timeScale = 0;
            if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (null !== interpolant) {
                    timeScale *= interpolant.evaluate(time)[0], time > interpolant.parameterPositions[1] && (this.stopWarping(), 
                    0 === timeScale ? this.paused = !0 : this.timeScale = timeScale);
                }
            }
            return this._effectiveTimeScale = timeScale, timeScale;
        },
        _updateTime: function(deltaTime) {
            var time = this.time + deltaTime;
            if (0 === deltaTime) return time;
            var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
            if (2200 === loop) {
                -1 === loopCount && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                handle_stop: {
                    if (time >= duration) time = duration; else {
                        if (!(time < 0)) break handle_stop;
                        time = 0;
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: deltaTime < 0 ? -1 : 1
                    });
                }
            } else {
                var pingPong = 2202 === loop;
                if (-1 === loopCount && (deltaTime >= 0 ? (loopCount = 0, this._setEndings(!0, 0 === this.repetitions, pingPong)) : this._setEndings(0 === this.repetitions, !0, pingPong)), 
                time >= duration || time < 0) {
                    var loopDelta = Math.floor(time / duration);
                    time -= duration * loopDelta, loopCount += Math.abs(loopDelta);
                    var pending = this.repetitions - loopCount;
                    if (pending < 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, 
                    time = deltaTime > 0 ? duration : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    }); else {
                        if (0 === pending) {
                            var atStart = deltaTime < 0;
                            this._setEndings(atStart, !atStart, pingPong);
                        } else this._setEndings(!1, !1, pingPong);
                        this._loopCount = loopCount, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: loopDelta
                        });
                    }
                }
                if (pingPong && 1 == (1 & loopCount)) return this.time = time, duration - time;
            }
            return this.time = time, time;
        },
        _setEndings: function(atStart, atEnd, pingPong) {
            var settings = this._interpolantSettings;
            pingPong ? (settings.endingStart = 2401, settings.endingEnd = 2401) : (settings.endingStart = atStart ? this.zeroSlopeAtStart ? 2401 : ZeroCurvatureEnding : 2402, 
            settings.endingEnd = atEnd ? this.zeroSlopeAtEnd ? 2401 : ZeroCurvatureEnding : 2402);
        },
        _scheduleFading: function(duration, weightNow, weightThen) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
            null === interpolant && (interpolant = mixer._lendControlInterpolant(), this._weightInterpolant = interpolant);
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            return times[0] = now, values[0] = weightNow, times[1] = now + duration, values[1] = weightThen, 
            this;
        }
    }), Object.assign(AnimationMixer.prototype, EventDispatcher.prototype, {
        _bindAction: function(action, prototypeAction) {
            var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
            void 0 === bindingsByName && (bindingsByName = {}, bindingsByRoot[rootUuid] = bindingsByName);
            for (var i = 0; i !== nTracks; ++i) {
                var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
                if (void 0 !== binding) bindings[i] = binding; else {
                    if (void 0 !== (binding = bindings[i])) {
                        null === binding._cacheIndex && (++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName));
                        continue;
                    }
                    var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                    binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize()), 
                    ++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName), 
                    bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
            }
        },
        _activateAction: function(action) {
            if (!this._isActiveAction(action)) {
                if (null === action._cacheIndex) {
                    var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]), this._addInactiveAction(action, clipUuid, rootUuid);
                }
                for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    0 == binding.useCount++ && (this._lendBinding(binding), binding.saveOriginalState());
                }
                this._lendAction(action);
            }
        },
        _deactivateAction: function(action) {
            if (this._isActiveAction(action)) {
                for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    0 == --binding.useCount && (binding.restoreOriginalState(), this._takeBackBinding(binding));
                }
                this._takeBackAction(action);
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], 
            this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], 
            this._nActiveControlInterpolants = 0;
            var scope = this;
            this.stats = {
                actions: {
                    get total() {
                        return scope._actions.length;
                    },
                    get inUse() {
                        return scope._nActiveActions;
                    }
                },
                bindings: {
                    get total() {
                        return scope._bindings.length;
                    },
                    get inUse() {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total() {
                        return scope._controlInterpolants.length;
                    },
                    get inUse() {
                        return scope._nActiveControlInterpolants;
                    }
                }
            };
        },
        _isActiveAction: function(action) {
            var index = action._cacheIndex;
            return null !== index && index < this._nActiveActions;
        },
        _addInactiveAction: function(action, clipUuid, rootUuid) {
            var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (void 0 === actionsForClip) actionsForClip = {
                knownActions: [ action ],
                actionByRoot: {}
            }, action._byClipCacheIndex = 0, actionsByClip[clipUuid] = actionsForClip; else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length, knownActions.push(action);
            }
            action._cacheIndex = actions.length, actions.push(action), actionsForClip.actionByRoot[rootUuid] = action;
        },
        _removeInactiveAction: function(action) {
            var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex, actions[cacheIndex] = lastInactiveAction, 
            actions.pop(), action._cacheIndex = null;
            var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex, knownActionsForClip[byClipCacheIndex] = lastKnownAction, 
            knownActionsForClip.pop(), action._byClipCacheIndex = null, delete actionsForClip.actionByRoot[(action._localRoot || this._root).uuid], 
            0 === knownActionsForClip.length && delete actionsByClip[clipUuid], this._removeInactiveBindingsForAction(action);
        },
        _removeInactiveBindingsForAction: function(action) {
            for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                0 == --binding.referenceCount && this._removeInactiveBinding(binding);
            }
        },
        _lendAction: function(action) {
            var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex, actions[lastActiveIndex] = action, firstInactiveAction._cacheIndex = prevIndex, 
            actions[prevIndex] = firstInactiveAction;
        },
        _takeBackAction: function(action) {
            var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex, actions[firstInactiveIndex] = action, lastActiveAction._cacheIndex = prevIndex, 
            actions[prevIndex] = lastActiveAction;
        },
        _addInactiveBinding: function(binding, rootUuid, trackName) {
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
            void 0 === bindingByName && (bindingByName = {}, bindingsByRoot[rootUuid] = bindingByName), 
            bindingByName[trackName] = binding, binding._cacheIndex = bindings.length, bindings.push(binding);
        },
        _removeInactiveBinding: function(binding) {
            var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex, bindings[cacheIndex] = lastInactiveBinding, 
            bindings.pop(), delete bindingByName[trackName];
            remove_empty_map: {
                for (var _ in bindingByName) break remove_empty_map;
                delete bindingsByRoot[rootUuid];
            }
        },
        _lendBinding: function(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex, bindings[lastActiveIndex] = binding, firstInactiveBinding._cacheIndex = prevIndex, 
            bindings[prevIndex] = firstInactiveBinding;
        },
        _takeBackBinding: function(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex, bindings[firstInactiveIndex] = binding, 
            lastActiveBinding._cacheIndex = prevIndex, bindings[prevIndex] = lastActiveBinding;
        },
        _lendControlInterpolant: function() {
            var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
            return void 0 === interpolant && (interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), 
            interpolant.__cacheIndex = lastActiveIndex, interpolants[lastActiveIndex] = interpolant), 
            interpolant;
        },
        _takeBackControlInterpolant: function(interpolant) {
            var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex, interpolants[firstInactiveIndex] = interpolant, 
            lastActiveInterpolant.__cacheIndex = prevIndex, interpolants[prevIndex] = lastActiveInterpolant;
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = "string" == typeof clip ? AnimationClip.findByName(root, clip) : clip, clipUuid = null !== clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
            if (void 0 !== actionsForClip) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (void 0 !== existingAction) return existingAction;
                prototypeAction = actionsForClip.knownActions[0], null === clipObject && (clipObject = prototypeAction._clip);
            }
            if (null === clipObject) return null;
            var newAction = new AnimationAction(this, clipObject, optionalRoot);
            return this._bindAction(newAction, prototypeAction), this._addInactiveAction(newAction, clipUuid, rootUuid), 
            newAction;
        },
        existingAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = "string" == typeof clip ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
            return void 0 !== actionsForClip ? actionsForClip.actionByRoot[rootUuid] || null : null;
        },
        stopAllAction: function() {
            var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
            this._nActiveActions = 0, this._nActiveBindings = 0;
            for (var i = 0; i !== nActions; ++i) actions[i].reset();
            for (var i = 0; i !== nBindings; ++i) bindings[i].useCount = 0;
            return this;
        },
        update: function(deltaTime) {
            deltaTime *= this.timeScale;
            for (var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1, i = 0; i !== nActions; ++i) {
                actions[i]._update(time, deltaTime, timeDirection, accuIndex);
            }
            for (var bindings = this._bindings, nBindings = this._nActiveBindings, i = 0; i !== nBindings; ++i) bindings[i].apply(accuIndex);
            return this;
        },
        getRoot: function() {
            return this._root;
        },
        uncacheClip: function(clip) {
            var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (void 0 !== actionsForClip) {
                for (var actionsToRemove = actionsForClip.knownActions, i = 0, n = actionsToRemove.length; i !== n; ++i) {
                    var action = actionsToRemove[i];
                    this._deactivateAction(action);
                    var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null, action._byClipCacheIndex = null, lastInactiveAction._cacheIndex = cacheIndex, 
                    actions[cacheIndex] = lastInactiveAction, actions.pop(), this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        },
        uncacheRoot: function(root) {
            var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
            for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                void 0 !== action && (this._deactivateAction(action), this._removeInactiveAction(action));
            }
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
            if (void 0 !== bindingByName) for (var trackName in bindingByName) {
                var binding = bindingByName[trackName];
                binding.restoreOriginalState(), this._removeInactiveBinding(binding);
            }
        },
        uncacheAction: function(clip, optionalRoot) {
            var action = this.existingAction(clip, optionalRoot);
            null !== action && (this._deactivateAction(action), this._removeInactiveAction(action));
        }
    }), Uniform.prototype.clone = function() {
        return new Uniform(void 0 === this.value.clone ? this.value : this.value.clone());
    }, InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
        constructor: InstancedBufferGeometry,
        isInstancedBufferGeometry: !0,
        addGroup: function(start, count, materialIndex) {
            this.groups.push({
                start: start,
                count: count,
                materialIndex: materialIndex
            });
        },
        copy: function(source) {
            var index = source.index;
            null !== index && this.setIndex(index.clone());
            var attributes = source.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            for (var groups = source.groups, i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            return this;
        }
    }), Object.defineProperties(InterleavedBufferAttribute.prototype, {
        count: {
            get: function() {
                return this.data.count;
            }
        },
        array: {
            get: function() {
                return this.data.array;
            }
        }
    }), Object.assign(InterleavedBufferAttribute.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(index, x) {
            return this.data.array[index * this.data.stride + this.offset] = x, this;
        },
        setY: function(index, y) {
            return this.data.array[index * this.data.stride + this.offset + 1] = y, this;
        },
        setZ: function(index, z) {
            return this.data.array[index * this.data.stride + this.offset + 2] = z, this;
        },
        setW: function(index, w) {
            return this.data.array[index * this.data.stride + this.offset + 3] = w, this;
        },
        getX: function(index) {
            return this.data.array[index * this.data.stride + this.offset];
        },
        getY: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 1];
        },
        getZ: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 2];
        },
        getW: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 3];
        },
        setXY: function(index, x, y) {
            return index = index * this.data.stride + this.offset, this.data.array[index + 0] = x, 
            this.data.array[index + 1] = y, this;
        },
        setXYZ: function(index, x, y, z) {
            return index = index * this.data.stride + this.offset, this.data.array[index + 0] = x, 
            this.data.array[index + 1] = y, this.data.array[index + 2] = z, this;
        },
        setXYZW: function(index, x, y, z, w) {
            return index = index * this.data.stride + this.offset, this.data.array[index + 0] = x, 
            this.data.array[index + 1] = y, this.data.array[index + 2] = z, this.data.array[index + 3] = w, 
            this;
        }
    }), Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
        set: function(value) {
            !0 === value && this.version++;
        }
    }), Object.assign(InterleavedBuffer.prototype, {
        isInterleavedBuffer: !0,
        setArray: function(array) {
            if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== array ? array.length / this.stride : 0, this.array = array;
        },
        setDynamic: function(value) {
            return this.dynamic = value, this;
        },
        copy: function(source) {
            return this.array = new source.array.constructor(source.array), this.count = source.count, 
            this.stride = source.stride, this.dynamic = source.dynamic, this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.stride, index2 *= attribute.stride;
            for (var i = 0, l = this.stride; i < l; i++) this.array[index1 + i] = attribute.array[index2 + i];
            return this;
        },
        set: function(value, offset) {
            return void 0 === offset && (offset = 0), this.array.set(value, offset), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        onUpload: function(callback) {
            return this.onUploadCallback = callback, this;
        }
    }), InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
        constructor: InstancedInterleavedBuffer,
        isInstancedInterleavedBuffer: !0,
        copy: function(source) {
            return InterleavedBuffer.prototype.copy.call(this, source), this.meshPerAttribute = source.meshPerAttribute, 
            this;
        }
    }), InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
        constructor: InstancedBufferAttribute,
        isInstancedBufferAttribute: !0,
        copy: function(source) {
            return BufferAttribute.prototype.copy.call(this, source), this.meshPerAttribute = source.meshPerAttribute, 
            this;
        }
    }), Object.assign(Raycaster.prototype, {
        linePrecision: 1,
        set: function(origin, direction) {
            this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
            camera && camera.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(camera.matrixWorld), 
            this.ray.direction.set(coords.x, coords.y, .5).unproject(camera).sub(this.ray.origin).normalize()) : camera && camera.isOrthographicCamera ? (this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera), 
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function(object, recursive) {
            var intersects = [];
            return intersectObject(object, this, intersects, recursive), intersects.sort(ascSort), 
            intersects;
        },
        intersectObjects: function(objects, recursive) {
            var intersects = [];
            if (!1 === Array.isArray(objects)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), 
            intersects;
            for (var i = 0, l = objects.length; i < l; i++) intersectObject(objects[i], this, intersects, recursive);
            return intersects.sort(ascSort), intersects;
        }
    }), Object.assign(Clock.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(), 
            this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1;
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime;
        },
        getDelta: function() {
            var diff = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var newTime = ("undefined" == typeof performance ? Date : performance).now();
                diff = (newTime - this.oldTime) / 1e3, this.oldTime = newTime, this.elapsedTime += diff;
            }
            return diff;
        }
    }), Object.assign(Spherical.prototype, {
        set: function(radius, phi, theta) {
            return this.radius = radius, this.phi = phi, this.theta = theta, this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(other) {
            return this.radius = other.radius, this.phi = other.phi, this.theta = other.theta, 
            this;
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
        },
        setFromVector3: function(vec3) {
            return this.radius = vec3.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(vec3.x, vec3.z), 
            this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1))), this;
        }
    }), Object.assign(Cylindrical.prototype, {
        set: function(radius, theta, y) {
            return this.radius = radius, this.theta = theta, this.y = y, this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(other) {
            return this.radius = other.radius, this.theta = other.theta, this.y = other.y, this;
        },
        setFromVector3: function(vec3) {
            return this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z), this.theta = Math.atan2(vec3.x, vec3.z), 
            this.y = vec3.y, this;
        }
    }), ImmediateRenderObject.prototype = Object.create(Object3D.prototype), ImmediateRenderObject.prototype.constructor = ImmediateRenderObject, 
    ImmediateRenderObject.prototype.isImmediateRenderObject = !0, VertexNormalsHelper.prototype = Object.create(LineSegments.prototype), 
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper, VertexNormalsHelper.prototype.update = function() {
        var v1 = new Vector3(), v2 = new Vector3(), normalMatrix = new Matrix3();
        return function() {
            var keys = [ "a", "b", "c" ];
            this.object.updateMatrixWorld(!0), normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld, position = this.geometry.attributes.position, objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) for (var vertices = objGeometry.vertices, faces = objGeometry.faces, idx = 0, i = 0, l = faces.length; i < l; i++) for (var face = faces[i], j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                var vertex = vertices[face[keys[j]]], normal = face.vertexNormals[j];
                v1.copy(vertex).applyMatrix4(matrixWorld), v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1), 
                position.setXYZ(idx, v1.x, v1.y, v1.z), idx += 1, position.setXYZ(idx, v2.x, v2.y, v2.z), 
                idx += 1;
            } else if (objGeometry && objGeometry.isBufferGeometry) for (var objPos = objGeometry.attributes.position, objNorm = objGeometry.attributes.normal, idx = 0, j = 0, jl = objPos.count; j < jl; j++) v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld), 
            v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j)), v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1), 
            position.setXYZ(idx, v1.x, v1.y, v1.z), idx += 1, position.setXYZ(idx, v2.x, v2.y, v2.z), 
            idx += 1;
            position.needsUpdate = !0;
        };
    }(), SpotLightHelper.prototype = Object.create(Object3D.prototype), SpotLightHelper.prototype.constructor = SpotLightHelper, 
    SpotLightHelper.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
    }, SpotLightHelper.prototype.update = function() {
        var vector = new Vector3(), vector2 = new Vector3();
        return function() {
            this.light.updateMatrixWorld();
            var coneLength = this.light.distance ? this.light.distance : 1e3, coneWidth = coneLength * Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength), vector.setFromMatrixPosition(this.light.matrixWorld), 
            vector2.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(vector2.sub(vector)), 
            void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
        };
    }(), SkeletonHelper.prototype = Object.create(LineSegments.prototype), SkeletonHelper.prototype.constructor = SkeletonHelper, 
    SkeletonHelper.prototype.onBeforeRender = function() {
        var vector = new Vector3(), boneMatrix = new Matrix4(), matrixWorldInv = new Matrix4();
        return function() {
            var bones = this.bones, geometry = this.geometry, position = geometry.getAttribute("position");
            matrixWorldInv.getInverse(this.root.matrixWorld);
            for (var i = 0, j = 0; i < bones.length; i++) {
                var bone = bones[i];
                bone.parent && bone.parent.isBone && (boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld), 
                vector.setFromMatrixPosition(boneMatrix), position.setXYZ(j, vector.x, vector.y, vector.z), 
                boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld), vector.setFromMatrixPosition(boneMatrix), 
                position.setXYZ(j + 1, vector.x, vector.y, vector.z), j += 2);
            }
            geometry.getAttribute("position").needsUpdate = !0;
        };
    }(), PointLightHelper.prototype = Object.create(Mesh.prototype), PointLightHelper.prototype.constructor = PointLightHelper, 
    PointLightHelper.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose();
    }, PointLightHelper.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }, RectAreaLightHelper.prototype = Object.create(Object3D.prototype), RectAreaLightHelper.prototype.constructor = RectAreaLightHelper, 
    RectAreaLightHelper.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }, RectAreaLightHelper.prototype.update = function() {
        var hx = .5 * this.light.width, hy = .5 * this.light.height, position = this.line.geometry.attributes.position, array = position.array;
        array[0] = hx, array[1] = -hy, array[2] = 0, array[3] = hx, array[4] = hy, array[5] = 0, 
        array[6] = -hx, array[7] = hy, array[8] = 0, array[9] = -hx, array[10] = -hy, array[11] = 0, 
        array[12] = hx, array[13] = -hy, array[14] = 0, position.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color);
    }, HemisphereLightHelper.prototype = Object.create(Object3D.prototype), HemisphereLightHelper.prototype.constructor = HemisphereLightHelper, 
    HemisphereLightHelper.prototype.dispose = function() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }, HemisphereLightHelper.prototype.update = function() {
        var vector = new Vector3(), color1 = new Color(), color2 = new Color();
        return function() {
            var mesh = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color); else {
                var colors = mesh.geometry.getAttribute("color");
                color1.copy(this.light.color), color2.copy(this.light.groundColor);
                for (var i = 0, l = colors.count; i < l; i++) {
                    var color = i < l / 2 ? color1 : color2;
                    colors.setXYZ(i, color.r, color.g, color.b);
                }
                colors.needsUpdate = !0;
            }
            mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        };
    }(), GridHelper.prototype = Object.create(LineSegments.prototype), GridHelper.prototype.constructor = GridHelper, 
    PolarGridHelper.prototype = Object.create(LineSegments.prototype), PolarGridHelper.prototype.constructor = PolarGridHelper, 
    FaceNormalsHelper.prototype = Object.create(LineSegments.prototype), FaceNormalsHelper.prototype.constructor = FaceNormalsHelper, 
    FaceNormalsHelper.prototype.update = function() {
        var v1 = new Vector3(), v2 = new Vector3(), normalMatrix = new Matrix3();
        return function() {
            this.object.updateMatrixWorld(!0), normalMatrix.getNormalMatrix(this.object.matrixWorld);
            for (var matrixWorld = this.object.matrixWorld, position = this.geometry.attributes.position, objGeometry = this.object.geometry, vertices = objGeometry.vertices, faces = objGeometry.faces, idx = 0, i = 0, l = faces.length; i < l; i++) {
                var face = faces[i], normal = face.normal;
                v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld), 
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1), 
                position.setXYZ(idx, v1.x, v1.y, v1.z), idx += 1, position.setXYZ(idx, v2.x, v2.y, v2.z), 
                idx += 1;
            }
            position.needsUpdate = !0;
        };
    }(), DirectionalLightHelper.prototype = Object.create(Object3D.prototype), DirectionalLightHelper.prototype.constructor = DirectionalLightHelper, 
    DirectionalLightHelper.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), 
        this.targetLine.material.dispose();
    }, DirectionalLightHelper.prototype.update = function() {
        var v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3();
        return function() {
            v1.setFromMatrixPosition(this.light.matrixWorld), v2.setFromMatrixPosition(this.light.target.matrixWorld), 
            v3.subVectors(v2, v1), this.lightPlane.lookAt(v3), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), 
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), 
            this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(v3), 
            this.targetLine.scale.z = v3.length();
        };
    }(), CameraHelper.prototype = Object.create(LineSegments.prototype), CameraHelper.prototype.constructor = CameraHelper, 
    CameraHelper.prototype.update = function() {
        function setPoint(point, x, y, z) {
            vector.set(x, y, z).unproject(camera);
            var points = pointMap[point];
            if (void 0 !== points) for (var position = geometry.getAttribute("position"), i = 0, l = points.length; i < l; i++) position.setXYZ(points[i], vector.x, vector.y, vector.z);
        }
        var geometry, pointMap, vector = new Vector3(), camera = new Camera();
        return function() {
            geometry = this.geometry, pointMap = this.pointMap;
            camera.projectionMatrix.copy(this.camera.projectionMatrix), setPoint("c", 0, 0, -1), 
            setPoint("t", 0, 0, 1), setPoint("n1", -1, -1, -1), setPoint("n2", 1, -1, -1), setPoint("n3", -1, 1, -1), 
            setPoint("n4", 1, 1, -1), setPoint("f1", -1, -1, 1), setPoint("f2", 1, -1, 1), setPoint("f3", -1, 1, 1), 
            setPoint("f4", 1, 1, 1), setPoint("u1", .7, 1.1, -1), setPoint("u2", -.7, 1.1, -1), 
            setPoint("u3", 0, 2, -1), setPoint("cf1", -1, 0, 1), setPoint("cf2", 1, 0, 1), setPoint("cf3", 0, -1, 1), 
            setPoint("cf4", 0, 1, 1), setPoint("cn1", -1, 0, -1), setPoint("cn2", 1, 0, -1), 
            setPoint("cn3", 0, -1, -1), setPoint("cn4", 0, 1, -1), geometry.getAttribute("position").needsUpdate = !0;
        };
    }(), BoxHelper.prototype = Object.create(LineSegments.prototype), BoxHelper.prototype.constructor = BoxHelper, 
    BoxHelper.prototype.update = function() {
        var box = new Box3();
        return function(object) {
            if (void 0 !== object && console.warn("THREE.BoxHelper: .update() has no longer arguments."), 
            void 0 !== this.object && box.setFromObject(this.object), !box.isEmpty()) {
                var min = box.min, max = box.max, position = this.geometry.attributes.position, array = position.array;
                array[0] = max.x, array[1] = max.y, array[2] = max.z, array[3] = min.x, array[4] = max.y, 
                array[5] = max.z, array[6] = min.x, array[7] = min.y, array[8] = max.z, array[9] = max.x, 
                array[10] = min.y, array[11] = max.z, array[12] = max.x, array[13] = max.y, array[14] = min.z, 
                array[15] = min.x, array[16] = max.y, array[17] = min.z, array[18] = min.x, array[19] = min.y, 
                array[20] = min.z, array[21] = max.x, array[22] = min.y, array[23] = min.z, position.needsUpdate = !0, 
                this.geometry.computeBoundingSphere();
            }
        };
    }(), BoxHelper.prototype.setFromObject = function(object) {
        return this.object = object, this.update(), this;
    }, Box3Helper.prototype = Object.create(LineSegments.prototype), Box3Helper.prototype.constructor = Box3Helper, 
    Box3Helper.prototype.onBeforeRender = function() {
        var box = this.box;
        box.isEmpty() || (box.getCenter(this.position), box.getSize(this.scale), this.scale.multiplyScalar(.5));
    }, PlaneHelper.prototype = Object.create(Line.prototype), PlaneHelper.prototype.constructor = PlaneHelper, 
    PlaneHelper.prototype.onBeforeRender = function() {
        var scale = -this.plane.constant;
        Math.abs(scale) < 1e-8 && (scale = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, scale), 
        this.lookAt(this.plane.normal), this.updateMatrixWorld();
    };
    var lineGeometry, coneGeometry;
    ArrowHelper.prototype = Object.create(Object3D.prototype), ArrowHelper.prototype.constructor = ArrowHelper, 
    ArrowHelper.prototype.setDirection = function() {
        var radians, axis = new Vector3();
        return function(dir) {
            dir.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : dir.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (axis.set(dir.z, 0, -dir.x).normalize(), 
            radians = Math.acos(dir.y), this.quaternion.setFromAxisAngle(axis, radians));
        };
    }(), ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
        void 0 === headLength && (headLength = .2 * length), void 0 === headWidth && (headWidth = .2 * headLength), 
        this.line.scale.set(1, Math.max(0, length - headLength), 1), this.line.updateMatrix(), 
        this.cone.scale.set(headWidth, headLength, headWidth), this.cone.position.y = length, 
        this.cone.updateMatrix();
    }, ArrowHelper.prototype.setColor = function(color) {
        this.line.material.color.copy(color), this.cone.material.color.copy(color);
    }, AxisHelper.prototype = Object.create(LineSegments.prototype), AxisHelper.prototype.constructor = AxisHelper;
    var tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
    CatmullRomCurve3.prototype = Object.create(Curve.prototype), CatmullRomCurve3.prototype.constructor = CatmullRomCurve3, 
    CatmullRomCurve3.prototype.getPoint = function(t) {
        var points = this.points, l = points.length, point = (l - (this.closed ? 0 : 1)) * t, intPoint = Math.floor(point), weight = point - intPoint;
        this.closed ? intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length : 0 === weight && intPoint === l - 1 && (intPoint = l - 2, 
        weight = 1);
        var p0, p1, p2, p3;
        if (this.closed || intPoint > 0 ? p0 = points[(intPoint - 1) % l] : (tmp.subVectors(points[0], points[1]).add(points[0]), 
        p0 = tmp), p1 = points[intPoint % l], p2 = points[(intPoint + 1) % l], this.closed || intPoint + 2 < l ? p3 = points[(intPoint + 2) % l] : (tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]), 
        p3 = tmp), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
            var pow = "chordal" === this.type ? .5 : .25, dt0 = Math.pow(p0.distanceToSquared(p1), pow), dt1 = Math.pow(p1.distanceToSquared(p2), pow), dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            dt1 < 1e-4 && (dt1 = 1), dt0 < 1e-4 && (dt0 = dt1), dt2 < 1e-4 && (dt2 = dt1), px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2), 
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2), pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if ("catmullrom" === this.type) {
            var tension = void 0 !== this.tension ? this.tension : .5;
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension), py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension), 
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
        }
        return new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
    }, CubicBezierCurve3.prototype = Object.create(Curve.prototype), CubicBezierCurve3.prototype.constructor = CubicBezierCurve3, 
    CubicBezierCurve3.prototype.getPoint = function(t) {
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        return new Vector3(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
    }, QuadraticBezierCurve3.prototype = Object.create(Curve.prototype), QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3, 
    QuadraticBezierCurve3.prototype.getPoint = function(t) {
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
        return new Vector3(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    }, LineCurve3.prototype = Object.create(Curve.prototype), LineCurve3.prototype.constructor = LineCurve3, 
    LineCurve3.prototype.getPoint = function(t) {
        if (1 === t) return this.v2.clone();
        var vector = new Vector3();
        return vector.subVectors(this.v2, this.v1), vector.multiplyScalar(t), vector.add(this.v1), 
        vector;
    }, ArcCurve.prototype = Object.create(EllipseCurve.prototype), ArcCurve.prototype.constructor = ArcCurve;
    var SceneUtils = {
        createMultiMaterialObject: function(geometry, materials) {
            for (var group = new Group(), i = 0, l = materials.length; i < l; i++) group.add(new Mesh(geometry, materials[i]));
            return group;
        },
        detach: function(child, parent, scene) {
            child.applyMatrix(parent.matrixWorld), parent.remove(child), scene.add(child);
        },
        attach: function(child, scene, parent) {
            child.applyMatrix(new Matrix4().getInverse(parent.matrixWorld)), scene.remove(child), 
            parent.add(child);
        }
    };
    Curve.create = function(construct, getPoint) {
        return console.log("THREE.Curve.create() has been deprecated"), construct.prototype = Object.create(Curve.prototype), 
        construct.prototype.constructor = construct, construct.prototype.getPoint = getPoint, 
        construct;
    }, ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype), SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype), 
    Spline.prototype = Object.create(CatmullRomCurve3.prototype), Object.assign(Spline.prototype, {
        initFromArray: function(a) {
            console.error("THREE.Spline: .initFromArray() has been removed.");
        },
        getControlPointsArray: function(optionalTarget) {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.");
        },
        reparametrizeByArcLength: function(samplingCoef) {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
        }
    }), GridHelper.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    }, SkeletonHelper.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    }, Object.assign(Box2.prototype, {
        center: function(optionalTarget) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), 
            this.getCenter(optionalTarget);
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        },
        isIntersectionBox: function(box) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), 
            this.intersectsBox(box);
        },
        size: function(optionalTarget) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(optionalTarget);
        }
    }), Object.assign(Box3.prototype, {
        center: function(optionalTarget) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), 
            this.getCenter(optionalTarget);
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        },
        isIntersectionBox: function(box) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), 
            this.intersectsBox(box);
        },
        isIntersectionSphere: function(sphere) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
            this.intersectsSphere(sphere);
        },
        size: function(optionalTarget) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(optionalTarget);
        }
    }), Line3.prototype.center = function(optionalTarget) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), 
        this.getCenter(optionalTarget);
    }, _Math.random16 = function() {
        return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), 
        Math.random();
    }, Object.assign(Matrix3.prototype, {
        flattenToArrayOffset: function(array, offset) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), 
            this.toArray(array, offset);
        },
        multiplyVector3: function(vector) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), 
            vector.applyMatrix3(this);
        },
        multiplyVector3Array: function(a) {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
        },
        applyToBuffer: function(buffer, offset, length) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), 
            this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function(array, offset, length) {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
        }
    }), Object.assign(Matrix4.prototype, {
        extractPosition: function(m) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), 
            this.copyPosition(m);
        },
        flattenToArrayOffset: function(array, offset) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), 
            this.toArray(array, offset);
        },
        getPosition: function() {
            var v1;
            return function() {
                return void 0 === v1 && (v1 = new Vector3()), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), 
                v1.setFromMatrixColumn(this, 3);
            };
        }(),
        setRotationFromQuaternion: function(q) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), 
            this.makeRotationFromQuaternion(q);
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
        },
        multiplyVector3: function(vector) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
            vector.applyMatrix4(this);
        },
        multiplyVector4: function(vector) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
            vector.applyMatrix4(this);
        },
        multiplyVector3Array: function(a) {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
        },
        rotateAxis: function(v) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), 
            v.transformDirection(this);
        },
        crossVector: function(vector) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
            vector.applyMatrix4(this);
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.");
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        },
        applyToBuffer: function(buffer, offset, length) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), 
            this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function(array, offset, length) {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
        },
        makeFrustum: function(left, right, bottom, top, near, far) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), 
            this.makePerspective(left, right, top, bottom, near, far);
        }
    }), Plane.prototype.isIntersectionLine = function(line) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), 
        this.intersectsLine(line);
    }, Quaternion.prototype.multiplyVector3 = function(vector) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), 
        vector.applyQuaternion(this);
    }, Object.assign(Ray.prototype, {
        isIntersectionBox: function(box) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), 
            this.intersectsBox(box);
        },
        isIntersectionPlane: function(plane) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), 
            this.intersectsPlane(plane);
        },
        isIntersectionSphere: function(sphere) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
            this.intersectsSphere(sphere);
        }
    }), Object.assign(Shape.prototype, {
        extrude: function(options) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), 
            new ExtrudeGeometry(this, options);
        },
        makeGeometry: function(options) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), 
            new ShapeGeometry(this, options);
        }
    }), Object.assign(Vector2.prototype, {
        fromAttribute: function(attribute, index, offset) {
            return console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), 
            this.fromBufferAttribute(attribute, index, offset);
        }
    }), Object.assign(Vector3.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
        },
        getPositionFromMatrix: function(m) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), 
            this.setFromMatrixPosition(m);
        },
        getScaleFromMatrix: function(m) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), 
            this.setFromMatrixScale(m);
        },
        getColumnFromMatrix: function(index, matrix) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), 
            this.setFromMatrixColumn(matrix, index);
        },
        applyProjection: function(m) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), 
            this.applyMatrix4(m);
        },
        fromAttribute: function(attribute, index, offset) {
            return console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), 
            this.fromBufferAttribute(attribute, index, offset);
        }
    }), Object.assign(Vector4.prototype, {
        fromAttribute: function(attribute, index, offset) {
            return console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), 
            this.fromBufferAttribute(attribute, index, offset);
        }
    }), Geometry.prototype.computeTangents = function() {
        console.warn("THREE.Geometry: .computeTangents() has been removed.");
    }, Object.assign(Object3D.prototype, {
        getChildByName: function(name) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), 
            this.getObjectByName(name);
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
        },
        translate: function(distance, axis) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), 
            this.translateOnAxis(axis, distance);
        }
    }), Object.defineProperties(Object3D.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
            },
            set: function(value) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = value;
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
            }
        }
    }), Object.defineProperties(LOD.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
            }
        }
    }), Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.");
        }
    }), Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), 
            this.arcLengthDivisions;
        },
        set: function(value) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), 
            this.arcLengthDivisions = value;
        }
    }), PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), 
        void 0 !== filmGauge && (this.filmGauge = filmGauge), this.setFocalLength(focalLength);
    }, Object.defineProperties(Light.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.");
            }
        },
        shadowCameraFov: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = value;
            }
        },
        shadowCameraLeft: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = value;
            }
        },
        shadowCameraRight: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = value;
            }
        },
        shadowCameraTop: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = value;
            }
        },
        shadowCameraBottom: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), 
                this.shadow.camera.bottom = value;
            }
        },
        shadowCameraNear: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = value;
            }
        },
        shadowCameraFar: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = value;
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
            }
        },
        shadowBias: {
            set: function(value) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = value;
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.");
            }
        },
        shadowMapWidth: {
            set: function(value) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = value;
            }
        },
        shadowMapHeight: {
            set: function(value) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = value;
            }
        }
    }), Object.defineProperties(BufferAttribute.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), 
                this.array.length;
            }
        }
    }), Object.assign(BufferGeometry.prototype, {
        addIndex: function(index) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), 
            this.setIndex(index);
        },
        addDrawCall: function(start, count, indexOffset) {
            void 0 !== indexOffset && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), 
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(start, count);
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), 
            this.clearGroups();
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
        }
    }), Object.defineProperties(BufferGeometry.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), 
                this.groups;
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), 
                this.groups;
            }
        }
    }), Object.defineProperties(Uniform.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), 
                this;
            }
        }
    }), Object.defineProperties(Material.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.");
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.");
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new Color();
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            },
            set: function(value) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), 
                this.flatShading = 1 === value;
            }
        }
    }), Object.defineProperties(MeshPhongMaterial.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), 
                !1;
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
            }
        }
    }), Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), 
                this.extensions.derivatives;
            },
            set: function(value) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), 
                this.extensions.derivatives = value;
            }
        }
    }), Object.assign(WebGLRenderer.prototype, {
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), 
            this.getRenderTarget();
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), 
            this.capabilities.getMaxAnisotropy();
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), 
            this.capabilities.precision;
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), 
            this.extensions.get("OES_texture_float");
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), 
            this.extensions.get("OES_texture_half_float");
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), 
            this.extensions.get("OES_standard_derivatives");
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), 
            this.extensions.get("WEBGL_compressed_texture_s3tc");
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), 
            this.extensions.get("WEBGL_compressed_texture_pvrtc");
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), 
            this.extensions.get("EXT_blend_minmax");
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), 
            this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), 
            this.extensions.get("ANGLE_instanced_arrays");
        },
        enableScissorTest: function(boolean) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), 
            this.setScissorTest(boolean);
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
        }
    }), Object.defineProperties(WebGLRenderer.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), 
                this.shadowMap.enabled = value;
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = value;
            }
        },
        shadowMapCullFace: {
            get: function() {
                return this.shadowMap.cullFace;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), 
                this.shadowMap.cullFace = value;
            }
        }
    }), Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
            get: function() {
                return this.renderReverseSided ? CullFaceFront : CullFaceBack;
            },
            set: function(cullFace) {
                var value = cullFace !== CullFaceBack;
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "."), 
                this.renderReverseSided = value;
            }
        }
    }), Object.defineProperties(WebGLRenderTarget.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = value;
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = value;
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), 
                this.texture.magFilter;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), 
                this.texture.magFilter = value;
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), 
                this.texture.minFilter;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), 
                this.texture.minFilter = value;
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), 
                this.texture.anisotropy;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), 
                this.texture.anisotropy = value;
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), 
                this.texture.offset;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = value;
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), 
                this.texture.repeat;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = value;
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), 
                this.texture.format;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = value;
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = value;
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
                this.texture.generateMipmaps;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
                this.texture.generateMipmaps = value;
            }
        }
    }), Audio.prototype.load = function(file) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var scope = this;
        return new AudioLoader().load(file, function(buffer) {
            scope.setBuffer(buffer);
        }), this;
    }, AudioAnalyser.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), 
        this.getFrequencyData();
    }, CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(renderer, scene);
    };
    var GeometryUtils = {
        merge: function(geometry1, geometry2, materialIndexOffset) {
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            var matrix;
            geometry2.isMesh && (geometry2.matrixAutoUpdate && geometry2.updateMatrix(), matrix = geometry2.matrix, 
            geometry2 = geometry2.geometry), geometry1.merge(geometry2, matrix, materialIndexOffset);
        },
        center: function(geometry) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), 
            geometry.center();
        }
    }, ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function(url, mapping, onLoad, onError) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var loader = new TextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(url, onLoad, void 0, onError);
            return mapping && (texture.mapping = mapping), texture;
        },
        loadTextureCube: function(urls, mapping, onLoad, onError) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var loader = new CubeTextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(urls, onLoad, void 0, onError);
            return mapping && (texture.mapping = mapping), texture;
        },
        loadCompressedTexture: function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
        },
        loadCompressedTextureCube: function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
        }
    };
    exports.WebGLRenderTargetCube = WebGLRenderTargetCube, exports.WebGLRenderTarget = WebGLRenderTarget, 
    exports.WebGLRenderer = WebGLRenderer, exports.ShaderLib = ShaderLib, exports.UniformsLib = UniformsLib, 
    exports.UniformsUtils = UniformsUtils, exports.ShaderChunk = ShaderChunk, exports.FogExp2 = FogExp2, 
    exports.Fog = Fog, exports.Scene = Scene, exports.LensFlare = LensFlare, exports.Sprite = Sprite, 
    exports.LOD = LOD, exports.SkinnedMesh = SkinnedMesh, exports.Skeleton = Skeleton, 
    exports.Bone = Bone, exports.Mesh = Mesh, exports.LineSegments = LineSegments, exports.LineLoop = LineLoop, 
    exports.Line = Line, exports.Points = Points, exports.Group = Group, exports.VideoTexture = VideoTexture, 
    exports.DataTexture = DataTexture, exports.CompressedTexture = CompressedTexture, 
    exports.CubeTexture = CubeTexture, exports.CanvasTexture = CanvasTexture, exports.DepthTexture = DepthTexture, 
    exports.Texture = Texture, exports.CompressedTextureLoader = CompressedTextureLoader, 
    exports.DataTextureLoader = DataTextureLoader, exports.CubeTextureLoader = CubeTextureLoader, 
    exports.TextureLoader = TextureLoader, exports.ObjectLoader = ObjectLoader, exports.MaterialLoader = MaterialLoader, 
    exports.BufferGeometryLoader = BufferGeometryLoader, exports.DefaultLoadingManager = DefaultLoadingManager, 
    exports.LoadingManager = LoadingManager, exports.JSONLoader = JSONLoader, exports.ImageLoader = ImageLoader, 
    exports.FontLoader = FontLoader, exports.FileLoader = FileLoader, exports.Loader = Loader, 
    exports.Cache = Cache, exports.AudioLoader = AudioLoader, exports.SpotLightShadow = SpotLightShadow, 
    exports.SpotLight = SpotLight, exports.PointLight = PointLight, exports.RectAreaLight = RectAreaLight, 
    exports.HemisphereLight = HemisphereLight, exports.DirectionalLightShadow = DirectionalLightShadow, 
    exports.DirectionalLight = DirectionalLight, exports.AmbientLight = AmbientLight, 
    exports.LightShadow = LightShadow, exports.Light = Light, exports.StereoCamera = StereoCamera, 
    exports.PerspectiveCamera = PerspectiveCamera, exports.OrthographicCamera = OrthographicCamera, 
    exports.CubeCamera = CubeCamera, exports.ArrayCamera = ArrayCamera, exports.Camera = Camera, 
    exports.AudioListener = AudioListener, exports.PositionalAudio = PositionalAudio, 
    exports.AudioContext = AudioContext, exports.AudioAnalyser = AudioAnalyser, exports.Audio = Audio, 
    exports.VectorKeyframeTrack = VectorKeyframeTrack, exports.StringKeyframeTrack = StringKeyframeTrack, 
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack, exports.NumberKeyframeTrack = NumberKeyframeTrack, 
    exports.ColorKeyframeTrack = ColorKeyframeTrack, exports.BooleanKeyframeTrack = BooleanKeyframeTrack, 
    exports.PropertyMixer = PropertyMixer, exports.PropertyBinding = PropertyBinding, 
    exports.KeyframeTrack = KeyframeTrack, exports.AnimationUtils = AnimationUtils, 
    exports.AnimationObjectGroup = AnimationObjectGroup, exports.AnimationMixer = AnimationMixer, 
    exports.AnimationClip = AnimationClip, exports.Uniform = Uniform, exports.InstancedBufferGeometry = InstancedBufferGeometry, 
    exports.BufferGeometry = BufferGeometry, exports.GeometryIdCount = GeometryIdCount, 
    exports.Geometry = Geometry, exports.InterleavedBufferAttribute = InterleavedBufferAttribute, 
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer, exports.InterleavedBuffer = InterleavedBuffer, 
    exports.InstancedBufferAttribute = InstancedBufferAttribute, exports.Face3 = Face3, 
    exports.Object3D = Object3D, exports.Raycaster = Raycaster, exports.Layers = Layers, 
    exports.EventDispatcher = EventDispatcher, exports.Clock = Clock, exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant, 
    exports.LinearInterpolant = LinearInterpolant, exports.DiscreteInterpolant = DiscreteInterpolant, 
    exports.CubicInterpolant = CubicInterpolant, exports.Interpolant = Interpolant, 
    exports.Triangle = Triangle, exports.Math = _Math, exports.Spherical = Spherical, 
    exports.Cylindrical = Cylindrical, exports.Plane = Plane, exports.Frustum = Frustum, 
    exports.Sphere = Sphere, exports.Ray = Ray, exports.Matrix4 = Matrix4, exports.Matrix3 = Matrix3, 
    exports.Box3 = Box3, exports.Box2 = Box2, exports.Line3 = Line3, exports.Euler = Euler, 
    exports.Vector4 = Vector4, exports.Vector3 = Vector3, exports.Vector2 = Vector2, 
    exports.Quaternion = Quaternion, exports.Color = Color, exports.ImmediateRenderObject = ImmediateRenderObject, 
    exports.VertexNormalsHelper = VertexNormalsHelper, exports.SpotLightHelper = SpotLightHelper, 
    exports.SkeletonHelper = SkeletonHelper, exports.PointLightHelper = PointLightHelper, 
    exports.RectAreaLightHelper = RectAreaLightHelper, exports.HemisphereLightHelper = HemisphereLightHelper, 
    exports.GridHelper = GridHelper, exports.PolarGridHelper = PolarGridHelper, exports.FaceNormalsHelper = FaceNormalsHelper, 
    exports.DirectionalLightHelper = DirectionalLightHelper, exports.CameraHelper = CameraHelper, 
    exports.BoxHelper = BoxHelper, exports.Box3Helper = Box3Helper, exports.PlaneHelper = PlaneHelper, 
    exports.ArrowHelper = ArrowHelper, exports.AxisHelper = AxisHelper, exports.CatmullRomCurve3 = CatmullRomCurve3, 
    exports.CubicBezierCurve3 = CubicBezierCurve3, exports.QuadraticBezierCurve3 = QuadraticBezierCurve3, 
    exports.LineCurve3 = LineCurve3, exports.ArcCurve = ArcCurve, exports.EllipseCurve = EllipseCurve, 
    exports.SplineCurve = SplineCurve, exports.CubicBezierCurve = CubicBezierCurve, 
    exports.QuadraticBezierCurve = QuadraticBezierCurve, exports.LineCurve = LineCurve, 
    exports.Shape = Shape, exports.Path = Path, exports.ShapePath = ShapePath, exports.Font = Font, 
    exports.CurvePath = CurvePath, exports.Curve = Curve, exports.ShapeUtils = ShapeUtils, 
    exports.SceneUtils = SceneUtils, exports.WebGLUtils = WebGLUtils, exports.WireframeGeometry = WireframeGeometry, 
    exports.ParametricGeometry = ParametricGeometry, exports.ParametricBufferGeometry = ParametricBufferGeometry, 
    exports.TetrahedronGeometry = TetrahedronGeometry, exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry, 
    exports.OctahedronGeometry = OctahedronGeometry, exports.OctahedronBufferGeometry = OctahedronBufferGeometry, 
    exports.IcosahedronGeometry = IcosahedronGeometry, exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry, 
    exports.DodecahedronGeometry = DodecahedronGeometry, exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry, 
    exports.PolyhedronGeometry = PolyhedronGeometry, exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry, 
    exports.TubeGeometry = TubeGeometry, exports.TubeBufferGeometry = TubeBufferGeometry, 
    exports.TorusKnotGeometry = TorusKnotGeometry, exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry, 
    exports.TorusGeometry = TorusGeometry, exports.TorusBufferGeometry = TorusBufferGeometry, 
    exports.TextGeometry = TextGeometry, exports.TextBufferGeometry = TextBufferGeometry, 
    exports.SphereGeometry = SphereGeometry, exports.SphereBufferGeometry = SphereBufferGeometry, 
    exports.RingGeometry = RingGeometry, exports.RingBufferGeometry = RingBufferGeometry, 
    exports.PlaneGeometry = PlaneGeometry, exports.PlaneBufferGeometry = PlaneBufferGeometry, 
    exports.LatheGeometry = LatheGeometry, exports.LatheBufferGeometry = LatheBufferGeometry, 
    exports.ShapeGeometry = ShapeGeometry, exports.ShapeBufferGeometry = ShapeBufferGeometry, 
    exports.ExtrudeGeometry = ExtrudeGeometry, exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry, 
    exports.EdgesGeometry = EdgesGeometry, exports.ConeGeometry = ConeGeometry, exports.ConeBufferGeometry = ConeBufferGeometry, 
    exports.CylinderGeometry = CylinderGeometry, exports.CylinderBufferGeometry = CylinderBufferGeometry, 
    exports.CircleGeometry = CircleGeometry, exports.CircleBufferGeometry = CircleBufferGeometry, 
    exports.BoxGeometry = BoxGeometry, exports.BoxBufferGeometry = BoxBufferGeometry, 
    exports.ShadowMaterial = ShadowMaterial, exports.SpriteMaterial = SpriteMaterial, 
    exports.RawShaderMaterial = RawShaderMaterial, exports.ShaderMaterial = ShaderMaterial;
    exports.PointsMaterial = PointsMaterial, exports.MeshPhysicalMaterial = MeshPhysicalMaterial, 
    exports.MeshStandardMaterial = MeshStandardMaterial, exports.MeshPhongMaterial = MeshPhongMaterial, 
    exports.MeshToonMaterial = MeshToonMaterial, exports.MeshNormalMaterial = MeshNormalMaterial, 
    exports.MeshLambertMaterial = MeshLambertMaterial, exports.MeshDepthMaterial = MeshDepthMaterial, 
    exports.MeshDistanceMaterial = MeshDistanceMaterial, exports.MeshBasicMaterial = MeshBasicMaterial, 
    exports.LineDashedMaterial = LineDashedMaterial, exports.LineBasicMaterial = LineBasicMaterial, 
    exports.Material = Material, exports.Float64BufferAttribute = Float64BufferAttribute, 
    exports.Float32BufferAttribute = Float32BufferAttribute, exports.Uint32BufferAttribute = Uint32BufferAttribute, 
    exports.Int32BufferAttribute = Int32BufferAttribute, exports.Uint16BufferAttribute = Uint16BufferAttribute, 
    exports.Int16BufferAttribute = Int16BufferAttribute, exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute, 
    exports.Uint8BufferAttribute = Uint8BufferAttribute, exports.Int8BufferAttribute = Int8BufferAttribute, 
    exports.BufferAttribute = BufferAttribute, exports.REVISION = REVISION, exports.MOUSE = MOUSE, 
    exports.CullFaceNone = CullFaceNone, exports.CullFaceBack = CullFaceBack, exports.CullFaceFront = CullFaceFront, 
    exports.CullFaceFrontBack = 3, exports.FrontFaceDirectionCW = FrontFaceDirectionCW, 
    exports.FrontFaceDirectionCCW = 1, exports.BasicShadowMap = 0, exports.PCFShadowMap = PCFShadowMap, 
    exports.PCFSoftShadowMap = PCFSoftShadowMap, exports.FrontSide = FrontSide, exports.BackSide = BackSide, 
    exports.DoubleSide = DoubleSide, exports.FlatShading = 1, exports.SmoothShading = 2, 
    exports.NoColors = NoColors, exports.FaceColors = FaceColors, exports.VertexColors = VertexColors, 
    exports.NoBlending = NoBlending, exports.NormalBlending = NormalBlending, exports.AdditiveBlending = AdditiveBlending, 
    exports.SubtractiveBlending = SubtractiveBlending, exports.MultiplyBlending = MultiplyBlending, 
    exports.CustomBlending = CustomBlending, exports.AddEquation = AddEquation, exports.SubtractEquation = SubtractEquation, 
    exports.ReverseSubtractEquation = ReverseSubtractEquation, exports.MinEquation = MinEquation, 
    exports.MaxEquation = MaxEquation, exports.ZeroFactor = ZeroFactor, exports.OneFactor = OneFactor, 
    exports.SrcColorFactor = SrcColorFactor, exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor, 
    exports.SrcAlphaFactor = SrcAlphaFactor, exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor, 
    exports.DstAlphaFactor = DstAlphaFactor, exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor, 
    exports.DstColorFactor = DstColorFactor, exports.OneMinusDstColorFactor = OneMinusDstColorFactor, 
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor, exports.NeverDepth = NeverDepth, 
    exports.AlwaysDepth = AlwaysDepth, exports.LessDepth = LessDepth, exports.LessEqualDepth = LessEqualDepth, 
    exports.EqualDepth = EqualDepth, exports.GreaterEqualDepth = GreaterEqualDepth, 
    exports.GreaterDepth = GreaterDepth, exports.NotEqualDepth = NotEqualDepth, exports.MultiplyOperation = MultiplyOperation, 
    exports.MixOperation = MixOperation, exports.AddOperation = AddOperation, exports.NoToneMapping = NoToneMapping, 
    exports.LinearToneMapping = LinearToneMapping, exports.ReinhardToneMapping = ReinhardToneMapping, 
    exports.Uncharted2ToneMapping = Uncharted2ToneMapping, exports.CineonToneMapping = CineonToneMapping, 
    exports.UVMapping = 300, exports.CubeReflectionMapping = CubeReflectionMapping, 
    exports.CubeRefractionMapping = CubeRefractionMapping, exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping, 
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping, exports.SphericalReflectionMapping = SphericalReflectionMapping, 
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping, exports.CubeUVRefractionMapping = CubeUVRefractionMapping, 
    exports.RepeatWrapping = RepeatWrapping, exports.ClampToEdgeWrapping = ClampToEdgeWrapping, 
    exports.MirroredRepeatWrapping = MirroredRepeatWrapping, exports.NearestFilter = NearestFilter, 
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter, exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter, 
    exports.LinearFilter = LinearFilter, exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter, 
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter, exports.UnsignedByteType = UnsignedByteType, 
    exports.ByteType = ByteType, exports.ShortType = ShortType, exports.UnsignedShortType = UnsignedShortType, 
    exports.IntType = IntType, exports.UnsignedIntType = UnsignedIntType, exports.FloatType = FloatType, 
    exports.HalfFloatType = HalfFloatType, exports.UnsignedShort4444Type = UnsignedShort4444Type, 
    exports.UnsignedShort5551Type = UnsignedShort5551Type, exports.UnsignedShort565Type = UnsignedShort565Type, 
    exports.UnsignedInt248Type = UnsignedInt248Type, exports.AlphaFormat = AlphaFormat, 
    exports.RGBFormat = RGBFormat, exports.RGBAFormat = RGBAFormat, exports.LuminanceFormat = LuminanceFormat, 
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat, exports.RGBEFormat = RGBEFormat, 
    exports.DepthFormat = DepthFormat, exports.DepthStencilFormat = DepthStencilFormat, 
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format, exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format, 
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format, exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format, 
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format, exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format, 
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format, exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format, 
    exports.RGB_ETC1_Format = RGB_ETC1_Format, exports.LoopOnce = 2200, exports.LoopRepeat = LoopRepeat, 
    exports.LoopPingPong = 2202, exports.InterpolateDiscrete = 2300, exports.InterpolateLinear = 2301, 
    exports.InterpolateSmooth = 2302, exports.ZeroCurvatureEnding = ZeroCurvatureEnding, 
    exports.ZeroSlopeEnding = 2401, exports.WrapAroundEnding = 2402, exports.TrianglesDrawMode = TrianglesDrawMode, 
    exports.TriangleStripDrawMode = TriangleStripDrawMode, exports.TriangleFanDrawMode = TriangleFanDrawMode, 
    exports.LinearEncoding = LinearEncoding, exports.sRGBEncoding = sRGBEncoding, exports.GammaEncoding = GammaEncoding, 
    exports.RGBEEncoding = RGBEEncoding, exports.LogLuvEncoding = 3003, exports.RGBM7Encoding = RGBM7Encoding, 
    exports.RGBM16Encoding = RGBM16Encoding, exports.RGBDEncoding = RGBDEncoding, exports.BasicDepthPacking = BasicDepthPacking, 
    exports.RGBADepthPacking = RGBADepthPacking, exports.CubeGeometry = BoxGeometry, 
    exports.Face4 = Face4, exports.LineStrip = 0, exports.LinePieces = 1, exports.MeshFaceMaterial = MeshFaceMaterial, 
    exports.MultiMaterial = MultiMaterial, exports.PointCloud = PointCloud, exports.Particle = Particle, 
    exports.ParticleSystem = ParticleSystem, exports.PointCloudMaterial = PointCloudMaterial, 
    exports.ParticleBasicMaterial = ParticleBasicMaterial, exports.ParticleSystemMaterial = ParticleSystemMaterial, 
    exports.Vertex = Vertex, exports.DynamicBufferAttribute = DynamicBufferAttribute, 
    exports.Int8Attribute = Int8Attribute, exports.Uint8Attribute = Uint8Attribute, 
    exports.Uint8ClampedAttribute = Uint8ClampedAttribute, exports.Int16Attribute = Int16Attribute, 
    exports.Uint16Attribute = Uint16Attribute, exports.Int32Attribute = Int32Attribute, 
    exports.Uint32Attribute = Uint32Attribute, exports.Float32Attribute = Float32Attribute, 
    exports.Float64Attribute = Float64Attribute, exports.ClosedSplineCurve3 = ClosedSplineCurve3, 
    exports.SplineCurve3 = SplineCurve3, exports.Spline = Spline, exports.BoundingBoxHelper = BoundingBoxHelper, 
    exports.EdgesHelper = EdgesHelper, exports.WireframeHelper = WireframeHelper, exports.XHRLoader = XHRLoader, 
    exports.BinaryTextureLoader = BinaryTextureLoader, exports.GeometryUtils = GeometryUtils, 
    exports.ImageUtils = ImageUtils, exports.Projector = Projector, exports.CanvasRenderer = CanvasRenderer, 
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
}), THREE.StereoEffect = function(renderer) {
    var _stereo = new THREE.StereoCamera();
    _stereo.aspect = .5, this.setEyeSeparation = function(eyeSep) {
        _stereo.eyeSep = eyeSep;
    }, this.setSize = function(width, height) {
        renderer.setSize(width, height);
    }, this.render = function(scene, camera) {
        scene.updateMatrixWorld(), null === camera.parent && camera.updateMatrixWorld(), 
        _stereo.update(camera);
        var size = renderer.getSize();
        renderer.autoClear && renderer.clear(), renderer.setScissorTest(!0), renderer.setScissor(0, 0, size.width / 2, size.height), 
        renderer.setViewport(0, 0, size.width / 2, size.height), renderer.render(scene, _stereo.cameraL), 
        renderer.setScissor(size.width / 2, 0, size.width / 2, size.height), renderer.setViewport(size.width / 2, 0, size.width / 2, size.height), 
        renderer.render(scene, _stereo.cameraR), renderer.setScissorTest(!1);
    };
}, THREE.AnaglyphEffect = function(renderer, width, height) {
    this.colorMatrixLeft = new THREE.Matrix3().fromArray([ 1.0671679973602295, -.0016435992438346148, .0001777536963345483, -.028107794001698494, -.00019593400065787137, -.0002875397040043026, -.04279090091586113, 15809757314855233e-21, -.00024287120322696865 ]), 
    this.colorMatrixRight = new THREE.Matrix3().fromArray([ -.0355340838432312, -.06440307199954987, .018319187685847282, -.10269022732973099, .8079727292060852, -.04835830628871918, .0001224992738571018, -.009558862075209618, .567823588848114 ]);
    var _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), _scene = new THREE.Scene(), _stereo = new THREE.StereoCamera(), _params = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.NearestFilter,
        format: THREE.RGBAFormat
    };
    void 0 === width && (width = 512), void 0 === height && (height = 512);
    var _renderTargetL = new THREE.WebGLRenderTarget(width, height, _params), _renderTargetR = new THREE.WebGLRenderTarget(width, height, _params), _material = new THREE.ShaderMaterial({
        uniforms: {
            mapLeft: {
                value: _renderTargetL.texture
            },
            mapRight: {
                value: _renderTargetR.texture
            },
            colorMatrixLeft: {
                value: this.colorMatrixLeft
            },
            colorMatrixRight: {
                value: this.colorMatrixRight
            }
        },
        vertexShader: [ "varying vec2 vUv;", "void main() {", "\tvUv = vec2( uv.x, uv.y );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
        fragmentShader: [ "uniform sampler2D mapLeft;", "uniform sampler2D mapRight;", "varying vec2 vUv;", "uniform mat3 colorMatrixLeft;", "uniform mat3 colorMatrixRight;", "float lin( float c ) {", "\treturn c <= 0.04045 ? c * 0.0773993808 :", "\t\t\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );", "}", "vec4 lin( vec4 c ) {", "\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );", "}", "float dev( float c ) {", "\treturn c <= 0.0031308 ? c * 12.92", "\t\t\t: pow( c, 0.41666 ) * 1.055 - 0.055;", "}", "void main() {", "\tvec2 uv = vUv;", "\tvec4 colorL = lin( texture2D( mapLeft, uv ) );", "\tvec4 colorR = lin( texture2D( mapRight, uv ) );", "\tvec3 color = clamp(", "\t\t\tcolorMatrixLeft * colorL.rgb +", "\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );", "\tgl_FragColor = vec4(", "\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),", "\t\t\tmax( colorL.a, colorR.a ) );", "}" ].join("\n")
    }), mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _material);
    _scene.add(mesh), this.setSize = function(width, height) {
        renderer.setSize(width, height);
        var pixelRatio = renderer.getPixelRatio();
        _renderTargetL.setSize(width * pixelRatio, height * pixelRatio), _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);
    }, this.render = function(scene, camera) {
        scene.updateMatrixWorld(), null === camera.parent && camera.updateMatrixWorld(), 
        _stereo.update(camera), renderer.render(scene, _stereo.cameraL, _renderTargetL, !0), 
        renderer.render(scene, _stereo.cameraR, _renderTargetR, !0), renderer.render(_scene, _camera);
    }, this.dispose = function() {
        _renderTargetL && _renderTargetL.dispose(), _renderTargetR && _renderTargetR.dispose();
    };
}, THREE.OrbitControls = function(object, domElement) {
    function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
        return Math.pow(.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
        sphericalDelta.phi -= angle;
    }
    function dollyIn(dollyScale) {
        scope.object instanceof THREE.PerspectiveCamera ? scale /= dollyScale : scope.object instanceof THREE.OrthographicCamera ? (scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale)), 
        scope.object.updateProjectionMatrix(), zoomChanged = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), 
        scope.enableZoom = !1);
    }
    function dollyOut(dollyScale) {
        scope.object instanceof THREE.PerspectiveCamera ? scale *= dollyScale : scope.object instanceof THREE.OrthographicCamera ? (scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale)), 
        scope.object.updateProjectionMatrix(), zoomChanged = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), 
        scope.enableZoom = !1);
    }
    function handleMouseDownRotate(event) {
        rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
        dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
        panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
        rotateEnd.set(event.clientX, event.clientY), rotateDelta.subVectors(rotateEnd, rotateStart);
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed), 
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed), 
        rotateStart.copy(rotateEnd), scope.update();
    }
    function handleMouseMoveDolly(event) {
        dollyEnd.set(event.clientX, event.clientY), dollyDelta.subVectors(dollyEnd, dollyStart), 
        dollyDelta.y > 0 ? dollyIn(getZoomScale()) : dollyDelta.y < 0 && dollyOut(getZoomScale()), 
        dollyStart.copy(dollyEnd), scope.update();
    }
    function handleMouseMovePan(event) {
        panEnd.set(event.clientX, event.clientY), panDelta.subVectors(panEnd, panStart), 
        pan(panDelta.x, panDelta.y), panStart.copy(panEnd), scope.update();
    }
    function handleMouseUp(event) {}
    function handleMouseWheel(event) {
        event.deltaY < 0 ? dollyOut(getZoomScale()) : event.deltaY > 0 && dollyIn(getZoomScale()), 
        scope.update();
    }
    function handleKeyDown(event) {
        switch (event.keyCode) {
          case scope.keys.UP:
            pan(0, scope.keyPanSpeed), scope.update();
            break;

          case scope.keys.BOTTOM:
            pan(0, -scope.keyPanSpeed), scope.update();
            break;

          case scope.keys.LEFT:
            pan(scope.keyPanSpeed, 0), scope.update();
            break;

          case scope.keys.RIGHT:
            pan(-scope.keyPanSpeed, 0), scope.update();
        }
    }
    function handleTouchStartRotate(event) {
        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }
    function handleTouchStartDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX, dy = event.touches[0].pageY - event.touches[1].pageY, distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
    }
    function handleTouchStartPan(event) {
        panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }
    function handleTouchMoveRotate(event) {
        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY), rotateDelta.subVectors(rotateEnd, rotateStart);
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed), 
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed), 
        rotateStart.copy(rotateEnd), scope.update();
    }
    function handleTouchMoveDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX, dy = event.touches[0].pageY - event.touches[1].pageY, distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance), dollyDelta.subVectors(dollyEnd, dollyStart), dollyDelta.y > 0 ? dollyOut(getZoomScale()) : dollyDelta.y < 0 && dollyIn(getZoomScale()), 
        dollyStart.copy(dollyEnd), scope.update();
    }
    function handleTouchMovePan(event) {
        panEnd.set(event.touches[0].pageX, event.touches[0].pageY), panDelta.subVectors(panEnd, panStart), 
        pan(panDelta.x, panDelta.y), panStart.copy(panEnd), scope.update();
    }
    function handleTouchEnd(event) {}
    function onMouseDown(event) {
        if (!1 !== scope.enabled) {
            switch (event.preventDefault(), event.button) {
              case scope.mouseButtons.ORBIT:
                if (!1 === scope.enableRotate) return;
                handleMouseDownRotate(event), state = STATE.ROTATE;
                break;

              case scope.mouseButtons.ZOOM:
                if (!1 === scope.enableZoom) return;
                handleMouseDownDolly(event), state = STATE.DOLLY;
                break;

              case scope.mouseButtons.PAN:
                if (!1 === scope.enablePan) return;
                handleMouseDownPan(event), state = STATE.PAN;
            }
            state !== STATE.NONE && (document.addEventListener("mousemove", onMouseMove, !1), 
            document.addEventListener("mouseup", onMouseUp, !1), scope.dispatchEvent(startEvent));
        }
    }
    function onMouseMove(event) {
        if (!1 !== scope.enabled) switch (event.preventDefault(), state) {
          case STATE.ROTATE:
            if (!1 === scope.enableRotate) return;
            handleMouseMoveRotate(event);
            break;

          case STATE.DOLLY:
            if (!1 === scope.enableZoom) return;
            handleMouseMoveDolly(event);
            break;

          case STATE.PAN:
            if (!1 === scope.enablePan) return;
            handleMouseMovePan(event);
        }
    }
    function onMouseUp(event) {
        !1 !== scope.enabled && (handleMouseUp(event), document.removeEventListener("mousemove", onMouseMove, !1), 
        document.removeEventListener("mouseup", onMouseUp, !1), scope.dispatchEvent(endEvent), 
        state = STATE.NONE);
    }
    function onMouseWheel(event) {
        !1 === scope.enabled || !1 === scope.enableZoom || state !== STATE.NONE && state !== STATE.ROTATE || (event.preventDefault(), 
        event.stopPropagation(), handleMouseWheel(event), scope.dispatchEvent(startEvent), 
        scope.dispatchEvent(endEvent));
    }
    function onKeyDown(event) {
        !1 !== scope.enabled && !1 !== scope.enableKeys && !1 !== scope.enablePan && handleKeyDown(event);
    }
    function onTouchStart(event) {
        if (!1 !== scope.enabled) {
            switch (event.touches.length) {
              case 1:
                if (!1 === scope.enableRotate) return;
                handleTouchStartRotate(event), state = STATE.TOUCH_ROTATE;
                break;

              case 2:
                if (!1 === scope.enableZoom) return;
                handleTouchStartDolly(event), state = STATE.TOUCH_DOLLY;
                break;

              case 3:
                if (!1 === scope.enablePan) return;
                handleTouchStartPan(event), state = STATE.TOUCH_PAN;
                break;

              default:
                state = STATE.NONE;
            }
            state !== STATE.NONE && scope.dispatchEvent(startEvent);
        }
    }
    function onTouchMove(event) {
        if (!1 !== scope.enabled) switch (event.preventDefault(), event.stopPropagation(), 
        event.touches.length) {
          case 1:
            if (!1 === scope.enableRotate) return;
            if (state !== STATE.TOUCH_ROTATE) return;
            handleTouchMoveRotate(event);
            break;

          case 2:
            if (!1 === scope.enableZoom) return;
            if (state !== STATE.TOUCH_DOLLY) return;
            handleTouchMoveDolly(event);
            break;

          case 3:
            if (!1 === scope.enablePan) return;
            if (state !== STATE.TOUCH_PAN) return;
            handleTouchMovePan(event);
            break;

          default:
            state = STATE.NONE;
        }
    }
    function onTouchEnd(event) {
        !1 !== scope.enabled && (handleTouchEnd(event), scope.dispatchEvent(endEvent), state = STATE.NONE);
    }
    function onContextMenu(event) {
        !1 !== scope.enabled && event.preventDefault();
    }
    this.object = object, this.domElement = void 0 !== domElement ? domElement : document, 
    this.enabled = !0, this.target = new THREE.Vector3(), this.minDistance = 0, this.maxDistance = 1 / 0, 
    this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, 
    this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, 
    this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, 
    this.rotateSpeed = 1, this.enablePan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, 
    this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
    }, this.mouseButtons = {
        ORBIT: THREE.MOUSE.LEFT,
        ZOOM: THREE.MOUSE.MIDDLE,
        PAN: THREE.MOUSE.RIGHT
    }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), 
    this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
        return spherical.phi;
    }, this.getAzimuthalAngle = function() {
        return spherical.theta;
    }, this.saveState = function() {
        scope.target0.copy(scope.target), scope.position0.copy(scope.object.position), scope.zoom0 = scope.object.zoom;
    }, this.reset = function() {
        scope.target.copy(scope.target0), scope.object.position.copy(scope.position0), scope.object.zoom = scope.zoom0, 
        scope.object.updateProjectionMatrix(), scope.dispatchEvent(changeEvent), scope.update(), 
        state = STATE.NONE;
    }, this.update = function() {
        var offset = new THREE.Vector3(), quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0)), quatInverse = quat.clone().inverse(), lastPosition = new THREE.Vector3(), lastQuaternion = new THREE.Quaternion();
        return function() {
            var position = scope.object.position;
            return offset.copy(position).sub(scope.target), offset.applyQuaternion(quat), spherical.setFromVector3(offset), 
            scope.autoRotate && state === STATE.NONE && rotateLeft(getAutoRotationAngle()), 
            spherical.theta += sphericalDelta.theta, spherical.phi += sphericalDelta.phi, spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta)), 
            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi)), 
            spherical.makeSafe(), spherical.radius *= scale, spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)), 
            scope.target.add(panOffset), offset.setFromSpherical(spherical), offset.applyQuaternion(quatInverse), 
            position.copy(scope.target).add(offset), scope.object.lookAt(scope.target), !0 === scope.enableDamping ? (sphericalDelta.theta *= 1 - scope.dampingFactor, 
            sphericalDelta.phi *= 1 - scope.dampingFactor) : sphericalDelta.set(0, 0, 0), scale = 1, 
            panOffset.set(0, 0, 0), !!(zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) && (scope.dispatchEvent(changeEvent), 
            lastPosition.copy(scope.object.position), lastQuaternion.copy(scope.object.quaternion), 
            zoomChanged = !1, !0);
        };
    }(), this.dispose = function() {
        scope.domElement.removeEventListener("contextmenu", onContextMenu, !1), scope.domElement.removeEventListener("mousedown", onMouseDown, !1), 
        scope.domElement.removeEventListener("wheel", onMouseWheel, !1), scope.domElement.removeEventListener("touchstart", onTouchStart, !1), 
        scope.domElement.removeEventListener("touchend", onTouchEnd, !1), scope.domElement.removeEventListener("touchmove", onTouchMove, !1), 
        document.removeEventListener("mousemove", onMouseMove, !1), document.removeEventListener("mouseup", onMouseUp, !1), 
        window.removeEventListener("keydown", onKeyDown, !1);
    };
    var scope = this, changeEvent = {
        type: "change"
    }, startEvent = {
        type: "start"
    }, endEvent = {
        type: "end"
    }, STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY: 4,
        TOUCH_PAN: 5
    }, state = STATE.NONE, EPS = 1e-6, spherical = new THREE.Spherical(), sphericalDelta = new THREE.Spherical(), scale = 1, panOffset = new THREE.Vector3(), zoomChanged = !1, rotateStart = new THREE.Vector2(), rotateEnd = new THREE.Vector2(), rotateDelta = new THREE.Vector2(), panStart = new THREE.Vector2(), panEnd = new THREE.Vector2(), panDelta = new THREE.Vector2(), dollyStart = new THREE.Vector2(), dollyEnd = new THREE.Vector2(), dollyDelta = new THREE.Vector2(), panLeft = function() {
        var v = new THREE.Vector3();
        return function(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 0), v.multiplyScalar(-distance), panOffset.add(v);
        };
    }(), panUp = function() {
        var v = new THREE.Vector3();
        return function(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 1), v.multiplyScalar(distance), panOffset.add(v);
        };
    }(), pan = function() {
        var offset = new THREE.Vector3();
        return function(deltaX, deltaY) {
            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
            if (scope.object instanceof THREE.PerspectiveCamera) {
                var position = scope.object.position;
                offset.copy(position).sub(scope.target);
                var targetDistance = offset.length();
                targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180), panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix), 
                panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
            } else scope.object instanceof THREE.OrthographicCamera ? (panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix), 
            panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), 
            scope.enablePan = !1);
        };
    }();
    scope.domElement.addEventListener("contextmenu", onContextMenu, !1), scope.domElement.addEventListener("mousedown", onMouseDown, !1), 
    scope.domElement.addEventListener("wheel", onMouseWheel, !1), scope.domElement.addEventListener("touchstart", onTouchStart, !1), 
    scope.domElement.addEventListener("touchend", onTouchEnd, !1), scope.domElement.addEventListener("touchmove", onTouchMove, !1), 
    window.addEventListener("keydown", onKeyDown, !1), this.update();
}, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), 
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls, Object.defineProperties(THREE.OrbitControls.prototype, {
    center: {
        get: function() {
            return console.warn("THREE.OrbitControls: .center has been renamed to .target"), 
            this.target;
        }
    },
    noZoom: {
        get: function() {
            return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), 
            !this.enableZoom;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), 
            this.enableZoom = !value;
        }
    },
    noRotate: {
        get: function() {
            return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), 
            !this.enableRotate;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), 
            this.enableRotate = !value;
        }
    },
    noPan: {
        get: function() {
            return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), 
            !this.enablePan;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), 
            this.enablePan = !value;
        }
    },
    noKeys: {
        get: function() {
            return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), 
            !this.enableKeys;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), 
            this.enableKeys = !value;
        }
    },
    staticMoving: {
        get: function() {
            return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), 
            !this.enableDamping;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), 
            this.enableDamping = !value;
        }
    },
    dynamicDampingFactor: {
        get: function() {
            return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), 
            this.dampingFactor;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), 
            this.dampingFactor = value;
        }
    }
}), THREE.FirstPersonControls = function(object, domElement) {
    function contextmenu(event) {
        event.preventDefault();
    }
    function bind(scope, fn) {
        return function() {
            fn.apply(scope, arguments);
        };
    }
    this.object = object, this.target = new THREE.Vector3(0, 0, 0), this.domElement = void 0 !== domElement ? domElement : document, 
    this.enabled = !0, this.movementSpeed = 1, this.lookSpeed = .005, this.lookVertical = !0, 
    this.autoForward = !1, this.activeLook = !0, this.heightSpeed = !1, this.heightCoef = 1, 
    this.heightMin = 0, this.heightMax = 1, this.constrainVertical = !1, this.verticalMin = 0, 
    this.verticalMax = Math.PI, this.autoSpeedFactor = 0, this.mouseX = 0, this.mouseY = 0, 
    this.lat = 0, this.lon = 0, this.phi = 0, this.theta = 0, this.moveForward = !1, 
    this.moveBackward = !1, this.moveLeft = !1, this.moveRight = !1, this.mouseDragOn = !1, 
    this.viewHalfX = 0, this.viewHalfY = 0, this.domElement !== document && this.domElement.setAttribute("tabindex", -1), 
    this.handleResize = function() {
        this.domElement === document ? (this.viewHalfX = window.innerWidth / 2, this.viewHalfY = window.innerHeight / 2) : (this.viewHalfX = this.domElement.offsetWidth / 2, 
        this.viewHalfY = this.domElement.offsetHeight / 2);
    }, this.onMouseDown = function(event) {
        if (this.domElement !== document && this.domElement.focus(), event.preventDefault(), 
        event.stopPropagation(), this.activeLook) switch (event.button) {
          case 0:
            this.moveForward = !0;
            break;

          case 2:
            this.moveBackward = !0;
        }
        this.mouseDragOn = !0;
    }, this.onMouseUp = function(event) {
        if (event.preventDefault(), event.stopPropagation(), this.activeLook) switch (event.button) {
          case 0:
            this.moveForward = !1;
            break;

          case 2:
            this.moveBackward = !1;
        }
        this.mouseDragOn = !1;
    }, this.onMouseMove = function(event) {
        this.domElement === document ? (this.mouseX = event.pageX - this.viewHalfX, this.mouseY = event.pageY - this.viewHalfY) : (this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX, 
        this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY);
    }, this.onKeyDown = function(event) {
        switch (event.keyCode) {
          case 38:
          case 87:
            this.moveForward = !0;
            break;

          case 37:
          case 65:
            this.moveLeft = !0;
            break;

          case 40:
          case 83:
            this.moveBackward = !0;
            break;

          case 39:
          case 68:
            this.moveRight = !0;
            break;

          case 82:
            this.moveUp = !0;
            break;

          case 70:
            this.moveDown = !0;
        }
    }, this.onKeyUp = function(event) {
        switch (event.keyCode) {
          case 38:
          case 87:
            this.moveForward = !1;
            break;

          case 37:
          case 65:
            this.moveLeft = !1;
            break;

          case 40:
          case 83:
            this.moveBackward = !1;
            break;

          case 39:
          case 68:
            this.moveRight = !1;
            break;

          case 82:
            this.moveUp = !1;
            break;

          case 70:
            this.moveDown = !1;
        }
    }, this.update = function(delta) {
        if (!1 !== this.enabled) {
            if (this.heightSpeed) {
                var y = THREE.Math.clamp(this.object.position.y, this.heightMin, this.heightMax), heightDelta = y - this.heightMin;
                this.autoSpeedFactor = delta * (heightDelta * this.heightCoef);
            } else this.autoSpeedFactor = 0;
            var actualMoveSpeed = delta * this.movementSpeed;
            (this.moveForward || this.autoForward && !this.moveBackward) && this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor)), 
            this.moveBackward && this.object.translateZ(actualMoveSpeed), this.moveLeft && this.object.translateX(-actualMoveSpeed), 
            this.moveRight && this.object.translateX(actualMoveSpeed), this.moveUp && this.object.translateY(actualMoveSpeed), 
            this.moveDown && this.object.translateY(-actualMoveSpeed);
            var actualLookSpeed = delta * this.lookSpeed;
            this.activeLook || (actualLookSpeed = 0);
            var verticalLookRatio = 1;
            this.constrainVertical && (verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin)), 
            this.lon += this.mouseX * actualLookSpeed, this.lookVertical && (this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio), 
            this.lat = Math.max(-85, Math.min(85, this.lat)), this.phi = THREE.Math.degToRad(90 - this.lat), 
            this.theta = THREE.Math.degToRad(this.lon), this.constrainVertical && (this.phi = THREE.Math.mapLinear(this.phi, 0, Math.PI, this.verticalMin, this.verticalMax));
            var targetPosition = this.target, position = this.object.position;
            targetPosition.x = position.x + 100 * Math.sin(this.phi) * Math.cos(this.theta), 
            targetPosition.y = position.y + 100 * Math.cos(this.phi), targetPosition.z = position.z + 100 * Math.sin(this.phi) * Math.sin(this.theta), 
            this.object.lookAt(targetPosition);
        }
    }, this.dispose = function() {
        this.domElement.removeEventListener("contextmenu", contextmenu, !1), this.domElement.removeEventListener("mousedown", _onMouseDown, !1), 
        this.domElement.removeEventListener("mousemove", _onMouseMove, !1), this.domElement.removeEventListener("mouseup", _onMouseUp, !1), 
        window.removeEventListener("keydown", _onKeyDown, !1), window.removeEventListener("keyup", _onKeyUp, !1);
    };
    var _onMouseMove = bind(this, this.onMouseMove), _onMouseDown = bind(this, this.onMouseDown), _onMouseUp = bind(this, this.onMouseUp), _onKeyDown = bind(this, this.onKeyDown), _onKeyUp = bind(this, this.onKeyUp);
    this.domElement.addEventListener("contextmenu", contextmenu, !1), this.domElement.addEventListener("mousemove", _onMouseMove, !1), 
    this.domElement.addEventListener("mousedown", _onMouseDown, !1), this.domElement.addEventListener("mouseup", _onMouseUp, !1), 
    window.addEventListener("keydown", _onKeyDown, !1), window.addEventListener("keyup", _onKeyUp, !1), 
    this.handleResize();
}, THREE.PointerLockControls = function(camera) {
    var scope = this;
    camera.rotation.set(0, 0, 0);
    var pitchObject = new THREE.Object3D();
    pitchObject.add(camera);
    var yawObject = new THREE.Object3D();
    yawObject.position.y = 10, yawObject.add(pitchObject);
    var PI_2 = Math.PI / 2, onMouseMove = function(event) {
        if (!1 !== scope.enabled) {
            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0, movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            yawObject.rotation.y -= .002 * movementX, pitchObject.rotation.x -= .002 * movementY, 
            pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
        }
    };
    this.dispose = function() {
        document.removeEventListener("mousemove", onMouseMove, !1);
    }, document.addEventListener("mousemove", onMouseMove, !1), this.enabled = !1, this.getObject = function() {
        return yawObject;
    }, this.getDirection = function() {
        var direction = new THREE.Vector3(0, 0, -1), rotation = new THREE.Euler(0, 0, 0, "YXZ");
        return function(v) {
            return rotation.set(pitchObject.rotation.x, yawObject.rotation.y, 0), v.copy(direction).applyEuler(rotation), 
            v;
        };
    }();
}, THREE.Mirror = function(width, height, options) {
    function updateTextureMatrix(camera) {
        scope.updateMatrixWorld(), mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld), 
        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld), rotationMatrix.extractRotation(scope.matrixWorld), 
        normal.set(0, 0, 1), normal.applyMatrix4(rotationMatrix), view.subVectors(mirrorWorldPosition, cameraWorldPosition), 
        view.reflect(normal).negate(), view.add(mirrorWorldPosition), rotationMatrix.extractRotation(camera.matrixWorld), 
        lookAtPosition.set(0, 0, -1), lookAtPosition.applyMatrix4(rotationMatrix), lookAtPosition.add(cameraWorldPosition), 
        target.subVectors(mirrorWorldPosition, lookAtPosition), target.reflect(normal).negate(), 
        target.add(mirrorWorldPosition), mirrorCamera.position.copy(view), mirrorCamera.up.set(0, 1, 0), 
        mirrorCamera.up.applyMatrix4(rotationMatrix), mirrorCamera.up.reflect(normal), mirrorCamera.lookAt(target), 
        mirrorCamera.aspect = camera.aspect, mirrorCamera.near = camera.near, mirrorCamera.far = camera.far, 
        mirrorCamera.updateMatrixWorld(), mirrorCamera.updateProjectionMatrix(), textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), 
        textureMatrix.multiply(mirrorCamera.projectionMatrix), textureMatrix.multiply(mirrorCamera.matrixWorldInverse), 
        mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition), mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse), 
        clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);
        var projectionMatrix = mirrorCamera.projectionMatrix;
        q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0], 
        q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5], 
        q.z = -1, q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14], 
        clipPlane.multiplyScalar(2 / clipPlane.dot(q)), projectionMatrix.elements[2] = clipPlane.x, 
        projectionMatrix.elements[6] = clipPlane.y, projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias, 
        projectionMatrix.elements[14] = clipPlane.w;
    }
    THREE.Mesh.call(this, new THREE.PlaneBufferGeometry(width, height));
    var scope = this;
    scope.name = "mirror_" + scope.id, scope.matrixNeedsUpdate = !0, options = options || {};
    var viewport = new THREE.Vector4(), textureWidth = void 0 !== options.textureWidth ? options.textureWidth : 512, textureHeight = void 0 !== options.textureHeight ? options.textureHeight : 512, clipBias = void 0 !== options.clipBias ? options.clipBias : 0, mirrorColor = void 0 !== options.color ? new THREE.Color(options.color) : new THREE.Color(8355711), mirrorPlane = new THREE.Plane(), normal = new THREE.Vector3(), mirrorWorldPosition = new THREE.Vector3(), cameraWorldPosition = new THREE.Vector3(), rotationMatrix = new THREE.Matrix4(), lookAtPosition = new THREE.Vector3(0, 0, -1), clipPlane = new THREE.Vector4(), view = new THREE.Vector3(), target = new THREE.Vector3(), q = new THREE.Vector4(), textureMatrix = new THREE.Matrix4(), mirrorCamera = new THREE.PerspectiveCamera(), parameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBFormat,
        stencilBuffer: !1
    }, renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);
    THREE.Math.isPowerOfTwo(textureWidth) && THREE.Math.isPowerOfTwo(textureHeight) || (renderTarget.texture.generateMipmaps = !1);
    var mirrorShader = {
        uniforms: {
            mirrorColor: {
                value: new THREE.Color(8355711)
            },
            mirrorSampler: {
                value: null
            },
            textureMatrix: {
                value: new THREE.Matrix4()
            }
        },
        vertexShader: [ "uniform mat4 textureMatrix;", "varying vec4 mirrorCoord;", "void main() {", "\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "\tmirrorCoord = textureMatrix * worldPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "}" ].join("\n"),
        fragmentShader: [ "uniform vec3 mirrorColor;", "uniform sampler2D mirrorSampler;", "varying vec4 mirrorCoord;", "float blendOverlay(float base, float blend) {", "\treturn( base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );", "}", "void main() {", "\tvec4 color = texture2DProj(mirrorSampler, mirrorCoord);", "\tcolor = vec4(blendOverlay(mirrorColor.r, color.r), blendOverlay(mirrorColor.g, color.g), blendOverlay(mirrorColor.b, color.b), 1.0);", "\tgl_FragColor = color;", "}" ].join("\n")
    }, mirrorUniforms = THREE.UniformsUtils.clone(mirrorShader.uniforms), material = new THREE.ShaderMaterial({
        fragmentShader: mirrorShader.fragmentShader,
        vertexShader: mirrorShader.vertexShader,
        uniforms: mirrorUniforms
    });
    material.uniforms.mirrorSampler.value = renderTarget.texture, material.uniforms.mirrorColor.value = mirrorColor, 
    material.uniforms.textureMatrix.value = textureMatrix, scope.material = material, 
    scope.onBeforeRender = function(renderer, scene, camera) {
        updateTextureMatrix(camera), scope.visible = !1;
        var currentRenderTarget = renderer.getRenderTarget(), currentVrEnabled = renderer.vr.enabled, currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
        renderer.vr.enabled = !1, renderer.shadowMap.autoUpdate = !1, renderer.render(scene, mirrorCamera, renderTarget, !0), 
        renderer.vr.enabled = currentVrEnabled, renderer.shadowMap.autoUpdate = currentShadowAutoUpdate, 
        renderer.setRenderTarget(currentRenderTarget);
        var bounds = camera.bounds;
        if (void 0 !== bounds) {
            var size = renderer.getSize(), pixelRatio = renderer.getPixelRatio();
            viewport.x = bounds.x * size.width * pixelRatio, viewport.y = bounds.y * size.height * pixelRatio, 
            viewport.z = bounds.z * size.width * pixelRatio, viewport.w = bounds.w * size.height * pixelRatio, 
            renderer.state.viewport(viewport);
        }
        scope.visible = !0;
    };
}, THREE.Mirror.prototype = Object.create(THREE.Mesh.prototype);

var Detector = {
    canvas: !!window.CanvasRenderingContext2D,
    webgl: function() {
        try {
            var canvas = document.createElement("canvas");
            return !(!window.WebGLRenderingContext || !canvas.getContext("webgl") && !canvas.getContext("experimental-webgl"));
        } catch (e) {
            return !1;
        }
    }(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
    getWebGLErrorMessage: function() {
        var element = document.createElement("div");
        return element.id = "webgl-error-message", element.style.fontFamily = "monospace", 
        element.style.fontSize = "13px", element.style.fontWeight = "normal", element.style.textAlign = "center", 
        element.style.background = "#fff", element.style.color = "#000", element.style.padding = "1.5em", 
        element.style.width = "400px", element.style.margin = "5em auto 0", this.webgl || (element.innerHTML = window.WebGLRenderingContext ? [ 'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.' ].join("\n") : [ 'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.' ].join("\n")), 
        element;
    },
    addGetWebGLMessage: function(parameters) {
        var parent, id, element;
        parameters = parameters || {}, parent = void 0 !== parameters.parent ? parameters.parent : document.body, 
        id = void 0 !== parameters.id ? parameters.id : "oldie", element = Detector.getWebGLErrorMessage(), 
        element.id = id, parent.appendChild(element);
    }
};

"object" == typeof module && (module.exports = Detector);

var THREEx = THREEx || {};

THREEx.WindowResize = function(renderer, camera, dimension) {
    dimension = dimension || function() {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        };
    };
    var callback = function() {
        var rendererSize = dimension();
        renderer.setSize(rendererSize.width, rendererSize.height), camera.aspect = rendererSize.width / rendererSize.height, 
        camera.updateProjectionMatrix();
    };
    return window.addEventListener("resize", callback, !1), {
        trigger: function() {
            callback();
        },
        destroy: function() {
            window.removeEventListener("resize", callback);
        }
    };
};

var THREEx = THREEx || {};

THREEx.RendererStats = function() {
    var container = document.createElement("div");
    container.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var msDiv = document.createElement("div");
    msDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#200;", 
    container.appendChild(msDiv);
    var msText = document.createElement("div");
    msText.style.cssText = "color:#f00;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    msText.innerHTML = "WebGLRenderer", msDiv.appendChild(msText);
    for (var msTexts = [], i = 0; i < 9; i++) msTexts[i] = document.createElement("div"), 
    msTexts[i].style.cssText = "color:#f00;background-color:#311;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    msDiv.appendChild(msTexts[i]), msTexts[i].innerHTML = "-";
    var lastTime = Date.now();
    return {
        domElement: container,
        update: function(webGLRenderer) {
            if (console.assert(webGLRenderer instanceof THREE.WebGLRenderer), !(Date.now() - lastTime < 1e3 / 30)) {
                lastTime = Date.now();
                var i = 0;
                msTexts[i++].textContent = "== Memory =====", msTexts[i++].textContent = "Programs: " + webGLRenderer.info.memory.programs, 
                msTexts[i++].textContent = "Geometries: " + webGLRenderer.info.memory.geometries, 
                msTexts[i++].textContent = "Textures: " + webGLRenderer.info.memory.textures, msTexts[i++].textContent = "== Render =====", 
                msTexts[i++].textContent = "Calls: " + webGLRenderer.info.render.calls, msTexts[i++].textContent = "Vertices: " + webGLRenderer.info.render.vertices, 
                msTexts[i++].textContent = "Faces: " + webGLRenderer.info.render.faces, msTexts[i++].textContent = "Points: " + webGLRenderer.info.render.points;
            }
        }
    };
};

var THREEx = THREEx || {};

THREEx.UniversalLoader = function() {}, THREEx.UniversalLoader.prototype.load = function(urls, onLoad) {
    return "string" == typeof urls && (urls = [ urls ]), urls[0].match(/\.stl$/i) && 1 === urls.length ? (this.loader = new THREE.STLLoader(), 
    this.loader.addEventListener("load", function(event) {
        var geometry = event.content, material = new THREE.MeshPhongMaterial(), object3d = new THREE.Mesh(geometry, material);
        onLoad(object3d);
    }), void this.loader.load(urls[0])) : urls[0].match(/\.dae$/i) && 1 === urls.length ? (this.loader = new THREE.ColladaLoader(), 
    this.loader.options.convertUpAxis = !0, void this.loader.load(urls[0], function(collada) {
        var object3d = collada.scene;
        onLoad(object3d);
    })) : urls[0].match(/\.js$/i) && 1 === urls.length ? (this.loader = new THREE.JSONLoader(), 
    void this.loader.load(urls[0], function(geometry, materials) {
        if (materials.length > 1) var material = new THREE.MeshFaceMaterial(materials); else var material = materials[0];
        var object3d = new THREE.Mesh(geometry, material);
        onLoad(object3d);
    })) : urls[0].match(/\.obj$/i) && 1 === urls.length ? (this.loader = new THREE.OBJLoader(), 
    void this.loader.load(urls[0], function(object3d) {
        onLoad(object3d);
    })) : 2 === urls.length && urls[0].match(/\.mtl$/i) && urls[1].match(/\.obj$/i) ? (this.loader = new THREE.OBJMTLLoader(), 
    void this.loader.load(urls[1], urls[0], function(object3d) {
        onLoad(object3d);
    })) : 2 === urls.length && urls[0].match(/\.obj$/i) && urls[1].match(/\.mtl$/i) ? (this.loader = new THREE.OBJMTLLoader(), 
    void this.loader.load(urls[0], urls[1], function(object3d) {
        onLoad(object3d);
    })) : void console.assert(!1);
};

var THREEx = THREEx || {};

THREEx.KeyboardState = function(domElement) {
    this.domElement = domElement || document, this.keyCodes = {}, this.modifiers = {};
    var _this = this;
    this._onKeyDown = function(event) {
        _this._onKeyChange(event);
    }, this._onKeyUp = function(event) {
        _this._onKeyChange(event);
    }, this.domElement.addEventListener("keydown", this._onKeyDown, !1), this.domElement.addEventListener("keyup", this._onKeyUp, !1), 
    this._onBlur = function() {
        for (var prop in _this.keyCodes) _this.keyCodes[prop] = !1;
        for (var prop in _this.modifiers) _this.modifiers[prop] = !1;
    }, window.addEventListener("blur", this._onBlur, !1);
}, THREEx.KeyboardState.prototype.destroy = function() {
    this.domElement.removeEventListener("keydown", this._onKeyDown, !1), this.domElement.removeEventListener("keyup", this._onKeyUp, !1), 
    window.removeEventListener("blur", this._onBlur, !1);
}, THREEx.KeyboardState.MODIFIERS = [ "shift", "ctrl", "alt", "meta" ], THREEx.KeyboardState.ALIAS = {
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    space: 32,
    pageup: 33,
    pagedown: 34,
    tab: 9,
    escape: 27
}, THREEx.KeyboardState.prototype._onKeyChange = function(event) {
    var keyCode = event.keyCode, pressed = "keydown" === event.type;
    this.keyCodes[keyCode] = pressed, this.modifiers.shift = event.shiftKey, this.modifiers.ctrl = event.ctrlKey, 
    this.modifiers.alt = event.altKey, this.modifiers.meta = event.metaKey;
}, THREEx.KeyboardState.prototype.pressed = function(keyDesc) {
    for (var keys = keyDesc.split("+"), i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!(-1 !== THREEx.KeyboardState.MODIFIERS.indexOf(key) ? this.modifiers[key] : -1 != Object.keys(THREEx.KeyboardState.ALIAS).indexOf(key) ? this.keyCodes[THREEx.KeyboardState.ALIAS[key]] : this.keyCodes[key.toUpperCase().charCodeAt(0)])) return !1;
    }
    return !0;
}, THREEx.KeyboardState.prototype.eventMatches = function(event, keyDesc) {
    for (var aliases = THREEx.KeyboardState.ALIAS, aliasKeys = Object.keys(aliases), keys = keyDesc.split("+"), i = 0; i < keys.length; i++) {
        var key = keys[i], pressed = !1;
        if ("shift" === key ? pressed = !!event.shiftKey : "ctrl" === key ? pressed = !!event.ctrlKey : "alt" === key ? pressed = !!event.altKey : "meta" === key ? pressed = !!event.metaKey : -1 !== aliasKeys.indexOf(key) ? pressed = event.keyCode === aliases[key] : event.keyCode === key.toUpperCase().charCodeAt(0) && (pressed = !0), 
        !pressed) return !1;
    }
    return !0;
};

var THREEx = THREEx || {};

THREEx.VolumetricSpotLightMaterial = function() {
    var vertexShader = [ "varying vec3 vNormal;", "varying vec3 vWorldPosition;", "void main(){", "// compute intensity", "vNormal\t\t= normalize( normalMatrix * normal );", "vec4 worldPosition\t= modelMatrix * vec4( position, 1.0 );", "vWorldPosition\t\t= worldPosition.xyz;", "// set gl_Position", "gl_Position\t= projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"), fragmentShader = [ "varying vec3\t\tvNormal;", "varying vec3\t\tvWorldPosition;", "uniform vec3\t\tlightColor;", "uniform vec3\t\tspotPosition;", "uniform float\t\tattenuation;", "uniform float\t\tanglePower;", "void main(){", "float intensity;", "intensity\t= distance(vWorldPosition, spotPosition)/attenuation;", "intensity\t= 1.0 - clamp(intensity, 0.0, 1.0);", "vec3 normal\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));", "float angleIntensity\t= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );", "intensity\t= intensity * angleIntensity;", "gl_FragColor\t= vec4( lightColor, intensity);", "}" ].join("\n");
    return new THREE.ShaderMaterial({
        uniforms: {
            attenuation: {
                type: "f",
                value: 5
            },
            anglePower: {
                type: "f",
                value: 1.2
            },
            spotPosition: {
                type: "v3",
                value: new THREE.Vector3(0, 0, 0)
            },
            lightColor: {
                type: "c",
                value: new THREE.Color("cyan")
            }
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: !0,
        depthWrite: !1
    });
};

var THREEx = THREEx || {};

THREEx.ThreePointsLighting = function() {
    var container = new THREE.Object3D(), object3d = new THREE.AmbientLight(1052688);
    object3d.name = "Ambient light", container.add(object3d);
    var object3d = new THREE.DirectionalLight("white", .225);
    object3d.position.set(2.6, 1, 3), object3d.name = "Back light", container.add(object3d);
    var object3d = new THREE.DirectionalLight("white", .375);
    object3d.position.set(-2, -1, 0), object3d.name = "Key light", container.add(object3d);
    var object3d = new THREE.DirectionalLight("white", .75);
    return object3d.position.set(3, 3, 2), object3d.name = "Fill light", container.add(object3d), 
    container;
}, THREEx.SunSetLighting = function() {
    var object3d = new THREE.Object3D(), light = new THREE.AmbientLight(526344);
    object3d.add(light);
    var light = new THREE.DirectionalLight("midnightblue", 1);
    light.position.set(5, 1, 0), object3d.add(light);
    var light = new THREE.DirectionalLight("darkred", 1.5);
    return object3d.add(light), object3d;
}, !function(a) {
    function b(a, b, c) {
        this.x = a, this.y = b, this.z = c;
    }
    function c(a) {
        return a * a * a * (a * (6 * a - 15) + 10);
    }
    function d(a, b, c) {
        return (1 - c) * a + c * b;
    }
    var e = a.noise = {};
    b.prototype.dot2 = function(a, b) {
        return this.x * a + this.y * b;
    }, b.prototype.dot3 = function(a, b, c) {
        return this.x * a + this.y * b + this.z * c;
    };
    var f = [ new b(1, 1, 0), new b(-1, 1, 0), new b(1, -1, 0), new b(-1, -1, 0), new b(1, 0, 1), new b(-1, 0, 1), new b(1, 0, -1), new b(-1, 0, -1), new b(0, 1, 1), new b(0, -1, 1), new b(0, 1, -1), new b(0, -1, -1) ], g = [ 151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180 ], h = new Array(512), i = new Array(512);
    e.seed = function(a) {
        a > 0 && a < 1 && (a *= 65536), (a = Math.floor(a)) < 256 && (a |= a << 8);
        for (var b = 0; b < 256; b++) {
            var c;
            c = 1 & b ? g[b] ^ 255 & a : g[b] ^ a >> 8 & 255, h[b] = h[b + 256] = c, i[b] = i[b + 256] = f[c % 12];
        }
    }, e.seed(Math.random());
    var j = .5 * (Math.sqrt(3) - 1), k = (3 - Math.sqrt(3)) / 6;
    e.simplex = function(a, b) {
        var c, d, e, p, q, f = (a + b) * j, g = Math.floor(a + f), l = Math.floor(b + f), m = (g + l) * k, n = a - g + m, o = b - l + m;
        n > o ? (p = 1, q = 0) : (p = 0, q = 1);
        var r = n - p + k, s = o - q + k, t = n - 1 + 2 * k, u = o - 1 + 2 * k;
        g &= 255, l &= 255;
        var v = i[g + h[l]], w = i[g + p + h[l + q]], x = i[g + 1 + h[l + 1]], y = .5 - n * n - o * o;
        y < 0 ? c = 0 : (y *= y, c = y * y * v.dot2(n, o));
        var z = .5 - r * r - s * s;
        z < 0 ? d = 0 : (z *= z, d = z * z * w.dot2(r, s));
        var A = .5 - t * t - u * u;
        return A < 0 ? e = 0 : (A *= A, e = A * A * x.dot2(t, u)), 70 * (c + d + e);
    }, e.perlin = function(a, b) {
        var e = Math.floor(a), f = Math.floor(b);
        a -= e, b -= f, e &= 255, f &= 255;
        var g = i[e + h[f]].dot2(a, b), j = i[e + h[f + 1]].dot2(a, b - 1), k = i[e + 1 + h[f]].dot2(a - 1, b), l = i[e + 1 + h[f + 1]].dot2(a - 1, b - 1), m = c(a);
        return d(d(g, k, m), d(j, l, m), c(b));
    };
}(this), THREE.Terrain = function(a) {
    var b = {
        after: null,
        easing: THREE.Terrain.Linear,
        heightmap: THREE.Terrain.DiamondSquare,
        material: null,
        maxHeight: 100,
        minHeight: -100,
        optimization: THREE.Terrain.NONE,
        frequency: 2.5,
        steps: 1,
        stretch: !0,
        turbulent: !1,
        useBufferGeometry: !1,
        xSegments: 63,
        xSize: 1024,
        ySegments: 63,
        ySize: 1024,
        _mesh: null
    };
    a = a || {};
    for (var c in b) b.hasOwnProperty(c) && (a[c] = void 0 === a[c] ? b[c] : a[c]);
    a.material = a.material || new THREE.MeshBasicMaterial({
        color: 15623731
    });
    var d = new THREE.Object3D();
    d.rotation.x = -.5 * Math.PI;
    var e = a._mesh;
    if (e && "PlaneGeometry" === e.geometry.type && e.geometry.parameters.widthSegments === a.xSegments && e.geometry.parameters.heightSegments === a.ySegments) {
        e.material = a.material, e.scale.x = a.xSize / e.geometry.parameters.width, e.scale.y = a.ySize / e.geometry.parameters.height;
        for (var f = 0, g = e.geometry.vertices.length; f < g; f++) e.geometry.vertices[f].z = 0;
    } else e = new THREE.Mesh(new THREE.PlaneGeometry(a.xSize, a.ySize, a.xSegments, a.ySegments), a.material);
    return delete a._mesh, a.heightmap instanceof HTMLCanvasElement || a.heightmap instanceof Image ? THREE.Terrain.fromHeightmap(e.geometry.vertices, a) : "function" == typeof a.heightmap ? a.heightmap(e.geometry.vertices, a) : console.warn("An invalid value was passed for `options.heightmap`: " + a.heightmap), 
    THREE.Terrain.Normalize(e, a), a.useBufferGeometry && (e.geometry = new THREE.BufferGeometry().fromGeometry(e.geometry)), 
    d.add(e), d;
}, THREE.Terrain.Normalize = function(a, b) {
    var c = a.geometry.vertices;
    b.turbulent && THREE.Terrain.Turbulence(c, b), b.steps > 1 && (THREE.Terrain.Step(c, b.steps), 
    THREE.Terrain.Smooth(c, b)), THREE.Terrain.Clamp(c, b), "function" == typeof b.after && b.after(c, b), 
    a.geometry.verticesNeedUpdate = !0, a.geometry.normalsNeedUpdate = !0, a.geometry.computeBoundingSphere(), 
    a.geometry.computeFaceNormals(), a.geometry.computeVertexNormals();
}, THREE.Terrain.NONE = 0, THREE.Terrain.GEOMIPMAP = 1, THREE.Terrain.GEOCLIPMAP = 2, 
THREE.Terrain.POLYGONREDUCTION = 3, THREE.Terrain.toArray2D = function(a, b) {
    var f, g, c = new Array(b.xSegments), d = b.xSegments + 1, e = b.ySegments + 1;
    for (f = 0; f < d; f++) for (c[f] = new Float64Array(b.ySegments), g = 0; g < e; g++) c[f][g] = a[g * d + f].z;
    return c;
}, THREE.Terrain.fromArray2D = function(a, b) {
    for (var c = 0, d = b.length; c < d; c++) for (var e = 0, f = b[c].length; e < f; e++) a[e * d + c].z = b[c][e];
}, THREE.Terrain.toArray1D = function(a) {
    for (var b = new Float64Array(a.length), c = 0, d = b.length; c < d; c++) b[c] = a[c].z;
    return b;
}, THREE.Terrain.fromArray1D = function(a, b) {
    for (var c = 0, d = Math.min(a.length, b.length); c < d; c++) a[c].z = b[c];
}, THREE.Terrain.heightmapArray = function(a, b) {
    var e, c = new Array((b.xSegments + 1) * (b.ySegments + 1)), d = c.length;
    for (e = 0; e < d; e++) c[e] = {
        z: 0
    };
    for (b.minHeight = b.minHeight || 0, b.maxHeight = void 0 === b.maxHeight ? 1 : b.maxHeight, 
    b.stretch = b.stretch || !1, a(c, b), THREE.Terrain.Clamp(c, b), e = 0; e < d; e++) c[e] = c[e].z;
    return c;
}, THREE.Terrain.Linear = function(a) {
    return a;
}, THREE.Terrain.EaseIn = function(a) {
    return a * a;
}, THREE.Terrain.EaseOut = function(a) {
    return -a * (a - 2);
}, THREE.Terrain.EaseInOut = function(a) {
    return a * a * (3 - 2 * a);
}, THREE.Terrain.InEaseOut = function(a) {
    var b = 2 * a - 1;
    return .5 * b * b * b + .5;
}, THREE.Terrain.EaseInWeak = function(a) {
    return Math.pow(a, 1.55);
}, THREE.Terrain.EaseInStrong = function(a) {
    return a * a * a * a * a * a * a;
}, THREE.Terrain.fromHeightmap = function(a, b) {
    var c = document.createElement("canvas"), d = c.getContext("2d"), e = b.ySegments + 1, f = b.xSegments + 1, g = b.maxHeight - b.minHeight;
    c.width = f, c.height = e, d.drawImage(b.heightmap, 0, 0, c.width, c.height);
    for (var h = d.getImageData(0, 0, c.width, c.height).data, i = 0; i < e; i++) for (var j = 0; j < f; j++) {
        var k = i * f + j, l = 4 * k;
        a[k].z = (h[l] + h[l + 1] + h[l + 2]) / 765 * g + b.minHeight;
    }
}, THREE.Terrain.toHeightmap = function(a, b) {
    var c = void 0 === b.maxHeight, d = void 0 === b.minHeight, e = c ? b.maxHeight : -1 / 0, f = d ? b.minHeight : 1 / 0;
    if (!c || !d) {
        for (var g = e, h = f, i = 0, j = a.length; i < j; i++) a[i].z > g && (g = a[i].z), 
        a[i].z < h && (h = a[i].z);
        c || (e = g), d || (f = h);
    }
    var k = b.heightmap instanceof HTMLCanvasElement ? b.heightmap : document.createElement("canvas"), l = k.getContext("2d"), m = b.ySegments + 1, n = b.xSegments + 1, o = b.maxHeight - b.minHeight;
    k.width = n, k.height = m;
    for (var p = l.createImageData(k.width, k.height), q = p.data, r = 0; r < m; r++) for (var s = 0; s < n; s++) {
        var t = r * n + s, u = 4 * t;
        q[u] = q[u + 1] = q[u + 2] = Math.round((a[t].z - b.minHeight) / o * 255), q[u + 3] = 255;
    }
    return l.putImageData(p, 0, 0), k;
}, THREE.Terrain.Clamp = function(a, b) {
    var f, c = 1 / 0, d = -1 / 0, e = a.length;
    for (b.easing = b.easing || THREE.Terrain.Linear, f = 0; f < e; f++) a[f].z < c && (c = a[f].z), 
    a[f].z > d && (d = a[f].z);
    var g = d - c, h = "number" != typeof b.maxHeight ? d : b.maxHeight, i = "number" != typeof b.minHeight ? c : b.minHeight, j = b.stretch ? h : d < h ? d : h, k = b.stretch ? i : c > i ? c : i, l = j - k;
    for (j < k && (j = h, l = j - k), f = 0; f < e; f++) a[f].z = b.easing((a[f].z - c) / g) * l + i;
}, THREE.Terrain.Edges = function(a, b, c, d, e, f) {
    var m, n, o, p, q, g = Math.floor(d / (b.xSize / b.xSegments)) || 1, h = Math.floor(d / (b.ySize / b.ySegments)) || 1, i = c ? b.maxHeight : b.minHeight, j = c ? Math.max : Math.min, k = b.xSegments + 1, l = b.ySegments + 1;
    for (e = e || THREE.Terrain.EaseInOut, "object" != typeof f && (f = {
        top: !0,
        bottom: !0,
        left: !0,
        right: !0
    }), m = 0; m < k; m++) for (n = 0; n < h; n++) o = e(1 - n / h), p = n * k + m, 
    q = (b.ySegments - n) * k + m, f.top && (a[p].z = j(a[p].z, (i - a[p].z) * o + a[p].z)), 
    f.bottom && (a[q].z = j(a[q].z, (i - a[q].z) * o + a[q].z));
    for (m = 0; m < l; m++) for (n = 0; n < g; n++) o = e(1 - n / g), p = m * k + n, 
    q = (b.ySegments - m) * k + (b.xSegments - n), f.left && (a[p].z = j(a[p].z, (i - a[p].z) * o + a[p].z)), 
    f.right && (a[q].z = j(a[q].z, (i - a[q].z) * o + a[q].z));
    THREE.Terrain.Clamp(a, {
        maxHeight: b.maxHeight,
        minHeight: b.minHeight,
        stretch: !0
    });
}, THREE.Terrain.RadialEdges = function(a, b, c, d, e) {
    var o, p, q, r, s, f = c ? b.maxHeight : b.minHeight, g = c ? Math.max : Math.min, h = b.xSegments + 1, i = b.ySegments + 1, j = .5 * h, k = .5 * i, l = b.xSize / b.xSegments, m = b.ySize / b.ySegments, n = .5 * Math.min(b.xSize, b.ySize) - d;
    for (o = 0; o < h; o++) for (p = 0; p < k; p++) r = p * h + o, (s = Math.min(n, Math.sqrt((j - o) * l * (j - o) * l + (k - p) * m * (k - p) * m) - d)) < 0 || (q = e(s / n), 
    a[r].z = g(a[r].z, (f - a[r].z) * q + a[r].z), r = (b.ySegments - p) * h + o, a[r].z = g(a[r].z, (f - a[r].z) * q + a[r].z));
}, THREE.Terrain.Smooth = function(a, b, c) {
    for (var d = new Float64Array(a.length), e = 0, f = b.xSegments + 1, g = b.ySegments + 1; e < f; e++) for (var h = 0; h < g; h++) {
        for (var i = 0, j = 0, k = -1; k <= 1; k++) for (var l = -1; l <= 1; l++) {
            var m = (h + k) * f + e + l;
            void 0 !== a[m] && e + l >= 0 && h + k >= 0 && e + l < f && h + k < g && (i += a[m].z, 
            j++);
        }
        d[h * f + e] = i / j;
    }
    c = c || 0;
    for (var n = 1 / (1 + c), o = 0, p = a.length; o < p; o++) a[o].z = (d[o] + a[o].z * c) * n;
}, THREE.Terrain.SmoothMedian = function(a, b) {
    for (var c = new Float64Array(a.length), d = [], e = [], f = function(a, b) {
        return d[a] - d[b];
    }, g = 0, h = b.xSegments + 1, i = b.ySegments + 1; g < h; g++) for (var j = 0; j < i; j++) {
        d.length = 0, e.length = 0;
        for (var k = -1; k <= 1; k++) for (var l = -1; l <= 1; l++) {
            var m = (j + k) * h + g + l;
            void 0 !== a[m] && g + l >= 0 && j + k >= 0 && g + l < h && j + k < i && (d.push(a[m].z), 
            e.push(m));
        }
        e.sort(f);
        var o, n = Math.floor(.5 * e.length);
        o = e.length % 2 == 1 ? a[e[n]].z : .5 * (a[e[n - 1]].z + a[e[n]].z), c[j * h + g] = o;
    }
    for (var p = 0, q = a.length; p < q; p++) a[p].z = c[p];
}, THREE.Terrain.SmoothConservative = function(a, b, c) {
    for (var d = new Float64Array(a.length), e = 0, f = b.xSegments + 1, g = b.ySegments + 1; e < f; e++) for (var h = 0; h < g; h++) {
        for (var i = -1 / 0, j = 1 / 0, k = -1; k <= 1; k++) for (var l = -1; l <= 1; l++) {
            var m = (h + k) * f + e + l;
            void 0 !== a[m] && k && l && e + l >= 0 && h + k >= 0 && e + l < f && h + k < g && (a[m].z < j && (j = a[m].z), 
            a[m].z > i && (i = a[m].z));
        }
        var n = h * f + e;
        if ("number" == typeof c) {
            var o = .5 * (i - j), p = j + o;
            i = p + o * c, j = p - o * c;
        }
        d[n] = a[n].z > i ? i : a[n].z < j ? j : a[n].z;
    }
    for (var q = 0, r = a.length; q < r; q++) a[q].z = d[q];
}, THREE.Terrain.Step = function(a, b) {
    var c = 0, d = 0, e = a.length, f = Math.floor(e / b), g = new Array(e), h = new Array(b);
    for (void 0 === b && (b = Math.floor(Math.pow(.5 * e, .25))), c = 0; c < e; c++) g[c] = a[c].z;
    for (g.sort(function(a, b) {
        return a - b;
    }), c = 0; c < b; c++) {
        var i = g.slice(c * f, (c + 1) * f), j = 0, k = i.length;
        for (d = 0; d < k; d++) j += i[d];
        h[c] = {
            min: i[0],
            max: i[i.length - 1],
            avg: j / k
        };
    }
    for (c = 0; c < e; c++) {
        var l = a[c].z;
        for (d = 0; d < b; d++) if (l >= h[d].min && l <= h[d].max) {
            a[c].z = h[d].avg;
            break;
        }
    }
}, THREE.Terrain.Turbulence = function(a, b) {
    for (var c = b.maxHeight - b.minHeight, d = 0, e = a.length; d < e; d++) a[d].z = b.minHeight + Math.abs(2 * (a[d].z - b.minHeight) - c);
}, THREE.Terrain.MultiPass = function(a, b, c) {
    var d = {};
    for (var e in b) b.hasOwnProperty(e) && (d[e] = b[e]);
    for (var f = b.maxHeight - b.minHeight, g = 0, h = c.length; g < h; g++) {
        var i = void 0 === c[g].amplitude ? 1 : c[g].amplitude, j = .5 * (f - f * i);
        d.maxHeight = b.maxHeight - j, d.minHeight = b.minHeight + j, d.frequency = void 0 === c[g].frequency ? b.frequency : c[g].frequency, 
        c[g].method(a, d);
    }
}, THREE.Terrain.Curve = function(a, b, c) {
    for (var d = .5 * (b.maxHeight - b.minHeight), e = b.frequency / (Math.min(b.xSegments, b.ySegments) + 1), f = 0, g = b.xSegments + 1, h = b.ySegments + 1; f < g; f++) for (var i = 0; i < h; i++) a[i * g + f].z += c(f * e, i * e) * d;
}, THREE.Terrain.Cosine = function(a, b) {
    for (var c = .5 * (b.maxHeight - b.minHeight), d = b.frequency * Math.PI / (Math.min(b.xSegments, b.ySegments) + 1), e = Math.random() * Math.PI * 2, f = 0, g = b.xSegments + 1; f < g; f++) for (var h = 0, i = b.ySegments + 1; h < i; h++) a[h * g + f].z += c * (Math.cos(f * d + e) + Math.cos(h * d + e));
}, THREE.Terrain.CosineLayers = function(a, b) {
    THREE.Terrain.MultiPass(a, b, [ {
        method: THREE.Terrain.Cosine,
        frequency: 2.5
    }, {
        method: THREE.Terrain.Cosine,
        amplitude: .1,
        frequency: 12
    }, {
        method: THREE.Terrain.Cosine,
        amplitude: .05,
        frequency: 15
    }, {
        method: THREE.Terrain.Cosine,
        amplitude: .025,
        frequency: 20
    } ]);
}, THREE.Terrain.DiamondSquare = function(a, b) {
    var g, h, c = THREE.Math.nextPowerOfTwo(Math.max(b.xSegments, b.ySegments) + 1), d = c + 1, e = [], f = b.maxHeight - b.minHeight, i = b.xSegments + 1, j = b.ySegments + 1;
    for (g = 0; g <= c; g++) e[g] = new Float64Array(c + 1);
    for (var k = c; k >= 2; k /= 2) {
        var n, o, p, q, l = Math.round(.5 * k), m = Math.round(k);
        for (f /= 2, n = 0; n < c; n += m) for (o = 0; o < c; o += m) q = Math.random() * f * 2 - f, 
        p = e[n][o] + e[n + m][o] + e[n][o + m] + e[n + m][o + m], p *= .25, e[n + l][o + l] = p + q;
        for (n = 0; n < c; n += l) for (o = (n + l) % k; o < c; o += k) q = Math.random() * f * 2 - f, 
        p = e[(n - l + d) % d][o] + e[(n + l) % d][o] + e[n][(o + l) % d] + e[n][(o - l + d) % d], 
        p *= .25, p += q, e[n][o] = p, 0 === n && (e[c][o] = p), 0 === o && (e[n][c] = p);
    }
    for (g = 0; g < i; g++) for (h = 0; h < j; h++) a[h * i + g].z += e[g][h];
}, THREE.Terrain.Fault = function(a, b) {
    for (var c = Math.sqrt(b.xSegments * b.xSegments + b.ySegments * b.ySegments), d = c * b.frequency, e = .5 * (b.maxHeight - b.minHeight), f = e / d, g = Math.min(b.xSize / b.xSegments, b.ySize / b.ySegments) * b.frequency, h = 0; h < d; h++) for (var i = Math.random(), j = Math.sin(i * Math.PI * 2), k = Math.cos(i * Math.PI * 2), l = Math.random() * c - .5 * c, m = 0, n = b.xSegments + 1; m < n; m++) for (var o = 0, p = b.ySegments + 1; o < p; o++) {
        var q = j * m + k * o - l;
        q > g ? a[o * n + m].z += f : q < -g ? a[o * n + m].z -= f : a[o * n + m].z += Math.cos(q / g * Math.PI * 2) * f;
    }
}, THREE.Terrain.Hill = function(a, b, c, d) {
    var e = 2 * b.frequency, f = e * e * 10, g = b.maxHeight - b.minHeight, h = g / (e * e), i = g / e, j = Math.min(b.xSize, b.ySize), k = j / (e * e), l = j / e;
    c = c || THREE.Terrain.Influences.Hill;
    for (var m = {
        x: 0,
        y: 0
    }, n = 0; n < f; n++) {
        var o = Math.random() * (l - k) + k, p = Math.random() * (i - h) + h;
        b.xSize, b.ySize;
        m.x = Math.random(), m.y = Math.random(), "function" == typeof d && d(m), THREE.Terrain.Influence(a, b, c, m.x, m.y, o, p, THREE.AdditiveBlending, THREE.Terrain.EaseInStrong);
    }
}, THREE.Terrain.HillIsland = function() {
    var a = function(a) {
        var b = Math.random() * Math.PI * 2;
        a.x = .5 + Math.cos(b) * a.x * .4, a.y = .5 + Math.sin(b) * a.y * .4;
    };
    return function(b, c, d) {
        THREE.Terrain.Hill(b, c, d, a);
    };
}(), function() {
    function a(b, c, d, e, f) {
        for (var g = d * e + c, h = 0; h < 3; h++) {
            switch (Math.floor(8 * Math.random())) {
              case 0:
                c++;
                break;

              case 1:
                c--;
                break;

              case 2:
                d++;
                break;

              case 3:
                d--;
                break;

              case 4:
                c++, d++;
                break;

              case 5:
                c++, d--;
                break;

              case 6:
                c--, d++;
                break;

              case 7:
                c--, d--;
            }
            var i = d * e + c;
            if (void 0 !== b[i]) {
                if (b[i].z < b[g].z) return void a(b, c, d, e, f);
            } else if (Math.random() < .2) return void (b[g].z += f);
        }
        b[g].z += f;
    }
    THREE.Terrain.Particles = function(b, c) {
        for (var d = Math.sqrt(c.xSegments * c.xSegments + c.ySegments * c.ySegments) * c.frequency * 300, e = c.xSegments + 1, f = (c.maxHeight - c.minHeight) / d * 1e3, g = Math.floor(Math.random() * c.xSegments), h = Math.floor(Math.random() * c.ySegments), i = .2 * Math.random() - .1, j = .2 * Math.random() - .1, k = 0; k < d; k++) {
            a(b, g, h, e, f);
            var l = Math.random() * Math.PI * 2;
            k % 1e3 == 0 && (i = .2 * Math.random() - .1, j = .2 * Math.random() - .1), k % 100 == 0 && (g = Math.floor(c.xSegments * (.5 + i) + Math.cos(l) * Math.random() * c.xSegments * (.5 - Math.abs(i))), 
            h = Math.floor(c.ySegments * (.5 + j) + Math.sin(l) * Math.random() * c.ySegments * (.5 - Math.abs(j))));
        }
    };
}(), THREE.Terrain.Perlin = function(a, b) {
    noise.seed(Math.random());
    for (var c = .5 * (b.maxHeight - b.minHeight), d = (Math.min(b.xSegments, b.ySegments) + 1) / b.frequency, e = 0, f = b.xSegments + 1; e < f; e++) for (var g = 0, h = b.ySegments + 1; g < h; g++) a[g * f + e].z += noise.perlin(e / d, g / d) * c;
}, THREE.Terrain.PerlinDiamond = function(a, b) {
    THREE.Terrain.MultiPass(a, b, [ {
        method: THREE.Terrain.Perlin
    }, {
        method: THREE.Terrain.DiamondSquare,
        amplitude: .75
    }, {
        method: function(a, b) {
            return THREE.Terrain.SmoothMedian(a, b);
        }
    } ]);
}, THREE.Terrain.PerlinLayers = function(a, b) {
    THREE.Terrain.MultiPass(a, b, [ {
        method: THREE.Terrain.Perlin,
        frequency: 1.25
    }, {
        method: THREE.Terrain.Perlin,
        amplitude: .05,
        frequency: 2.5
    }, {
        method: THREE.Terrain.Perlin,
        amplitude: .35,
        frequency: 5
    }, {
        method: THREE.Terrain.Perlin,
        amplitude: .15,
        frequency: 10
    } ]);
}, THREE.Terrain.Simplex = function(a, b) {
    noise.seed(Math.random());
    for (var c = .5 * (b.maxHeight - b.minHeight), d = 2 * (Math.min(b.xSegments, b.ySegments) + 1) / b.frequency, e = 0, f = b.xSegments + 1; e < f; e++) for (var g = 0, h = b.ySegments + 1; g < h; g++) a[g * f + e].z += noise.simplex(e / d, g / d) * c;
}, THREE.Terrain.SimplexLayers = function(a, b) {
    THREE.Terrain.MultiPass(a, b, [ {
        method: THREE.Terrain.Simplex,
        frequency: 1.25
    }, {
        method: THREE.Terrain.Simplex,
        amplitude: .5,
        frequency: 2.5
    }, {
        method: THREE.Terrain.Simplex,
        amplitude: .25,
        frequency: 5
    }, {
        method: THREE.Terrain.Simplex,
        amplitude: .125,
        frequency: 10
    }, {
        method: THREE.Terrain.Simplex,
        amplitude: .0625,
        frequency: 20
    } ]);
}, function() {
    function a(a, b, c, d, e, f) {
        if (!(c > d)) {
            var g = 0, h = 0, i = d, j = d, k = Math.floor(d / c), l = -k, m = -k;
            for (g = 0; g <= i; g += k) {
                for (h = 0; h <= j; h += k) {
                    var n = h * i + g;
                    if (f[n] = Math.random() * e, !(l < 0 && m < 0)) {
                        for (var o = f[n], p = f[h * i + (g - k)] || o, q = f[(h - k) * i + g] || o, r = f[(h - k) * i + (g - k)] || o, s = l; s < g; s++) for (var t = m; t < h; t++) if (s !== l || t !== m) {
                            var u = t * i + s;
                            if (!(u < 0)) {
                                var v = (s - l) / k, w = (t - m) / k, x = v * q + (1 - v) * r, y = v * o + (1 - v) * p;
                                f[u] = w * y + (1 - w) * x;
                            }
                        }
                        m = h;
                    }
                }
                l = g, m = -k;
            }
            for (g = 0, i = b.xSegments + 1; g < i; g++) for (h = 0, j = b.ySegments + 1; h < j; h++) {
                var z = h * i + g, A = h * d + g;
                a[z].z += f[A];
            }
        }
    }
    THREE.Terrain.Value = function(b, c) {
        for (var d = THREE.Math.nextPowerOfTwo(Math.max(c.xSegments, c.ySegments) + 1), e = new Float64Array((d + 1) * (d + 1)), f = c.maxHeight - c.minHeight, g = 2; g < 7; g++) a(b, c, Math.pow(2, g), d, f * Math.pow(2, 2.4 - 1.2 * g), e);
        THREE.Terrain.Clamp(b, {
            maxHeight: c.maxHeight,
            minHeight: c.minHeight,
            stretch: !0
        });
    };
}(), THREE.Terrain.Weierstrass = function(a, b) {
    for (var c = .5 * (b.maxHeight - b.minHeight), d = Math.random() < .5 ? 1 : -1, e = Math.random() < .5 ? 1 : -1, f = .5 + 1 * Math.random(), g = .5 + 1 * Math.random(), h = .025 + .1 * Math.random(), i = 2 * Math.random() - 1, j = .5 + 1 * Math.random(), k = .5 + 1 * Math.random(), l = .025 + .1 * Math.random(), m = 2 * Math.random() - 1, n = 0, o = b.xSegments + 1; n < o; n++) for (var p = 0, q = b.ySegments + 1; p < q; p++) {
        for (var r = 0, s = 0; s < 20; s++) {
            var t = Math.pow(1 + f, -s) * Math.sin(Math.pow(1 + g, s) * (n + .25 * Math.cos(p) + i * p) * h), u = Math.pow(1 + j, -s) * Math.sin(Math.pow(1 + k, s) * (p + .25 * Math.cos(n) + m * n) * l);
            r -= Math.exp(d * t * t + e * u * u);
        }
        a[p * o + n].z += r * c;
    }
    THREE.Terrain.Clamp(a, b);
}, THREE.Terrain.generateBlendedMaterial = function(a) {
    function b(a) {
        return a === (0 | a) ? a + ".0" : a + "";
    }
    for (var c = THREE.UniformsUtils.merge([ THREE.ShaderLib.lambert.uniforms ]), d = "", e = "", f = a[0].texture.repeat, g = a[0].texture.offset, h = 0, i = a.length; h < i; h++) if (a[h].wrapS = a[h].wrapT = THREE.RepeatWrapping, 
    a[h].needsUpdate = !0, c["texture_" + h] = {
        type: "t",
        value: a[h].texture
    }, d += "uniform sampler2D texture_" + h + ";\n", 0 !== h) {
        var j = a[h].levels, k = a[h].glsl, l = void 0 !== j, m = a[h].texture.repeat, n = a[h].texture.offset;
        if (l) {
            j[1] - j[0] < 1 && (j[0] -= 1), j[3] - j[2] < 1 && (j[3] += 1);
            for (var o = 0; o < j.length; o++) j[o] = b(j[o]);
        }
        var p = l ? "1.0 - smoothstep(" + j[0] + ", " + j[1] + ", vPosition.z) + smoothstep(" + j[2] + ", " + j[3] + ", vPosition.z)" : k;
        e += "        color = mix( texture2D( texture_" + h + ", MyvUv * vec2( " + b(m.x) + ", " + b(m.y) + " ) + vec2( " + b(n.x) + ", " + b(n.y) + " ) ), color, max(min(" + p + ", 1.0), 0.0));\n";
    }
    var q = {
        fog: !0,
        lights: !0,
        uniforms: c,
        vertexShader: THREE.ShaderLib.lambert.vertexShader.replace("void main() {", "varying vec2 MyvUv;\nvarying vec3 vPosition;\nvarying vec3 myNormal; void main() {\nMyvUv = uv;\nvPosition = position;\nmyNormal = normal;"),
        fragmentShader: [ "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "    varying vec3 vLightBack;", "#endif", THREE.ShaderChunk.common, THREE.ShaderChunk.packing, THREE.ShaderChunk.dithering_pars_fragment, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.uv_pars_fragment, THREE.ShaderChunk.uv2_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.aomap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.emissivemap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.bsdfs, THREE.ShaderChunk.lights_pars, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.shadowmask_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, THREE.ShaderChunk.clipping_planes_pars_fragment, d, "varying vec2 MyvUv;", "varying vec3 vPosition;", "varying vec3 myNormal;", "void main() {", THREE.ShaderChunk.clipping_planes_fragment, "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "vec3 totalEmissiveRadiance = emissive;", "float slope = acos(max(min(dot(myNormal, vec3(0.0, 0.0, 1.0)), 1.0), -1.0));", "    vec4 diffuseColor = vec4( diffuse, opacity );", "    vec4 color = texture2D( texture_0, MyvUv * vec2( " + b(f.x) + ", " + b(f.y) + " ) + vec2( " + b(g.x) + ", " + b(g.y) + " ) ); // base", e, "    diffuseColor = color;", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.emissivemap_fragment, "   reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );", THREE.ShaderChunk.lightmap_fragment, "    reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );", "    #ifdef DOUBLE_SIDED", "            reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;", "    #else", "            reflectedLight.directDiffuse = vLightFront;", "    #endif", "    reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();", THREE.ShaderChunk.aomap_fragment, "   vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;", THREE.ShaderChunk.normal_flip, THREE.ShaderChunk.envmap_fragment, "   gl_FragColor = vec4( outgoingLight, diffuseColor.a );", THREE.ShaderChunk.tonemapping_fragment, THREE.ShaderChunk.encodings_fragment, THREE.ShaderChunk.fog_fragment, THREE.ShaderChunk.premultiplied_alpha_fragment, THREE.ShaderChunk.dithering_fragment, "}" ].join("\n")
    };
    return new THREE.ShaderMaterial(q);
}, THREE.Terrain.ScatterMeshes = function(a, b) {
    if (!b.mesh) return void console.error("options.mesh is required for THREE.Terrain.ScatterMeshes but was not passed");
    if (a instanceof THREE.BufferGeometry) return void console.warn("The terrain mesh is using BufferGeometry but THREE.Terrain.ScatterMeshes can only work with Geometry.");
    b.scene || (b.scene = new THREE.Object3D());
    var c = {
        spread: .025,
        smoothSpread: 0,
        sizeVariance: .1,
        randomness: Math.random,
        maxSlope: .6283185307179586,
        maxTilt: 1 / 0,
        w: 0,
        h: 0
    };
    for (var d in c) c.hasOwnProperty(d) && (b[d] = void 0 === b[d] ? c[d] : b[d]);
    var f, g, e = "number" == typeof b.spread, h = 1 / b.smoothSpread, i = 2 * b.sizeVariance, j = a.vertices, k = [], l = b.mesh.up.clone().applyAxisAngle(new THREE.Vector3(1, 0, 0), .5 * Math.PI);
    e && (f = b.randomness(), g = "number" == typeof f ? Math.random : function(a) {
        return f[a];
    });
    for (var m = 0, n = 2 * b.w; m < n; m++) for (var o = 0, p = b.h; o < p; o++) {
        var q = o * n + m, r = a.faces[q], s = !1;
        if (e) {
            var t = g(q);
            t < b.spread ? s = !0 : t < b.spread + b.smoothSpread && (s = THREE.Terrain.EaseInOut((t - b.spread) * h) * b.spread > Math.random());
        } else s = b.spread(j[r.a], q, r, m, o);
        if (s) {
            if (r.normal.angleTo(l) > b.maxSlope) continue;
            var u = b.mesh.clone();
            if (u.position.copy(j[r.a]).add(j[r.b]).add(j[r.c]).divideScalar(3), b.maxTilt > 0) {
                var v = u.position.clone().add(r.normal);
                u.lookAt(v);
                var w = r.normal.angleTo(l);
                if (w > b.maxTilt) {
                    var x = b.maxTilt / w;
                    u.rotation.x *= x, u.rotation.y *= x, u.rotation.z *= x;
                }
            }
            if (u.rotation.x += .5 * Math.PI, u.rotateY(2 * Math.random() * Math.PI), b.sizeVariance) {
                var y = Math.random() * i - b.sizeVariance;
                u.scale.x = u.scale.z = 1 + y, u.scale.y += y;
            }
            k.push(u);
        }
    }
    var z, A;
    if (b.mesh.geometry instanceof THREE.Geometry) {
        var B = new THREE.Geometry();
        for (z = 0, A = k.length; z < A; z++) {
            var C = k[z];
            C.updateMatrix(), B.merge(C.geometry, C.matrix);
        }
        b.scene.add(new THREE.Mesh(B, b.mesh.material));
    } else for (z = 0, A = k.length; z < A; z++) b.scene.add(k[z]);
    return b.scene;
}, THREE.Terrain.ScatterHelper = function(a, b, c, d) {
    c = c || 1, d = d || .25, b.frequency = b.frequency || 2.5;
    var e = {};
    for (var f in b) b.hasOwnProperty(f) && (e[f] = b[f]);
    e.xSegments *= 2, e.stretch = !0, e.maxHeight = 1, e.minHeight = 0;
    for (var g = THREE.Terrain.heightmapArray(a, e), h = 0, i = g.length; h < i; h++) (h % c || Math.random() > d) && (g[h] = 1);
    return function() {
        return g;
    };
}, THREE.Terrain.Influences = {
    Mesa: function(a) {
        return 1.25 * Math.min(.8, Math.exp(-a * a));
    },
    Hole: function(a) {
        return -THREE.Terrain.Influences.Mesa(a);
    },
    Hill: function(a) {
        return a < 0 ? (a + 1) * (a + 1) * (3 - 2 * (a + 1)) : 1 - a * a * (3 - 2 * a);
    },
    Valley: function(a) {
        return -THREE.Terrain.Influences.Hill(a);
    },
    Dome: function(a) {
        return -(a + 1) * (a - 1);
    },
    Flat: function(a) {
        return 0;
    },
    Volcano: function(a) {
        return .94 - .32 * (Math.abs(2 * a) + Math.cos(2 * Math.PI * Math.abs(a) + .4));
    }
}, THREE.Terrain.Influence = function(a, b, c, d, e, f, g, h, i) {
    c = c || THREE.Terrain.Influences.Hill, d = void 0 === d ? .5 : d, e = void 0 === e ? .5 : e, 
    f = void 0 === f ? 64 : f, g = void 0 === g ? 64 : g, h = void 0 === h ? THREE.NormalBlending : h, 
    i = i || THREE.Terrain.EaseIn;
    for (var j = b.xSegments + 1, k = b.ySegments + 1, l = j * d, m = k * e, n = b.xSize / b.xSegments, o = b.ySize / b.ySegments, p = f / n, q = f / o, r = 1 / f, s = Math.ceil(l - p), t = Math.floor(l + p), u = Math.ceil(m - q), v = Math.floor(m + q), w = s; w < t; w++) for (var x = u; x < v; x++) {
        var y = x * j + w, z = (w - l) * n, A = (x - m) * o, B = Math.sqrt(z * z + A * A), C = B * r, D = z * r, E = A * r, F = c(C, D, E) * g * (1 - i(C, D, E));
        B > f || void 0 === a[y] || (h === THREE.AdditiveBlending ? a[y].z += F : h === THREE.SubtractiveBlending ? a[y].z -= F : h === THREE.MultiplyBlending ? a[y].z *= F : h === THREE.NoBlending ? a[y].z = F : h === THREE.NormalBlending ? a[y].z = i(C, D, E) * a[y].z + F : "function" == typeof h && (a[y].z = h(a[y].z, F, C, D, E)));
    }
}, THREE.ShaderLib.water = {
    uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.fog, {
        normalSampler: {
            type: "t",
            value: null
        },
        mirrorSampler: {
            type: "t",
            value: null
        },
        alpha: {
            type: "f",
            value: 1
        },
        time: {
            type: "f",
            value: 0
        },
        distortionScale: {
            type: "f",
            value: 20
        },
        noiseScale: {
            type: "f",
            value: 1
        },
        textureMatrix: {
            type: "m4",
            value: new THREE.Matrix4()
        },
        sunColor: {
            type: "c",
            value: new THREE.Color(8355711)
        },
        sunDirection: {
            type: "v3",
            value: new THREE.Vector3(.70707, .70707, 0)
        },
        eye: {
            type: "v3",
            value: new THREE.Vector3(0, 0, 0)
        },
        waterColor: {
            type: "c",
            value: new THREE.Color(5592405)
        }
    } ]),
    vertexShader: [ "uniform mat4 textureMatrix;", "uniform float time;", "varying vec4 mirrorCoord;", "varying vec3 worldPosition;", "varying vec3 modelPosition;", "varying vec3 surfaceX;", "varying vec3 surfaceY;", "varying vec3 surfaceZ;", "void main()", "{", "  mirrorCoord = modelMatrix * vec4(position, 1.0);", "  worldPosition = mirrorCoord.xyz;", "  modelPosition = position;", "  surfaceX = vec3( modelMatrix[0][0], modelMatrix[0][1], modelMatrix[0][2]);", "  surfaceY = vec3( modelMatrix[1][0], modelMatrix[1][1], modelMatrix[1][2]);", "  surfaceZ = vec3( modelMatrix[2][0], modelMatrix[2][1], modelMatrix[2][2]);", "  mirrorCoord = textureMatrix * mirrorCoord;", "  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}" ].join("\n"),
    fragmentShader: [ "uniform sampler2D mirrorSampler;", "uniform float alpha;", "uniform float time;", "uniform float distortionScale;", "uniform float noiseScale;", "uniform sampler2D normalSampler;", "uniform vec3 sunColor;", "uniform vec3 sunDirection;", "uniform vec3 eye;", "uniform vec3 waterColor;", "varying vec4 mirrorCoord;", "varying vec3 worldPosition;", "varying vec3 modelPosition;", "varying vec3 surfaceX;", "varying vec3 surfaceY;", "varying vec3 surfaceZ;", "void sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, in float shiny, in float spec, in float diffuse, inout vec3 diffuseColor, inout vec3 specularColor)", "{", "  vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));", "  float direction = max(0.0, dot(eyeDirection, reflection));", "  specularColor += pow(direction, shiny) * sunColor * spec;", "  diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;", "}", "vec3 getNoise(in vec2 uv)", "{", "  vec2 uv0 = uv / (103.0 * noiseScale) + vec2(time / 17.0, time / 29.0);", "  vec2 uv1 = uv / (107.0 * noiseScale) - vec2(time / -19.0, time / 31.0);", "  vec2 uv2 = uv / (vec2(8907.0, 9803.0) * noiseScale) + vec2(time / 101.0, time /   97.0);", "  vec2 uv3 = uv / (vec2(1091.0, 1027.0) * noiseScale) - vec2(time / 109.0, time / -113.0);", "  vec4 noise = texture2D(normalSampler, uv0) +", "    texture2D(normalSampler, uv1) +", "    texture2D(normalSampler, uv2) +", "    texture2D(normalSampler, uv3);", "  return noise.xyz * 0.5 - 1.0;", "}", THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, "void main()", "{", "  vec3 worldToEye = eye - worldPosition;", "  vec3 eyeDirection = normalize(worldToEye);", "  vec3 noise = getNoise(modelPosition.xy * 1.0);", "  vec3 distordCoord = noise.x * surfaceX + noise.y * surfaceY;", "  vec3 distordNormal = distordCoord + surfaceZ;", "  if(dot(eyeDirection, surfaceZ) < 0.0)", "    distordNormal = distordNormal * -1.0;", "  vec3 diffuseLight = vec3(0.0);", "  vec3 specularLight = vec3(0.0);", "  sunLight(distordNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);", "  float distance = length(worldToEye);", "  vec2 distortion = distordCoord.xy * distortionScale * sqrt(distance) * 0.07;", " vec3 mirrorDistord = mirrorCoord.xyz + vec3(distortion.x, distortion.y, 1.0);", " vec3 reflectionSample = texture2DProj(mirrorSampler, mirrorDistord).xyz;", "  float theta = max(dot(eyeDirection, distordNormal), 0.0);", "  float reflectance = 0.3 + (1.0 - 0.3) * pow((1.0 - theta), 3.0);", "  vec3 scatter = max(0.0, dot(distordNormal, eyeDirection)) * waterColor;", "  vec3 albedo = mix(sunColor * diffuseLight * 0.3 + scatter, (vec3(0.1) + reflectionSample * 0.9 + reflectionSample * specularLight), reflectance);", " vec3 outgoingLight = albedo;", THREE.ShaderChunk.fog_fragment, " gl_FragColor = vec4( outgoingLight, alpha );", "}" ].join("\n")
}, THREE.Water = function(renderer, camera, scene, options) {
    function optionalParameter(value, defaultValue) {
        return void 0 !== value ? value : defaultValue;
    }
    THREE.Object3D.call(this), this.name = "water_" + this.id, options = options || {}, 
    this.matrixNeedsUpdate = !0;
    var width = optionalParameter(options.textureWidth, 512), height = optionalParameter(options.textureHeight, 512);
    this.clipBias = optionalParameter(options.clipBias, -1e-4), this.alpha = optionalParameter(options.alpha, 1), 
    this.time = optionalParameter(options.time, 0), this.normalSampler = optionalParameter(options.waterNormals, null), 
    this.sunDirection = optionalParameter(options.sunDirection, new THREE.Vector3(.70707, .70707, 0)), 
    this.sunColor = new THREE.Color(optionalParameter(options.sunColor, 16777215)), 
    this.waterColor = new THREE.Color(optionalParameter(options.waterColor, 8355711)), 
    this.eye = optionalParameter(options.eye, new THREE.Vector3(0, 0, 0)), this.distortionScale = optionalParameter(options.distortionScale, 20), 
    this.noiseScale = optionalParameter(options.noiseScale, 1), this.side = optionalParameter(options.side, THREE.FrontSide), 
    this.fog = optionalParameter(options.fog, !1), this.renderer = renderer, this.scene = scene, 
    this.mirrorPlane = new THREE.Plane(), this.normal = new THREE.Vector3(0, 0, 1), 
    this.cameraWorldPosition = new THREE.Vector3(), this.rotationMatrix = new THREE.Matrix4(), 
    this.lookAtPosition = new THREE.Vector3(0, 0, -1), this.clipPlane = new THREE.Vector4(), 
    camera instanceof THREE.PerspectiveCamera ? this.camera = camera : (this.camera = new THREE.PerspectiveCamera(), 
    console.log(this.name + ": camera is not a Perspective Camera!")), this.textureMatrix = new THREE.Matrix4(), 
    this.mirrorCamera = this.camera.clone(), this.texture = new THREE.WebGLRenderTarget(width, height), 
    this.tempTexture = new THREE.WebGLRenderTarget(width, height);
    var mirrorShader = THREE.ShaderLib.water, mirrorUniforms = THREE.UniformsUtils.clone(mirrorShader.uniforms);
    this.material = new THREE.ShaderMaterial({
        fragmentShader: mirrorShader.fragmentShader,
        vertexShader: mirrorShader.vertexShader,
        uniforms: mirrorUniforms,
        transparent: !0,
        side: this.side,
        fog: this.fog
    }), this.mesh = new THREE.Object3D(), this.material.uniforms.mirrorSampler.value = this.texture, 
    this.material.uniforms.textureMatrix.value = this.textureMatrix, this.material.uniforms.alpha.value = this.alpha, 
    this.material.uniforms.time.value = this.time, this.material.uniforms.normalSampler.value = this.normalSampler, 
    this.material.uniforms.sunColor.value = this.sunColor, this.material.uniforms.waterColor.value = this.waterColor, 
    this.material.uniforms.sunDirection.value = this.sunDirection, this.material.uniforms.distortionScale.value = this.distortionScale, 
    this.material.uniforms.noiseScale.value = this.noiseScale, this.material.uniforms.eye.value = this.eye, 
    THREE.Math.isPowerOfTwo(width) && THREE.Math.isPowerOfTwo(height) || (this.texture.generateMipmaps = !1, 
    this.tempTexture.generateMipmaps = !1);
}, THREE.Water.prototype = Object.create(THREE.Object3D.prototype), THREE.Water.prototype.renderWithMirror = function(otherMirror) {
    this.updateTextureMatrix(), this.matrixNeedsUpdate = !1;
    var tempCamera = otherMirror.camera;
    otherMirror.camera = this.mirrorCamera, otherMirror.render(!0), this.render(), this.matrixNeedsUpdate = !0, 
    otherMirror.camera = tempCamera, otherMirror.updateTextureMatrix();
}, THREE.Water.prototype.updateTextureMatrix = function() {
    function sign(x) {
        return x ? x < 0 ? -1 : 1 : 0;
    }
    void 0 !== this.parent && (this.mesh = this.parent), this.updateMatrixWorld(), this.camera.updateMatrixWorld(), 
    this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld), this.rotationMatrix.extractRotation(this.matrixWorld), 
    this.normal = new THREE.Vector3(0, 0, 1).applyEuler(this.mesh.rotation);
    var cameraPosition = this.camera.position.clone().sub(this.mesh.position);
    if (this.normal.dot(cameraPosition) < 0) {
        var meshNormal = new THREE.Vector3(0, 0, 1).applyEuler(this.mesh.rotation);
        this.normal.reflect(meshNormal);
    }
    var view = this.mesh.position.clone().sub(this.cameraWorldPosition);
    view.reflect(this.normal).negate(), view.add(this.mesh.position), this.rotationMatrix.extractRotation(this.camera.matrixWorld), 
    this.lookAtPosition.set(0, 0, -1), this.lookAtPosition.applyMatrix4(this.rotationMatrix), 
    this.lookAtPosition.add(this.cameraWorldPosition);
    var target = this.mesh.position.clone().sub(this.lookAtPosition);
    target.reflect(this.normal).negate(), target.add(this.mesh.position), this.up.set(0, -1, 0), 
    this.up.applyMatrix4(this.rotationMatrix), this.up.reflect(this.normal).negate(), 
    this.mirrorCamera.position.copy(view), this.mirrorCamera.up = this.up, this.mirrorCamera.lookAt(target), 
    this.mirrorCamera.aspect = this.camera.aspect, this.mirrorCamera.updateProjectionMatrix(), 
    this.mirrorCamera.updateMatrixWorld(), this.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld), 
    this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), 
    this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse), this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal, this.mesh.position), 
    this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse), this.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant);
    var q = new THREE.Vector4(), projectionMatrix = this.mirrorCamera.projectionMatrix;
    q.x = (sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0], 
    q.y = (sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5], 
    q.z = -1, q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    var c = new THREE.Vector4();
    c = this.clipPlane.multiplyScalar(2 / this.clipPlane.dot(q)), projectionMatrix.elements[2] = c.x, 
    projectionMatrix.elements[6] = c.y, projectionMatrix.elements[10] = c.z + 1 - this.clipBias, 
    projectionMatrix.elements[14] = c.w;
    var worldCoordinates = new THREE.Vector3();
    worldCoordinates.setFromMatrixPosition(this.camera.matrixWorld), this.eye = worldCoordinates, 
    this.material.uniforms.eye.value = this.eye;
}, THREE.Water.prototype.render = function(isTempTexture) {
    if (this.matrixNeedsUpdate && this.updateTextureMatrix(), this.matrixNeedsUpdate = !0, 
    void 0 !== this.scene && this.scene instanceof THREE.Scene) {
        this.material.visible = !1;
        var renderTexture = void 0 !== isTempTexture && isTempTexture ? this.tempTexture : this.texture;
        this.renderer.render(this.scene, this.mirrorCamera, renderTexture, !0), this.material.visible = !0, 
        this.material.uniforms.mirrorSampler.value = renderTexture;
    }
};

var SPE = {
    distributions: {
        BOX: 1,
        SPHERE: 2,
        DISC: 3
    },
    valueOverLifetimeLength: 4
};

"function" == typeof define && define.amd ? define("spe", SPE) : void 0 !== exports && "undefined" != typeof module && (module.exports = SPE), 
SPE.TypedArrayHelper = function(TypedArrayConstructor, size, componentSize, indexOffset) {
    this.componentSize = componentSize || 1, this.size = size || 1, this.TypedArrayConstructor = TypedArrayConstructor || Float32Array, 
    this.array = new TypedArrayConstructor(size * this.componentSize), this.indexOffset = indexOffset || 0;
}, SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper, SPE.TypedArrayHelper.prototype.setSize = function(size, noComponentMultiply) {
    var currentArraySize = this.array.length;
    return noComponentMultiply || (size *= this.componentSize), size < currentArraySize ? this.shrink(size) : size > currentArraySize ? this.grow(size) : void console.info("TypedArray is already of size:", size + ".", "Will not resize.");
}, SPE.TypedArrayHelper.prototype.shrink = function(size) {
    return this.array = this.array.subarray(0, size), this.size = size, this;
}, SPE.TypedArrayHelper.prototype.grow = function(size) {
    var existingArray = this.array, newArray = new this.TypedArrayConstructor(size);
    return newArray.set(existingArray), this.array = newArray, this.size = size, this;
}, SPE.TypedArrayHelper.prototype.splice = function(start, end) {
    start *= this.componentSize, end *= this.componentSize;
    for (var data = [], array = this.array, size = array.length, i = 0; i < size; ++i) (i < start || i >= end) && data.push(array[i]);
    return this.setFromArray(0, data), this;
}, SPE.TypedArrayHelper.prototype.setFromArray = function(index, array) {
    var sourceArraySize = array.length, newSize = index + sourceArraySize;
    return newSize > this.array.length ? this.grow(newSize) : newSize < this.array.length && this.shrink(newSize), 
    this.array.set(array, this.indexOffset + index), this;
}, SPE.TypedArrayHelper.prototype.setVec2 = function(index, vec2) {
    return this.setVec2Components(index, vec2.x, vec2.y);
}, SPE.TypedArrayHelper.prototype.setVec2Components = function(index, x, y) {
    var array = this.array, i = this.indexOffset + index * this.componentSize;
    return array[i] = x, array[i + 1] = y, this;
}, SPE.TypedArrayHelper.prototype.setVec3 = function(index, vec3) {
    return this.setVec3Components(index, vec3.x, vec3.y, vec3.z);
}, SPE.TypedArrayHelper.prototype.setVec3Components = function(index, x, y, z) {
    var array = this.array, i = this.indexOffset + index * this.componentSize;
    return array[i] = x, array[i + 1] = y, array[i + 2] = z, this;
}, SPE.TypedArrayHelper.prototype.setVec4 = function(index, vec4) {
    return this.setVec4Components(index, vec4.x, vec4.y, vec4.z, vec4.w);
}, SPE.TypedArrayHelper.prototype.setVec4Components = function(index, x, y, z, w) {
    var array = this.array, i = this.indexOffset + index * this.componentSize;
    return array[i] = x, array[i + 1] = y, array[i + 2] = z, array[i + 3] = w, this;
}, SPE.TypedArrayHelper.prototype.setMat3 = function(index, mat3) {
    return this.setFromArray(this.indexOffset + index * this.componentSize, mat3.elements);
}, SPE.TypedArrayHelper.prototype.setMat4 = function(index, mat4) {
    return this.setFromArray(this.indexOffset + index * this.componentSize, mat4.elements);
}, SPE.TypedArrayHelper.prototype.setColor = function(index, color) {
    return this.setVec3Components(index, color.r, color.g, color.b);
}, SPE.TypedArrayHelper.prototype.setNumber = function(index, numericValue) {
    return this.array[this.indexOffset + index * this.componentSize] = numericValue, 
    this;
}, SPE.TypedArrayHelper.prototype.getValueAtIndex = function(index) {
    return this.array[this.indexOffset + index];
}, SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function(index) {
    return this.array.subarray(this.indexOffset + index * this.componentSize);
}, SPE.ShaderAttribute = function(type, dynamicBuffer, arrayType) {
    var typeMap = SPE.ShaderAttribute.typeSizeMap;
    this.type = "string" == typeof type && typeMap.hasOwnProperty(type) ? type : "f", 
    this.componentSize = typeMap[this.type], this.arrayType = arrayType || Float32Array, 
    this.typedArray = null, this.bufferAttribute = null, this.dynamicBuffer = !!dynamicBuffer, 
    this.updateMin = 0, this.updateMax = 0;
}, SPE.ShaderAttribute.constructor = SPE.ShaderAttribute, SPE.ShaderAttribute.typeSizeMap = {
    f: 1,
    v2: 2,
    v3: 3,
    v4: 4,
    c: 3,
    m3: 9,
    m4: 16
}, SPE.ShaderAttribute.prototype.setUpdateRange = function(min, max) {
    this.updateMin = Math.min(min * this.componentSize, this.updateMin * this.componentSize), 
    this.updateMax = Math.max(max * this.componentSize, this.updateMax * this.componentSize);
}, SPE.ShaderAttribute.prototype.flagUpdate = function() {
    var attr = this.bufferAttribute, range = attr.updateRange;
    range.offset = this.updateMin, range.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length), 
    attr.needsUpdate = !0;
}, SPE.ShaderAttribute.prototype.resetUpdateRange = function() {
    this.updateMin = 0, this.updateMax = 0;
}, SPE.ShaderAttribute.prototype.resetDynamic = function() {
    this.bufferAttribute.dynamic = this.dynamicBuffer;
}, SPE.ShaderAttribute.prototype.splice = function(start, end) {
    this.typedArray.splice(start, end), this.forceUpdateAll();
}, SPE.ShaderAttribute.prototype.forceUpdateAll = function() {
    this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.updateRange.offset = 0, 
    this.bufferAttribute.updateRange.count = -1, this.bufferAttribute.dynamic = !1, 
    this.bufferAttribute.needsUpdate = !0;
}, SPE.ShaderAttribute.prototype._ensureTypedArray = function(size) {
    null !== this.typedArray && this.typedArray.size === size * this.componentSize || (null !== this.typedArray && this.typedArray.size !== size ? this.typedArray.setSize(size) : null === this.typedArray && (this.typedArray = new SPE.TypedArrayHelper(this.arrayType, size, this.componentSize)));
}, SPE.ShaderAttribute.prototype._createBufferAttribute = function(size) {
    if (this._ensureTypedArray(size), null !== this.bufferAttribute) return this.bufferAttribute.array = this.typedArray.array, 
    void (this.bufferAttribute.needsUpdate = !0);
    this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize), 
    this.bufferAttribute.dynamic = this.dynamicBuffer;
}, SPE.ShaderAttribute.prototype.getLength = function() {
    return null === this.typedArray ? 0 : this.typedArray.array.length;
}, SPE.shaderChunks = {
    defines: [ "#define PACKED_COLOR_SIZE 256.0", "#define PACKED_COLOR_DIVISOR 255.0" ].join("\n"),
    uniforms: [ "uniform float deltaTime;", "uniform float runTime;", "uniform sampler2D texture;", "uniform vec4 textureAnimation;", "uniform float scale;" ].join("\n"),
    attributes: [ "attribute vec4 acceleration;", "attribute vec3 velocity;", "attribute vec4 rotation;", "attribute vec3 rotationCenter;", "attribute vec4 params;", "attribute vec4 size;", "attribute vec4 angle;", "attribute vec4 color;", "attribute vec4 opacity;" ].join("\n"),
    varyings: [ "varying vec4 vColor;", "#ifdef SHOULD_ROTATE_TEXTURE", "    varying float vAngle;", "#endif", "#ifdef SHOULD_CALCULATE_SPRITE", "    varying vec4 vSpriteSheet;", "#endif" ].join("\n"),
    branchAvoidanceFunctions: [ "float when_gt(float x, float y) {", "    return max(sign(x - y), 0.0);", "}", "float when_lt(float x, float y) {", "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );", "}", "float when_eq( float x, float y ) {", "    return 1.0 - abs( sign( x - y ) );", "}", "float when_ge(float x, float y) {", "  return 1.0 - when_lt(x, y);", "}", "float when_le(float x, float y) {", "  return 1.0 - when_gt(x, y);", "}", "float and(float a, float b) {", "    return a * b;", "}", "float or(float a, float b) {", "    return min(a + b, 1.0);", "}" ].join("\n"),
    unpackColor: [ "vec3 unpackColor( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   return c;", "}" ].join("\n"),
    unpackRotationAxis: [ "vec3 unpackRotationAxis( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   c *= vec3( 2.0 );", "   c -= vec3( 1.0 );", "   return c;", "}" ].join("\n"),
    floatOverLifetime: [ "float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {", "    highp float value = 0.0;", "    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );", "    float fIndex = 0.0;", "    float shouldApplyValue = 0.0;", "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );", "", "    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {", "       fIndex = float( i );", "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );", "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );", "    }", "", "    return value;", "}" ].join("\n"),
    colorOverLifetime: [ "vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {", "    vec3 value = vec3( 0.0 );", "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );", "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );", "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );", "    return value;", "}" ].join("\n"),
    paramFetchingFunctions: [ "float getAlive() {", "   return params.x;", "}", "float getAge() {", "   return params.y;", "}", "float getMaxAge() {", "   return params.z;", "}", "float getWiggle() {", "   return params.w;", "}" ].join("\n"),
    forceFetchingFunctions: [ "vec4 getPosition( in float age ) {", "   return modelViewMatrix * vec4( position, 1.0 );", "}", "vec3 getVelocity( in float age ) {", "   return velocity * age;", "}", "vec3 getAcceleration( in float age ) {", "   return acceleration.xyz * age;", "}" ].join("\n"),
    rotationFunctions: [ "#ifdef SHOULD_ROTATE_PARTICLES", "   mat4 getRotationMatrix( in vec3 axis, in float angle) {", "       axis = normalize(axis);", "       float s = sin(angle);", "       float c = cos(angle);", "       float oc = 1.0 - c;", "", "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,", "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,", "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,", "                   0.0,                                0.0,                                0.0,                                1.0);", "   }", "", "   vec3 getRotation( in vec3 pos, in float positionInTime ) {", "      if( rotation.y == 0.0 ) {", "           return pos;", "      }", "", "      vec3 axis = unpackRotationAxis( rotation.x );", "      vec3 center = rotationCenter;", "      vec3 translated;", "      mat4 rotationMatrix;", "      float angle = 0.0;", "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;", "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );", "      translated = rotationCenter - pos;", "      rotationMatrix = getRotationMatrix( axis, angle );", "      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );", "   }", "#endif" ].join("\n"),
    rotateTexture: [ "    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );", "", "    #ifdef SHOULD_ROTATE_TEXTURE", "       float x = gl_PointCoord.x - 0.5;", "       float y = 1.0 - gl_PointCoord.y - 0.5;", "       float c = cos( -vAngle );", "       float s = sin( -vAngle );", "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );", "    #endif", "", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = vSpriteSheet.x;", "        float framesY = vSpriteSheet.y;", "        float columnNorm = vSpriteSheet.z;", "        float rowNorm = vSpriteSheet.w;", "        vUv.x = gl_PointCoord.x * framesX + columnNorm;", "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);", "    #endif", "", "    vec4 rotatedTexture = texture2D( texture, vUv );" ].join("\n")
}, SPE.shaders = {
    vertex: [ SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.unpackRotationAxis, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, "void main() {", "    highp float age = getAge();", "    highp float alive = getAlive();", "    highp float maxAge = getMaxAge();", "    highp float positionInTime = (age / maxAge);", "    highp float isAlive = when_gt( alive, 0.0 );", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        float wiggleAmount = positionInTime * getWiggle();", "        float wiggleSin = isAlive * sin( wiggleAmount );", "        float wiggleCos = isAlive * cos( wiggleAmount );", "    #endif", "    vec3 vel = getVelocity( age );", "    vec3 accel = getAcceleration( age );", "    vec3 force = vec3( 0.0 );", "    vec3 pos = vec3( position );", "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;", "    force += vel;", "    force *= drag;", "    force += accel * age;", "    pos += force;", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        pos.x += wiggleSin;", "        pos.y += wiggleCos;", "        pos.z += wiggleSin;", "    #endif", "    #ifdef SHOULD_ROTATE_PARTICLES", "        pos = getRotation( pos, positionInTime );", "    #endif", "    vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );", "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;", "    #ifdef HAS_PERSPECTIVE", "        float perspective = scale / length( mvPos.xyz );", "    #else", "        float perspective = 1.0;", "    #endif", "    float pointSizePerspective = pointSize * perspective;", "    #ifdef COLORIZE", "       vec3 c = isAlive * getColorOverLifetime(", "           positionInTime,", "           unpackColor( color.x ),", "           unpackColor( color.y ),", "           unpackColor( color.z ),", "           unpackColor( color.w )", "       );", "    #else", "       vec3 c = vec3(1.0);", "    #endif", "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );", "    vColor = vec4( c, o );", "    #ifdef SHOULD_ROTATE_TEXTURE", "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );", "    #endif", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = textureAnimation.x;", "        float framesY = textureAnimation.y;", "        float loopCount = textureAnimation.w;", "        float totalFrames = textureAnimation.z;", "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );", "        float column = floor(mod( frameNumber, framesX ));", "        float row = floor( (frameNumber - column) / framesX );", "        float columnNorm = column / framesX;", "        float rowNorm = row / framesY;", "        vSpriteSheet.x = 1.0 / framesX;", "        vSpriteSheet.y = 1.0 / framesY;", "        vSpriteSheet.z = columnNorm;", "        vSpriteSheet.w = rowNorm;", "    #endif", "    gl_PointSize = pointSizePerspective;", "    gl_Position = projectionMatrix * mvPos;", THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
    fragment: [ SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, "void main() {", "    vec3 outgoingLight = vColor.xyz;", "    ", "    #ifdef ALPHATEST", "       if ( vColor.w < float(ALPHATEST) ) discard;", "    #endif", SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, "    outgoingLight = vColor.xyz * rotatedTexture.xyz;", THREE.ShaderChunk.fog_fragment, "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", "}" ].join("\n")
}, SPE.utils = {
    types: {
        BOOLEAN: "boolean",
        STRING: "string",
        NUMBER: "number",
        OBJECT: "object"
    },
    ensureTypedArg: function(arg, type, defaultValue) {
        return typeof arg === type ? arg : defaultValue;
    },
    ensureArrayTypedArg: function(arg, type, defaultValue) {
        if (Array.isArray(arg)) {
            for (var i = arg.length - 1; i >= 0; --i) if (typeof arg[i] !== type) return defaultValue;
            return arg;
        }
        return this.ensureTypedArg(arg, type, defaultValue);
    },
    ensureInstanceOf: function(arg, instance, defaultValue) {
        return void 0 !== instance && arg instanceof instance ? arg : defaultValue;
    },
    ensureArrayInstanceOf: function(arg, instance, defaultValue) {
        if (Array.isArray(arg)) {
            for (var i = arg.length - 1; i >= 0; --i) if (void 0 !== instance && arg[i] instanceof instance == !1) return defaultValue;
            return arg;
        }
        return this.ensureInstanceOf(arg, instance, defaultValue);
    },
    ensureValueOverLifetimeCompliance: function(property, minLength, maxLength) {
        minLength = minLength || 3, maxLength = maxLength || 3, !1 === Array.isArray(property._value) && (property._value = [ property._value ]), 
        !1 === Array.isArray(property._spread) && (property._spread = [ property._spread ]);
        var valueLength = this.clamp(property._value.length, minLength, maxLength), spreadLength = this.clamp(property._spread.length, minLength, maxLength), desiredLength = Math.max(valueLength, spreadLength);
        property._value.length !== desiredLength && (property._value = this.interpolateArray(property._value, desiredLength)), 
        property._spread.length !== desiredLength && (property._spread = this.interpolateArray(property._spread, desiredLength));
    },
    interpolateArray: function(srcArray, newLength) {
        for (var sourceLength = srcArray.length, newArray = [ "function" == typeof srcArray[0].clone ? srcArray[0].clone() : srcArray[0] ], factor = (sourceLength - 1) / (newLength - 1), i = 1; i < newLength - 1; ++i) {
            var f = i * factor, before = Math.floor(f), after = Math.ceil(f), delta = f - before;
            newArray[i] = this.lerpTypeAgnostic(srcArray[before], srcArray[after], delta);
        }
        return newArray.push("function" == typeof srcArray[sourceLength - 1].clone ? srcArray[sourceLength - 1].clone() : srcArray[sourceLength - 1]), 
        newArray;
    },
    clamp: function(value, min, max) {
        return Math.max(min, Math.min(value, max));
    },
    zeroToEpsilon: function(value, randomise) {
        var result = value;
        return result = randomise ? 1e-5 * Math.random() * 10 : 1e-5, value < 0 && value > -1e-5 && (result = -result), 
        result;
    },
    lerpTypeAgnostic: function(start, end, delta) {
        var out, types = this.types;
        return typeof start === types.NUMBER && typeof end === types.NUMBER ? start + (end - start) * delta : start instanceof THREE.Vector2 && end instanceof THREE.Vector2 ? (out = start.clone(), 
        out.x = this.lerp(start.x, end.x, delta), out.y = this.lerp(start.y, end.y, delta), 
        out) : start instanceof THREE.Vector3 && end instanceof THREE.Vector3 ? (out = start.clone(), 
        out.x = this.lerp(start.x, end.x, delta), out.y = this.lerp(start.y, end.y, delta), 
        out.z = this.lerp(start.z, end.z, delta), out) : start instanceof THREE.Vector4 && end instanceof THREE.Vector4 ? (out = start.clone(), 
        out.x = this.lerp(start.x, end.x, delta), out.y = this.lerp(start.y, end.y, delta), 
        out.z = this.lerp(start.z, end.z, delta), out.w = this.lerp(start.w, end.w, delta), 
        out) : start instanceof THREE.Color && end instanceof THREE.Color ? (out = start.clone(), 
        out.r = this.lerp(start.r, end.r, delta), out.g = this.lerp(start.g, end.g, delta), 
        out.b = this.lerp(start.b, end.b, delta), out) : void console.warn("Invalid argument types, or argument types do not match:", start, end);
    },
    lerp: function(start, end, delta) {
        return start + (end - start) * delta;
    },
    roundToNearestMultiple: function(n, multiple) {
        var remainder = 0;
        return 0 === multiple ? n : (remainder = Math.abs(n) % multiple, 0 === remainder ? n : n < 0 ? -(Math.abs(n) - remainder) : n + multiple - remainder);
    },
    arrayValuesAreEqual: function(array) {
        for (var i = 0; i < array.length - 1; ++i) if (array[i] !== array[i + 1]) return !1;
        return !0;
    },
    randomFloat: function(base, spread) {
        return base + spread * (Math.random() - .5);
    },
    randomVector3: function(attribute, index, base, spread, spreadClamp) {
        var x = base.x + (Math.random() * spread.x - .5 * spread.x), y = base.y + (Math.random() * spread.y - .5 * spread.y), z = base.z + (Math.random() * spread.z - .5 * spread.z);
        spreadClamp && (x = .5 * -spreadClamp.x + this.roundToNearestMultiple(x, spreadClamp.x), 
        y = .5 * -spreadClamp.y + this.roundToNearestMultiple(y, spreadClamp.y), z = .5 * -spreadClamp.z + this.roundToNearestMultiple(z, spreadClamp.z)), 
        attribute.typedArray.setVec3Components(index, x, y, z);
    },
    randomColor: function(attribute, index, base, spread) {
        var r = base.r + Math.random() * spread.x, g = base.g + Math.random() * spread.y, b = base.b + Math.random() * spread.z;
        r = this.clamp(r, 0, 1), g = this.clamp(g, 0, 1), b = this.clamp(b, 0, 1), attribute.typedArray.setVec3Components(index, r, g, b);
    },
    randomColorAsHex: function() {
        var workingColor = new THREE.Color();
        return function(attribute, index, base, spread) {
            for (var numItems = base.length, colors = [], i = 0; i < numItems; ++i) {
                var spreadVector = spread[i];
                workingColor.copy(base[i]), workingColor.r += Math.random() * spreadVector.x - .5 * spreadVector.x, 
                workingColor.g += Math.random() * spreadVector.y - .5 * spreadVector.y, workingColor.b += Math.random() * spreadVector.z - .5 * spreadVector.z, 
                workingColor.r = this.clamp(workingColor.r, 0, 1), workingColor.g = this.clamp(workingColor.g, 0, 1), 
                workingColor.b = this.clamp(workingColor.b, 0, 1), colors.push(workingColor.getHex());
            }
            attribute.typedArray.setVec4Components(index, colors[0], colors[1], colors[2], colors[3]);
        };
    }(),
    randomVector3OnSphere: function(attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp, distributionClamp) {
        var depth = 2 * Math.random() - 1, t = 6.2832 * Math.random(), r = Math.sqrt(1 - depth * depth), rand = this.randomFloat(radius, radiusSpread), x = 0, y = 0, z = 0;
        radiusSpreadClamp && (rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp), 
        x = r * Math.cos(t) * rand, y = r * Math.sin(t) * rand, z = depth * rand, x *= radiusScale.x, 
        y *= radiusScale.y, z *= radiusScale.z, x += base.x, y += base.y, z += base.z, attribute.typedArray.setVec3Components(index, x, y, z);
    },
    seededRandom: function(seed) {
        var x = 1e4 * Math.sin(seed);
        return x - (0 | x);
    },
    randomVector3OnDisc: function(attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp) {
        var t = 6.2832 * Math.random(), rand = Math.abs(this.randomFloat(radius, radiusSpread)), x = 0, y = 0, z = 0;
        radiusSpreadClamp && (rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp), 
        x = Math.cos(t) * rand, y = Math.sin(t) * rand, x *= radiusScale.x, y *= radiusScale.y, 
        x += base.x, y += base.y, z += base.z, attribute.typedArray.setVec3Components(index, x, y, z);
    },
    randomDirectionVector3OnSphere: function() {
        var v = new THREE.Vector3();
        return function(attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {
            v.copy(emitterPosition), v.x -= posX, v.y -= posY, v.z -= posZ, v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread)), 
            attribute.typedArray.setVec3Components(index, v.x, v.y, v.z);
        };
    }(),
    randomDirectionVector3OnDisc: function() {
        var v = new THREE.Vector3();
        return function(attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {
            v.copy(emitterPosition), v.x -= posX, v.y -= posY, v.z -= posZ, v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread)), 
            attribute.typedArray.setVec3Components(index, v.x, v.y, 0);
        };
    }(),
    getPackedRotationAxis: function() {
        var v = new THREE.Vector3(), vSpread = new THREE.Vector3(), c = new THREE.Color(), addOne = new THREE.Vector3(1, 1, 1);
        return function(axis, axisSpread) {
            return v.copy(axis).normalize(), vSpread.copy(axisSpread).normalize(), v.x += .5 * -axisSpread.x + Math.random() * axisSpread.x, 
            v.y += .5 * -axisSpread.y + Math.random() * axisSpread.y, v.z += .5 * -axisSpread.z + Math.random() * axisSpread.z, 
            v.normalize().add(addOne).multiplyScalar(.5), c.setRGB(v.x, v.y, v.z), c.getHex();
        };
    }()
}, SPE.Group = function(options) {
    var utils = SPE.utils, types = utils.types;
    options = utils.ensureTypedArg(options, types.OBJECT, {}), options.texture = utils.ensureTypedArg(options.texture, types.OBJECT, {}), 
    this.uuid = THREE.Math.generateUUID(), this.fixedTimeStep = utils.ensureTypedArg(options.fixedTimeStep, types.NUMBER, .016), 
    this.texture = utils.ensureInstanceOf(options.texture.value, THREE.Texture, null), 
    this.textureFrames = utils.ensureInstanceOf(options.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1)), 
    this.textureFrameCount = utils.ensureTypedArg(options.texture.frameCount, types.NUMBER, this.textureFrames.x * this.textureFrames.y), 
    this.textureLoop = utils.ensureTypedArg(options.texture.loop, types.NUMBER, 1), 
    this.textureFrames.max(new THREE.Vector2(1, 1)), this.hasPerspective = utils.ensureTypedArg(options.hasPerspective, types.BOOLEAN, !0), 
    this.colorize = utils.ensureTypedArg(options.colorize, types.BOOLEAN, !0), this.maxParticleCount = utils.ensureTypedArg(options.maxParticleCount, types.NUMBER, null), 
    this.blending = utils.ensureTypedArg(options.blending, types.NUMBER, THREE.AdditiveBlending), 
    this.transparent = utils.ensureTypedArg(options.transparent, types.BOOLEAN, !0), 
    this.alphaTest = parseFloat(utils.ensureTypedArg(options.alphaTest, types.NUMBER, 0)), 
    this.depthWrite = utils.ensureTypedArg(options.depthWrite, types.BOOLEAN, !1), this.depthTest = utils.ensureTypedArg(options.depthTest, types.BOOLEAN, !0), 
    this.fog = utils.ensureTypedArg(options.fog, types.BOOLEAN, !0), this.scale = utils.ensureTypedArg(options.scale, types.NUMBER, 300), 
    this.emitters = [], this.emitterIDs = [], this._pool = [], this._poolCreationSettings = null, 
    this._createNewWhenPoolEmpty = 0, this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !1, 
    this.particleCount = 0, this.uniforms = {
        texture: {
            type: "t",
            value: this.texture
        },
        textureAnimation: {
            type: "v4",
            value: new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))
        },
        fogColor: {
            type: "c",
            value: null
        },
        fogNear: {
            type: "f",
            value: 10
        },
        fogFar: {
            type: "f",
            value: 200
        },
        fogDensity: {
            type: "f",
            value: .5
        },
        deltaTime: {
            type: "f",
            value: 0
        },
        runTime: {
            type: "f",
            value: 0
        },
        scale: {
            type: "f",
            value: this.scale
        }
    }, this.defines = {
        HAS_PERSPECTIVE: this.hasPerspective,
        COLORIZE: this.colorize,
        VALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,
        SHOULD_ROTATE_TEXTURE: !1,
        SHOULD_ROTATE_PARTICLES: !1,
        SHOULD_WIGGLE_PARTICLES: !1,
        SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1
    }, this.attributes = {
        position: new SPE.ShaderAttribute("v3", !0),
        acceleration: new SPE.ShaderAttribute("v4", !0),
        velocity: new SPE.ShaderAttribute("v3", !0),
        rotation: new SPE.ShaderAttribute("v4", !0),
        rotationCenter: new SPE.ShaderAttribute("v3", !0),
        params: new SPE.ShaderAttribute("v4", !0),
        size: new SPE.ShaderAttribute("v4", !0),
        angle: new SPE.ShaderAttribute("v4", !0),
        color: new SPE.ShaderAttribute("v4", !0),
        opacity: new SPE.ShaderAttribute("v4", !0)
    }, this.attributeKeys = Object.keys(this.attributes), this.attributeCount = this.attributeKeys.length, 
    this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: SPE.shaders.vertex,
        fragmentShader: SPE.shaders.fragment,
        blending: this.blending,
        transparent: this.transparent,
        alphaTest: this.alphaTest,
        depthWrite: this.depthWrite,
        depthTest: this.depthTest,
        defines: this.defines,
        fog: this.fog
    }), this.geometry = new THREE.BufferGeometry(), this.mesh = new THREE.Points(this.geometry, this.material), 
    null === this.maxParticleCount && console.warn("SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.");
}, SPE.Group.constructor = SPE.Group, SPE.Group.prototype._updateDefines = function() {
    var emitter, emitters = this.emitters, i = emitters.length - 1, defines = this.defines;
    for (i; i >= 0; --i) emitter = emitters[i], defines.SHOULD_CALCULATE_SPRITE || (defines.SHOULD_ROTATE_TEXTURE = defines.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, emitter.angle.value), Math.max.apply(null, emitter.angle.spread))), 
    defines.SHOULD_ROTATE_PARTICLES = defines.SHOULD_ROTATE_PARTICLES || !!Math.max(emitter.rotation.angle, emitter.rotation.angleSpread), 
    defines.SHOULD_WIGGLE_PARTICLES = defines.SHOULD_WIGGLE_PARTICLES || !!Math.max(emitter.wiggle.value, emitter.wiggle.spread);
    this.material.needsUpdate = !0;
}, SPE.Group.prototype._applyAttributesToGeometry = function() {
    var attribute, geometryAttribute, attributes = this.attributes, geometry = this.geometry, geometryAttributes = geometry.attributes;
    for (var attr in attributes) attributes.hasOwnProperty(attr) && (attribute = attributes[attr], 
    geometryAttribute = geometryAttributes[attr], geometryAttribute ? geometryAttribute.array = attribute.typedArray.array : geometry.addAttribute(attr, attribute.bufferAttribute), 
    attribute.bufferAttribute.needsUpdate = !0);
    this.geometry.setDrawRange(0, this.particleCount);
}, SPE.Group.prototype.addEmitter = function(emitter) {
    if (emitter instanceof SPE.Emitter == !1) return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", emitter);
    if (this.emitterIDs.indexOf(emitter.uuid) > -1) return void console.error("Emitter already exists in this group. Will not add again.");
    if (null !== emitter.group) return void console.error("Emitter already belongs to another group. Will not add to requested group.");
    var attributes = this.attributes, start = this.particleCount, end = start + emitter.particleCount;
    this.particleCount = end, null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("SPE.Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount), 
    emitter._calculatePPSValue(emitter.maxAge._value + emitter.maxAge._spread), emitter._setBufferUpdateRanges(this.attributeKeys), 
    emitter._setAttributeOffset(start), emitter.group = this, emitter.attributes = this.attributes;
    for (var attr in attributes) attributes.hasOwnProperty(attr) && attributes[attr]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
    for (var i = start; i < end; ++i) emitter._assignPositionValue(i), emitter._assignForceValue(i, "velocity"), 
    emitter._assignForceValue(i, "acceleration"), emitter._assignAbsLifetimeValue(i, "opacity"), 
    emitter._assignAbsLifetimeValue(i, "size"), emitter._assignAngleValue(i), emitter._assignRotationValue(i), 
    emitter._assignParamsValue(i), emitter._assignColorValue(i);
    return this._applyAttributesToGeometry(), this.emitters.push(emitter), this.emitterIDs.push(emitter.uuid), 
    this._updateDefines(emitter), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, 
    this._attributesNeedRefresh = !0, this;
}, SPE.Group.prototype.removeEmitter = function(emitter) {
    var emitterIndex = this.emitterIDs.indexOf(emitter.uuid);
    if (emitter instanceof SPE.Emitter == !1) return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", emitter);
    if (-1 === emitterIndex) return void console.error("Emitter does not exist in this group. Will not remove.");
    for (var start = emitter.attributeOffset, end = start + emitter.particleCount, params = this.attributes.params.typedArray, i = start; i < end; ++i) params.array[4 * i] = 0, 
    params.array[4 * i + 1] = 0;
    this.emitters.splice(emitterIndex, 1), this.emitterIDs.splice(emitterIndex, 1);
    for (var attr in this.attributes) this.attributes.hasOwnProperty(attr) && this.attributes[attr].splice(start, end);
    this.particleCount -= emitter.particleCount, emitter._onRemove(), this._attributesNeedRefresh = !0;
}, SPE.Group.prototype.getFromPool = function() {
    var pool = this._pool, createNew = this._createNewWhenPoolEmpty;
    return pool.length ? pool.pop() : createNew ? new SPE.Emitter(this._poolCreationSettings) : null;
}, SPE.Group.prototype.releaseIntoPool = function(emitter) {
    return emitter instanceof SPE.Emitter == !1 ? void console.error("Argument is not instanceof SPE.Emitter:", emitter) : (emitter.reset(), 
    this._pool.unshift(emitter), this);
}, SPE.Group.prototype.getPool = function() {
    return this._pool;
}, SPE.Group.prototype.addPool = function(numEmitters, emitterOptions, createNew) {
    var emitter;
    this._poolCreationSettings = emitterOptions, this._createNewWhenPoolEmpty = !!createNew;
    for (var i = 0; i < numEmitters; ++i) emitter = Array.isArray(emitterOptions) ? new SPE.Emitter(emitterOptions[i]) : new SPE.Emitter(emitterOptions), 
    this.addEmitter(emitter), this.releaseIntoPool(emitter);
    return this;
}, SPE.Group.prototype._triggerSingleEmitter = function(pos) {
    var emitter = this.getFromPool(), self = this;
    return null === emitter ? void console.log("SPE.Group pool ran out.") : (pos instanceof THREE.Vector3 && (emitter.position.value.copy(pos), 
    emitter.position.value = emitter.position.value), emitter.enable(), setTimeout(function() {
        emitter.disable(), self.releaseIntoPool(emitter);
    }, 1e3 * Math.max(emitter.duration, emitter.maxAge.value + emitter.maxAge.spread)), 
    this);
}, SPE.Group.prototype.triggerPoolEmitter = function(numEmitters, position) {
    if ("number" == typeof numEmitters && numEmitters > 1) for (var i = 0; i < numEmitters; ++i) this._triggerSingleEmitter(position); else this._triggerSingleEmitter(position);
    return this;
}, SPE.Group.prototype._updateUniforms = function(dt) {
    this.uniforms.runTime.value += dt, this.uniforms.deltaTime.value = dt;
}, SPE.Group.prototype._resetBufferRanges = function() {
    var keys = this.attributeKeys, i = this.attributeCount - 1, attrs = this.attributes;
    for (i; i >= 0; --i) attrs[keys[i]].resetUpdateRange();
}, SPE.Group.prototype._updateBuffers = function(emitter) {
    var key, emitterAttr, attr, keys = this.attributeKeys, i = this.attributeCount - 1, attrs = this.attributes, emitterRanges = emitter.bufferUpdateRanges;
    for (i; i >= 0; --i) key = keys[i], emitterAttr = emitterRanges[key], attr = attrs[key], 
    attr.setUpdateRange(emitterAttr.min, emitterAttr.max), attr.flagUpdate();
}, SPE.Group.prototype.tick = function(dt) {
    var i, emitters = this.emitters, numEmitters = emitters.length, deltaTime = dt || this.fixedTimeStep, keys = this.attributeKeys, attrs = this.attributes;
    if (this._updateUniforms(deltaTime), this._resetBufferRanges(), 0 !== numEmitters || !1 !== this._attributesNeedRefresh || !1 !== this._attributesNeedDynamicReset) {
        for (var emitter, i = 0; i < numEmitters; ++i) emitter = emitters[i], emitter.tick(deltaTime), 
        this._updateBuffers(emitter);
        if (!0 === this._attributesNeedDynamicReset) {
            for (i = this.attributeCount - 1; i >= 0; --i) attrs[keys[i]].resetDynamic();
            this._attributesNeedDynamicReset = !1;
        }
        if (!0 === this._attributesNeedRefresh) {
            for (i = this.attributeCount - 1; i >= 0; --i) attrs[keys[i]].forceUpdateAll();
            this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !0;
        }
    }
}, SPE.Group.prototype.dispose = function() {
    return this.geometry.dispose(), this.material.dispose(), this;
}, SPE.Emitter = function(options) {
    var utils = SPE.utils, types = utils.types, lifetimeLength = SPE.valueOverLifetimeLength;
    options = utils.ensureTypedArg(options, types.OBJECT, {}), options.position = utils.ensureTypedArg(options.position, types.OBJECT, {}), 
    options.velocity = utils.ensureTypedArg(options.velocity, types.OBJECT, {}), options.acceleration = utils.ensureTypedArg(options.acceleration, types.OBJECT, {}), 
    options.radius = utils.ensureTypedArg(options.radius, types.OBJECT, {}), options.drag = utils.ensureTypedArg(options.drag, types.OBJECT, {}), 
    options.rotation = utils.ensureTypedArg(options.rotation, types.OBJECT, {}), options.color = utils.ensureTypedArg(options.color, types.OBJECT, {}), 
    options.opacity = utils.ensureTypedArg(options.opacity, types.OBJECT, {}), options.size = utils.ensureTypedArg(options.size, types.OBJECT, {}), 
    options.angle = utils.ensureTypedArg(options.angle, types.OBJECT, {}), options.wiggle = utils.ensureTypedArg(options.wiggle, types.OBJECT, {}), 
    options.maxAge = utils.ensureTypedArg(options.maxAge, types.OBJECT, {}), options.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."), 
    this.uuid = THREE.Math.generateUUID(), this.type = utils.ensureTypedArg(options.type, types.NUMBER, SPE.distributions.BOX), 
    this.position = {
        _value: utils.ensureInstanceOf(options.position.value, THREE.Vector3, new THREE.Vector3()),
        _spread: utils.ensureInstanceOf(options.position.spread, THREE.Vector3, new THREE.Vector3()),
        _spreadClamp: utils.ensureInstanceOf(options.position.spreadClamp, THREE.Vector3, new THREE.Vector3()),
        _distribution: utils.ensureTypedArg(options.position.distribution, types.NUMBER, this.type),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1),
        _radius: utils.ensureTypedArg(options.position.radius, types.NUMBER, 10),
        _radiusScale: utils.ensureInstanceOf(options.position.radiusScale, THREE.Vector3, new THREE.Vector3(1, 1, 1)),
        _distributionClamp: utils.ensureTypedArg(options.position.distributionClamp, types.NUMBER, 0)
    }, this.velocity = {
        _value: utils.ensureInstanceOf(options.velocity.value, THREE.Vector3, new THREE.Vector3()),
        _spread: utils.ensureInstanceOf(options.velocity.spread, THREE.Vector3, new THREE.Vector3()),
        _distribution: utils.ensureTypedArg(options.velocity.distribution, types.NUMBER, this.type),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.acceleration = {
        _value: utils.ensureInstanceOf(options.acceleration.value, THREE.Vector3, new THREE.Vector3()),
        _spread: utils.ensureInstanceOf(options.acceleration.spread, THREE.Vector3, new THREE.Vector3()),
        _distribution: utils.ensureTypedArg(options.acceleration.distribution, types.NUMBER, this.type),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.drag = {
        _value: utils.ensureTypedArg(options.drag.value, types.NUMBER, 0),
        _spread: utils.ensureTypedArg(options.drag.spread, types.NUMBER, 0),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.wiggle = {
        _value: utils.ensureTypedArg(options.wiggle.value, types.NUMBER, 0),
        _spread: utils.ensureTypedArg(options.wiggle.spread, types.NUMBER, 0)
    }, this.rotation = {
        _axis: utils.ensureInstanceOf(options.rotation.axis, THREE.Vector3, new THREE.Vector3(0, 1, 0)),
        _axisSpread: utils.ensureInstanceOf(options.rotation.axisSpread, THREE.Vector3, new THREE.Vector3()),
        _angle: utils.ensureTypedArg(options.rotation.angle, types.NUMBER, 0),
        _angleSpread: utils.ensureTypedArg(options.rotation.angleSpread, types.NUMBER, 0),
        _static: utils.ensureTypedArg(options.rotation.static, types.BOOLEAN, !1),
        _center: utils.ensureInstanceOf(options.rotation.center, THREE.Vector3, this.position._value.clone()),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.maxAge = {
        _value: utils.ensureTypedArg(options.maxAge.value, types.NUMBER, 2),
        _spread: utils.ensureTypedArg(options.maxAge.spread, types.NUMBER, 0)
    }, this.color = {
        _value: utils.ensureArrayInstanceOf(options.color.value, THREE.Color, new THREE.Color()),
        _spread: utils.ensureArrayInstanceOf(options.color.spread, THREE.Vector3, new THREE.Vector3()),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.opacity = {
        _value: utils.ensureArrayTypedArg(options.opacity.value, types.NUMBER, 1),
        _spread: utils.ensureArrayTypedArg(options.opacity.spread, types.NUMBER, 0),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.size = {
        _value: utils.ensureArrayTypedArg(options.size.value, types.NUMBER, 1),
        _spread: utils.ensureArrayTypedArg(options.size.spread, types.NUMBER, 0),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.angle = {
        _value: utils.ensureArrayTypedArg(options.angle.value, types.NUMBER, 0),
        _spread: utils.ensureArrayTypedArg(options.angle.spread, types.NUMBER, 0),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.particleCount = utils.ensureTypedArg(options.particleCount, types.NUMBER, 100), 
    this.duration = utils.ensureTypedArg(options.duration, types.NUMBER, null), this.isStatic = utils.ensureTypedArg(options.isStatic, types.BOOLEAN, !1), 
    this.activeMultiplier = utils.ensureTypedArg(options.activeMultiplier, types.NUMBER, 1), 
    this.direction = utils.ensureTypedArg(options.direction, types.NUMBER, 1), this.alive = utils.ensureTypedArg(options.alive, types.BOOLEAN, !0), 
    this.particlesPerSecond = 0, this.activationIndex = 0, this.attributeOffset = 0, 
    this.attributeEnd = 0, this.age = 0, this.activeParticleCount = 0, this.group = null, 
    this.attributes = null, this.paramsArray = null, this.resetFlags = {
        position: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1) || utils.ensureTypedArg(options.radius.randomise, types.BOOLEAN, !1),
        velocity: utils.ensureTypedArg(options.velocity.randomise, types.BOOLEAN, !1),
        acceleration: utils.ensureTypedArg(options.acceleration.randomise, types.BOOLEAN, !1) || utils.ensureTypedArg(options.drag.randomise, types.BOOLEAN, !1),
        rotation: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, !1),
        rotationCenter: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, !1),
        size: utils.ensureTypedArg(options.size.randomise, types.BOOLEAN, !1),
        color: utils.ensureTypedArg(options.color.randomise, types.BOOLEAN, !1),
        opacity: utils.ensureTypedArg(options.opacity.randomise, types.BOOLEAN, !1),
        angle: utils.ensureTypedArg(options.angle.randomise, types.BOOLEAN, !1)
    }, this.updateFlags = {}, this.updateCounts = {}, this.updateMap = {
        maxAge: "params",
        position: "position",
        velocity: "velocity",
        acceleration: "acceleration",
        drag: "acceleration",
        wiggle: "params",
        rotation: "rotation",
        size: "size",
        color: "color",
        opacity: "opacity",
        angle: "angle"
    };
    for (var i in this.updateMap) this.updateMap.hasOwnProperty(i) && (this.updateCounts[this.updateMap[i]] = 0, 
    this.updateFlags[this.updateMap[i]] = !1, this._createGetterSetters(this[i], i));
    this.bufferUpdateRanges = {}, this.attributeKeys = null, this.attributeCount = 0, 
    utils.ensureValueOverLifetimeCompliance(this.color, lifetimeLength, lifetimeLength), 
    utils.ensureValueOverLifetimeCompliance(this.opacity, lifetimeLength, lifetimeLength), 
    utils.ensureValueOverLifetimeCompliance(this.size, lifetimeLength, lifetimeLength), 
    utils.ensureValueOverLifetimeCompliance(this.angle, lifetimeLength, lifetimeLength);
}, SPE.Emitter.constructor = SPE.Emitter, SPE.Emitter.prototype._createGetterSetters = function(propObj, propName) {
    var self = this;
    for (var i in propObj) if (propObj.hasOwnProperty(i)) {
        var name = i.replace("_", "");
        Object.defineProperty(propObj, name, {
            get: function(prop) {
                return function() {
                    return this[prop];
                };
            }(i),
            set: function(prop) {
                return function(value) {
                    var mapName = self.updateMap[propName], prevValue = this[prop], length = SPE.valueOverLifetimeLength;
                    "_rotationCenter" === prop ? (self.updateFlags.rotationCenter = !0, self.updateCounts.rotationCenter = 0) : "_randomise" === prop ? self.resetFlags[mapName] = value : (self.updateFlags[mapName] = !0, 
                    self.updateCounts[mapName] = 0), self.group._updateDefines(), this[prop] = value, 
                    Array.isArray(prevValue) && SPE.utils.ensureValueOverLifetimeCompliance(self[propName], length, length);
                };
            }(i)
        });
    }
}, SPE.Emitter.prototype._setBufferUpdateRanges = function(keys) {
    this.attributeKeys = keys, this.attributeCount = keys.length;
    for (var i = this.attributeCount - 1; i >= 0; --i) this.bufferUpdateRanges[keys[i]] = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
    };
}, SPE.Emitter.prototype._calculatePPSValue = function(groupMaxAge) {
    var particleCount = this.particleCount;
    this.duration ? this.particlesPerSecond = particleCount / (groupMaxAge < this.duration ? groupMaxAge : this.duration) : this.particlesPerSecond = particleCount / groupMaxAge;
}, SPE.Emitter.prototype._setAttributeOffset = function(startIndex) {
    this.attributeOffset = startIndex, this.activationIndex = startIndex, this.activationEnd = startIndex + this.particleCount;
}, SPE.Emitter.prototype._assignValue = function(prop, index) {
    switch (prop) {
      case "position":
        this._assignPositionValue(index);
        break;

      case "velocity":
      case "acceleration":
        this._assignForceValue(index, prop);
        break;

      case "size":
      case "opacity":
        this._assignAbsLifetimeValue(index, prop);
        break;

      case "angle":
        this._assignAngleValue(index);
        break;

      case "params":
        this._assignParamsValue(index);
        break;

      case "rotation":
        this._assignRotationValue(index);
        break;

      case "color":
        this._assignColorValue(index);
    }
}, SPE.Emitter.prototype._assignPositionValue = function(index) {
    var distributions = SPE.distributions, utils = SPE.utils, prop = this.position, attr = this.attributes.position, value = prop._value, spread = prop._spread;
    switch (prop._distribution) {
      case distributions.BOX:
        utils.randomVector3(attr, index, value, spread, prop._spreadClamp);
        break;

      case distributions.SPHERE:
        utils.randomVector3OnSphere(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x, prop._distributionClamp || this.particleCount);
        break;

      case distributions.DISC:
        utils.randomVector3OnDisc(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x);
    }
}, SPE.Emitter.prototype._assignForceValue = function(index, attrName) {
    var pos, positionX, positionY, positionZ, i, distributions = SPE.distributions, utils = SPE.utils, prop = this[attrName], value = prop._value, spread = prop._spread, distribution = prop._distribution;
    switch (distribution) {
      case distributions.BOX:
        utils.randomVector3(this.attributes[attrName], index, value, spread);
        break;

      case distributions.SPHERE:
        pos = this.attributes.position.typedArray.array, i = 3 * index, positionX = pos[i], 
        positionY = pos[i + 1], positionZ = pos[i + 2], utils.randomDirectionVector3OnSphere(this.attributes[attrName], index, positionX, positionY, positionZ, this.position._value, prop._value.x, prop._spread.x);
        break;

      case distributions.DISC:
        pos = this.attributes.position.typedArray.array, i = 3 * index, positionX = pos[i], 
        positionY = pos[i + 1], positionZ = pos[i + 2], utils.randomDirectionVector3OnDisc(this.attributes[attrName], index, positionX, positionY, positionZ, this.position._value, prop._value.x, prop._spread.x);
    }
    if ("acceleration" === attrName) {
        var drag = utils.clamp(utils.randomFloat(this.drag._value, this.drag._spread), 0, 1);
        this.attributes.acceleration.typedArray.array[4 * index + 3] = drag;
    }
}, SPE.Emitter.prototype._assignAbsLifetimeValue = function(index, propName) {
    var value, array = this.attributes[propName].typedArray, prop = this[propName], utils = SPE.utils;
    utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread) ? (value = Math.abs(utils.randomFloat(prop._value[0], prop._spread[0])), 
    array.setVec4Components(index, value, value, value, value)) : array.setVec4Components(index, Math.abs(utils.randomFloat(prop._value[0], prop._spread[0])), Math.abs(utils.randomFloat(prop._value[1], prop._spread[1])), Math.abs(utils.randomFloat(prop._value[2], prop._spread[2])), Math.abs(utils.randomFloat(prop._value[3], prop._spread[3])));
}, SPE.Emitter.prototype._assignAngleValue = function(index) {
    var value, array = this.attributes.angle.typedArray, prop = this.angle, utils = SPE.utils;
    utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread) ? (value = utils.randomFloat(prop._value[0], prop._spread[0]), 
    array.setVec4Components(index, value, value, value, value)) : array.setVec4Components(index, utils.randomFloat(prop._value[0], prop._spread[0]), utils.randomFloat(prop._value[1], prop._spread[1]), utils.randomFloat(prop._value[2], prop._spread[2]), utils.randomFloat(prop._value[3], prop._spread[3]));
}, SPE.Emitter.prototype._assignParamsValue = function(index) {
    this.attributes.params.typedArray.setVec4Components(index, this.isStatic ? 1 : 0, 0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread));
}, SPE.Emitter.prototype._assignRotationValue = function(index) {
    this.attributes.rotation.typedArray.setVec3Components(index, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1), 
    this.attributes.rotationCenter.typedArray.setVec3(index, this.rotation._center);
}, SPE.Emitter.prototype._assignColorValue = function(index) {
    SPE.utils.randomColorAsHex(this.attributes.color, index, this.color._value, this.color._spread);
}, SPE.Emitter.prototype._resetParticle = function(index) {
    for (var key, updateFlag, resetFlags = this.resetFlags, updateFlags = this.updateFlags, updateCounts = this.updateCounts, keys = this.attributeKeys, i = this.attributeCount - 1; i >= 0; --i) key = keys[i], 
    updateFlag = updateFlags[key], !0 !== resetFlags[key] && !0 !== updateFlag || (this._assignValue(key, index), 
    this._updateAttributeUpdateRange(key, index), !0 === updateFlag && updateCounts[key] === this.particleCount ? (updateFlags[key] = !1, 
    updateCounts[key] = 0) : 1 == updateFlag && ++updateCounts[key]);
}, SPE.Emitter.prototype._updateAttributeUpdateRange = function(attr, i) {
    var ranges = this.bufferUpdateRanges[attr];
    ranges.min = Math.min(i, ranges.min), ranges.max = Math.max(i, ranges.max);
}, SPE.Emitter.prototype._resetBufferRanges = function() {
    var key, ranges = this.bufferUpdateRanges, keys = this.bufferUpdateKeys, i = this.bufferUpdateCount - 1;
    for (i; i >= 0; --i) key = keys[i], ranges[key].min = Number.POSITIVE_INFINITY, 
    ranges[key].max = Number.NEGATIVE_INFINITY;
}, SPE.Emitter.prototype._onRemove = function() {
    this.particlesPerSecond = 0, this.attributeOffset = 0, this.activationIndex = 0, 
    this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, 
    this.age = 0;
}, SPE.Emitter.prototype._decrementParticleCount = function() {
    --this.activeParticleCount;
}, SPE.Emitter.prototype._incrementParticleCount = function() {
    ++this.activeParticleCount;
}, SPE.Emitter.prototype._checkParticleAges = function(start, end, params, dt) {
    for (var index, maxAge, age, alive, i = end - 1; i >= start; --i) index = 4 * i, 
    0 !== (alive = params[index]) && (age = params[index + 1], maxAge = params[index + 2], 
    1 === this.direction ? (age += dt) >= maxAge && (age = 0, alive = 0, this._decrementParticleCount()) : (age -= dt) <= 0 && (age = maxAge, 
    alive = 0, this._decrementParticleCount()), params[index] = alive, params[index + 1] = age, 
    this._updateAttributeUpdateRange("params", i));
}, SPE.Emitter.prototype._activateParticles = function(activationStart, activationEnd, params, dtPerParticle) {
    for (var index, dtValue, direction = this.direction, i = activationStart; i < activationEnd; ++i) index = 4 * i, 
    0 != params[index] && 1 !== this.particleCount || (this._incrementParticleCount(), 
    params[index] = 1, this._resetParticle(i), dtValue = dtPerParticle * (i - activationStart), 
    params[index + 1] = -1 === direction ? params[index + 2] - dtValue : dtValue, this._updateAttributeUpdateRange("params", i));
}, SPE.Emitter.prototype.tick = function(dt) {
    if (!this.isStatic) {
        null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
        var start = this.attributeOffset, end = start + this.particleCount, params = this.paramsArray, ppsDt = this.particlesPerSecond * this.activeMultiplier * dt, activationIndex = this.activationIndex;
        if (this._resetBufferRanges(), this._checkParticleAges(start, end, params, dt), 
        !1 === this.alive) return void (this.age = 0);
        if (null !== this.duration && this.age > this.duration) return this.alive = !1, 
        void (this.age = 0);
        var activationStart = 1 === this.particleCount ? activationIndex : 0 | activationIndex, activationEnd = Math.min(activationStart + ppsDt, this.activationEnd), activationCount = activationEnd - this.activationIndex | 0, dtPerParticle = activationCount > 0 ? dt / activationCount : 0;
        this._activateParticles(activationStart, activationEnd, params, dtPerParticle), 
        this.activationIndex += ppsDt, this.activationIndex > end && (this.activationIndex = start), 
        this.age += dt;
    }
}, SPE.Emitter.prototype.reset = function(force) {
    if (this.age = 0, this.alive = !1, !0 === force) {
        for (var index, start = this.attributeOffset, end = start + this.particleCount, array = this.paramsArray, attr = this.attributes.params.bufferAttribute, i = end - 1; i >= start; --i) index = 4 * i, 
        array[index] = 0, array[index + 1] = 0;
        attr.updateRange.offset = 0, attr.updateRange.count = -1, attr.needsUpdate = !0;
    }
    return this;
}, SPE.Emitter.prototype.enable = function() {
    return this.alive = !0, this;
}, SPE.Emitter.prototype.disable = function() {
    return this.alive = !1, this;
}, SPE.Emitter.prototype.remove = function() {
    return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), 
    this;
};

var THREEx;

THREEx = THREEx || {}, THREEx.DynamicTexture = function(width, height) {
    var canvas, context, texture;
    canvas = document.createElement("canvas"), canvas.width = width, canvas.height = height, 
    this.canvas = canvas, context = canvas.getContext("2d"), this.context = context, 
    texture = new THREE.Texture(canvas), this.texture = texture;
}, THREEx.DynamicTexture.prototype.clear = function(fillStyle) {
    return void 0 !== fillStyle ? (this.context.fillStyle = fillStyle, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)) : this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), 
    this.texture.needsUpdate = !0, this;
}, THREEx.DynamicTexture.prototype.drawText = function(text, x, y, fillStyle, contextFont) {
    var textSize;
    return void 0 !== contextFont && (this.context.font = contextFont), void 0 !== x && null !== x || (textSize = this.context.measureText(text), 
    x = (this.canvas.width - textSize.width) / 2), this.context.fillStyle = fillStyle, 
    this.context.fillText(text, x, y), this.texture.needsUpdate = !0, this;
}, THREEx.DynamicTexture.prototype.drawTextCooked = function(options) {
    var canvas, computeMaxTextLength, context, maxText, params, text, textSize, x, y;
    for (context = this.context, canvas = this.canvas, computeMaxTextLength = function(text) {
        var maxText, maxWidth, textSize;
        for (maxText = "", maxWidth = (1 - 2 * params.margin) * canvas.width; maxText.length !== text.length && (textSize = context.measureText(maxText), 
        !(textSize.width > maxWidth)); ) maxText += text.substr(maxText.length, 1);
        return maxText;
    }, options = options || {}, text = options.text, params = {
        margin: void 0 !== options.margin ? options.margin : .1,
        lineHeight: void 0 !== options.lineHeight ? options.lineHeight : .1,
        align: void 0 !== options.align ? options.align : "left",
        fillStyle: void 0 !== options.fillStyle ? options.fillStyle : "black",
        fillLineWidth: null != options.fillLineWidth ? options.fillLineWidth : 1,
        strokeStyle: void 0,
        strokeLineWidth: null != options.strokeLineWidth ? options.strokeLineWidth : 20,
        font: void 0 !== options.font ? options.font : "bold 102.4px Arial",
        x: null != options.x ? options.x : 0,
        y: null != options.y ? options.y : 0
    }, console.assert("string" == typeof text), context.save(), context.fillStyle = params.fillStyle, 
    null != options.strokeStyle && (context.miterLimit = 2, context.lineJoin = "circle", 
    context.strokeStyle = options.strokeStyle), context.font = params.font, y = (params.lineHeight + params.margin) * canvas.height; text.length > 0; ) maxText = computeMaxTextLength(text), 
    text = text.substr(maxText.length), textSize = context.measureText(maxText), "left" === params.align ? x = params.margin * canvas.width : "right" === params.align ? x = (1 - params.margin) * canvas.width - textSize.width : "center" === params.align ? x = (canvas.width - textSize.width) / 2 : console.assert(!1), 
    null != options.strokeStyle && (this.context.lineWidth = params.strokeLineWidth, 
    this.context.strokeText(maxText, x + params.x, y + params.y)), this.context.lineWidth = params.fillLineWidth, 
    this.context.fillText(maxText, x + params.x, y + params.y), y += params.lineHeight * canvas.height;
    return context.restore(), this.texture.needsUpdate = !0, this;
}, THREEx.DynamicTexture.prototype.drawImage = function() {
    return this.context.drawImage.apply(this.context, arguments), this.texture.needsUpdate = !0, 
    this;
}, THREE.DeviceOrientationControls = function(object) {
    var onDeviceOrientationChangeEvent, onScreenOrientationChangeEvent, scope, setObjectQuaternion;
    scope = this, this.object = object, this.object.rotation.reorder("YXZ"), this.enabled = !0, 
    this.deviceOrientation = {}, this.screenOrientation = 0, this.alpha = 0, this.alphaOffsetAngle = 0, 
    onDeviceOrientationChangeEvent = function(event) {
        scope.deviceOrientation = event;
    }, onScreenOrientationChangeEvent = function() {
        scope.screenOrientation = window.orientation || 0;
    }, setObjectQuaternion = function() {
        var euler, q0, q1, zee;
        return zee = new THREE.Vector3(0, 0, 1), euler = new THREE.Euler(), q0 = new THREE.Quaternion(), 
        q1 = new THREE.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)), function(quaternion, alpha, beta, gamma, orient) {
            euler.set(beta, alpha, -gamma, "YXZ"), quaternion.setFromEuler(euler), quaternion.multiply(q1), 
            quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
        };
    }(), this.connect = function() {
        onScreenOrientationChangeEvent(), window.addEventListener("orientationchange", onScreenOrientationChangeEvent, !1), 
        window.addEventListener("deviceorientation", onDeviceOrientationChangeEvent, !1), 
        scope.enabled = !0;
    }, this.disconnect = function() {
        window.removeEventListener("orientationchange", onScreenOrientationChangeEvent, !1), 
        window.removeEventListener("deviceorientation", onDeviceOrientationChangeEvent, !1), 
        scope.enabled = !1;
    }, this.update = function() {
        var alpha, beta, gamma, orient;
        !1 !== scope.enabled && (alpha = scope.deviceOrientation.alpha ? THREE.Math.degToRad(scope.deviceOrientation.alpha) + this.alphaOffsetAngle : 0, 
        beta = scope.deviceOrientation.beta ? THREE.Math.degToRad(scope.deviceOrientation.beta) : 0, 
        gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad(scope.deviceOrientation.gamma) : 0, 
        orient = scope.screenOrientation ? THREE.Math.degToRad(scope.screenOrientation) : 0, 
        setObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient), this.alpha = alpha);
    }, this.updateAlphaOffsetAngle = function(angle) {
        this.alphaOffsetAngle = angle, this.update();
    }, this.dispose = function() {
        this.disconnect();
    }, this.connect();
}, THREE.ConvolutionShader = {
    defines: {
        KERNEL_SIZE_FLOAT: "25.0",
        KERNEL_SIZE_INT: "25"
    },
    uniforms: {
        tDiffuse: {
            value: null
        },
        uImageIncrement: {
            value: new THREE.Vector2(.001953125, 0)
        },
        cKernel: {
            value: []
        }
    },
    vertexShader: [ "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "uniform float cKernel[ KERNEL_SIZE_INT ];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "vec2 imageCoord = vUv;", "vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );", "for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {", "sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];", "imageCoord += uImageIncrement;", "}", "gl_FragColor = sum;", "}" ].join("\n"),
    buildKernel: function(sigma) {
        var i, values, sum, halfWidth, kernelSize = 2 * Math.ceil(3 * sigma) + 1;
        for (kernelSize > 25 && (kernelSize = 25), halfWidth = .5 * (kernelSize - 1), values = new Array(kernelSize), 
        sum = 0, i = 0; i < kernelSize; ++i) values[i] = function(x, sigma) {
            return Math.exp(-x * x / (2 * sigma * sigma));
        }(i - halfWidth, sigma), sum += values[i];
        for (i = 0; i < kernelSize; ++i) values[i] /= sum;
        return values;
    }
}, THREE.CopyShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        opacity: {
            value: 1
        }
    },
    vertexShader: [ "varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}" ].join("\n")
}, THREE.FXAAShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        resolution: {
            value: new THREE.Vector2(1 / 1024, 1 / 512)
        }
    },
    vertexShader: [ "void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "#define FXAA_REDUCE_MIN   (1.0/128.0)", "#define FXAA_REDUCE_MUL   (1.0/8.0)", "#define FXAA_SPAN_MAX     8.0", "void main() {", "vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;", "vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;", "vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );", "vec3 rgbM  = rgbaM.xyz;", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float lumaNW = dot( rgbNW, luma );", "float lumaNE = dot( rgbNE, luma );", "float lumaSW = dot( rgbSW, luma );", "float lumaSE = dot( rgbSE, luma );", "float lumaM  = dot( rgbM,  luma );", "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );", "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );", "vec2 dir;", "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));", "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));", "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );", "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );", "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),", "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),", "dir * rcpDirMin)) * resolution;", "vec4 rgbA = (1.0/2.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));", "vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));", "float lumaB = dot(rgbB, vec4(luma, 0.0));", "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {", "gl_FragColor = rgbA;", "} else {", "gl_FragColor = rgbB;", "}", "}" ].join("\n")
}, THREE.FilmShader = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        time: {
            value: 0
        },
        nIntensity: {
            value: .5
        },
        sIntensity: {
            value: .05
        },
        sCount: {
            value: 4096
        },
        grayscale: {
            value: 1
        }
    },
    vertexShader: [ "varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "#include <common>", "uniform float time;", "uniform bool grayscale;", "uniform float nIntensity;", "uniform float sIntensity;", "uniform float sCount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 cTextureScreen = texture2D( tDiffuse, vUv );", "float dx = rand( vUv + time );", "vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );", "vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );", "cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;", "cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );", "if( grayscale ) {", "cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );", "}", "gl_FragColor =  vec4( cResult, cTextureScreen.a );", "}" ].join("\n")
}, THREE.BokehShader = {
    defines: {
        DEPTH_PACKING: 1,
        PERSPECTIVE_CAMERA: 1
    },
    uniforms: {
        tColor: {
            value: null
        },
        tDepth: {
            value: null
        },
        focus: {
            value: 1
        },
        aspect: {
            value: 1
        },
        aperture: {
            value: .025
        },
        maxblur: {
            value: 1
        },
        nearClip: {
            value: 1
        },
        farClip: {
            value: 1e3
        }
    },
    vertexShader: [ "varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "#include <common>", "varying vec2 vUv;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "uniform float maxblur;", "uniform float aperture;", "uniform float nearClip;", "uniform float farClip;", "uniform float focus;", "uniform float aspect;", "#include <packing>", "float getDepth( const in vec2 screenPosition ) {", "\t#if DEPTH_PACKING == 1", "\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "\t#else", "\treturn texture2D( tDepth, screenPosition ).x;", "\t#endif", "}", "float getViewZ( const in float depth ) {", "\t#if PERSPECTIVE_CAMERA == 1", "\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );", "\t#else", "\treturn orthoDepthToViewZ( depth, nearClip, farClip );", "\t#endif", "}", "void main() {", "vec2 aspectcorrect = vec2( 1.0, aspect );", "float viewZ = getViewZ( getDepth( vUv ) );", "float factor = ( focus + viewZ );", "vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );", "vec2 dofblur9 = dofblur * 0.9;", "vec2 dofblur7 = dofblur * 0.7;", "vec2 dofblur4 = dofblur * 0.4;", "vec4 col = vec4( 0.0 );", "col += texture2D( tColor, vUv.xy );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );", "col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );", "gl_FragColor = col / 41.0;", "gl_FragColor.a = 1.0;", "}" ].join("\n")
}, THREE.DigitalGlitch = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        tDisp: {
            value: null
        },
        byp: {
            value: 0
        },
        amount: {
            value: .08
        },
        angle: {
            value: .02
        },
        seed: {
            value: .02
        },
        seed_x: {
            value: .02
        },
        seed_y: {
            value: .02
        },
        distortion_x: {
            value: .5
        },
        distortion_y: {
            value: .6
        },
        col_s: {
            value: .05
        }
    },
    vertexShader: [ "varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "uniform int byp;", "uniform sampler2D tDiffuse;", "uniform sampler2D tDisp;", "uniform float amount;", "uniform float angle;", "uniform float seed;", "uniform float seed_x;", "uniform float seed_y;", "uniform float distortion_x;", "uniform float distortion_y;", "uniform float col_s;", "varying vec2 vUv;", "float rand(vec2 co){", "return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);", "}", "void main() {", "if(byp<1) {", "vec2 p = vUv;", "float xs = floor(gl_FragCoord.x / 0.5);", "float ys = floor(gl_FragCoord.y / 0.5);", "vec4 normal = texture2D (tDisp, p*seed*seed);", "if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {", "if(seed_x>0.){", "p.y = 1. - (p.y + distortion_y);", "}", "else {", "p.y = distortion_y;", "}", "}", "if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {", "if(seed_y>0.){", "p.x=distortion_x;", "}", "else {", "p.x = 1. - (p.x + distortion_x);", "}", "}", "p.x+=normal.x*seed_x*(seed/5.);", "p.y+=normal.y*seed_y*(seed/5.);", "vec2 offset = amount * vec2( cos(angle), sin(angle));", "vec4 cr = texture2D(tDiffuse, p + offset);", "vec4 cga = texture2D(tDiffuse, p);", "vec4 cb = texture2D(tDiffuse, p - offset);", "gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);", "vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);", "gl_FragColor = gl_FragColor+ snow;", "}", "else {", "gl_FragColor=texture2D (tDiffuse, vUv);", "}", "}" ].join("\n")
}, THREE.LuminosityHighPassShader = {
    shaderID: "luminosityHighPass",
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null
        },
        luminosityThreshold: {
            type: "f",
            value: 1
        },
        smoothWidth: {
            type: "f",
            value: 1
        },
        defaultColor: {
            type: "c",
            value: new THREE.Color(0)
        },
        defaultOpacity: {
            type: "f",
            value: 0
        }
    },
    vertexShader: [ "varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float v = dot( texel.xyz, luma );", "vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "gl_FragColor = mix( outputColor, texel, alpha );", "}" ].join("\n")
}, THREE.EffectComposer = function(renderer, renderTarget) {
    if (this.renderer = renderer, void 0 === renderTarget) {
        var parameters = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: !1
        }, size = renderer.getSize();
        renderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters), 
        renderTarget.texture.name = "EffectComposer.rt1";
    }
    this.renderTarget1 = renderTarget, this.renderTarget2 = renderTarget.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", 
    this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.passes = [], 
    void 0 === THREE.CopyShader && console.error("THREE.EffectComposer relies on THREE.CopyShader"), 
    void 0 === THREE.ShaderPass && console.error("THREE.EffectComposer relies on THREE.ShaderPass"), 
    this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
}, Object.assign(THREE.EffectComposer.prototype, {
    swapBuffers: function() {
        var tmp = this.readBuffer;
        this.readBuffer = this.writeBuffer, this.writeBuffer = tmp;
    },
    addPass: function(pass) {
        this.passes.push(pass);
        var size = this.renderer.getSize();
        pass.setSize(size.width, size.height);
    },
    insertPass: function(pass, index) {
        this.passes.splice(index, 0, pass);
    },
    render: function(delta) {
        var pass, i, maskActive = !1, il = this.passes.length;
        for (i = 0; i < il; i++) if (pass = this.passes[i], !1 !== pass.enabled) {
            if (pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive), 
            pass.needsSwap) {
                if (maskActive) {
                    var context = this.renderer.context;
                    context.stencilFunc(context.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta), 
                    context.stencilFunc(context.EQUAL, 1, 4294967295);
                }
                this.swapBuffers();
            }
            void 0 !== THREE.MaskPass && (pass instanceof THREE.MaskPass ? maskActive = !0 : pass instanceof THREE.ClearMaskPass && (maskActive = !1));
        }
    },
    reset: function(renderTarget) {
        if (void 0 === renderTarget) {
            var size = this.renderer.getSize();
            renderTarget = this.renderTarget1.clone(), renderTarget.setSize(size.width, size.height);
        }
        this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = renderTarget, 
        this.renderTarget2 = renderTarget.clone(), this.writeBuffer = this.renderTarget1, 
        this.readBuffer = this.renderTarget2;
    },
    setSize: function(width, height) {
        this.renderTarget1.setSize(width, height), this.renderTarget2.setSize(width, height);
        for (var i = 0; i < this.passes.length; i++) this.passes[i].setSize(width, height);
    }
}), THREE.Pass = function() {
    this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
}, Object.assign(THREE.Pass.prototype, {
    setSize: function(width, height) {},
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        console.error("THREE.Pass: .render() must be implemented in derived pass.");
    }
}), THREE.MaskPass = function(scene, camera) {
    THREE.Pass.call(this), this.scene = scene, this.camera = camera, this.clear = !0, 
    this.needsSwap = !1, this.inverse = !1;
}, THREE.MaskPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.MaskPass,
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        var context = renderer.context, state = renderer.state;
        state.buffers.color.setMask(!1), state.buffers.depth.setMask(!1), state.buffers.color.setLocked(!0), 
        state.buffers.depth.setLocked(!0);
        var writeValue, clearValue;
        this.inverse ? (writeValue = 0, clearValue = 1) : (writeValue = 1, clearValue = 0), 
        state.buffers.stencil.setTest(!0), state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE), 
        state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295), state.buffers.stencil.setClear(clearValue), 
        renderer.render(this.scene, this.camera, readBuffer, this.clear), renderer.render(this.scene, this.camera, writeBuffer, this.clear), 
        state.buffers.color.setLocked(!1), state.buffers.depth.setLocked(!1), state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295), 
        state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    }
}), THREE.ClearMaskPass = function() {
    THREE.Pass.call(this), this.needsSwap = !1;
}, THREE.ClearMaskPass.prototype = Object.create(THREE.Pass.prototype), Object.assign(THREE.ClearMaskPass.prototype, {
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        renderer.state.buffers.stencil.setTest(!1);
    }
}), THREE.RenderPass = function(scene, camera, overrideMaterial, clearColor, clearAlpha) {
    THREE.Pass.call(this), this.scene = scene, this.camera = camera, this.overrideMaterial = overrideMaterial, 
    this.clearColor = clearColor, this.clearAlpha = void 0 !== clearAlpha ? clearAlpha : 0, 
    this.clear = !0, this.clearDepth = !1, this.needsSwap = !1;
}, THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.RenderPass,
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        var oldAutoClear = renderer.autoClear;
        renderer.autoClear = !1, this.scene.overrideMaterial = this.overrideMaterial;
        var oldClearColor, oldClearAlpha;
        this.clearColor && (oldClearColor = renderer.getClearColor().getHex(), oldClearAlpha = renderer.getClearAlpha(), 
        renderer.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && renderer.clearDepth(), 
        renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear), 
        this.clearColor && renderer.setClearColor(oldClearColor, oldClearAlpha), this.scene.overrideMaterial = null, 
        renderer.autoClear = oldAutoClear;
    }
}), THREE.ShaderPass = function(shader, textureID) {
    THREE.Pass.call(this), this.textureID = void 0 !== textureID ? textureID : "tDiffuse", 
    shader instanceof THREE.ShaderMaterial ? (this.uniforms = shader.uniforms, this.material = shader) : shader && (this.uniforms = THREE.UniformsUtils.clone(shader.uniforms), 
    this.material = new THREE.ShaderMaterial({
        defines: shader.defines || {},
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
    })), this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), this.scene = new THREE.Scene(), 
    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null), this.quad.frustumCulled = !1, 
    this.scene.add(this.quad);
}, THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.ShaderPass,
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = readBuffer.texture), 
        this.quad.material = this.material, this.renderToScreen ? renderer.render(this.scene, this.camera) : renderer.render(this.scene, this.camera, writeBuffer, this.clear);
    }
}), THREE.BloomPass = function(strength, kernelSize, sigma, resolution) {
    THREE.Pass.call(this), strength = void 0 !== strength ? strength : 1, kernelSize = void 0 !== kernelSize ? kernelSize : 25, 
    sigma = void 0 !== sigma ? sigma : 4, resolution = void 0 !== resolution ? resolution : 256;
    var pars = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
    };
    this.renderTargetX = new THREE.WebGLRenderTarget(resolution, resolution, pars), 
    this.renderTargetX.texture.name = "BloomPass.x", this.renderTargetY = new THREE.WebGLRenderTarget(resolution, resolution, pars), 
    this.renderTargetY.texture.name = "BloomPass.y", void 0 === THREE.CopyShader && console.error("THREE.BloomPass relies on THREE.CopyShader");
    var copyShader = THREE.CopyShader;
    this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms), this.copyUniforms.opacity.value = strength, 
    this.materialCopy = new THREE.ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: copyShader.vertexShader,
        fragmentShader: copyShader.fragmentShader,
        blending: THREE.AdditiveBlending,
        transparent: !0
    }), void 0 === THREE.ConvolutionShader && console.error("THREE.BloomPass relies on THREE.ConvolutionShader");
    var convolutionShader = THREE.ConvolutionShader;
    this.convolutionUniforms = THREE.UniformsUtils.clone(convolutionShader.uniforms), 
    this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurX, this.convolutionUniforms.cKernel.value = THREE.ConvolutionShader.buildKernel(sigma), 
    this.materialConvolution = new THREE.ShaderMaterial({
        uniforms: this.convolutionUniforms,
        vertexShader: convolutionShader.vertexShader,
        fragmentShader: convolutionShader.fragmentShader,
        defines: {
            KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),
            KERNEL_SIZE_INT: kernelSize.toFixed(0)
        }
    }), this.needsSwap = !1, this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), 
    this.scene = new THREE.Scene(), this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null), 
    this.quad.frustumCulled = !1, this.scene.add(this.quad);
}, THREE.BloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.BloomPass,
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        maskActive && renderer.context.disable(renderer.context.STENCIL_TEST), this.quad.material = this.materialConvolution, 
        this.convolutionUniforms.tDiffuse.value = readBuffer.texture, this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurX, 
        renderer.render(this.scene, this.camera, this.renderTargetX, !0), this.convolutionUniforms.tDiffuse.value = this.renderTargetX.texture, 
        this.convolutionUniforms.uImageIncrement.value = THREE.BloomPass.blurY, renderer.render(this.scene, this.camera, this.renderTargetY, !0), 
        this.quad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetY.texture, 
        maskActive && renderer.context.enable(renderer.context.STENCIL_TEST), renderer.render(this.scene, this.camera, readBuffer, this.clear);
    }
}), THREE.BloomPass.blurX = new THREE.Vector2(.001953125, 0), THREE.BloomPass.blurY = new THREE.Vector2(0, .001953125), 
THREE.FilmPass = function(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {
    THREE.Pass.call(this), void 0 === THREE.FilmShader && console.error("THREE.FilmPass relies on THREE.FilmShader");
    var shader = THREE.FilmShader;
    this.uniforms = THREE.UniformsUtils.clone(shader.uniforms), this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
    }), void 0 !== grayscale && (this.uniforms.grayscale.value = grayscale), void 0 !== noiseIntensity && (this.uniforms.nIntensity.value = noiseIntensity), 
    void 0 !== scanlinesIntensity && (this.uniforms.sIntensity.value = scanlinesIntensity), 
    void 0 !== scanlinesCount && (this.uniforms.sCount.value = scanlinesCount), this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), 
    this.scene = new THREE.Scene(), this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null), 
    this.quad.frustumCulled = !1, this.scene.add(this.quad);
}, THREE.FilmPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.FilmPass,
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        this.uniforms.tDiffuse.value = readBuffer.texture, this.uniforms.time.value += delta, 
        this.quad.material = this.material, this.renderToScreen ? renderer.render(this.scene, this.camera) : renderer.render(this.scene, this.camera, writeBuffer, this.clear);
    }
}), THREE.BokehPass = function(scene, camera, params) {
    THREE.Pass.call(this), this.scene = scene, this.camera = camera;
    var focus = void 0 !== params.focus ? params.focus : 1, aspect = void 0 !== params.aspect ? params.aspect : camera.aspect, aperture = void 0 !== params.aperture ? params.aperture : .025, maxblur = void 0 !== params.maxblur ? params.maxblur : 1, width = params.width || window.innerWidth || 1, height = params.height || window.innerHeight || 1;
    this.renderTargetColor = new THREE.WebGLRenderTarget(width, height, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBFormat
    }), this.renderTargetColor.texture.name = "BokehPass.color", this.renderTargetDepth = this.renderTargetColor.clone(), 
    this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new THREE.MeshDepthMaterial(), 
    this.materialDepth.depthPacking = THREE.RGBADepthPacking, this.materialDepth.blending = THREE.NoBlending, 
    void 0 === THREE.BokehShader && console.error("THREE.BokehPass relies on THREE.BokehShader");
    var bokehShader = THREE.BokehShader, bokehUniforms = THREE.UniformsUtils.clone(bokehShader.uniforms);
    bokehUniforms.tDepth.value = this.renderTargetDepth.texture, bokehUniforms.focus.value = focus, 
    bokehUniforms.aspect.value = aspect, bokehUniforms.aperture.value = aperture, bokehUniforms.maxblur.value = maxblur, 
    bokehUniforms.nearClip.value = camera.near, bokehUniforms.farClip.value = camera.far, 
    this.materialBokeh = new THREE.ShaderMaterial({
        defines: bokehShader.defines,
        uniforms: bokehUniforms,
        vertexShader: bokehShader.vertexShader,
        fragmentShader: bokehShader.fragmentShader
    }), this.uniforms = bokehUniforms, this.needsSwap = !1, this.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), 
    this.scene2 = new THREE.Scene(), this.quad2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null), 
    this.quad2.frustumCulled = !1, this.scene2.add(this.quad2), this.oldClearColor = new THREE.Color(), 
    this.oldClearAlpha = 1;
}, THREE.BokehPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.BokehPass,
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        this.quad2.material = this.materialBokeh, this.scene.overrideMaterial = this.materialDepth, 
        this.oldClearColor.copy(renderer.getClearColor()), this.oldClearAlpha = renderer.getClearAlpha();
        renderer.autoClear;
        renderer.autoClear = !1, renderer.setClearColor(16777215), renderer.setClearAlpha(1), 
        renderer.render(this.scene, this.camera, this.renderTargetDepth, !0), this.uniforms.tColor.value = readBuffer.texture, 
        this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, 
        this.renderToScreen ? renderer.render(this.scene2, this.camera2) : renderer.render(this.scene2, this.camera2, writeBuffer, this.clear), 
        this.scene.overrideMaterial = null, renderer.setClearColor(this.oldClearColor), 
        renderer.setClearAlpha(this.oldClearAlpha), renderer.autoClear = this.oldAutoClear;
    }
}), THREE.GlitchPass = function(dt_size) {
    THREE.Pass.call(this), void 0 === THREE.DigitalGlitch && console.error("THREE.GlitchPass relies on THREE.DigitalGlitch");
    var shader = THREE.DigitalGlitch;
    this.uniforms = THREE.UniformsUtils.clone(shader.uniforms), void 0 == dt_size && (dt_size = 64), 
    this.uniforms.tDisp.value = this.generateHeightmap(dt_size), this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
    }), this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), this.scene = new THREE.Scene(), 
    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null), this.quad.frustumCulled = !1, 
    this.scene.add(this.quad), this.goWild = !1, this.curF = 0, this.generateTrigger();
}, THREE.GlitchPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.GlitchPass,
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        this.uniforms.tDiffuse.value = readBuffer.texture, this.uniforms.seed.value = Math.random(), 
        this.uniforms.byp.value = 0, this.curF % this.randX == 0 || 1 == this.goWild ? (this.uniforms.amount.value = Math.random() / 30, 
        this.uniforms.angle.value = THREE.Math.randFloat(-Math.PI, Math.PI), this.uniforms.seed_x.value = THREE.Math.randFloat(-1, 1), 
        this.uniforms.seed_y.value = THREE.Math.randFloat(-1, 1), this.uniforms.distortion_x.value = THREE.Math.randFloat(0, 1), 
        this.uniforms.distortion_y.value = THREE.Math.randFloat(0, 1), this.curF = 0, this.generateTrigger()) : this.curF % this.randX < this.randX / 5 ? (this.uniforms.amount.value = Math.random() / 90, 
        this.uniforms.angle.value = THREE.Math.randFloat(-Math.PI, Math.PI), this.uniforms.distortion_x.value = THREE.Math.randFloat(0, 1), 
        this.uniforms.distortion_y.value = THREE.Math.randFloat(0, 1), this.uniforms.seed_x.value = THREE.Math.randFloat(-.3, .3), 
        this.uniforms.seed_y.value = THREE.Math.randFloat(-.3, .3)) : 0 == this.goWild && (this.uniforms.byp.value = 1), 
        this.curF++, this.quad.material = this.material, this.renderToScreen ? renderer.render(this.scene, this.camera) : renderer.render(this.scene, this.camera, writeBuffer, this.clear);
    },
    generateTrigger: function() {
        this.randX = THREE.Math.randInt(120, 240);
    },
    generateHeightmap: function(dt_size) {
        for (var data_arr = new Float32Array(dt_size * dt_size * 3), length = dt_size * dt_size, i = 0; i < length; i++) {
            var val = THREE.Math.randFloat(0, 1);
            data_arr[3 * i + 0] = val, data_arr[3 * i + 1] = val, data_arr[3 * i + 2] = val;
        }
        var texture = new THREE.DataTexture(data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType);
        return texture.needsUpdate = !0, texture;
    }
}), THREE.UnrealBloomPass = function(resolution, strength, radius, threshold) {
    THREE.Pass.call(this), this.strength = void 0 !== strength ? strength : 1, this.radius = radius, 
    this.threshold = threshold, this.resolution = void 0 !== resolution ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);
    var pars = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
    };
    this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
    var resx = Math.round(this.resolution.x / 2), resy = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", 
    this.renderTargetBright.texture.generateMipmaps = !1;
    for (var i = 0; i < this.nMips; i++) {
        var renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);
        renderTarget.texture.name = "UnrealBloomPass.h" + i, renderTarget.texture.generateMipmaps = !1, 
        this.renderTargetsHorizontal.push(renderTarget);
        var renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);
        renderTarget.texture.name = "UnrealBloomPass.v" + i, renderTarget.texture.generateMipmaps = !1, 
        this.renderTargetsVertical.push(renderTarget), resx = Math.round(resx / 2), resy = Math.round(resy / 2);
    }
    void 0 === THREE.LuminosityHighPassShader && console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader");
    var highPassShader = THREE.LuminosityHighPassShader;
    this.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms), this.highPassUniforms.luminosityThreshold.value = threshold, 
    this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new THREE.ShaderMaterial({
        uniforms: this.highPassUniforms,
        vertexShader: highPassShader.vertexShader,
        fragmentShader: highPassShader.fragmentShader,
        defines: {}
    }), this.separableBlurMaterials = [];
    for (var kernelSizeArray = [ 3, 5, 7, 9, 11 ], resx = Math.round(this.resolution.x / 2), resy = Math.round(this.resolution.y / 2), i = 0; i < this.nMips; i++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i])), 
    this.separableBlurMaterials[i].uniforms.texSize.value = new THREE.Vector2(resx, resy), 
    resx = Math.round(resx / 2), resy = Math.round(resy / 2);
    this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, 
    this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, 
    this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, 
    this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, 
    this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, 
    this.compositeMaterial.uniforms.bloomStrength.value = strength, this.compositeMaterial.uniforms.bloomRadius.value = .1, 
    this.compositeMaterial.needsUpdate = !0;
    var bloomFactors = [ 1, .8, .6, .4, .2 ];
    this.compositeMaterial.uniforms.bloomFactors.value = bloomFactors, this.bloomTintColors = [ new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1) ], 
    this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, void 0 === THREE.CopyShader && console.error("THREE.BloomPass relies on THREE.CopyShader");
    var copyShader = THREE.CopyShader;
    this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms), this.copyUniforms.opacity.value = 1, 
    this.materialCopy = new THREE.ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: copyShader.vertexShader,
        fragmentShader: copyShader.fragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
    }), this.enabled = !0, this.needsSwap = !1, this.oldClearColor = new THREE.Color(), 
    this.oldClearAlpha = 1, this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), 
    this.scene = new THREE.Scene(), this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null), 
    this.quad.frustumCulled = !1, this.scene.add(this.quad);
}, THREE.UnrealBloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.UnrealBloomPass,
    dispose: function() {
        for (var i = 0; i < this.renderTargetsHorizontal.length; i++) this.renderTargetsHorizontal[i].dispose();
        for (var i = 0; i < this.renderTargetsVertical.length; i++) this.renderTargetsVertical[i].dispose();
        this.renderTargetBright.dispose();
    },
    setSize: function(width, height) {
        var resx = Math.round(width / 2), resy = Math.round(height / 2);
        this.renderTargetBright.setSize(resx, resy);
        for (var i = 0; i < this.nMips; i++) this.renderTargetsHorizontal[i].setSize(resx, resy), 
        this.renderTargetsVertical[i].setSize(resx, resy), this.separableBlurMaterials[i].uniforms.texSize.value = new THREE.Vector2(resx, resy), 
        resx = Math.round(resx / 2), resy = Math.round(resy / 2);
    },
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        this.oldClearColor.copy(renderer.getClearColor()), this.oldClearAlpha = renderer.getClearAlpha();
        var oldAutoClear = renderer.autoClear;
        renderer.autoClear = !1, renderer.setClearColor(new THREE.Color(0, 0, 0), 0), maskActive && renderer.context.disable(renderer.context.STENCIL_TEST), 
        this.highPassUniforms.tDiffuse.value = readBuffer.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, 
        this.quad.material = this.materialHighPassFilter, renderer.render(this.scene, this.camera, this.renderTargetBright, !0);
        for (var inputRenderTarget = this.renderTargetBright, i = 0; i < this.nMips; i++) this.quad.material = this.separableBlurMaterials[i], 
        this.separableBlurMaterials[i].uniforms.colorTexture.value = inputRenderTarget.texture, 
        this.separableBlurMaterials[i].uniforms.direction.value = THREE.UnrealBloomPass.BlurDirectionX, 
        renderer.render(this.scene, this.camera, this.renderTargetsHorizontal[i], !0), this.separableBlurMaterials[i].uniforms.colorTexture.value = this.renderTargetsHorizontal[i].texture, 
        this.separableBlurMaterials[i].uniforms.direction.value = THREE.UnrealBloomPass.BlurDirectionY, 
        renderer.render(this.scene, this.camera, this.renderTargetsVertical[i], !0), inputRenderTarget = this.renderTargetsVertical[i];
        this.quad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, 
        this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, 
        renderer.render(this.scene, this.camera, this.renderTargetsHorizontal[0], !0), this.quad.material = this.materialCopy, 
        this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, maskActive && renderer.context.enable(renderer.context.STENCIL_TEST), 
        renderer.render(this.scene, this.camera, readBuffer, !1), renderer.setClearColor(this.oldClearColor, this.oldClearAlpha), 
        renderer.autoClear = oldAutoClear;
    },
    getSeperableBlurMaterial: function(kernelRadius) {
        return new THREE.ShaderMaterial({
            defines: {
                KERNEL_RADIUS: kernelRadius,
                SIGMA: kernelRadius
            },
            uniforms: {
                colorTexture: {
                    value: null
                },
                texSize: {
                    value: new THREE.Vector2(.5, .5)
                },
                direction: {
                    value: new THREE.Vector2(.5, .5)
                }
            },
            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader: "#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
        });
    },
    getCompositeMaterial: function(nMips) {
        return new THREE.ShaderMaterial({
            defines: {
                NUM_MIPS: nMips
            },
            uniforms: {
                blurTexture1: {
                    value: null
                },
                blurTexture2: {
                    value: null
                },
                blurTexture3: {
                    value: null
                },
                blurTexture4: {
                    value: null
                },
                blurTexture5: {
                    value: null
                },
                dirtTexture: {
                    value: null
                },
                bloomStrength: {
                    value: 1
                },
                bloomFactors: {
                    value: null
                },
                bloomTintColors: {
                    value: null
                },
                bloomRadius: {
                    value: 0
                }
            },
            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader: "varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"
        });
    }
}), THREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1, 0), THREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0, 1), 
THREE.OutlinePass = function(resolution, scene, camera, selectedObjects) {
    this.renderScene = scene, this.renderCamera = camera, this.selectedObjects = void 0 !== selectedObjects ? selectedObjects : [], 
    this.visibleEdgeColor = new THREE.Color(1, 1, 1), this.hiddenEdgeColor = new THREE.Color(.1, .04, .02), 
    this.edgeGlow = 0, this.usePatternTexture = !1, this.edgeThickness = 1, this.edgeStrength = 3, 
    this.downSampleRatio = 2, this.pulsePeriod = 0, THREE.Pass.call(this), this.resolution = void 0 !== resolution ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);
    var pars = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
    }, resx = Math.round(this.resolution.x / this.downSampleRatio), resy = Math.round(this.resolution.y / this.downSampleRatio);
    this.maskBufferMaterial = new THREE.MeshBasicMaterial({
        color: 16777215
    }), this.maskBufferMaterial.side = THREE.DoubleSide, this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars), 
    this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = !1, 
    this.depthMaterial = new THREE.MeshDepthMaterial(), this.depthMaterial.side = THREE.DoubleSide, 
    this.depthMaterial.depthPacking = THREE.RGBADepthPacking, this.depthMaterial.blending = THREE.NoBlending, 
    this.prepareMaskMaterial = this.getPrepareMaskMaterial(), this.prepareMaskMaterial.side = THREE.DoubleSide, 
    this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars), 
    this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = !1, 
    this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(resx, resy, pars), 
    this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", 
    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1, this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars), 
    this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = !1, 
    this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars), 
    this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = !1, 
    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars), 
    this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1, 
    this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars), 
    this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1;
    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(4), this.separableBlurMaterial1.uniforms.texSize.value = new THREE.Vector2(resx, resy), 
    this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeperableBlurMaterial(4), 
    this.separableBlurMaterial2.uniforms.texSize.value = new THREE.Vector2(Math.round(resx / 2), Math.round(resy / 2)), 
    this.separableBlurMaterial2.uniforms.kernelRadius.value = 4, this.overlayMaterial = this.getOverlayMaterial(), 
    void 0 === THREE.CopyShader && console.error("THREE.OutlinePass relies on THREE.CopyShader");
    var copyShader = THREE.CopyShader;
    this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms), this.copyUniforms.opacity.value = 1, 
    this.materialCopy = new THREE.ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: copyShader.vertexShader,
        fragmentShader: copyShader.fragmentShader,
        blending: THREE.NoBlending,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
    }), this.enabled = !0, this.needsSwap = !1, this.oldClearColor = new THREE.Color(), 
    this.oldClearAlpha = 1, this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), 
    this.scene = new THREE.Scene(), this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null), 
    this.quad.frustumCulled = !1, this.scene.add(this.quad), this.tempPulseColor1 = new THREE.Color(), 
    this.tempPulseColor2 = new THREE.Color(), this.textureMatrix = new THREE.Matrix4();
}, THREE.OutlinePass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.OutlinePass,
    dispose: function() {
        this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), 
        this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), 
        this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose();
    },
    setSize: function(width, height) {
        this.renderTargetMaskBuffer.setSize(width, height);
        var resx = Math.round(width / this.downSampleRatio), resy = Math.round(height / this.downSampleRatio);
        this.renderTargetMaskDownSampleBuffer.setSize(resx, resy), this.renderTargetBlurBuffer1.setSize(resx, resy), 
        this.renderTargetEdgeBuffer1.setSize(resx, resy), this.separableBlurMaterial1.uniforms.texSize.value = new THREE.Vector2(resx, resy), 
        resx = Math.round(resx / 2), resy = Math.round(resy / 2), this.renderTargetBlurBuffer2.setSize(resx, resy), 
        this.renderTargetEdgeBuffer2.setSize(resx, resy), this.separableBlurMaterial2.uniforms.texSize.value = new THREE.Vector2(resx, resy);
    },
    changeVisibilityOfSelectedObjects: function(bVisible) {
        function gatherSelectedMeshesCallBack(object) {
            object instanceof THREE.Mesh && (object.visible = bVisible);
        }
        for (var i = 0; i < this.selectedObjects.length; i++) {
            this.selectedObjects[i].traverse(gatherSelectedMeshesCallBack);
        }
    },
    changeVisibilityOfNonSelectedObjects: function(bVisible) {
        function gatherSelectedMeshesCallBack(object) {
            object instanceof THREE.Mesh && selectedMeshes.push(object);
        }
        function VisibilityChangeCallBack(object) {
            if (object instanceof THREE.Mesh) {
                for (var bFound = !1, i = 0; i < selectedMeshes.length; i++) {
                    if (selectedMeshes[i].id === object.id) {
                        bFound = !0;
                        break;
                    }
                }
                if (!bFound) {
                    var visibility = object.visible;
                    bVisible && !object.bVisible || (object.visible = bVisible), object.bVisible = visibility;
                }
            }
        }
        for (var selectedMeshes = [], i = 0; i < this.selectedObjects.length; i++) {
            this.selectedObjects[i].traverse(gatherSelectedMeshesCallBack);
        }
        this.renderScene.traverse(VisibilityChangeCallBack);
    },
    updateTextureMatrix: function() {
        this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), 
        this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
    },
    render: function(renderer, writeBuffer, readBuffer, delta, maskActive) {
        if (0 !== this.selectedObjects.length) {
            this.oldClearColor.copy(renderer.getClearColor()), this.oldClearAlpha = renderer.getClearAlpha();
            var oldAutoClear = renderer.autoClear;
            if (renderer.autoClear = !1, maskActive && renderer.context.disable(renderer.context.STENCIL_TEST), 
            renderer.setClearColor(16777215, 1), this.changeVisibilityOfSelectedObjects(!1), 
            this.renderScene.overrideMaterial = this.depthMaterial, renderer.render(this.renderScene, this.renderCamera, this.renderTargetDepthBuffer, !0), 
            this.changeVisibilityOfSelectedObjects(!0), this.updateTextureMatrix(), this.changeVisibilityOfNonSelectedObjects(!1), 
            this.renderScene.overrideMaterial = this.prepareMaskMaterial, this.prepareMaskMaterial.uniforms.cameraNearFar.value = new THREE.Vector2(this.renderCamera.near, this.renderCamera.far), 
            this.prepareMaskMaterial.uniforms.depthTexture.value = this.renderTargetDepthBuffer.texture, 
            this.prepareMaskMaterial.uniforms.textureMatrix.value = this.textureMatrix, renderer.render(this.renderScene, this.renderCamera, this.renderTargetMaskBuffer, !0), 
            this.renderScene.overrideMaterial = null, this.changeVisibilityOfNonSelectedObjects(!0), 
            this.quad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, 
            renderer.render(this.scene, this.camera, this.renderTargetMaskDownSampleBuffer, !0), 
            this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), 
            this.pulsePeriod > 0) {
                var scalar = .625 + .75 * Math.cos(.01 * performance.now() / this.pulsePeriod) / 2;
                this.tempPulseColor1.multiplyScalar(scalar), this.tempPulseColor2.multiplyScalar(scalar);
            }
            this.quad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, 
            this.edgeDetectionMaterial.uniforms.texSize.value = new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), 
            this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, 
            this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, 
            renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, !0), this.quad.material = this.separableBlurMaterial1, 
            this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, 
            this.separableBlurMaterial1.uniforms.direction.value = THREE.OutlinePass.BlurDirectionX, 
            this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, renderer.render(this.scene, this.camera, this.renderTargetBlurBuffer1, !0), 
            this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, 
            this.separableBlurMaterial1.uniforms.direction.value = THREE.OutlinePass.BlurDirectionY, 
            renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, !0), this.quad.material = this.separableBlurMaterial2, 
            this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, 
            this.separableBlurMaterial2.uniforms.direction.value = THREE.OutlinePass.BlurDirectionX, 
            renderer.render(this.scene, this.camera, this.renderTargetBlurBuffer2, !0), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, 
            this.separableBlurMaterial2.uniforms.direction.value = THREE.OutlinePass.BlurDirectionY, 
            renderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer2, !0), this.quad.material = this.overlayMaterial, 
            this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, 
            this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, 
            this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, 
            this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, 
            this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, 
            maskActive && renderer.context.enable(renderer.context.STENCIL_TEST), renderer.render(this.scene, this.camera, readBuffer, !1), 
            renderer.setClearColor(this.oldClearColor, this.oldClearAlpha), renderer.autoClear = oldAutoClear;
        }
    },
    getPrepareMaskMaterial: function() {
        return new THREE.ShaderMaterial({
            uniforms: {
                depthTexture: {
                    value: null
                },
                cameraNearFar: {
                    value: new THREE.Vector2(.5, .5)
                },
                textureMatrix: {
                    value: new THREE.Matrix4()
                }
            },
            vertexShader: "varying vec2 vUv;\t\t\t\tvarying vec4 projTexCoord;\t\t\t\tvarying vec4 vPosition;\t\t\t\tuniform mat4 textureMatrix;\t\t\t\tvoid main() {\t\t\t\t\tvUv = uv;\t\t\t\t\tvPosition = modelViewMatrix * vec4( position, 1.0 );\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader: "#include <packing>\t\t\t\tvarying vec2 vUv;\t\t\t\tvarying vec4 vPosition;\t\t\t\tvarying vec4 projTexCoord;\t\t\t\tuniform sampler2D depthTexture;\t\t\t\tuniform vec2 cameraNearFar;\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\t\t\t\t\tfloat viewZ = -perspectiveDepthToViewZ( depth, cameraNearFar.x, cameraNearFar.y );\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\t\t\t\t}"
        });
    },
    getEdgeDetectionMaterial: function() {
        return new THREE.ShaderMaterial({
            uniforms: {
                maskTexture: {
                    value: null
                },
                texSize: {
                    value: new THREE.Vector2(.5, .5)
                },
                visibleEdgeColor: {
                    value: new THREE.Vector3(1, 1, 1)
                },
                hiddenEdgeColor: {
                    value: new THREE.Vector3(1, 1, 1)
                }
            },
            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader: "varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec3 visibleEdgeColor;\t\t\t\tuniform vec3 hiddenEdgeColor;\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\t\t\t\t}"
        });
    },
    getSeperableBlurMaterial: function(maxRadius) {
        return new THREE.ShaderMaterial({
            defines: {
                MAX_RADIUS: maxRadius
            },
            uniforms: {
                colorTexture: {
                    value: null
                },
                texSize: {
                    value: new THREE.Vector2(.5, .5)
                },
                direction: {
                    value: new THREE.Vector2(.5, .5)
                },
                kernelRadius: {
                    value: 1
                }
            },
            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader: "#include <common>\t\t\t\tvarying vec2 vUv;\t\t\t\tuniform sampler2D colorTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\tuniform float kernelRadius;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\t\t\t\t\tvec2 uvOffset = delta;\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\t\t\t\t\t\tweightSum += (2.0 * w);\t\t\t\t\t\tuvOffset += delta;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\t\t\t\t}"
        });
    },
    getOverlayMaterial: function() {
        return new THREE.ShaderMaterial({
            uniforms: {
                maskTexture: {
                    value: null
                },
                edgeTexture1: {
                    value: null
                },
                edgeTexture2: {
                    value: null
                },
                patternTexture: {
                    value: null
                },
                edgeStrength: {
                    value: 1
                },
                edgeGlow: {
                    value: 1
                },
                usePatternTexture: {
                    value: 0
                }
            },
            vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
            fragmentShader: "varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform sampler2D edgeTexture1;\t\t\t\tuniform sampler2D edgeTexture2;\t\t\t\tuniform sampler2D patternTexture;\t\t\t\tuniform float edgeStrength;\t\t\t\tuniform float edgeGlow;\t\t\t\tuniform bool usePatternTexture;\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\t\t\t\t\tif(usePatternTexture)\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\t\t\t\t\tgl_FragColor = finalColor;\t\t\t\t}",
            blending: THREE.AdditiveBlending,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
    }
}), THREE.OutlinePass.BlurDirectionX = new THREE.Vector2(1, 0), THREE.OutlinePass.BlurDirectionY = new THREE.Vector2(0, 1);

var AmmoLib = function(Module) {
    function globalEval(x) {
        throw "NO_DYNAMIC_EXECUTION was set, cannot eval";
    }
    function assert(condition, text) {
        condition || abort("Assertion failed: " + text);
    }
    function getCFunc(ident) {
        var func = Module["_" + ident];
        return func || abort("NO_DYNAMIC_EXECUTION was set, cannot eval - ccall/cwrap are not functional"), 
        assert(func, "Cannot call unknown function " + ident + " (perhaps LLVM optimizations or closure removed it?)"), 
        func;
    }
    function setValue(ptr, value, type, noSafe) {
        switch (type = type || "i8", "*" === type.charAt(type.length - 1) && (type = "i32"), 
        type) {
          case "i1":
          case "i8":
            HEAP8[ptr >> 0] = value;
            break;

          case "i16":
            HEAP16[ptr >> 1] = value;
            break;

          case "i32":
            HEAP32[ptr >> 2] = value;
            break;

          case "i64":
            tempI64 = [ value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math_min(+Math_floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], 
            HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
            break;

          case "float":
            HEAPF32[ptr >> 2] = value;
            break;

          case "double":
            HEAPF64[ptr >> 3] = value;
            break;

          default:
            abort("invalid type for setValue: " + type);
        }
    }
    function getValue(ptr, type, noSafe) {
        switch (type = type || "i8", "*" === type.charAt(type.length - 1) && (type = "i32"), 
        type) {
          case "i1":
          case "i8":
            return HEAP8[ptr >> 0];

          case "i16":
            return HEAP16[ptr >> 1];

          case "i32":
          case "i64":
            return HEAP32[ptr >> 2];

          case "float":
            return HEAPF32[ptr >> 2];

          case "double":
            return HEAPF64[ptr >> 3];

          default:
            abort("invalid type for setValue: " + type);
        }
        return null;
    }
    function allocate(slab, types, allocator, ptr) {
        var zeroinit, size;
        "number" == typeof slab ? (zeroinit = !0, size = slab) : (zeroinit = !1, size = slab.length);
        var ret, singleType = "string" == typeof types ? types : null;
        if (ret = allocator == ALLOC_NONE ? ptr : [ _malloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc ][void 0 === allocator ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length)), 
        zeroinit) {
            var stop, ptr = ret;
            for (assert(0 == (3 & ret)), stop = ret + (-4 & size); ptr < stop; ptr += 4) HEAP32[ptr >> 2] = 0;
            for (stop = ret + size; ptr < stop; ) HEAP8[ptr++ >> 0] = 0;
            return ret;
        }
        if ("i8" === singleType) return slab.subarray || slab.slice ? HEAPU8.set(slab, ret) : HEAPU8.set(new Uint8Array(slab), ret), 
        ret;
        for (var type, typeSize, previousType, i = 0; i < size; ) {
            var curr = slab[i];
            "function" == typeof curr && (curr = Runtime.getFunctionIndex(curr)), type = singleType || types[i], 
            0 !== type ? ("i64" == type && (type = "i32"), setValue(ret + i, curr, type), previousType !== type && (typeSize = Runtime.getNativeTypeSize(type), 
            previousType = type), i += typeSize) : i++;
        }
        return ret;
    }
    function getMemory(size) {
        return staticSealed ? void 0 !== _sbrk && !_sbrk.called || !runtimeInitialized ? Runtime.dynamicAlloc(size) : _malloc(size) : Runtime.staticAlloc(size);
    }
    function Pointer_stringify(ptr, length) {
        if (0 === length || !ptr) return "";
        for (var t, hasUtf = 0, i = 0; ;) {
            if (t = HEAPU8[ptr + i >> 0], hasUtf |= t, 0 == t && !length) break;
            if (i++, length && i == length) break;
        }
        length || (length = i);
        var ret = "";
        if (hasUtf < 128) {
            for (var curr; length > 0; ) curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, 1024))), 
            ret = ret ? ret + curr : curr, ptr += 1024, length -= 1024;
            return ret;
        }
        return Module.UTF8ToString(ptr);
    }
    function AsciiToString(ptr) {
        for (var str = ""; ;) {
            var ch = HEAP8[ptr++ >> 0];
            if (!ch) return str;
            str += String.fromCharCode(ch);
        }
    }
    function stringToAscii(str, outPtr) {
        return writeAsciiToMemory(str, outPtr, !1);
    }
    function UTF8ArrayToString(u8Array, idx) {
        for (var u0, u1, u2, u3, u4, u5, str = ""; ;) {
            if (!(u0 = u8Array[idx++])) return str;
            if (128 & u0) if (u1 = 63 & u8Array[idx++], 192 != (224 & u0)) if (u2 = 63 & u8Array[idx++], 
            224 == (240 & u0) ? u0 = (15 & u0) << 12 | u1 << 6 | u2 : (u3 = 63 & u8Array[idx++], 
            240 == (248 & u0) ? u0 = (7 & u0) << 18 | u1 << 12 | u2 << 6 | u3 : (u4 = 63 & u8Array[idx++], 
            248 == (252 & u0) ? u0 = (3 & u0) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4 : (u5 = 63 & u8Array[idx++], 
            u0 = (1 & u0) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5))), u0 < 65536) str += String.fromCharCode(u0); else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | 1023 & ch);
            } else str += String.fromCharCode((31 & u0) << 6 | u1); else str += String.fromCharCode(u0);
        }
    }
    function UTF8ToString(ptr) {
        return UTF8ArrayToString(HEAPU8, ptr);
    }
    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
        if (!(maxBytesToWrite > 0)) return 0;
        for (var startIdx = outIdx, endIdx = outIdx + maxBytesToWrite - 1, i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343 && (u = 65536 + ((1023 & u) << 10) | 1023 & str.charCodeAt(++i)), 
            u <= 127) {
                if (outIdx >= endIdx) break;
                outU8Array[outIdx++] = u;
            } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx) break;
                outU8Array[outIdx++] = 192 | u >> 6, outU8Array[outIdx++] = 128 | 63 & u;
            } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx) break;
                outU8Array[outIdx++] = 224 | u >> 12, outU8Array[outIdx++] = 128 | u >> 6 & 63, 
                outU8Array[outIdx++] = 128 | 63 & u;
            } else if (u <= 2097151) {
                if (outIdx + 3 >= endIdx) break;
                outU8Array[outIdx++] = 240 | u >> 18, outU8Array[outIdx++] = 128 | u >> 12 & 63, 
                outU8Array[outIdx++] = 128 | u >> 6 & 63, outU8Array[outIdx++] = 128 | 63 & u;
            } else if (u <= 67108863) {
                if (outIdx + 4 >= endIdx) break;
                outU8Array[outIdx++] = 248 | u >> 24, outU8Array[outIdx++] = 128 | u >> 18 & 63, 
                outU8Array[outIdx++] = 128 | u >> 12 & 63, outU8Array[outIdx++] = 128 | u >> 6 & 63, 
                outU8Array[outIdx++] = 128 | 63 & u;
            } else {
                if (outIdx + 5 >= endIdx) break;
                outU8Array[outIdx++] = 252 | u >> 30, outU8Array[outIdx++] = 128 | u >> 24 & 63, 
                outU8Array[outIdx++] = 128 | u >> 18 & 63, outU8Array[outIdx++] = 128 | u >> 12 & 63, 
                outU8Array[outIdx++] = 128 | u >> 6 & 63, outU8Array[outIdx++] = 128 | 63 & u;
            }
        }
        return outU8Array[outIdx] = 0, outIdx - startIdx;
    }
    function stringToUTF8(str, outPtr, maxBytesToWrite) {
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }
    function lengthBytesUTF8(str) {
        for (var len = 0, i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            u >= 55296 && u <= 57343 && (u = 65536 + ((1023 & u) << 10) | 1023 & str.charCodeAt(++i)), 
            u <= 127 ? ++len : len += u <= 2047 ? 2 : u <= 65535 ? 3 : u <= 2097151 ? 4 : u <= 67108863 ? 5 : 6;
        }
        return len;
    }
    function UTF16ToString(ptr) {
        for (var i = 0, str = ""; ;) {
            var codeUnit = HEAP16[ptr + 2 * i >> 1];
            if (0 == codeUnit) return str;
            ++i, str += String.fromCharCode(codeUnit);
        }
    }
    function stringToUTF16(str, outPtr, maxBytesToWrite) {
        if (void 0 === maxBytesToWrite && (maxBytesToWrite = 2147483647), maxBytesToWrite < 2) return 0;
        maxBytesToWrite -= 2;
        for (var startPtr = outPtr, numCharsToWrite = maxBytesToWrite < 2 * str.length ? maxBytesToWrite / 2 : str.length, i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            HEAP16[outPtr >> 1] = codeUnit, outPtr += 2;
        }
        return HEAP16[outPtr >> 1] = 0, outPtr - startPtr;
    }
    function lengthBytesUTF16(str) {
        return 2 * str.length;
    }
    function UTF32ToString(ptr) {
        for (var i = 0, str = ""; ;) {
            var utf32 = HEAP32[ptr + 4 * i >> 2];
            if (0 == utf32) return str;
            if (++i, utf32 >= 65536) {
                var ch = utf32 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | 1023 & ch);
            } else str += String.fromCharCode(utf32);
        }
    }
    function stringToUTF32(str, outPtr, maxBytesToWrite) {
        if (void 0 === maxBytesToWrite && (maxBytesToWrite = 2147483647), maxBytesToWrite < 4) return 0;
        for (var startPtr = outPtr, endPtr = startPtr + maxBytesToWrite - 4, i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
                codeUnit = 65536 + ((1023 & codeUnit) << 10) | 1023 & str.charCodeAt(++i);
            }
            if (HEAP32[outPtr >> 2] = codeUnit, (outPtr += 4) + 4 > endPtr) break;
        }
        return HEAP32[outPtr >> 2] = 0, outPtr - startPtr;
    }
    function lengthBytesUTF32(str) {
        for (var len = 0, i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            codeUnit >= 55296 && codeUnit <= 57343 && ++i, len += 4;
        }
        return len;
    }
    function demangle(func) {
        function parseNested() {
            i++, "K" === func[i] && i++;
            for (var parts = []; "E" !== func[i]; ) if ("S" !== func[i]) if ("C" !== func[i]) {
                var size = parseInt(func.substr(i)), pre = size.toString().length;
                if (!size || !pre) {
                    i--;
                    break;
                }
                var curr = func.substr(i + pre, size);
                parts.push(curr), subs.push(curr), i += pre + size;
            } else parts.push(parts[parts.length - 1]), i += 2; else {
                i++;
                var next = func.indexOf("_", i), num = func.substring(i, next) || 0;
                parts.push(subs[num] || "?"), i = next + 1;
            }
            return i++, parts;
        }
        function parse(rawList, limit, allowVoid) {
            limit = limit || 1 / 0;
            var name, ret = "", list = [];
            if ("N" === func[i]) {
                if (name = parseNested().join("::"), 0 === --limit) return rawList ? [ name ] : name;
            } else {
                ("K" === func[i] || first && "L" === func[i]) && i++;
                var size = parseInt(func.substr(i));
                if (size) {
                    var pre = size.toString().length;
                    name = func.substr(i + pre, size), i += pre + size;
                }
            }
            if (first = !1, "I" === func[i]) {
                i++;
                var iList = parse(!0);
                ret += parse(!0, 1, !0)[0] + " " + name + "<" + iList.join(", ") + ">";
            } else ret = name;
            paramLoop: for (;i < func.length && limit-- > 0; ) {
                var c = func[i++];
                if (c in basicTypes) list.push(basicTypes[c]); else switch (c) {
                  case "P":
                    list.push(parse(!0, 1, !0)[0] + "*");
                    break;

                  case "R":
                    list.push(parse(!0, 1, !0)[0] + "&");
                    break;

                  case "L":
                    i++;
                    var end = func.indexOf("E", i), size = end - i;
                    list.push(func.substr(i, size)), i += size + 2;
                    break;

                  case "A":
                    var size = parseInt(func.substr(i));
                    if (i += size.toString().length, "_" !== func[i]) throw "?";
                    i++, list.push(parse(!0, 1, !0)[0] + " [" + size + "]");
                    break;

                  case "E":
                    break paramLoop;

                  default:
                    ret += "?" + c;
                    break paramLoop;
                }
            }
            return allowVoid || 1 !== list.length || "void" !== list[0] || (list = []), rawList ? (ret && list.push(ret + "?"), 
            list) : ret + function() {
                return "(" + list.join(", ") + ")";
            }();
        }
        var hasLibcxxabi = !!Module.___cxa_demangle;
        if (hasLibcxxabi) try {
            var buf = _malloc(func.length);
            writeStringToMemory(func.substr(1), buf);
            var status = _malloc(4), ret = Module.___cxa_demangle(buf, 0, 0, status);
            if (0 === getValue(status, "i32") && ret) return Pointer_stringify(ret);
        } catch (e) {} finally {
            buf && _free(buf), status && _free(status), ret && _free(ret);
        }
        var i = 3, basicTypes = {
            v: "void",
            b: "bool",
            c: "char",
            s: "short",
            i: "int",
            l: "long",
            f: "float",
            d: "double",
            w: "wchar_t",
            a: "signed char",
            h: "unsigned char",
            t: "unsigned short",
            j: "unsigned int",
            m: "unsigned long",
            x: "long long",
            y: "unsigned long long",
            z: "..."
        }, subs = [], first = !0, parsed = func;
        try {
            if ("Object._main" == func || "_main" == func) return "main()";
            if ("number" == typeof func && (func = Pointer_stringify(func)), "_" !== func[0]) return func;
            if ("_" !== func[1]) return func;
            if ("Z" !== func[2]) return func;
            switch (func[3]) {
              case "n":
                return "operator new()";

              case "d":
                return "operator delete()";
            }
            parsed = parse();
        } catch (e) {
            parsed += "?";
        }
        return parsed.indexOf("?") >= 0 && !hasLibcxxabi && Runtime.warnOnce("warning: a problem occurred in builtin C++ name demangling; build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling"), 
        parsed;
    }
    function demangleAll(text) {
        return text.replace(/__Z[\w\d_]+/g, function(x) {
            var y = demangle(x);
            return x === y ? x : x + " [" + y + "]";
        });
    }
    function jsStackTrace() {
        var err = new Error();
        if (!err.stack) {
            try {
                throw new Error(0);
            } catch (e) {
                err = e;
            }
            if (!err.stack) return "(no stack trace available)";
        }
        return err.stack.toString();
    }
    function stackTrace() {
        return demangleAll(jsStackTrace());
    }
    function alignMemoryPage(x) {
        return x % 4096 > 0 && (x += 4096 - x % 4096), x;
    }
    function enlargeMemory() {
        abort("Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.");
    }
    function callRuntimeCallbacks(callbacks) {
        for (;callbacks.length > 0; ) {
            var callback = callbacks.shift();
            if ("function" != typeof callback) {
                var func = callback.func;
                "number" == typeof func ? void 0 === callback.arg ? Runtime.dynCall("v", func) : Runtime.dynCall("vi", func, [ callback.arg ]) : func(void 0 === callback.arg ? null : callback.arg);
            } else callback();
        }
    }
    function preRun() {
        if (Module.preRun) for ("function" == typeof Module.preRun && (Module.preRun = [ Module.preRun ]); Module.preRun.length; ) addOnPreRun(Module.preRun.shift());
        callRuntimeCallbacks(__ATPRERUN__);
    }
    function ensureInitRuntime() {
        runtimeInitialized || (runtimeInitialized = !0, callRuntimeCallbacks(__ATINIT__));
    }
    function preMain() {
        callRuntimeCallbacks(__ATMAIN__);
    }
    function exitRuntime() {
        callRuntimeCallbacks(__ATEXIT__), runtimeExited = !0;
    }
    function postRun() {
        if (Module.postRun) for ("function" == typeof Module.postRun && (Module.postRun = [ Module.postRun ]); Module.postRun.length; ) addOnPostRun(Module.postRun.shift());
        callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
    }
    function addOnInit(cb) {
        __ATINIT__.unshift(cb);
    }
    function addOnPreMain(cb) {
        __ATMAIN__.unshift(cb);
    }
    function addOnExit(cb) {
        __ATEXIT__.unshift(cb);
    }
    function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
    }
    function intArrayFromString(stringy, dontAddNull, length) {
        var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1, u8array = new Array(len), numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
        return dontAddNull && (u8array.length = numBytesWritten), u8array;
    }
    function intArrayToString(array) {
        for (var ret = [], i = 0; i < array.length; i++) {
            var chr = array[i];
            chr > 255 && (chr &= 255), ret.push(String.fromCharCode(chr));
        }
        return ret.join("");
    }
    function writeStringToMemory(string, buffer, dontAddNull) {
        for (var array = intArrayFromString(string, dontAddNull), i = 0; i < array.length; ) {
            var chr = array[i];
            HEAP8[buffer + i >> 0] = chr, i += 1;
        }
    }
    function writeArrayToMemory(array, buffer) {
        for (var i = 0; i < array.length; i++) HEAP8[buffer++ >> 0] = array[i];
    }
    function writeAsciiToMemory(str, buffer, dontAddNull) {
        for (var i = 0; i < str.length; ++i) HEAP8[buffer++ >> 0] = str.charCodeAt(i);
        dontAddNull || (HEAP8[buffer >> 0] = 0);
    }
    function addRunDependency(id) {
        runDependencies++, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies);
    }
    function removeRunDependency(id) {
        if (runDependencies--, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies), 
        0 == runDependencies && (null !== runDependencyWatcher && (clearInterval(runDependencyWatcher), 
        runDependencyWatcher = null), dependenciesFulfilled)) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null, callback();
        }
    }
    function _emscripten_asm_const_8(code, a0, a1, a2, a3, a4, a5, a6, a7) {
        return 0 | ASM_CONSTS[code](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    function __ZN15btCapsuleShapeZC1Eff() {
        Module.printErr("missing function: _ZN15btCapsuleShapeZC1Eff"), abort(-1);
    }
    function __Z22btAlignedAllocInternalji() {
        Module.printErr("missing function: _Z22btAlignedAllocInternalji"), abort(-1);
    }
    function __ZN16btDbvtBroadphaseC1EP22btOverlappingPairCache() {
        Module.printErr("missing function: _ZN16btDbvtBroadphaseC1EP22btOverlappingPairCache"), 
        abort(-1);
    }
    function __ZSt18uncaught_exceptionv() {
        return !!__ZSt18uncaught_exceptionv.uncaught_exception;
    }
    function ___resumeException(ptr) {
        throw EXCEPTIONS.last || (EXCEPTIONS.last = ptr), EXCEPTIONS.clearRef(EXCEPTIONS.deAdjust(ptr)), 
        ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";
    }
    function ___cxa_find_matching_catch() {
        var thrown = EXCEPTIONS.last;
        if (!thrown) return 0 | (asm.setTempRet0(0), 0);
        var info = EXCEPTIONS.infos[thrown], throwntype = info.type;
        if (!throwntype) return 0 | (asm.setTempRet0(0), thrown);
        var typeArray = Array.prototype.slice.call(arguments);
        Module.___cxa_is_pointer_type(throwntype);
        ___cxa_find_matching_catch.buffer || (___cxa_find_matching_catch.buffer = _malloc(4)), 
        HEAP32[___cxa_find_matching_catch.buffer >> 2] = thrown, thrown = ___cxa_find_matching_catch.buffer;
        for (var i = 0; i < typeArray.length; i++) if (typeArray[i] && Module.___cxa_can_catch(typeArray[i], throwntype, thrown)) return thrown = HEAP32[thrown >> 2], 
        info.adjusted = thrown, 0 | (asm.setTempRet0(typeArray[i]), thrown);
        return thrown = HEAP32[thrown >> 2], 0 | (asm.setTempRet0(throwntype), thrown);
    }
    function ___cxa_throw(ptr, type, destructor) {
        throw EXCEPTIONS.infos[ptr] = {
            ptr: ptr,
            adjusted: ptr,
            type: type,
            destructor: destructor,
            refcount: 0
        }, EXCEPTIONS.last = ptr, "uncaught_exception" in __ZSt18uncaught_exceptionv ? __ZSt18uncaught_exceptionv.uncaught_exception++ : __ZSt18uncaught_exceptionv.uncaught_exception = 1, 
        ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";
    }
    function __ZN30btKinematicCharacterControllerC1EP24btPairCachingGhostObjectP13btConvexShapefi() {
        Module.printErr("missing function: _ZN30btKinematicCharacterControllerC1EP24btPairCachingGhostObjectP13btConvexShapefi"), 
        abort(-1);
    }
    function __ZN16btCylinderShapeXC1ERK9btVector3() {
        Module.printErr("missing function: _ZN16btCylinderShapeXC1ERK9btVector3"), abort(-1);
    }
    function __ZN15btCompoundShape13addChildShapeERK11btTransformP16btCollisionShape() {
        Module.printErr("missing function: _ZN15btCompoundShape13addChildShapeERK11btTransformP16btCollisionShape"), 
        abort(-1);
    }
    function __ZN21btConeTwistConstraintC1ER11btRigidBodyRK11btTransform() {
        Module.printErr("missing function: _ZN21btConeTwistConstraintC1ER11btRigidBodyRK11btTransform"), 
        abort(-1);
    }
    function __ZN30btKinematicCharacterController14getGhostObjectEv() {
        Module.printErr("missing function: _ZN30btKinematicCharacterController14getGhostObjectEv"), 
        abort(-1);
    }
    function __ZN31btDefaultCollisionConfigurationC1ERK34btDefaultCollisionConstructionInfo() {
        Module.printErr("missing function: _ZN31btDefaultCollisionConfigurationC1ERK34btDefaultCollisionConstructionInfo"), 
        abort(-1);
    }
    function __ZN29btGeneric6DofSpringConstraint10setDampingEif() {
        Module.printErr("missing function: _ZN29btGeneric6DofSpringConstraint10setDampingEif"), 
        abort(-1);
    }
    function __ZN17btHingeConstraintC1ER11btRigidBodyRK11btTransformb() {
        Module.printErr("missing function: _ZN17btHingeConstraintC1ER11btRigidBodyRK11btTransformb"), 
        abort(-1);
    }
    function __ZN11btRigidBody10setDampingEff() {
        Module.printErr("missing function: _ZN11btRigidBody10setDampingEff"), abort(-1);
    }
    function __ZN16btCollisionWorld15contactPairTestEP17btCollisionObjectS1_RNS_21ContactResultCallbackE() {
        Module.printErr("missing function: _ZN16btCollisionWorld15contactPairTestEP17btCollisionObjectS1_RNS_21ContactResultCallbackE"), 
        abort(-1);
    }
    function _pthread_key_create(key, destructor) {
        return 0 == key ? ERRNO_CODES.EINVAL : (HEAP32[key >> 2] = PTHREAD_SPECIFIC_NEXT_KEY, 
        PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0, PTHREAD_SPECIFIC_NEXT_KEY++, 0);
    }
    function __ZN17btConvexHullShape8addPointERK9btVector3b() {
        Module.printErr("missing function: _ZN17btConvexHullShape8addPointERK9btVector3b"), 
        abort(-1);
    }
    function __ZN30btKinematicCharacterController16setMaxJumpHeightEf() {
        Module.printErr("missing function: _ZN30btKinematicCharacterController16setMaxJumpHeightEf"), 
        abort(-1);
    }
    function __ZNK17btCollisionObject8activateEb() {
        Module.printErr("missing function: _ZNK17btCollisionObject8activateEb"), abort(-1);
    }
    function __ZN16btRaycastVehicle16setSteeringValueEfi() {
        Module.printErr("missing function: _ZN16btRaycastVehicle16setSteeringValueEfi"), 
        abort(-1);
    }
    function __ZNK30btKinematicCharacterController10getGravityEv() {
        Module.printErr("missing function: _ZNK30btKinematicCharacterController10getGravityEv"), 
        abort(-1);
    }
    function __ZN21btConeTwistConstraint31setMotorTargetInConstraintSpaceERK12btQuaternion() {
        Module.printErr("missing function: _ZN21btConeTwistConstraint31setMotorTargetInConstraintSpaceERK12btQuaternion"), 
        abort(-1);
    }
    function __ZN30btKinematicCharacterController12setFallSpeedEf() {
        Module.printErr("missing function: _ZN30btKinematicCharacterController12setFallSpeedEf"), 
        abort(-1);
    }
    function __ZN29btGeneric6DofSpringConstraint12setStiffnessEif() {
        Module.printErr("missing function: _ZN29btGeneric6DofSpringConstraint12setStiffnessEif"), 
        abort(-1);
    }
    function _pthread_cleanup_push(routine, arg) {
        __ATEXIT__.push(function() {
            Runtime.dynCall("vi", routine, [ arg ]);
        }), _pthread_cleanup_push.level = __ATEXIT__.length;
    }
    function __ZN23btGeneric6DofConstraintC1ER11btRigidBodyRK11btTransformb() {
        Module.printErr("missing function: _ZN23btGeneric6DofConstraintC1ER11btRigidBodyRK11btTransformb"), 
        abort(-1);
    }
    function __ZNK17btCollisionObject18setActivationStateEi() {
        Module.printErr("missing function: _ZNK17btCollisionObject18setActivationStateEi"), 
        abort(-1);
    }
    function __Z21btAlignedFreeInternalPv() {
        Module.printErr("missing function: _Z21btAlignedFreeInternalPv"), abort(-1);
    }
    function __ZN14btTriangleMeshC1Ebb() {
        Module.printErr("missing function: _ZN14btTriangleMeshC1Ebb"), abort(-1);
    }
    function __ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b() {
        Module.printErr("missing function: _ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"), 
        abort(-1);
    }
    function __ZN23btDiscreteDynamicsWorldC1EP12btDispatcherP21btBroadphaseInterfaceP18btConstraintSolverP24btCollisionConfiguration() {
        Module.printErr("missing function: _ZN23btDiscreteDynamicsWorldC1EP12btDispatcherP21btBroadphaseInterfaceP18btConstraintSolverP24btCollisionConfiguration"), 
        abort(-1);
    }
    function __ZN11btRigidBody24setCenterOfMassTransformERK11btTransform() {
        Module.printErr("missing function: _ZN11btRigidBody24setCenterOfMassTransformERK11btTransform"), 
        abort(-1);
    }
    function _emscripten_memcpy_big(dest, src, num) {
        return HEAPU8.set(HEAPU8.subarray(src, src + num), dest), dest;
    }
    function __ZN21btConvexInternalShapeC2Ev() {
        Module.printErr("missing function: _ZN21btConvexInternalShapeC2Ev"), abort(-1);
    }
    function __ZN14btAngularLimit3setEfffff() {
        Module.printErr("missing function: _ZN14btAngularLimit3setEfffff"), abort(-1);
    }
    function _sbrk(bytes) {
        var self = _sbrk;
        self.called || (DYNAMICTOP = alignMemoryPage(DYNAMICTOP), self.called = !0, assert(Runtime.dynamicAlloc), 
        self.alloc = Runtime.dynamicAlloc, Runtime.dynamicAlloc = function() {
            abort("cannot dynamically allocate, sbrk now has control");
        });
        var ret = DYNAMICTOP;
        if (0 != bytes) {
            if (!self.alloc(bytes)) return -1 >>> 0;
        }
        return ret;
    }
    function __ZN12btConeShapeXC1Eff() {
        Module.printErr("missing function: _ZN12btConeShapeXC1Eff"), abort(-1);
    }
    function __ZN14btCapsuleShapeC1Eff() {
        Module.printErr("missing function: _ZN14btCapsuleShapeC1Eff"), abort(-1);
    }
    function __ZN23btPoint2PointConstraintC1ER11btRigidBodyS1_RK9btVector3S4_() {
        Module.printErr("missing function: _ZN23btPoint2PointConstraintC1ER11btRigidBodyS1_RK9btVector3S4_"), 
        abort(-1);
    }
    function __ZN15btCompoundShapeC1Ebi() {
        Module.printErr("missing function: _ZN15btCompoundShapeC1Ebi"), abort(-1);
    }
    function __ZN15btCompoundShape23removeChildShapeByIndexEi() {
        Module.printErr("missing function: _ZN15btCompoundShape23removeChildShapeByIndexEi"), 
        abort(-1);
    }
    function ___cxa_guard_release() {}
    function __ZN30btKinematicCharacterController12setJumpSpeedEf() {
        Module.printErr("missing function: _ZN30btKinematicCharacterController12setJumpSpeedEf"), 
        abort(-1);
    }
    function __ZN30btKinematicCharacterController11setMaxSlopeEf() {
        Module.printErr("missing function: _ZN30btKinematicCharacterController11setMaxSlopeEf"), 
        abort(-1);
    }
    function __ZN29btGeneric6DofSpringConstraint12enableSpringEib() {
        Module.printErr("missing function: _ZN29btGeneric6DofSpringConstraint12enableSpringEib"), 
        abort(-1);
    }
    function __ZN14btTriangleMesh11addTriangleERK9btVector3S2_S2_b() {
        Module.printErr("missing function: _ZN14btTriangleMesh11addTriangleERK9btVector3S2_S2_b"), 
        abort(-1);
    }
    function ___setErrNo(value) {
        return Module.___errno_location && (HEAP32[Module.___errno_location() >> 2] = value), 
        value;
    }
    function _sysconf(name) {
        switch (name) {
          case 30:
            return PAGE_SIZE;

          case 85:
            return totalMemory / PAGE_SIZE;

          case 132:
          case 133:
          case 12:
          case 137:
          case 138:
          case 15:
          case 235:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 149:
          case 13:
          case 10:
          case 236:
          case 153:
          case 9:
          case 21:
          case 22:
          case 159:
          case 154:
          case 14:
          case 77:
          case 78:
          case 139:
          case 80:
          case 81:
          case 82:
          case 68:
          case 67:
          case 164:
          case 11:
          case 29:
          case 47:
          case 48:
          case 95:
          case 52:
          case 51:
          case 46:
            return 200809;

          case 79:
            return 0;

          case 27:
          case 246:
          case 127:
          case 128:
          case 23:
          case 24:
          case 160:
          case 161:
          case 181:
          case 182:
          case 242:
          case 183:
          case 184:
          case 243:
          case 244:
          case 245:
          case 165:
          case 178:
          case 179:
          case 49:
          case 50:
          case 168:
          case 169:
          case 175:
          case 170:
          case 171:
          case 172:
          case 97:
          case 76:
          case 32:
          case 173:
          case 35:
            return -1;

          case 176:
          case 177:
          case 7:
          case 155:
          case 8:
          case 157:
          case 125:
          case 126:
          case 92:
          case 93:
          case 129:
          case 130:
          case 131:
          case 94:
          case 91:
            return 1;

          case 74:
          case 60:
          case 69:
          case 70:
          case 4:
            return 1024;

          case 31:
          case 42:
          case 72:
            return 32;

          case 87:
          case 26:
          case 33:
            return 2147483647;

          case 34:
          case 1:
            return 47839;

          case 38:
          case 36:
            return 99;

          case 43:
          case 37:
            return 2048;

          case 0:
            return 2097152;

          case 3:
            return 65536;

          case 28:
            return 32768;

          case 44:
            return 32767;

          case 75:
            return 16384;

          case 39:
            return 1e3;

          case 89:
            return 700;

          case 71:
            return 256;

          case 40:
            return 255;

          case 2:
            return 100;

          case 180:
            return 64;

          case 25:
            return 20;

          case 5:
            return 16;

          case 6:
            return 6;

          case 73:
            return 4;

          case 84:
            return "object" == typeof navigator ? navigator.hardwareConcurrency || 1 : 1;
        }
        return ___setErrNo(ERRNO_CODES.EINVAL), -1;
    }
    function __ZN21btCollisionDispatcherC1EP24btCollisionConfiguration() {
        Module.printErr("missing function: _ZN21btCollisionDispatcherC1EP24btCollisionConfiguration"), 
        abort(-1);
    }
    function __ZN18btSliderConstraintC1ER11btRigidBodyRK11btTransformb() {
        Module.printErr("missing function: _ZN18btSliderConstraintC1ER11btRigidBodyRK11btTransformb"), 
        abort(-1);
    }
    function __ZN23btPoint2PointConstraintC1ER11btRigidBodyRK9btVector3() {
        Module.printErr("missing function: _ZN23btPoint2PointConstraintC1ER11btRigidBodyRK9btVector3"), 
        abort(-1);
    }
    function _abort() {
        Module.abort();
    }
    function __ZN21btConeTwistConstraintC1ER11btRigidBodyS1_RK11btTransformS4_() {
        Module.printErr("missing function: _ZN21btConeTwistConstraintC1ER11btRigidBodyS1_RK11btTransformS4_"), 
        abort(-1);
    }
    function _pthread_once(ptr, func) {
        _pthread_once.seen || (_pthread_once.seen = {}), ptr in _pthread_once.seen || (Runtime.dynCall("v", func), 
        _pthread_once.seen[ptr] = 1);
    }
    function __ZN16btRaycastVehicleC1ERKNS_15btVehicleTuningEP11btRigidBodyP18btVehicleRaycaster() {
        Module.printErr("missing function: _ZN16btRaycastVehicleC1ERKNS_15btVehicleTuningEP11btRigidBodyP18btVehicleRaycaster"), 
        abort(-1);
    }
    function __ZN15btCylinderShapeC1ERK9btVector3() {
        Module.printErr("missing function: _ZN15btCylinderShapeC1ERK9btVector3"), abort(-1);
    }
    function __ZN21btConeTwistConstraint14setMotorTargetERK12btQuaternion() {
        Module.printErr("missing function: _ZN21btConeTwistConstraint14setMotorTargetERK12btQuaternion"), 
        abort(-1);
    }
    function __ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyRK11btTransformb() {
        Module.printErr("missing function: _ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyRK11btTransformb"), 
        abort(-1);
    }
    function _pthread_getspecific(key) {
        return PTHREAD_SPECIFIC[key] || 0;
    }
    function __ZN16btRaycastVehicle12getWheelInfoEi() {
        Module.printErr("missing function: _ZN16btRaycastVehicle12getWheelInfoEi"), abort(-1);
    }
    function __ZNK16btRaycastVehicle19getWheelTransformWSEi() {
        Module.printErr("missing function: _ZNK16btRaycastVehicle19getWheelTransformWSEi"), 
        abort(-1);
    }
    function __ZN35btSequentialImpulseConstraintSolverC1Ev() {
        Module.printErr("missing function: _ZN35btSequentialImpulseConstraintSolverC1Ev"), 
        abort(-1);
    }
    function __ZN17btConvexHullShapeC1EPKfii() {
        Module.printErr("missing function: _ZN17btConvexHullShapeC1EPKfii"), abort(-1);
    }
    function __ZN18btSliderConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b() {
        Module.printErr("missing function: _ZN18btSliderConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"), 
        abort(-1);
    }
    function __ZN12btAxisSweep3C1ERK9btVector3S2_tP22btOverlappingPairCacheb() {
        Module.printErr("missing function: _ZN12btAxisSweep3C1ERK9btVector3S2_tP22btOverlappingPairCacheb"), 
        abort(-1);
    }
    function _pthread_setspecific(key, value) {
        return key in PTHREAD_SPECIFIC ? (PTHREAD_SPECIFIC[key] = value, 0) : ERRNO_CODES.EINVAL;
    }
    function __ZN24btPairCachingGhostObjectC1Ev() {
        Module.printErr("missing function: _ZN24btPairCachingGhostObjectC1Ev"), abort(-1);
    }
    function _malloc(bytes) {
        return Runtime.dynamicAlloc(bytes + 8) + 8 & 4294967288;
    }
    function ___cxa_allocate_exception(size) {
        return _malloc(size);
    }
    function __ZN11btRigidBodyC1ERKNS_27btRigidBodyConstructionInfoE() {
        Module.printErr("missing function: _ZN11btRigidBodyC1ERKNS_27btRigidBodyConstructionInfoE"), 
        abort(-1);
    }
    function __ZN13btGhostObjectC1Ev() {
        Module.printErr("missing function: _ZN13btGhostObjectC1Ev"), abort(-1);
    }
    function __ZN16btRaycastVehicle16applyEngineForceEfi() {
        Module.printErr("missing function: _ZN16btRaycastVehicle16applyEngineForceEfi"), 
        abort(-1);
    }
    function __ZN11btRigidBody12setMassPropsEfRK9btVector3() {
        Module.printErr("missing function: _ZN11btRigidBody12setMassPropsEfRK9btVector3"), 
        abort(-1);
    }
    function __ZN20btPersistentManifoldC1Ev() {
        Module.printErr("missing function: _ZN20btPersistentManifoldC1Ev"), abort(-1);
    }
    function _time(ptr) {
        var ret = Date.now() / 1e3 | 0;
        return ptr && (HEAP32[ptr >> 2] = ret), ret;
    }
    function __ZN10btBoxShapeC1ERK9btVector3() {
        Module.printErr("missing function: _ZN10btBoxShapeC1ERK9btVector3"), abort(-1);
    }
    function ___cxa_guard_acquire(variable) {
        return HEAP8[variable >> 0] ? 0 : (HEAP8[variable >> 0] = 1, 1);
    }
    function __ZN16btRaycastVehicle8setBrakeEfi() {
        Module.printErr("missing function: _ZN16btRaycastVehicle8setBrakeEfi"), abort(-1);
    }
    function __ZN22btBvhTriangleMeshShapeC1EP23btStridingMeshInterfacebb() {
        Module.printErr("missing function: _ZN22btBvhTriangleMeshShapeC1EP23btStridingMeshInterfacebb"), 
        abort(-1);
    }
    function ___cxa_begin_catch(ptr) {
        return __ZSt18uncaught_exceptionv.uncaught_exception--, EXCEPTIONS.caught.push(ptr), 
        EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr)), ptr;
    }
    function __ZN18btStaticPlaneShapeC1ERK9btVector3f() {
        Module.printErr("missing function: _ZN18btStaticPlaneShapeC1ERK9btVector3f"), abort(-1);
    }
    function __ZNK17btCollisionObject20forceActivationStateEi() {
        Module.printErr("missing function: _ZNK17btCollisionObject20forceActivationStateEi"), 
        abort(-1);
    }
    function ___syscall6(which, varargs) {
        SYSCALLS.varargs = varargs;
        try {
            var stream = SYSCALLS.getStreamFromFD();
            return FS.close(stream), 0;
        } catch (e) {
            return "undefined" != typeof FS && e instanceof FS.ErrnoError || abort(e), -e.errno;
        }
    }
    function __ZN16btRaycastVehicle8addWheelERK9btVector3S2_S2_ffRKNS_15btVehicleTuningEb() {
        Module.printErr("missing function: _ZN16btRaycastVehicle8addWheelERK9btVector3S2_S2_ffRKNS_15btVehicleTuningEb"), 
        abort(-1);
    }
    function __ZNK16btCollisionWorld15convexSweepTestEPK13btConvexShapeRK11btTransformS5_RNS_20ConvexResultCallbackEf() {
        Module.printErr("missing function: _ZNK16btCollisionWorld15convexSweepTestEPK13btConvexShapeRK11btTransformS5_RNS_20ConvexResultCallbackEf"), 
        abort(-1);
    }
    function __ZN11btConeShapeC1Eff() {
        Module.printErr("missing function: _ZN11btConeShapeC1Eff"), abort(-1);
    }
    function __ZN11btRigidBody19updateInertiaTensorEv() {
        Module.printErr("missing function: _ZN11btRigidBody19updateInertiaTensorEv"), abort(-1);
    }
    function __ZN23btGeneric6DofConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b() {
        Module.printErr("missing function: _ZN23btGeneric6DofConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"), 
        abort(-1);
    }
    function _pthread_cleanup_pop() {
        assert(_pthread_cleanup_push.level == __ATEXIT__.length, "cannot pop if something else added meanwhile!"), 
        __ATEXIT__.pop(), _pthread_cleanup_push.level = __ATEXIT__.length;
    }
    function __ZN12btConeShapeZC1Eff() {
        Module.printErr("missing function: _ZN12btConeShapeZC1Eff"), abort(-1);
    }
    function __ZNK30btKinematicCharacterController11getMaxSlopeEv() {
        Module.printErr("missing function: _ZNK30btKinematicCharacterController11getMaxSlopeEv"), 
        abort(-1);
    }
    function __ZN17btHingeConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_S4_b() {
        Module.printErr("missing function: _ZN17btHingeConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_S4_b"), 
        abort(-1);
    }
    function __ZN16btRaycastVehicle20updateWheelTransformEib() {
        Module.printErr("missing function: _ZN16btRaycastVehicle20updateWheelTransformEib"), 
        abort(-1);
    }
    function __ZN17btHingeConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b() {
        Module.printErr("missing function: _ZN17btHingeConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b"), 
        abort(-1);
    }
    function __ZN25btConvexTriangleMeshShapeC1EP23btStridingMeshInterfaceb() {
        Module.printErr("missing function: _ZN25btConvexTriangleMeshShapeC1EP23btStridingMeshInterfaceb"), 
        abort(-1);
    }
    function _pthread_self() {
        return 0;
    }
    function ___syscall140(which, varargs) {
        SYSCALLS.varargs = varargs;
        try {
            var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get(), offset = offset_low;
            return assert(0 === offset_high), FS.llseek(stream, offset, whence), HEAP32[result >> 2] = stream.position, 
            stream.getdents && 0 === offset && 0 === whence && (stream.getdents = null), 0;
        } catch (e) {
            return "undefined" != typeof FS && e instanceof FS.ErrnoError || abort(e), -e.errno;
        }
    }
    function __ZN15btCapsuleShapeXC1Eff() {
        Module.printErr("missing function: _ZN15btCapsuleShapeXC1Eff"), abort(-1);
    }
    function ___syscall146(which, varargs) {
        SYSCALLS.varargs = varargs;
        try {
            var iov = (SYSCALLS.get(), SYSCALLS.get()), iovcnt = SYSCALLS.get(), ret = 0;
            ___syscall146.buffer || (___syscall146.buffer = []);
            for (var buffer = ___syscall146.buffer, i = 0; i < iovcnt; i++) {
                for (var ptr = HEAP32[iov + 8 * i >> 2], len = HEAP32[iov + (8 * i + 4) >> 2], j = 0; j < len; j++) {
                    var curr = HEAPU8[ptr + j];
                    0 === curr || 10 === curr ? (Module.print(UTF8ArrayToString(buffer, 0)), buffer.length = 0) : buffer.push(curr);
                }
                ret += len;
            }
            return ret;
        } catch (e) {
            return "undefined" != typeof FS && e instanceof FS.ErrnoError || abort(e), -e.errno;
        }
    }
    function __ZN16btCylinderShapeZC1ERK9btVector3() {
        Module.printErr("missing function: _ZN16btCylinderShapeZC1ERK9btVector3"), abort(-1);
    }
    function __ZN30btKinematicCharacterController10setGravityEf() {
        Module.printErr("missing function: _ZN30btKinematicCharacterController10setGravityEf"), 
        abort(-1);
    }
    function __ZTV13btSphereShape() {
        Module.printErr("missing function: _ZTV13btSphereShape"), abort(-1);
    }
    function __ZTV25btDefaultVehicleRaycaster() {
        Module.printErr("missing function: _ZTV25btDefaultVehicleRaycaster"), abort(-1);
    }
    function invoke_vi(index, a1) {
        try {
            Module.dynCall_vi(index, a1);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_iiii(index, a1, a2, a3) {
        try {
            return Module.dynCall_iiii(index, a1, a2, a3);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_vidi(index, a1, a2, a3) {
        try {
            Module.dynCall_vidi(index, a1, a2, a3);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
        try {
            Module.dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_viiiii(index, a1, a2, a3, a4, a5) {
        try {
            Module.dynCall_viiiii(index, a1, a2, a3, a4, a5);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_diiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
        try {
            return Module.dynCall_diiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_vid(index, a1, a2) {
        try {
            Module.dynCall_vid(index, a1, a2);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_di(index, a1) {
        try {
            return Module.dynCall_di(index, a1);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_iidid(index, a1, a2, a3, a4) {
        try {
            return Module.dynCall_iidid(index, a1, a2, a3, a4);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_vii(index, a1, a2) {
        try {
            Module.dynCall_vii(index, a1, a2);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_ii(index, a1) {
        try {
            return Module.dynCall_ii(index, a1);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_viii(index, a1, a2, a3) {
        try {
            Module.dynCall_viii(index, a1, a2, a3);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_v(index) {
        try {
            Module.dynCall_v(index);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_viid(index, a1, a2, a3) {
        try {
            Module.dynCall_viid(index, a1, a2, a3);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_iiiii(index, a1, a2, a3, a4) {
        try {
            return Module.dynCall_iiiii(index, a1, a2, a3, a4);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_viiii(index, a1, a2, a3, a4) {
        try {
            Module.dynCall_viiii(index, a1, a2, a3, a4);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_iii(index, a1, a2) {
        try {
            return Module.dynCall_iii(index, a1, a2);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function invoke_diii(index, a1, a2, a3) {
        try {
            return Module.dynCall_diii(index, a1, a2, a3);
        } catch (e) {
            if ("number" != typeof e && "longjmp" !== e) throw e;
            asm.setThrew(1, 0);
        }
    }
    function ExitStatus(status) {
        this.name = "ExitStatus", this.message = "Program terminated with exit(" + status + ")", 
        this.status = status;
    }
    function run(args) {
        function doRun() {
            Module.calledRun || (Module.calledRun = !0, ABORT || (ensureInitRuntime(), preMain(), 
            Module.onRuntimeInitialized && Module.onRuntimeInitialized(), Module._main && shouldRunNow && Module.callMain(args), 
            postRun()));
        }
        args = args || Module.arguments, null === preloadStartTime && (preloadStartTime = Date.now()), 
        runDependencies > 0 || (preRun(), runDependencies > 0 || Module.calledRun || (Module.setStatus ? (Module.setStatus("Running..."), 
        setTimeout(function() {
            setTimeout(function() {
                Module.setStatus("");
            }, 1), doRun();
        }, 1)) : doRun()));
    }
    function exit(status, implicit) {
        if (!implicit || !Module.noExitRuntime) throw Module.noExitRuntime || (ABORT = !0, 
        EXITSTATUS = status, STACKTOP = initialStackTop, exitRuntime(), Module.onExit && Module.onExit(status)), 
        ENVIRONMENT_IS_NODE ? (process.stdout.once("drain", function() {
            process.exit(status);
        }), console.log(" "), setTimeout(function() {
            process.exit(status);
        }, 500)) : ENVIRONMENT_IS_SHELL && "function" == typeof quit && quit(status), new ExitStatus(status);
    }
    function abort(what) {
        void 0 !== what ? (Module.print(what), Module.printErr(what), what = JSON.stringify(what)) : what = "", 
        ABORT = !0, EXITSTATUS = 1;
        var output = "abort(" + what + ") at " + stackTrace() + "\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";
        throw abortDecorators && abortDecorators.forEach(function(decorator) {
            output = decorator(output, what);
        }), output;
    }
    function WrapperObject() {}
    function getCache(__class__) {
        return (__class__ || WrapperObject).__cache__;
    }
    function wrapPointer(ptr, __class__) {
        var cache = getCache(__class__), ret = cache[ptr];
        return ret || (ret = Object.create((__class__ || WrapperObject).prototype), ret.ptr = ptr, 
        cache[ptr] = ret);
    }
    function castObject(obj, __class__) {
        return wrapPointer(obj.ptr, __class__);
    }
    function destroy(obj) {
        if (!obj.__destroy__) throw "Error: Cannot destroy object. (Did you create it yourself?)";
        obj.__destroy__(), delete getCache(obj.__class__)[obj.ptr];
    }
    function compare(obj1, obj2) {
        return obj1.ptr === obj2.ptr;
    }
    function getPointer(obj) {
        return obj.ptr;
    }
    function getClass(obj) {
        return obj.__class__;
    }
    function btCollisionShape() {
        throw "cannot construct a btCollisionShape, no constructor in IDL";
    }
    function btCollisionObject() {
        throw "cannot construct a btCollisionObject, no constructor in IDL";
    }
    function btConcaveShape() {
        throw "cannot construct a btConcaveShape, no constructor in IDL";
    }
    function btCollisionWorld() {
        throw "cannot construct a btCollisionWorld, no constructor in IDL";
    }
    function btTypedConstraint() {
        throw "cannot construct a btTypedConstraint, no constructor in IDL";
    }
    function btCapsuleShape(arg0, arg1) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        this.ptr = _emscripten_bind_btCapsuleShape_btCapsuleShape_2(arg0, arg1), getCache(btCapsuleShape)[this.ptr] = this;
    }
    function btGeneric6DofConstraint(arg0, arg1, arg2, arg3, arg4) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), void 0 === arg3 ? (this.ptr = _emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_3(arg0, arg1, arg2), 
        void (getCache(btGeneric6DofConstraint)[this.ptr] = this)) : void 0 === arg4 ? (this.ptr = _emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_4(arg0, arg1, arg2, arg3), 
        void (getCache(btGeneric6DofConstraint)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_5(arg0, arg1, arg2, arg3, arg4), 
        void (getCache(btGeneric6DofConstraint)[this.ptr] = this));
    }
    function btStridingMeshInterface() {
        throw "cannot construct a btStridingMeshInterface, no constructor in IDL";
    }
    function ConvexResultCallback() {
        throw "cannot construct a ConvexResultCallback, no constructor in IDL";
    }
    function btMotionState() {
        throw "cannot construct a btMotionState, no constructor in IDL";
    }
    function btConeShape(arg0, arg1) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        this.ptr = _emscripten_bind_btConeShape_btConeShape_2(arg0, arg1), getCache(btConeShape)[this.ptr] = this;
    }
    function btConvexShape() {
        throw "cannot construct a btConvexShape, no constructor in IDL";
    }
    function ContactResultCallback() {
        throw "cannot construct a ContactResultCallback, no constructor in IDL";
    }
    function btTriangleMeshShape() {
        throw "cannot construct a btTriangleMeshShape, no constructor in IDL";
    }
    function btDispatcher() {
        throw "cannot construct a btDispatcher, no constructor in IDL";
    }
    function btDynamicsWorld() {
        throw "cannot construct a btDynamicsWorld, no constructor in IDL";
    }
    function RayResultCallback() {
        throw "cannot construct a RayResultCallback, no constructor in IDL";
    }
    function btVector3(arg0, arg1, arg2) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), void 0 === arg0 ? (this.ptr = _emscripten_bind_btVector3_btVector3_0(), 
        void (getCache(btVector3)[this.ptr] = this)) : void 0 === arg1 ? (this.ptr = _emscripten_bind_btVector3_btVector3_1(arg0), 
        void (getCache(btVector3)[this.ptr] = this)) : void 0 === arg2 ? (this.ptr = _emscripten_bind_btVector3_btVector3_2(arg0, arg1), 
        void (getCache(btVector3)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btVector3_btVector3_3(arg0, arg1, arg2), 
        void (getCache(btVector3)[this.ptr] = this));
    }
    function btVehicleRaycaster() {
        throw "cannot construct a btVehicleRaycaster, no constructor in IDL";
    }
    function btGhostObject() {
        this.ptr = _emscripten_bind_btGhostObject_btGhostObject_0(), getCache(btGhostObject)[this.ptr] = this;
    }
    function btQuadWord() {
        throw "cannot construct a btQuadWord, no constructor in IDL";
    }
    function btCylinderShape(arg0) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), this.ptr = _emscripten_bind_btCylinderShape_btCylinderShape_1(arg0), 
        getCache(btCylinderShape)[this.ptr] = this;
    }
    function btActionInterface() {
        throw "cannot construct a btActionInterface, no constructor in IDL";
    }
    function btMatrix3x3() {
        throw "cannot construct a btMatrix3x3, no constructor in IDL";
    }
    function ConcreteContactResultCallback() {
        this.ptr = _emscripten_bind_ConcreteContactResultCallback_ConcreteContactResultCallback_0(), 
        getCache(ConcreteContactResultCallback)[this.ptr] = this;
    }
    function btBvhTriangleMeshShape(arg0, arg1, arg2) {
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), void 0 === arg2) return this.ptr = _emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_2(arg0, arg1), 
        void (getCache(btBvhTriangleMeshShape)[this.ptr] = this);
        this.ptr = _emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_3(arg0, arg1, arg2), 
        getCache(btBvhTriangleMeshShape)[this.ptr] = this;
    }
    function btDbvtBroadphase() {
        this.ptr = _emscripten_bind_btDbvtBroadphase_btDbvtBroadphase_0(), getCache(btDbvtBroadphase)[this.ptr] = this;
    }
    function VoidPtr() {
        throw "cannot construct a VoidPtr, no constructor in IDL";
    }
    function btSequentialImpulseConstraintSolver() {
        this.ptr = _emscripten_bind_btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver_0(), 
        getCache(btSequentialImpulseConstraintSolver)[this.ptr] = this;
    }
    function btDispatcherInfo() {
        throw "cannot construct a btDispatcherInfo, no constructor in IDL";
    }
    function btCollisionConfiguration() {
        throw "cannot construct a btCollisionConfiguration, no constructor in IDL";
    }
    function btAxisSweep3(arg0, arg1, arg2, arg3, arg4) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), void 0 === arg2 ? (this.ptr = _emscripten_bind_btAxisSweep3_btAxisSweep3_2(arg0, arg1), 
        void (getCache(btAxisSweep3)[this.ptr] = this)) : void 0 === arg3 ? (this.ptr = _emscripten_bind_btAxisSweep3_btAxisSweep3_3(arg0, arg1, arg2), 
        void (getCache(btAxisSweep3)[this.ptr] = this)) : void 0 === arg4 ? (this.ptr = _emscripten_bind_btAxisSweep3_btAxisSweep3_4(arg0, arg1, arg2, arg3), 
        void (getCache(btAxisSweep3)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btAxisSweep3_btAxisSweep3_5(arg0, arg1, arg2, arg3, arg4), 
        void (getCache(btAxisSweep3)[this.ptr] = this));
    }
    function btPairCachingGhostObject() {
        this.ptr = _emscripten_bind_btPairCachingGhostObject_btPairCachingGhostObject_0(), 
        getCache(btPairCachingGhostObject)[this.ptr] = this;
    }
    function btRigidBodyConstructionInfo(arg0, arg1, arg2, arg3) {
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        void 0 === arg3) return this.ptr = _emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_3(arg0, arg1, arg2), 
        void (getCache(btRigidBodyConstructionInfo)[this.ptr] = this);
        this.ptr = _emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_4(arg0, arg1, arg2, arg3), 
        getCache(btRigidBodyConstructionInfo)[this.ptr] = this;
    }
    function btManifoldPoint() {
        throw "cannot construct a btManifoldPoint, no constructor in IDL";
    }
    function btBroadphaseInterface() {
        throw "cannot construct a btBroadphaseInterface, no constructor in IDL";
    }
    function btDiscreteDynamicsWorld(arg0, arg1, arg2, arg3) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        this.ptr = _emscripten_bind_btDiscreteDynamicsWorld_btDiscreteDynamicsWorld_4(arg0, arg1, arg2, arg3), 
        getCache(btDiscreteDynamicsWorld)[this.ptr] = this;
    }
    function btConvexTriangleMeshShape(arg0, arg1) {
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        void 0 === arg1) return this.ptr = _emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_1(arg0), 
        void (getCache(btConvexTriangleMeshShape)[this.ptr] = this);
        this.ptr = _emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_2(arg0, arg1), 
        getCache(btConvexTriangleMeshShape)[this.ptr] = this;
    }
    function btPoint2PointConstraint(arg0, arg1, arg2, arg3) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        void 0 === arg2 ? (this.ptr = _emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_2(arg0, arg1), 
        void (getCache(btPoint2PointConstraint)[this.ptr] = this)) : void 0 === arg3 ? (this.ptr = _emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_3(arg0, arg1, arg2), 
        void (getCache(btPoint2PointConstraint)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_4(arg0, arg1, arg2, arg3), 
        void (getCache(btPoint2PointConstraint)[this.ptr] = this));
    }
    function btSliderConstraint(arg0, arg1, arg2, arg3, arg4) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), void 0 === arg3 ? (this.ptr = _emscripten_bind_btSliderConstraint_btSliderConstraint_3(arg0, arg1, arg2), 
        void (getCache(btSliderConstraint)[this.ptr] = this)) : void 0 === arg4 ? (this.ptr = _emscripten_bind_btSliderConstraint_btSliderConstraint_4(arg0, arg1, arg2, arg3), 
        void (getCache(btSliderConstraint)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btSliderConstraint_btSliderConstraint_5(arg0, arg1, arg2, arg3, arg4), 
        void (getCache(btSliderConstraint)[this.ptr] = this));
    }
    function btConeTwistConstraint(arg0, arg1, arg2, arg3) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        void 0 === arg2 ? (this.ptr = _emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_2(arg0, arg1), 
        void (getCache(btConeTwistConstraint)[this.ptr] = this)) : void 0 === arg3 ? (this.ptr = _emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_3(arg0, arg1, arg2), 
        void (getCache(btConeTwistConstraint)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_4(arg0, arg1, arg2, arg3), 
        void (getCache(btConeTwistConstraint)[this.ptr] = this));
    }
    function btDefaultCollisionConfiguration(arg0) {
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), void 0 === arg0) return this.ptr = _emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_0(), 
        void (getCache(btDefaultCollisionConfiguration)[this.ptr] = this);
        this.ptr = _emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_1(arg0), 
        getCache(btDefaultCollisionConfiguration)[this.ptr] = this;
    }
    function btConeShapeZ(arg0, arg1) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        this.ptr = _emscripten_bind_btConeShapeZ_btConeShapeZ_2(arg0, arg1), getCache(btConeShapeZ)[this.ptr] = this;
    }
    function btConeShapeX(arg0, arg1) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        this.ptr = _emscripten_bind_btConeShapeX_btConeShapeX_2(arg0, arg1), getCache(btConeShapeX)[this.ptr] = this;
    }
    function btTriangleMesh(arg0, arg1) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        void 0 === arg0 ? (this.ptr = _emscripten_bind_btTriangleMesh_btTriangleMesh_0(), 
        void (getCache(btTriangleMesh)[this.ptr] = this)) : void 0 === arg1 ? (this.ptr = _emscripten_bind_btTriangleMesh_btTriangleMesh_1(arg0), 
        void (getCache(btTriangleMesh)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btTriangleMesh_btTriangleMesh_2(arg0, arg1), 
        void (getCache(btTriangleMesh)[this.ptr] = this));
    }
    function btConvexHullShape() {
        this.ptr = _emscripten_bind_btConvexHullShape_btConvexHullShape_0(), getCache(btConvexHullShape)[this.ptr] = this;
    }
    function btPersistentManifold() {
        this.ptr = _emscripten_bind_btPersistentManifold_btPersistentManifold_0(), getCache(btPersistentManifold)[this.ptr] = this;
    }
    function btBoxShape(arg0) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), this.ptr = _emscripten_bind_btBoxShape_btBoxShape_1(arg0), 
        getCache(btBoxShape)[this.ptr] = this;
    }
    function btCollisionDispatcher(arg0) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), this.ptr = _emscripten_bind_btCollisionDispatcher_btCollisionDispatcher_1(arg0), 
        getCache(btCollisionDispatcher)[this.ptr] = this;
    }
    function btVehicleTuning() {
        this.ptr = _emscripten_bind_btVehicleTuning_btVehicleTuning_0(), getCache(btVehicleTuning)[this.ptr] = this;
    }
    function btCompoundShape(arg0) {
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), void 0 === arg0) return this.ptr = _emscripten_bind_btCompoundShape_btCompoundShape_0(), 
        void (getCache(btCompoundShape)[this.ptr] = this);
        this.ptr = _emscripten_bind_btCompoundShape_btCompoundShape_1(arg0), getCache(btCompoundShape)[this.ptr] = this;
    }
    function btCollisionObjectWrapper() {
        throw "cannot construct a btCollisionObjectWrapper, no constructor in IDL";
    }
    function ClosestConvexResultCallback(arg0, arg1) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        this.ptr = _emscripten_bind_ClosestConvexResultCallback_ClosestConvexResultCallback_2(arg0, arg1), 
        getCache(ClosestConvexResultCallback)[this.ptr] = this;
    }
    function btDefaultMotionState(arg0, arg1) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        void 0 === arg0 ? (this.ptr = _emscripten_bind_btDefaultMotionState_btDefaultMotionState_0(), 
        void (getCache(btDefaultMotionState)[this.ptr] = this)) : void 0 === arg1 ? (this.ptr = _emscripten_bind_btDefaultMotionState_btDefaultMotionState_1(arg0), 
        void (getCache(btDefaultMotionState)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btDefaultMotionState_btDefaultMotionState_2(arg0, arg1), 
        void (getCache(btDefaultMotionState)[this.ptr] = this));
    }
    function ClosestRayResultCallback(arg0, arg1) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        this.ptr = _emscripten_bind_ClosestRayResultCallback_ClosestRayResultCallback_2(arg0, arg1), 
        getCache(ClosestRayResultCallback)[this.ptr] = this;
    }
    function btCapsuleShapeX(arg0, arg1) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        this.ptr = _emscripten_bind_btCapsuleShapeX_btCapsuleShapeX_2(arg0, arg1), getCache(btCapsuleShapeX)[this.ptr] = this;
    }
    function btQuaternion(arg0, arg1, arg2, arg3) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        this.ptr = _emscripten_bind_btQuaternion_btQuaternion_4(arg0, arg1, arg2, arg3), 
        getCache(btQuaternion)[this.ptr] = this;
    }
    function btCapsuleShapeZ(arg0, arg1) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        this.ptr = _emscripten_bind_btCapsuleShapeZ_btCapsuleShapeZ_2(arg0, arg1), getCache(btCapsuleShapeZ)[this.ptr] = this;
    }
    function btDefaultVehicleRaycaster(arg0) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), this.ptr = _emscripten_bind_btDefaultVehicleRaycaster_btDefaultVehicleRaycaster_1(arg0), 
        getCache(btDefaultVehicleRaycaster)[this.ptr] = this;
    }
    function btWheelInfo() {
        throw "cannot construct a btWheelInfo, no constructor in IDL";
    }
    function btVector4(arg0, arg1, arg2, arg3) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        void 0 === arg0 ? (this.ptr = _emscripten_bind_btVector4_btVector4_0(), void (getCache(btVector4)[this.ptr] = this)) : void 0 === arg1 ? (this.ptr = _emscripten_bind_btVector4_btVector4_1(arg0), 
        void (getCache(btVector4)[this.ptr] = this)) : void 0 === arg2 ? (this.ptr = _emscripten_bind_btVector4_btVector4_2(arg0, arg1), 
        void (getCache(btVector4)[this.ptr] = this)) : void 0 === arg3 ? (this.ptr = _emscripten_bind_btVector4_btVector4_3(arg0, arg1, arg2), 
        void (getCache(btVector4)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btVector4_btVector4_4(arg0, arg1, arg2, arg3), 
        void (getCache(btVector4)[this.ptr] = this));
    }
    function btKinematicCharacterController(arg0, arg1, arg2, arg3) {
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        void 0 === arg3) return this.ptr = _emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_3(arg0, arg1, arg2), 
        void (getCache(btKinematicCharacterController)[this.ptr] = this);
        this.ptr = _emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_4(arg0, arg1, arg2, arg3), 
        getCache(btKinematicCharacterController)[this.ptr] = this;
    }
    function btStaticPlaneShape(arg0, arg1) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        this.ptr = _emscripten_bind_btStaticPlaneShape_btStaticPlaneShape_2(arg0, arg1), 
        getCache(btStaticPlaneShape)[this.ptr] = this;
    }
    function btContactSolverInfo() {
        throw "cannot construct a btContactSolverInfo, no constructor in IDL";
    }
    function btOverlappingPairCache() {
        throw "cannot construct a btOverlappingPairCache, no constructor in IDL";
    }
    function btSphereShape(arg0) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), this.ptr = _emscripten_bind_btSphereShape_btSphereShape_1(arg0), 
        getCache(btSphereShape)[this.ptr] = this;
    }
    function btDefaultCollisionConstructionInfo() {
        this.ptr = _emscripten_bind_btDefaultCollisionConstructionInfo_btDefaultCollisionConstructionInfo_0(), 
        getCache(btDefaultCollisionConstructionInfo)[this.ptr] = this;
    }
    function btHingeConstraint(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), arg5 && "object" == typeof arg5 && (arg5 = arg5.ptr), 
        arg6 && "object" == typeof arg6 && (arg6 = arg6.ptr), void 0 === arg2 ? (this.ptr = _emscripten_bind_btHingeConstraint_btHingeConstraint_2(arg0, arg1), 
        void (getCache(btHingeConstraint)[this.ptr] = this)) : void 0 === arg3 ? (this.ptr = _emscripten_bind_btHingeConstraint_btHingeConstraint_3(arg0, arg1, arg2), 
        void (getCache(btHingeConstraint)[this.ptr] = this)) : void 0 === arg4 ? (this.ptr = _emscripten_bind_btHingeConstraint_btHingeConstraint_4(arg0, arg1, arg2, arg3), 
        void (getCache(btHingeConstraint)[this.ptr] = this)) : void 0 === arg5 ? (this.ptr = _emscripten_bind_btHingeConstraint_btHingeConstraint_5(arg0, arg1, arg2, arg3, arg4), 
        void (getCache(btHingeConstraint)[this.ptr] = this)) : void 0 === arg6 ? (this.ptr = _emscripten_bind_btHingeConstraint_btHingeConstraint_6(arg0, arg1, arg2, arg3, arg4, arg5), 
        void (getCache(btHingeConstraint)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btHingeConstraint_btHingeConstraint_7(arg0, arg1, arg2, arg3, arg4, arg5, arg6), 
        void (getCache(btHingeConstraint)[this.ptr] = this));
    }
    function btConstraintSetting() {
        this.ptr = _emscripten_bind_btConstraintSetting_btConstraintSetting_0(), getCache(btConstraintSetting)[this.ptr] = this;
    }
    function LocalShapeInfo() {
        throw "cannot construct a LocalShapeInfo, no constructor in IDL";
    }
    function btConstraintSolver() {
        throw "cannot construct a btConstraintSolver, no constructor in IDL";
    }
    function btGeneric6DofSpringConstraint(arg0, arg1, arg2, arg3, arg4) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), void 0 === arg3 ? (this.ptr = _emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_3(arg0, arg1, arg2), 
        void (getCache(btGeneric6DofSpringConstraint)[this.ptr] = this)) : void 0 === arg4 ? (this.ptr = _emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_4(arg0, arg1, arg2, arg3), 
        void (getCache(btGeneric6DofSpringConstraint)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_5(arg0, arg1, arg2, arg3, arg4), 
        void (getCache(btGeneric6DofSpringConstraint)[this.ptr] = this));
    }
    function LocalConvexResult(arg0, arg1, arg2, arg3, arg4) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), this.ptr = _emscripten_bind_LocalConvexResult_LocalConvexResult_5(arg0, arg1, arg2, arg3, arg4), 
        getCache(LocalConvexResult)[this.ptr] = this;
    }
    function btOverlappingPairCallback() {
        throw "cannot construct a btOverlappingPairCallback, no constructor in IDL";
    }
    function btRigidBody(arg0) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), this.ptr = _emscripten_bind_btRigidBody_btRigidBody_1(arg0), 
        getCache(btRigidBody)[this.ptr] = this;
    }
    function btCylinderShapeX(arg0) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), this.ptr = _emscripten_bind_btCylinderShapeX_btCylinderShapeX_1(arg0), 
        getCache(btCylinderShapeX)[this.ptr] = this;
    }
    function btCylinderShapeZ(arg0) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), this.ptr = _emscripten_bind_btCylinderShapeZ_btCylinderShapeZ_1(arg0), 
        getCache(btCylinderShapeZ)[this.ptr] = this;
    }
    function btTransform(arg0, arg1) {
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        void 0 === arg0 ? (this.ptr = _emscripten_bind_btTransform_btTransform_0(), void (getCache(btTransform)[this.ptr] = this)) : void 0 === arg1 ? (this.ptr = _emscripten_bind_btTransform_btTransform_1(arg0), 
        void (getCache(btTransform)[this.ptr] = this)) : (this.ptr = _emscripten_bind_btTransform_btTransform_2(arg0, arg1), 
        void (getCache(btTransform)[this.ptr] = this));
    }
    function btRaycastVehicle(arg0, arg1, arg2) {
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), this.ptr = _emscripten_bind_btRaycastVehicle_btRaycastVehicle_3(arg0, arg1, arg2), 
        getCache(btRaycastVehicle)[this.ptr] = this;
    }
    function btGhostPairCallback() {
        this.ptr = _emscripten_bind_btGhostPairCallback_btGhostPairCallback_0(), getCache(btGhostPairCallback)[this.ptr] = this;
    }
    Module = Module || {};
    var Module;
    Module || (Module = (void 0 !== AmmoLib ? AmmoLib : null) || {});
    var moduleOverrides = {};
    for (var key in Module) Module.hasOwnProperty(key) && (moduleOverrides[key] = Module[key]);
    var ENVIRONMENT_IS_WEB = "object" == typeof window, ENVIRONMENT_IS_WORKER = "function" == typeof importScripts, ENVIRONMENT_IS_NODE = "object" == typeof process && "function" == typeof require && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER, ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
    if (ENVIRONMENT_IS_NODE) {
        Module.print || (Module.print = function(x) {
            process.stdout.write(x + "\n");
        }), Module.printErr || (Module.printErr = function(x) {
            process.stderr.write(x + "\n");
        });
        var nodeFS = require("fs"), nodePath = require("path");
        Module.read = function(filename, binary) {
            filename = nodePath.normalize(filename);
            var ret = nodeFS.readFileSync(filename);
            return ret || filename == nodePath.resolve(filename) || (filename = path.join(__dirname, "..", "src", filename), 
            ret = nodeFS.readFileSync(filename)), ret && !binary && (ret = ret.toString()), 
            ret;
        }, Module.readBinary = function(filename) {
            return Module.read(filename, !0);
        }, Module.load = function(f) {
            globalEval(read(f));
        }, Module.thisProgram || (process.argv.length > 1 ? Module.thisProgram = process.argv[1].replace(/\\/g, "/") : Module.thisProgram = "unknown-program"), 
        Module.arguments = process.argv.slice(2), "undefined" != typeof module && (module.exports = Module), 
        process.on("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) throw ex;
        }), Module.inspect = function() {
            return "[Emscripten Module object]";
        };
    } else if (ENVIRONMENT_IS_SHELL) Module.print || (Module.print = print), "undefined" != typeof printErr && (Module.printErr = printErr), 
    "undefined" != typeof read ? Module.read = read : Module.read = function() {
        throw "no read() available (jsc?)";
    }, Module.readBinary = function(f) {
        if ("function" == typeof readbuffer) return new Uint8Array(readbuffer(f));
        var data = read(f, "binary");
        return assert("object" == typeof data), data;
    }, "undefined" != typeof scriptArgs ? Module.arguments = scriptArgs : void 0 !== arguments && (Module.arguments = arguments); else {
        if (!ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER) throw "Unknown runtime environment. Where are we?";
        if (Module.read = function(url) {
            var xhr = new XMLHttpRequest();
            return xhr.open("GET", url, !1), xhr.send(null), xhr.responseText;
        }, void 0 !== arguments && (Module.arguments = arguments), "undefined" != typeof console) Module.print || (Module.print = function(x) {
            console.log(x);
        }), Module.printErr || (Module.printErr = function(x) {
            console.log(x);
        }); else {
            Module.print || (Module.print = function(x) {});
        }
        ENVIRONMENT_IS_WORKER && (Module.load = importScripts), void 0 === Module.setWindowTitle && (Module.setWindowTitle = function(title) {
            document.title = title;
        });
    }
    !Module.load && Module.read && (Module.load = function(f) {
        globalEval(Module.read(f));
    }), Module.print || (Module.print = function() {}), Module.printErr || (Module.printErr = Module.print), 
    Module.arguments || (Module.arguments = []), Module.thisProgram || (Module.thisProgram = "./this.program"), 
    Module.print = Module.print, Module.printErr = Module.printErr, Module.preRun = [], 
    Module.postRun = [];
    for (var key in moduleOverrides) moduleOverrides.hasOwnProperty(key) && (Module[key] = moduleOverrides[key]);
    var Runtime = {
        setTempRet0: function(value) {
            tempRet0 = value;
        },
        getTempRet0: function() {
            return tempRet0;
        },
        stackSave: function() {
            return STACKTOP;
        },
        stackRestore: function(stackTop) {
            STACKTOP = stackTop;
        },
        getNativeTypeSize: function(type) {
            switch (type) {
              case "i1":
              case "i8":
                return 1;

              case "i16":
                return 2;

              case "i32":
                return 4;

              case "i64":
                return 8;

              case "float":
                return 4;

              case "double":
                return 8;

              default:
                if ("*" === type[type.length - 1]) return Runtime.QUANTUM_SIZE;
                if ("i" === type[0]) {
                    var bits = parseInt(type.substr(1));
                    return assert(bits % 8 == 0), bits / 8;
                }
                return 0;
            }
        },
        getNativeFieldSize: function(type) {
            return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
        },
        STACK_ALIGN: 16,
        prepVararg: function(ptr, type) {
            return "double" === type || "i64" === type ? 7 & ptr && (assert(4 == (7 & ptr)), 
            ptr += 4) : assert(0 == (3 & ptr)), ptr;
        },
        getAlignSize: function(type, size, vararg) {
            return vararg || "i64" != type && "double" != type ? type ? Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE) : Math.min(size, 8) : 8;
        },
        dynCall: function(sig, ptr, args) {
            return args && args.length ? (args.splice || (args = Array.prototype.slice.call(args)), 
            args.splice(0, 0, ptr), Module["dynCall_" + sig].apply(null, args)) : Module["dynCall_" + sig].call(null, ptr);
        },
        functionPointers: [],
        addFunction: function(func) {
            for (var i = 0; i < Runtime.functionPointers.length; i++) if (!Runtime.functionPointers[i]) return Runtime.functionPointers[i] = func, 
            2 * (1 + i);
            throw "Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.";
        },
        removeFunction: function(index) {
            Runtime.functionPointers[(index - 2) / 2] = null;
        },
        warnOnce: function(text) {
            Runtime.warnOnce.shown || (Runtime.warnOnce.shown = {}), Runtime.warnOnce.shown[text] || (Runtime.warnOnce.shown[text] = 1, 
            Module.printErr(text));
        },
        funcWrappers: {},
        getFuncWrapper: function(func, sig) {
            assert(sig), Runtime.funcWrappers[sig] || (Runtime.funcWrappers[sig] = {});
            var sigCache = Runtime.funcWrappers[sig];
            return sigCache[func] || (sigCache[func] = function() {
                return Runtime.dynCall(sig, func, arguments);
            }), sigCache[func];
        },
        getCompilerSetting: function(name) {
            throw "You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work";
        },
        stackAlloc: function(size) {
            var ret = STACKTOP;
            return STACKTOP = STACKTOP + size | 0, STACKTOP = STACKTOP + 15 & -16, ret;
        },
        staticAlloc: function(size) {
            var ret = STATICTOP;
            return STATICTOP = STATICTOP + size | 0, STATICTOP = STATICTOP + 15 & -16, ret;
        },
        dynamicAlloc: function(size) {
            var ret = DYNAMICTOP;
            if (DYNAMICTOP = DYNAMICTOP + size | 0, (DYNAMICTOP = DYNAMICTOP + 15 & -16) >= TOTAL_MEMORY) {
                if (!enlargeMemory()) return DYNAMICTOP = ret, 0;
            }
            return ret;
        },
        alignMemory: function(size, quantum) {
            return size = Math.ceil(size / (quantum || 16)) * (quantum || 16);
        },
        makeBigInt: function(low, high, unsigned) {
            return unsigned ? +(low >>> 0) + 4294967296 * +(high >>> 0) : +(low >>> 0) + 4294967296 * +(0 | high);
        },
        GLOBAL_BASE: 8,
        QUANTUM_SIZE: 4,
        __dummy__: 0
    };
    Module.Runtime = Runtime;
    var tempDouble, tempI64, tempRet0, cwrap, ccall, ABORT = !1, EXITSTATUS = 0;
    !function() {
        var JSfuncs = {
            stackSave: function() {
                Runtime.stackSave();
            },
            stackRestore: function() {
                Runtime.stackRestore();
            },
            arrayToC: function(arr) {
                var ret = Runtime.stackAlloc(arr.length);
                return writeArrayToMemory(arr, ret), ret;
            },
            stringToC: function(str) {
                var ret = 0;
                return null !== str && void 0 !== str && 0 !== str && (ret = Runtime.stackAlloc(1 + (str.length << 2)), 
                writeStringToMemory(str, ret)), ret;
            }
        }, toC = {
            string: JSfuncs.stringToC,
            array: JSfuncs.arrayToC
        };
        ccall = function(ident, returnType, argTypes, args, opts) {
            var func = getCFunc(ident), cArgs = [], stack = 0;
            if (args) for (var i = 0; i < args.length; i++) {
                var converter = toC[argTypes[i]];
                converter ? (0 === stack && (stack = Runtime.stackSave()), cArgs[i] = converter(args[i])) : cArgs[i] = args[i];
            }
            var ret = func.apply(null, cArgs);
            if ("string" === returnType && (ret = Pointer_stringify(ret)), 0 !== stack) {
                if (opts && opts.async) return void EmterpreterAsync.asyncFinalizers.push(function() {
                    Runtime.stackRestore(stack);
                });
                Runtime.stackRestore(stack);
            }
            return ret;
        }, cwrap = function(ident, returnType, argTypes) {
            return function() {
                return ccall(ident, returnType, argTypes, arguments);
            };
        };
    }(), Module.ccall = ccall, Module.cwrap = cwrap, Module.setValue = setValue, Module.getValue = getValue;
    var ALLOC_STATIC = 2, ALLOC_NONE = 4;
    Module.ALLOC_NORMAL = 0, Module.ALLOC_STACK = 1, Module.ALLOC_STATIC = ALLOC_STATIC, 
    Module.ALLOC_DYNAMIC = 3, Module.ALLOC_NONE = ALLOC_NONE, Module.allocate = allocate, 
    Module.getMemory = getMemory, Module.Pointer_stringify = Pointer_stringify, Module.AsciiToString = AsciiToString, 
    Module.stringToAscii = stringToAscii, Module.UTF8ArrayToString = UTF8ArrayToString, 
    Module.UTF8ToString = UTF8ToString, Module.stringToUTF8Array = stringToUTF8Array, 
    Module.stringToUTF8 = stringToUTF8, Module.lengthBytesUTF8 = lengthBytesUTF8, Module.UTF16ToString = UTF16ToString, 
    Module.stringToUTF16 = stringToUTF16, Module.lengthBytesUTF16 = lengthBytesUTF16, 
    Module.UTF32ToString = UTF32ToString, Module.stringToUTF32 = stringToUTF32, Module.lengthBytesUTF32 = lengthBytesUTF32, 
    Module.stackTrace = stackTrace;
    for (var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64, PAGE_SIZE = 4096, STATIC_BASE = 0, STATICTOP = 0, staticSealed = !1, STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0, DYNAMIC_BASE = 0, DYNAMICTOP = 0, TOTAL_STACK = Module.TOTAL_STACK || 5242880, TOTAL_MEMORY = Module.TOTAL_MEMORY || 67108864, totalMemory = 65536; totalMemory < TOTAL_MEMORY || totalMemory < 2 * TOTAL_STACK; ) totalMemory < 16777216 ? totalMemory *= 2 : totalMemory += 16777216;
    totalMemory !== TOTAL_MEMORY && (Module.printErr("increasing TOTAL_MEMORY to " + totalMemory + " to be compliant with the asm.js spec (and given that TOTAL_STACK=" + TOTAL_STACK + ")"), 
    TOTAL_MEMORY = totalMemory), assert("undefined" != typeof Int32Array && "undefined" != typeof Float64Array && !!new Int32Array(1).subarray && !!new Int32Array(1).set, "JS engine does not provide full typed array support");
    var buffer;
    buffer = new ArrayBuffer(TOTAL_MEMORY), HEAP8 = new Int8Array(buffer), HEAP16 = new Int16Array(buffer), 
    HEAP32 = new Int32Array(buffer), HEAPU8 = new Uint8Array(buffer), HEAPU16 = new Uint16Array(buffer), 
    HEAPU32 = new Uint32Array(buffer), HEAPF32 = new Float32Array(buffer), HEAPF64 = new Float64Array(buffer), 
    HEAP32[0] = 255, assert(255 === HEAPU8[0] && 0 === HEAPU8[3], "Typed arrays 2 must be run on a little-endian system"), 
    Module.HEAP = void 0, Module.buffer = buffer, Module.HEAP8 = HEAP8, Module.HEAP16 = HEAP16, 
    Module.HEAP32 = HEAP32, Module.HEAPU8 = HEAPU8, Module.HEAPU16 = HEAPU16, Module.HEAPU32 = HEAPU32, 
    Module.HEAPF32 = HEAPF32, Module.HEAPF64 = HEAPF64;
    var __ATPRERUN__ = [], __ATINIT__ = [], __ATMAIN__ = [], __ATEXIT__ = [], __ATPOSTRUN__ = [], runtimeInitialized = !1, runtimeExited = !1;
    Module.addOnPreRun = addOnPreRun, Module.addOnInit = addOnInit, Module.addOnPreMain = addOnPreMain, 
    Module.addOnExit = addOnExit, Module.addOnPostRun = addOnPostRun, Module.intArrayFromString = intArrayFromString, 
    Module.intArrayToString = intArrayToString, Module.writeStringToMemory = writeStringToMemory, 
    Module.writeArrayToMemory = writeArrayToMemory, Module.writeAsciiToMemory = writeAsciiToMemory, 
    Math.imul && -5 === Math.imul(4294967295, 5) || (Math.imul = function(a, b) {
        var ah = a >>> 16, al = 65535 & a, bh = b >>> 16, bl = 65535 & b;
        return al * bl + (ah * bl + al * bh << 16) | 0;
    }), Math.imul = Math.imul, Math.clz32 || (Math.clz32 = function(x) {
        x >>>= 0;
        for (var i = 0; i < 32; i++) if (x & 1 << 31 - i) return i;
        return 32;
    }), Math.clz32 = Math.clz32;
    var Math_abs = Math.abs, Math_cos = Math.cos, Math_sin = Math.sin, Math_sqrt = (Math.tan, 
    Math.acos, Math.asin, Math.atan, Math.atan2, Math.exp, Math.log, Math.sqrt), Math_ceil = Math.ceil, Math_floor = Math.floor, Math_min = (Math.pow, 
    Math.imul, Math.fround, Math.min), runDependencies = (Math.clz32, 0), runDependencyWatcher = null, dependenciesFulfilled = null;
    Module.addRunDependency = addRunDependency, Module.removeRunDependency = removeRunDependency, 
    Module.preloadedImages = {}, Module.preloadedAudios = {};
    var ASM_CONSTS = [ function($0, $1, $2, $3, $4, $5, $6, $7) {
        var self = Module.getCache(Module.ConcreteContactResultCallback)[$0];
        if (!self.hasOwnProperty("addSingleResult")) throw "a JSImplementation must implement all functions, you forgot ConcreteContactResultCallback::addSingleResult.";
        return self.addSingleResult($1, $2, $3, $4, $5, $6, $7);
    } ];
    STATIC_BASE = 8, STATICTOP = STATIC_BASE + 5136, __ATINIT__.push(), allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 3, 0, 0, 216, 5, 0, 0, 56, 0, 0, 0, 0, 0, 0, 0, 248, 2, 0, 0, 238, 5, 0, 0, 32, 3, 0, 0, 10, 6, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 248, 2, 0, 0, 57, 6, 0, 0, 32, 3, 0, 0, 97, 6, 0, 0, 104, 0, 0, 0, 0, 0, 0, 0, 248, 2, 0, 0, 120, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 3, 0, 0, 136, 6, 0, 0, 144, 0, 0, 0, 0, 0, 0, 0, 248, 2, 0, 0, 186, 6, 0, 0, 32, 3, 0, 0, 13, 8, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 248, 2, 0, 0, 45, 8, 0, 0, 32, 3, 0, 0, 89, 8, 0, 0, 192, 0, 0, 0, 0, 0, 0, 0, 248, 2, 0, 0, 102, 8, 0, 0, 248, 2, 0, 0, 115, 8, 0, 0, 32, 3, 0, 0, 128, 8, 0, 0, 200, 0, 0, 0, 0, 0, 0, 0, 32, 3, 0, 0, 161, 8, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0, 32, 3, 0, 0, 231, 8, 0, 0, 208, 0, 0, 0, 0, 0, 0, 0, 32, 3, 0, 0, 195, 8, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 32, 3, 0, 0, 9, 9, 0, 0, 224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 88, 0, 0, 0, 5, 0, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 7, 0, 0, 0, 8, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 152, 0, 0, 0, 9, 0, 0, 0, 10, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 176, 0, 0, 0, 11, 0, 0, 0, 12, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 224, 0, 0, 0, 13, 0, 0, 0, 14, 0, 0, 0, 15, 0, 0, 0, 16, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 16, 1, 0, 0, 13, 0, 0, 0, 17, 0, 0, 0, 15, 0, 0, 0, 16, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 250, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 57, 98, 116, 71, 104, 111, 115, 116, 80, 97, 105, 114, 67, 97, 108, 108, 98, 97, 99, 107, 0, 50, 53, 98, 116, 79, 118, 101, 114, 108, 97, 112, 112, 105, 110, 103, 80, 97, 105, 114, 67, 97, 108, 108, 98, 97, 99, 107, 0, 78, 49, 54, 98, 116, 67, 111, 108, 108, 105, 115, 105, 111, 110, 87, 111, 114, 108, 100, 50, 52, 67, 108, 111, 115, 101, 115, 116, 82, 97, 121, 82, 101, 115, 117, 108, 116, 67, 97, 108, 108, 98, 97, 99, 107, 69, 0, 78, 49, 54, 98, 116, 67, 111, 108, 108, 105, 115, 105, 111, 110, 87, 111, 114, 108, 100, 49, 55, 82, 97, 121, 82, 101, 115, 117, 108, 116, 67, 97, 108, 108, 98, 97, 99, 107, 69, 0, 50, 48, 98, 116, 68, 101, 102, 97, 117, 108, 116, 77, 111, 116, 105, 111, 110, 83, 116, 97, 116, 101, 0, 49, 51, 98, 116, 77, 111, 116, 105, 111, 110, 83, 116, 97, 116, 101, 0, 78, 49, 54, 98, 116, 67, 111, 108, 108, 105, 115, 105, 111, 110, 87, 111, 114, 108, 100, 50, 55, 67, 108, 111, 115, 101, 115, 116, 67, 111, 110, 118, 101, 120, 82, 101, 115, 117, 108, 116, 67, 97, 108, 108, 98, 97, 99, 107, 69, 0, 78, 49, 54, 98, 116, 67, 111, 108, 108, 105, 115, 105, 111, 110, 87, 111, 114, 108, 100, 50, 48, 67, 111, 110, 118, 101, 120, 82, 101, 115, 117, 108, 116, 67, 97, 108, 108, 98, 97, 99, 107, 69, 0, 123, 32, 118, 97, 114, 32, 115, 101, 108, 102, 32, 61, 32, 77, 111, 100, 117, 108, 101, 91, 39, 103, 101, 116, 67, 97, 99, 104, 101, 39, 93, 40, 77, 111, 100, 117, 108, 101, 91, 39, 67, 111, 110, 99, 114, 101, 116, 101, 67, 111, 110, 116, 97, 99, 116, 82, 101, 115, 117, 108, 116, 67, 97, 108, 108, 98, 97, 99, 107, 39, 93, 41, 91, 36, 48, 93, 59, 32, 105, 102, 32, 40, 33, 115, 101, 108, 102, 46, 104, 97, 115, 79, 119, 110, 80, 114, 111, 112, 101, 114, 116, 121, 40, 39, 97, 100, 100, 83, 105, 110, 103, 108, 101, 82, 101, 115, 117, 108, 116, 39, 41, 41, 32, 116, 104, 114, 111, 119, 32, 39, 97, 32, 74, 83, 73, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 109, 117, 115, 116, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 32, 97, 108, 108, 32, 102, 117, 110, 99, 116, 105, 111, 110, 115, 44, 32, 121, 111, 117, 32, 102, 111, 114, 103, 111, 116, 32, 67, 111, 110, 99, 114, 101, 116, 101, 67, 111, 110, 116, 97, 99, 116, 82, 101, 115, 117, 108, 116, 67, 97, 108, 108, 98, 97, 99, 107, 58, 58, 97, 100, 100, 83, 105, 110, 103, 108, 101, 82, 101, 115, 117, 108, 116, 46, 39, 59, 32, 114, 101, 116, 117, 114, 110, 32, 115, 101, 108, 102, 91, 39, 97, 100, 100, 83, 105, 110, 103, 108, 101, 82, 101, 115, 117, 108, 116, 39, 93, 40, 36, 49, 44, 36, 50, 44, 36, 51, 44, 36, 52, 44, 36, 53, 44, 36, 54, 44, 36, 55, 41, 59, 32, 125, 0, 50, 57, 67, 111, 110, 99, 114, 101, 116, 101, 67, 111, 110, 116, 97, 99, 116, 82, 101, 115, 117, 108, 116, 67, 97, 108, 108, 98, 97, 99, 107, 0, 78, 49, 54, 98, 116, 67, 111, 108, 108, 105, 115, 105, 111, 110, 87, 111, 114, 108, 100, 50, 49, 67, 111, 110, 116, 97, 99, 116, 82, 101, 115, 117, 108, 116, 67, 97, 108, 108, 98, 97, 99, 107, 69, 0, 83, 116, 57, 98, 97, 100, 95, 97, 108, 108, 111, 99, 0, 83, 116, 57, 101, 120, 99, 101, 112, 116, 105, 111, 110, 0, 83, 116, 57, 116, 121, 112, 101, 95, 105, 110, 102, 111, 0, 78, 49, 48, 95, 95, 99, 120, 120, 97, 98, 105, 118, 49, 49, 54, 95, 95, 115, 104, 105, 109, 95, 116, 121, 112, 101, 95, 105, 110, 102, 111, 69, 0, 78, 49, 48, 95, 95, 99, 120, 120, 97, 98, 105, 118, 49, 49, 55, 95, 95, 99, 108, 97, 115, 115, 95, 116, 121, 112, 101, 95, 105, 110, 102, 111, 69, 0, 78, 49, 48, 95, 95, 99, 120, 120, 97, 98, 105, 118, 49, 49, 57, 95, 95, 112, 111, 105, 110, 116, 101, 114, 95, 116, 121, 112, 101, 95, 105, 110, 102, 111, 69, 0, 78, 49, 48, 95, 95, 99, 120, 120, 97, 98, 105, 118, 49, 49, 55, 95, 95, 112, 98, 97, 115, 101, 95, 116, 121, 112, 101, 95, 105, 110, 102, 111, 69, 0, 78, 49, 48, 95, 95, 99, 120, 120, 97, 98, 105, 118, 49, 50, 48, 95, 95, 115, 105, 95, 99, 108, 97, 115, 115, 95, 116, 121, 112, 101, 95, 105, 110, 102, 111, 69, 0, 112, 116, 104, 114, 101, 97, 100, 95, 111, 110, 99, 101, 32, 102, 97, 105, 108, 117, 114, 101, 32, 105, 110, 32, 95, 95, 99, 120, 97, 95, 103, 101, 116, 95, 103, 108, 111, 98, 97, 108, 115, 95, 102, 97, 115, 116, 40, 41, 0, 115, 116, 100, 58, 58, 98, 97, 100, 95, 97, 108, 108, 111, 99, 0, 116, 101, 114, 109, 105, 110, 97, 116, 101, 95, 104, 97, 110, 100, 108, 101, 114, 32, 117, 110, 101, 120, 112, 101, 99, 116, 101, 100, 108, 121, 32, 114, 101, 116, 117, 114, 110, 101, 100, 0, 99, 97, 110, 110, 111, 116, 32, 99, 114, 101, 97, 116, 101, 32, 112, 116, 104, 114, 101, 97, 100, 32, 107, 101, 121, 32, 102, 111, 114, 32, 95, 95, 99, 120, 97, 95, 103, 101, 116, 95, 103, 108, 111, 98, 97, 108, 115, 40, 41, 0, 99, 97, 110, 110, 111, 116, 32, 122, 101, 114, 111, 32, 111, 117, 116, 32, 116, 104, 114, 101, 97, 100, 32, 118, 97, 108, 117, 101, 32, 102, 111, 114, 32, 95, 95, 99, 120, 97, 95, 103, 101, 116, 95, 103, 108, 111, 98, 97, 108, 115, 40, 41, 0, 116, 101, 114, 109, 105, 110, 97, 116, 105, 110, 103, 32, 119, 105, 116, 104, 32, 37, 115, 32, 101, 120, 99, 101, 112, 116, 105, 111, 110, 32, 111, 102, 32, 116, 121, 112, 101, 32, 37, 115, 58, 32, 37, 115, 0, 116, 101, 114, 109, 105, 110, 97, 116, 105, 110, 103, 32, 119, 105, 116, 104, 32, 37, 115, 32, 101, 120, 99, 101, 112, 116, 105, 111, 110, 32, 111, 102, 32, 116, 121, 112, 101, 32, 37, 115, 0, 116, 101, 114, 109, 105, 110, 97, 116, 105, 110, 103, 32, 119, 105, 116, 104, 32, 37, 115, 32, 102, 111, 114, 101, 105, 103, 110, 32, 101, 120, 99, 101, 112, 116, 105, 111, 110, 0, 116, 101, 114, 109, 105, 110, 97, 116, 105, 110, 103, 0, 117, 110, 99, 97, 117, 103, 104, 116, 0, 84, 33, 34, 25, 13, 1, 2, 3, 17, 75, 28, 12, 16, 4, 11, 29, 18, 30, 39, 104, 110, 111, 112, 113, 98, 32, 5, 6, 15, 19, 20, 21, 26, 8, 22, 7, 40, 36, 23, 24, 9, 10, 14, 27, 31, 37, 35, 131, 130, 125, 38, 42, 43, 60, 61, 62, 63, 67, 71, 74, 77, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 99, 100, 101, 102, 103, 105, 106, 107, 108, 114, 115, 116, 121, 122, 123, 124, 0, 73, 108, 108, 101, 103, 97, 108, 32, 98, 121, 116, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101, 0, 68, 111, 109, 97, 105, 110, 32, 101, 114, 114, 111, 114, 0, 82, 101, 115, 117, 108, 116, 32, 110, 111, 116, 32, 114, 101, 112, 114, 101, 115, 101, 110, 116, 97, 98, 108, 101, 0, 78, 111, 116, 32, 97, 32, 116, 116, 121, 0, 80, 101, 114, 109, 105, 115, 115, 105, 111, 110, 32, 100, 101, 110, 105, 101, 100, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 110, 111, 116, 32, 112, 101, 114, 109, 105, 116, 116, 101, 100, 0, 78, 111, 32, 115, 117, 99, 104, 32, 102, 105, 108, 101, 32, 111, 114, 32, 100, 105, 114, 101, 99, 116, 111, 114, 121, 0, 78, 111, 32, 115, 117, 99, 104, 32, 112, 114, 111, 99, 101, 115, 115, 0, 70, 105, 108, 101, 32, 101, 120, 105, 115, 116, 115, 0, 86, 97, 108, 117, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 32, 102, 111, 114, 32, 100, 97, 116, 97, 32, 116, 121, 112, 101, 0, 78, 111, 32, 115, 112, 97, 99, 101, 32, 108, 101, 102, 116, 32, 111, 110, 32, 100, 101, 118, 105, 99, 101, 0, 79, 117, 116, 32, 111, 102, 32, 109, 101, 109, 111, 114, 121, 0, 82, 101, 115, 111, 117, 114, 99, 101, 32, 98, 117, 115, 121, 0, 73, 110, 116, 101, 114, 114, 117, 112, 116, 101, 100, 32, 115, 121, 115, 116, 101, 109, 32, 99, 97, 108, 108, 0, 82, 101, 115, 111, 117, 114, 99, 101, 32, 116, 101, 109, 112, 111, 114, 97, 114, 105, 108, 121, 32, 117, 110, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 73, 110, 118, 97, 108, 105, 100, 32, 115, 101, 101, 107, 0, 67, 114, 111, 115, 115, 45, 100, 101, 118, 105, 99, 101, 32, 108, 105, 110, 107, 0, 82, 101, 97, 100, 45, 111, 110, 108, 121, 32, 102, 105, 108, 101, 32, 115, 121, 115, 116, 101, 109, 0, 68, 105, 114, 101, 99, 116, 111, 114, 121, 32, 110, 111, 116, 32, 101, 109, 112, 116, 121, 0, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 114, 101, 115, 101, 116, 32, 98, 121, 32, 112, 101, 101, 114, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 116, 105, 109, 101, 100, 32, 111, 117, 116, 0, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 114, 101, 102, 117, 115, 101, 100, 0, 72, 111, 115, 116, 32, 105, 115, 32, 100, 111, 119, 110, 0, 72, 111, 115, 116, 32, 105, 115, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 0, 65, 100, 100, 114, 101, 115, 115, 32, 105, 110, 32, 117, 115, 101, 0, 66, 114, 111, 107, 101, 110, 32, 112, 105, 112, 101, 0, 73, 47, 79, 32, 101, 114, 114, 111, 114, 0, 78, 111, 32, 115, 117, 99, 104, 32, 100, 101, 118, 105, 99, 101, 32, 111, 114, 32, 97, 100, 100, 114, 101, 115, 115, 0, 66, 108, 111, 99, 107, 32, 100, 101, 118, 105, 99, 101, 32, 114, 101, 113, 117, 105, 114, 101, 100, 0, 78, 111, 32, 115, 117, 99, 104, 32, 100, 101, 118, 105, 99, 101, 0, 78, 111, 116, 32, 97, 32, 100, 105, 114, 101, 99, 116, 111, 114, 121, 0, 73, 115, 32, 97, 32, 100, 105, 114, 101, 99, 116, 111, 114, 121, 0, 84, 101, 120, 116, 32, 102, 105, 108, 101, 32, 98, 117, 115, 121, 0, 69, 120, 101, 99, 32, 102, 111, 114, 109, 97, 116, 32, 101, 114, 114, 111, 114, 0, 73, 110, 118, 97, 108, 105, 100, 32, 97, 114, 103, 117, 109, 101, 110, 116, 0, 65, 114, 103, 117, 109, 101, 110, 116, 32, 108, 105, 115, 116, 32, 116, 111, 111, 32, 108, 111, 110, 103, 0, 83, 121, 109, 98, 111, 108, 105, 99, 32, 108, 105, 110, 107, 32, 108, 111, 111, 112, 0, 70, 105, 108, 101, 110, 97, 109, 101, 32, 116, 111, 111, 32, 108, 111, 110, 103, 0, 84, 111, 111, 32, 109, 97, 110, 121, 32, 111, 112, 101, 110, 32, 102, 105, 108, 101, 115, 32, 105, 110, 32, 115, 121, 115, 116, 101, 109, 0, 78, 111, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 66, 97, 100, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0, 78, 111, 32, 99, 104, 105, 108, 100, 32, 112, 114, 111, 99, 101, 115, 115, 0, 66, 97, 100, 32, 97, 100, 100, 114, 101, 115, 115, 0, 70, 105, 108, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0, 84, 111, 111, 32, 109, 97, 110, 121, 32, 108, 105, 110, 107, 115, 0, 78, 111, 32, 108, 111, 99, 107, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 82, 101, 115, 111, 117, 114, 99, 101, 32, 100, 101, 97, 100, 108, 111, 99, 107, 32, 119, 111, 117, 108, 100, 32, 111, 99, 99, 117, 114, 0, 83, 116, 97, 116, 101, 32, 110, 111, 116, 32, 114, 101, 99, 111, 118, 101, 114, 97, 98, 108, 101, 0, 80, 114, 101, 118, 105, 111, 117, 115, 32, 111, 119, 110, 101, 114, 32, 100, 105, 101, 100, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 99, 97, 110, 99, 101, 108, 101, 100, 0, 70, 117, 110, 99, 116, 105, 111, 110, 32, 110, 111, 116, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 101, 100, 0, 78, 111, 32, 109, 101, 115, 115, 97, 103, 101, 32, 111, 102, 32, 100, 101, 115, 105, 114, 101, 100, 32, 116, 121, 112, 101, 0, 73, 100, 101, 110, 116, 105, 102, 105, 101, 114, 32, 114, 101, 109, 111, 118, 101, 100, 0, 68, 101, 118, 105, 99, 101, 32, 110, 111, 116, 32, 97, 32, 115, 116, 114, 101, 97, 109, 0, 78, 111, 32, 100, 97, 116, 97, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 68, 101, 118, 105, 99, 101, 32, 116, 105, 109, 101, 111, 117, 116, 0, 79, 117, 116, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 115, 32, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 76, 105, 110, 107, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 115, 101, 118, 101, 114, 101, 100, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 101, 114, 114, 111, 114, 0, 66, 97, 100, 32, 109, 101, 115, 115, 97, 103, 101, 0, 70, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 105, 110, 32, 98, 97, 100, 32, 115, 116, 97, 116, 101, 0, 78, 111, 116, 32, 97, 32, 115, 111, 99, 107, 101, 116, 0, 68, 101, 115, 116, 105, 110, 97, 116, 105, 111, 110, 32, 97, 100, 100, 114, 101, 115, 115, 32, 114, 101, 113, 117, 105, 114, 101, 100, 0, 77, 101, 115, 115, 97, 103, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 119, 114, 111, 110, 103, 32, 116, 121, 112, 101, 32, 102, 111, 114, 32, 115, 111, 99, 107, 101, 116, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 110, 111, 116, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 83, 111, 99, 107, 101, 116, 32, 116, 121, 112, 101, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 78, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 80, 114, 111, 116, 111, 99, 111, 108, 32, 102, 97, 109, 105, 108, 121, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 0, 65, 100, 100, 114, 101, 115, 115, 32, 102, 97, 109, 105, 108, 121, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 32, 98, 121, 32, 112, 114, 111, 116, 111, 99, 111, 108, 0, 65, 100, 100, 114, 101, 115, 115, 32, 110, 111, 116, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 78, 101, 116, 119, 111, 114, 107, 32, 105, 115, 32, 100, 111, 119, 110, 0, 78, 101, 116, 119, 111, 114, 107, 32, 117, 110, 114, 101, 97, 99, 104, 97, 98, 108, 101, 0, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 114, 101, 115, 101, 116, 32, 98, 121, 32, 110, 101, 116, 119, 111, 114, 107, 0, 67, 111, 110, 110, 101, 99, 116, 105, 111, 110, 32, 97, 98, 111, 114, 116, 101, 100, 0, 78, 111, 32, 98, 117, 102, 102, 101, 114, 32, 115, 112, 97, 99, 101, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 0, 83, 111, 99, 107, 101, 116, 32, 105, 115, 32, 99, 111, 110, 110, 101, 99, 116, 101, 100, 0, 83, 111, 99, 107, 101, 116, 32, 110, 111, 116, 32, 99, 111, 110, 110, 101, 99, 116, 101, 100, 0, 67, 97, 110, 110, 111, 116, 32, 115, 101, 110, 100, 32, 97, 102, 116, 101, 114, 32, 115, 111, 99, 107, 101, 116, 32, 115, 104, 117, 116, 100, 111, 119, 110, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 97, 108, 114, 101, 97, 100, 121, 32, 105, 110, 32, 112, 114, 111, 103, 114, 101, 115, 115, 0, 79, 112, 101, 114, 97, 116, 105, 111, 110, 32, 105, 110, 32, 112, 114, 111, 103, 114, 101, 115, 115, 0, 83, 116, 97, 108, 101, 32, 102, 105, 108, 101, 32, 104, 97, 110, 100, 108, 101, 0, 82, 101, 109, 111, 116, 101, 32, 73, 47, 79, 32, 101, 114, 114, 111, 114, 0, 81, 117, 111, 116, 97, 32, 101, 120, 99, 101, 101, 100, 101, 100, 0, 78, 111, 32, 109, 101, 100, 105, 117, 109, 32, 102, 111, 117, 110, 100, 0, 87, 114, 111, 110, 103, 32, 109, 101, 100, 105, 117, 109, 32, 116, 121, 112, 101, 0, 78, 111, 32, 101, 114, 114, 111, 114, 32, 105, 110, 102, 111, 114, 109, 97, 116, 105, 111, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 10, 0, 17, 17, 17, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 15, 10, 17, 17, 17, 3, 10, 7, 0, 1, 19, 9, 11, 11, 0, 0, 9, 6, 11, 0, 0, 11, 0, 6, 17, 0, 0, 0, 17, 17, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 10, 10, 17, 17, 17, 0, 10, 0, 0, 2, 0, 9, 11, 0, 0, 0, 9, 0, 11, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 12, 0, 0, 0, 0, 9, 12, 0, 0, 0, 0, 0, 12, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 4, 13, 0, 0, 0, 0, 9, 14, 0, 0, 0, 0, 0, 14, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 15, 0, 0, 0, 0, 9, 16, 0, 0, 0, 0, 0, 16, 0, 0, 16, 0, 0, 18, 0, 0, 0, 18, 18, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 18, 18, 18, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 10, 0, 0, 0, 0, 9, 11, 0, 0, 0, 0, 0, 11, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 12, 0, 0, 0, 0, 9, 12, 0, 0, 0, 0, 0, 12, 0, 0, 12, 0, 0, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 45, 43, 32, 32, 32, 48, 88, 48, 120, 0, 40, 110, 117, 108, 108, 41, 0, 45, 48, 88, 43, 48, 88, 32, 48, 88, 45, 48, 120, 43, 48, 120, 32, 48, 120, 0, 105, 110, 102, 0, 73, 78, 70, 0, 110, 97, 110, 0, 78, 65, 78, 0, 46, 0 ], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE);
    var tempDoublePtr = Runtime.alignMemory(allocate(12, "i8", ALLOC_STATIC), 8);
    assert(tempDoublePtr % 8 == 0), Module._i64Subtract = _i64Subtract, Module._i64Add = _i64Add;
    var EXCEPTIONS = {
        last: 0,
        caught: [],
        infos: {},
        deAdjust: function(adjusted) {
            if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;
            for (var ptr in EXCEPTIONS.infos) {
                if (EXCEPTIONS.infos[ptr].adjusted === adjusted) return ptr;
            }
            return adjusted;
        },
        addRef: function(ptr) {
            if (ptr) {
                EXCEPTIONS.infos[ptr].refcount++;
            }
        },
        decRef: function(ptr) {
            if (ptr) {
                var info = EXCEPTIONS.infos[ptr];
                assert(info.refcount > 0), info.refcount--, 0 === info.refcount && (info.destructor && Runtime.dynCall("vi", info.destructor, [ ptr ]), 
                delete EXCEPTIONS.infos[ptr], ___cxa_free_exception(ptr));
            }
        },
        clearRef: function(ptr) {
            if (ptr) {
                EXCEPTIONS.infos[ptr].refcount = 0;
            }
        }
    }, _sqrtf = Math_sqrt, PTHREAD_SPECIFIC = {}, PTHREAD_SPECIFIC_NEXT_KEY = 1, ERRNO_CODES = {
        EPERM: 1,
        ENOENT: 2,
        ESRCH: 3,
        EINTR: 4,
        EIO: 5,
        ENXIO: 6,
        E2BIG: 7,
        ENOEXEC: 8,
        EBADF: 9,
        ECHILD: 10,
        EAGAIN: 11,
        EWOULDBLOCK: 11,
        ENOMEM: 12,
        EACCES: 13,
        EFAULT: 14,
        ENOTBLK: 15,
        EBUSY: 16,
        EEXIST: 17,
        EXDEV: 18,
        ENODEV: 19,
        ENOTDIR: 20,
        EISDIR: 21,
        EINVAL: 22,
        ENFILE: 23,
        EMFILE: 24,
        ENOTTY: 25,
        ETXTBSY: 26,
        EFBIG: 27,
        ENOSPC: 28,
        ESPIPE: 29,
        EROFS: 30,
        EMLINK: 31,
        EPIPE: 32,
        EDOM: 33,
        ERANGE: 34,
        ENOMSG: 42,
        EIDRM: 43,
        ECHRNG: 44,
        EL2NSYNC: 45,
        EL3HLT: 46,
        EL3RST: 47,
        ELNRNG: 48,
        EUNATCH: 49,
        ENOCSI: 50,
        EL2HLT: 51,
        EDEADLK: 35,
        ENOLCK: 37,
        EBADE: 52,
        EBADR: 53,
        EXFULL: 54,
        ENOANO: 55,
        EBADRQC: 56,
        EBADSLT: 57,
        EDEADLOCK: 35,
        EBFONT: 59,
        ENOSTR: 60,
        ENODATA: 61,
        ETIME: 62,
        ENOSR: 63,
        ENONET: 64,
        ENOPKG: 65,
        EREMOTE: 66,
        ENOLINK: 67,
        EADV: 68,
        ESRMNT: 69,
        ECOMM: 70,
        EPROTO: 71,
        EMULTIHOP: 72,
        EDOTDOT: 73,
        EBADMSG: 74,
        ENOTUNIQ: 76,
        EBADFD: 77,
        EREMCHG: 78,
        ELIBACC: 79,
        ELIBBAD: 80,
        ELIBSCN: 81,
        ELIBMAX: 82,
        ELIBEXEC: 83,
        ENOSYS: 38,
        ENOTEMPTY: 39,
        ENAMETOOLONG: 36,
        ELOOP: 40,
        EOPNOTSUPP: 95,
        EPFNOSUPPORT: 96,
        ECONNRESET: 104,
        ENOBUFS: 105,
        EAFNOSUPPORT: 97,
        EPROTOTYPE: 91,
        ENOTSOCK: 88,
        ENOPROTOOPT: 92,
        ESHUTDOWN: 108,
        ECONNREFUSED: 111,
        EADDRINUSE: 98,
        ECONNABORTED: 103,
        ENETUNREACH: 101,
        ENETDOWN: 100,
        ETIMEDOUT: 110,
        EHOSTDOWN: 112,
        EHOSTUNREACH: 113,
        EINPROGRESS: 115,
        EALREADY: 114,
        EDESTADDRREQ: 89,
        EMSGSIZE: 90,
        EPROTONOSUPPORT: 93,
        ESOCKTNOSUPPORT: 94,
        EADDRNOTAVAIL: 99,
        ENETRESET: 102,
        EISCONN: 106,
        ENOTCONN: 107,
        ETOOMANYREFS: 109,
        EUSERS: 87,
        EDQUOT: 122,
        ESTALE: 116,
        ENOTSUP: 95,
        ENOMEDIUM: 123,
        EILSEQ: 84,
        EOVERFLOW: 75,
        ECANCELED: 125,
        ENOTRECOVERABLE: 131,
        EOWNERDEAD: 130,
        ESTRPIPE: 86
    };
    Module._memcpy = _memcpy;
    var _cosf = Math_cos;
    Module._memset = _memset;
    Module._bitshift64Shl = _bitshift64Shl, Module._bitshift64Lshr = _bitshift64Lshr, 
    Module._malloc = _malloc;
    var _sinf = Math_sin, SYSCALLS = {
        varargs: 0,
        get: function(varargs) {
            return SYSCALLS.varargs += 4, HEAP32[SYSCALLS.varargs - 4 >> 2];
        },
        getStr: function() {
            return Pointer_stringify(SYSCALLS.get());
        },
        get64: function() {
            var low = SYSCALLS.get(), high = SYSCALLS.get();
            return assert(low >= 0 ? 0 === high : -1 === high), low;
        },
        getZero: function() {
            assert(0 === SYSCALLS.get());
        }
    };
    STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP), staticSealed = !0, STACK_MAX = STACK_BASE + TOTAL_STACK, 
    DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX), assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");
    var cttz_i8 = allocate([ 8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0 ], "i8", 3);
    Module.asmGlobalArg = {
        Math: Math,
        Int8Array: Int8Array,
        Int16Array: Int16Array,
        Int32Array: Int32Array,
        Uint8Array: Uint8Array,
        Uint16Array: Uint16Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array,
        NaN: NaN,
        Infinity: 1 / 0
    }, Module.asmLibraryArg = {
        abort: abort,
        assert: assert,
        invoke_vi: invoke_vi,
        invoke_iiii: invoke_iiii,
        invoke_vidi: invoke_vidi,
        invoke_viiiiii: invoke_viiiiii,
        invoke_viiiii: invoke_viiiii,
        invoke_diiiiiiii: invoke_diiiiiiii,
        invoke_vid: invoke_vid,
        invoke_di: invoke_di,
        invoke_iidid: invoke_iidid,
        invoke_vii: invoke_vii,
        invoke_ii: invoke_ii,
        invoke_viii: invoke_viii,
        invoke_v: invoke_v,
        invoke_viid: invoke_viid,
        invoke_iiiii: invoke_iiiii,
        invoke_viiii: invoke_viiii,
        invoke_iii: invoke_iii,
        invoke_diii: invoke_diii,
        _pthread_key_create: _pthread_key_create,
        __ZN13btGhostObjectC1Ev: __ZN13btGhostObjectC1Ev,
        __ZN10btBoxShapeC1ERK9btVector3: __ZN10btBoxShapeC1ERK9btVector3,
        ___cxa_guard_acquire: ___cxa_guard_acquire,
        __ZN17btConvexHullShape8addPointERK9btVector3b: __ZN17btConvexHullShape8addPointERK9btVector3b,
        ___setErrNo: ___setErrNo,
        __ZN25btConvexTriangleMeshShapeC1EP23btStridingMeshInterfaceb: __ZN25btConvexTriangleMeshShapeC1EP23btStridingMeshInterfaceb,
        __ZN30btKinematicCharacterController16setMaxJumpHeightEf: __ZN30btKinematicCharacterController16setMaxJumpHeightEf,
        __ZSt18uncaught_exceptionv: __ZSt18uncaught_exceptionv,
        __ZN21btCollisionDispatcherC1EP24btCollisionConfiguration: __ZN21btCollisionDispatcherC1EP24btCollisionConfiguration,
        __ZN15btCompoundShape13addChildShapeERK11btTransformP16btCollisionShape: __ZN15btCompoundShape13addChildShapeERK11btTransformP16btCollisionShape,
        __Z21btAlignedFreeInternalPv: __Z21btAlignedFreeInternalPv,
        __ZN16btCylinderShapeXC1ERK9btVector3: __ZN16btCylinderShapeXC1ERK9btVector3,
        __ZN22btBvhTriangleMeshShapeC1EP23btStridingMeshInterfacebb: __ZN22btBvhTriangleMeshShapeC1EP23btStridingMeshInterfacebb,
        __ZN17btHingeConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b: __ZN17btHingeConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b,
        _sbrk: _sbrk,
        ___cxa_begin_catch: ___cxa_begin_catch,
        _sinf: _sinf,
        _sysconf: _sysconf,
        __ZN18btStaticPlaneShapeC1ERK9btVector3f: __ZN18btStaticPlaneShapeC1ERK9btVector3f,
        __ZN12btAxisSweep3C1ERK9btVector3S2_tP22btOverlappingPairCacheb: __ZN12btAxisSweep3C1ERK9btVector3S2_tP22btOverlappingPairCacheb,
        __ZN30btKinematicCharacterControllerC1EP24btPairCachingGhostObjectP13btConvexShapefi: __ZN30btKinematicCharacterControllerC1EP24btPairCachingGhostObjectP13btConvexShapefi,
        __ZN21btConeTwistConstraintC1ER11btRigidBodyS1_RK11btTransformS4_: __ZN21btConeTwistConstraintC1ER11btRigidBodyS1_RK11btTransformS4_,
        __ZN21btConeTwistConstraintC1ER11btRigidBodyRK11btTransform: __ZN21btConeTwistConstraintC1ER11btRigidBodyRK11btTransform,
        __ZN14btCapsuleShapeC1Eff: __ZN14btCapsuleShapeC1Eff,
        __ZN15btCompoundShape23removeChildShapeByIndexEi: __ZN15btCompoundShape23removeChildShapeByIndexEi,
        _pthread_cleanup_push: _pthread_cleanup_push,
        __ZN15btCapsuleShapeZC1Eff: __ZN15btCapsuleShapeZC1Eff,
        ___syscall140: ___syscall140,
        __ZN30btKinematicCharacterController11setMaxSlopeEf: __ZN30btKinematicCharacterController11setMaxSlopeEf,
        __ZN16btCollisionWorld15contactPairTestEP17btCollisionObjectS1_RNS_21ContactResultCallbackE: __ZN16btCollisionWorld15contactPairTestEP17btCollisionObjectS1_RNS_21ContactResultCallbackE,
        ___syscall146: ___syscall146,
        __ZNK16btCollisionWorld15convexSweepTestEPK13btConvexShapeRK11btTransformS5_RNS_20ConvexResultCallbackEf: __ZNK16btCollisionWorld15convexSweepTestEPK13btConvexShapeRK11btTransformS5_RNS_20ConvexResultCallbackEf,
        _pthread_cleanup_pop: _pthread_cleanup_pop,
        __ZN16btRaycastVehicleC1ERKNS_15btVehicleTuningEP11btRigidBodyP18btVehicleRaycaster: __ZN16btRaycastVehicleC1ERKNS_15btVehicleTuningEP11btRigidBodyP18btVehicleRaycaster,
        __ZNK16btRaycastVehicle19getWheelTransformWSEi: __ZNK16btRaycastVehicle19getWheelTransformWSEi,
        __ZN15btCylinderShapeC1ERK9btVector3: __ZN15btCylinderShapeC1ERK9btVector3,
        __ZN11btRigidBody12setMassPropsEfRK9btVector3: __ZN11btRigidBody12setMassPropsEfRK9btVector3,
        __ZN20btPersistentManifoldC1Ev: __ZN20btPersistentManifoldC1Ev,
        __ZN16btRaycastVehicle16applyEngineForceEfi: __ZN16btRaycastVehicle16applyEngineForceEfi,
        ___cxa_find_matching_catch: ___cxa_find_matching_catch,
        __ZN15btCompoundShapeC1Ebi: __ZN15btCompoundShapeC1Ebi,
        ___cxa_guard_release: ___cxa_guard_release,
        __ZN11btRigidBody19updateInertiaTensorEv: __ZN11btRigidBody19updateInertiaTensorEv,
        __ZN30btKinematicCharacterController12setFallSpeedEf: __ZN30btKinematicCharacterController12setFallSpeedEf,
        __ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyRK11btTransformb: __ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyRK11btTransformb,
        ___resumeException: ___resumeException,
        __ZN15btCapsuleShapeXC1Eff: __ZN15btCapsuleShapeXC1Eff,
        __ZN16btCylinderShapeZC1ERK9btVector3: __ZN16btCylinderShapeZC1ERK9btVector3,
        __ZN29btGeneric6DofSpringConstraint12setStiffnessEif: __ZN29btGeneric6DofSpringConstraint12setStiffnessEif,
        __ZN30btKinematicCharacterController10setGravityEf: __ZN30btKinematicCharacterController10setGravityEf,
        _pthread_once: _pthread_once,
        __ZN12btConeShapeXC1Eff: __ZN12btConeShapeXC1Eff,
        __ZN21btConeTwistConstraint14setMotorTargetERK12btQuaternion: __ZN21btConeTwistConstraint14setMotorTargetERK12btQuaternion,
        __ZN11btConeShapeC1Eff: __ZN11btConeShapeC1Eff,
        ___syscall6: ___syscall6,
        _time: _time,
        __ZN16btRaycastVehicle12getWheelInfoEi: __ZN16btRaycastVehicle12getWheelInfoEi,
        _emscripten_asm_const_8: _emscripten_asm_const_8,
        __ZN29btGeneric6DofSpringConstraint12enableSpringEib: __ZN29btGeneric6DofSpringConstraint12enableSpringEib,
        __ZN17btHingeConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_S4_b: __ZN17btHingeConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_S4_b,
        __ZN18btSliderConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b: __ZN18btSliderConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b,
        __ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b: __ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b,
        __ZN18btSliderConstraintC1ER11btRigidBodyRK11btTransformb: __ZN18btSliderConstraintC1ER11btRigidBodyRK11btTransformb,
        __ZNK30btKinematicCharacterController10getGravityEv: __ZNK30btKinematicCharacterController10getGravityEv,
        ___cxa_allocate_exception: ___cxa_allocate_exception,
        __ZN23btPoint2PointConstraintC1ER11btRigidBodyRK9btVector3: __ZN23btPoint2PointConstraintC1ER11btRigidBodyRK9btVector3,
        __ZN23btPoint2PointConstraintC1ER11btRigidBodyS1_RK9btVector3S4_: __ZN23btPoint2PointConstraintC1ER11btRigidBodyS1_RK9btVector3S4_,
        __ZN11btRigidBodyC1ERKNS_27btRigidBodyConstructionInfoE: __ZN11btRigidBodyC1ERKNS_27btRigidBodyConstructionInfoE,
        __ZN23btGeneric6DofConstraintC1ER11btRigidBodyRK11btTransformb: __ZN23btGeneric6DofConstraintC1ER11btRigidBodyRK11btTransformb,
        __ZNK30btKinematicCharacterController11getMaxSlopeEv: __ZNK30btKinematicCharacterController11getMaxSlopeEv,
        _pthread_getspecific: _pthread_getspecific,
        _emscripten_memcpy_big: _emscripten_memcpy_big,
        __Z22btAlignedAllocInternalji: __Z22btAlignedAllocInternalji,
        __ZN21btConeTwistConstraint31setMotorTargetInConstraintSpaceERK12btQuaternion: __ZN21btConeTwistConstraint31setMotorTargetInConstraintSpaceERK12btQuaternion,
        __ZN30btKinematicCharacterController12setJumpSpeedEf: __ZN30btKinematicCharacterController12setJumpSpeedEf,
        _sqrtf: _sqrtf,
        __ZN31btDefaultCollisionConfigurationC1ERK34btDefaultCollisionConstructionInfo: __ZN31btDefaultCollisionConfigurationC1ERK34btDefaultCollisionConstructionInfo,
        __ZN16btDbvtBroadphaseC1EP22btOverlappingPairCache: __ZN16btDbvtBroadphaseC1EP22btOverlappingPairCache,
        _abort: _abort,
        __ZN11btRigidBody10setDampingEff: __ZN11btRigidBody10setDampingEff,
        __ZN16btRaycastVehicle20updateWheelTransformEib: __ZN16btRaycastVehicle20updateWheelTransformEib,
        __ZNK17btCollisionObject20forceActivationStateEi: __ZNK17btCollisionObject20forceActivationStateEi,
        _cosf: _cosf,
        __ZN17btConvexHullShapeC1EPKfii: __ZN17btConvexHullShapeC1EPKfii,
        __ZN30btKinematicCharacterController14getGhostObjectEv: __ZN30btKinematicCharacterController14getGhostObjectEv,
        __ZN21btConvexInternalShapeC2Ev: __ZN21btConvexInternalShapeC2Ev,
        __ZN23btGeneric6DofConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b: __ZN23btGeneric6DofConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b,
        __ZN12btConeShapeZC1Eff: __ZN12btConeShapeZC1Eff,
        __ZN11btRigidBody24setCenterOfMassTransformERK11btTransform: __ZN11btRigidBody24setCenterOfMassTransformERK11btTransform,
        __ZN16btRaycastVehicle16setSteeringValueEfi: __ZN16btRaycastVehicle16setSteeringValueEfi,
        __ZNK17btCollisionObject8activateEb: __ZNK17btCollisionObject8activateEb,
        __ZN14btTriangleMesh11addTriangleERK9btVector3S2_S2_b: __ZN14btTriangleMesh11addTriangleERK9btVector3S2_S2_b,
        __ZN17btHingeConstraintC1ER11btRigidBodyRK11btTransformb: __ZN17btHingeConstraintC1ER11btRigidBodyRK11btTransformb,
        __ZN29btGeneric6DofSpringConstraint10setDampingEif: __ZN29btGeneric6DofSpringConstraint10setDampingEif,
        _pthread_self: _pthread_self,
        __ZNK17btCollisionObject18setActivationStateEi: __ZNK17btCollisionObject18setActivationStateEi,
        __ZN35btSequentialImpulseConstraintSolverC1Ev: __ZN35btSequentialImpulseConstraintSolverC1Ev,
        __ZN24btPairCachingGhostObjectC1Ev: __ZN24btPairCachingGhostObjectC1Ev,
        _pthread_setspecific: _pthread_setspecific,
        ___cxa_throw: ___cxa_throw,
        __ZN16btRaycastVehicle8setBrakeEfi: __ZN16btRaycastVehicle8setBrakeEfi,
        __ZN14btTriangleMeshC1Ebb: __ZN14btTriangleMeshC1Ebb,
        __ZN23btDiscreteDynamicsWorldC1EP12btDispatcherP21btBroadphaseInterfaceP18btConstraintSolverP24btCollisionConfiguration: __ZN23btDiscreteDynamicsWorldC1EP12btDispatcherP21btBroadphaseInterfaceP18btConstraintSolverP24btCollisionConfiguration,
        __ZN16btRaycastVehicle8addWheelERK9btVector3S2_S2_ffRKNS_15btVehicleTuningEb: __ZN16btRaycastVehicle8addWheelERK9btVector3S2_S2_ffRKNS_15btVehicleTuningEb,
        __ZN14btAngularLimit3setEfffff: __ZN14btAngularLimit3setEfffff,
        STACKTOP: STACKTOP,
        STACK_MAX: STACK_MAX,
        tempDoublePtr: tempDoublePtr,
        ABORT: ABORT,
        cttz_i8: cttz_i8,
        __ZTV13btSphereShape: __ZTV13btSphereShape,
        __ZTV25btDefaultVehicleRaycaster: __ZTV25btDefaultVehicleRaycaster
    };
    var asm = function(global, env, buffer) {
        "use asm";
        var a = new global.Int8Array(buffer);
        var b = new global.Int16Array(buffer);
        var c = new global.Int32Array(buffer);
        var d = new global.Uint8Array(buffer);
        var e = new global.Uint16Array(buffer);
        var f = new global.Uint32Array(buffer);
        var g = new global.Float32Array(buffer);
        var h = new global.Float64Array(buffer);
        var i = env.STACKTOP | 0;
        var j = env.STACK_MAX | 0;
        var k = env.tempDoublePtr | 0;
        var l = env.ABORT | 0;
        var m = env.cttz_i8 | 0;
        var n = env.__ZTV13btSphereShape | 0;
        var o = env.__ZTV25btDefaultVehicleRaycaster | 0;
        var p = 0;
        var q = 0;
        var r = 0;
        var s = 0;
        var t = global.NaN, u = global.Infinity;
        var v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0;
        var E = 0;
        var F = 0;
        var G = 0;
        var H = 0;
        var I = 0;
        var J = 0;
        var K = 0;
        var L = 0;
        var M = 0;
        var N = 0;
        var O = global.Math.floor;
        var P = global.Math.abs;
        var Q = global.Math.sqrt;
        var R = global.Math.pow;
        var S = global.Math.cos;
        var T = global.Math.sin;
        var U = global.Math.tan;
        var V = global.Math.acos;
        var W = global.Math.asin;
        var X = global.Math.atan;
        var Y = global.Math.atan2;
        var Z = global.Math.exp;
        var _ = global.Math.log;
        var $ = global.Math.ceil;
        var aa = global.Math.imul;
        var ba = global.Math.min;
        var ca = global.Math.clz32;
        var da = env.abort;
        var ea = env.assert;
        var fa = env.invoke_vi;
        var ga = env.invoke_iiii;
        var ha = env.invoke_vidi;
        var ia = env.invoke_viiiiii;
        var ja = env.invoke_viiiii;
        var ka = env.invoke_diiiiiiii;
        var la = env.invoke_vid;
        var ma = env.invoke_di;
        var na = env.invoke_iidid;
        var oa = env.invoke_vii;
        var pa = env.invoke_ii;
        var qa = env.invoke_viii;
        var ra = env.invoke_v;
        var sa = env.invoke_viid;
        var ta = env.invoke_iiiii;
        var ua = env.invoke_viiii;
        var va = env.invoke_iii;
        var wa = env.invoke_diii;
        var xa = env._pthread_key_create;
        var ya = env.__ZN13btGhostObjectC1Ev;
        var za = env.__ZN10btBoxShapeC1ERK9btVector3;
        var Aa = env.___cxa_guard_acquire;
        var Ba = env.__ZN17btConvexHullShape8addPointERK9btVector3b;
        var Ca = env.___setErrNo;
        var Da = env.__ZN25btConvexTriangleMeshShapeC1EP23btStridingMeshInterfaceb;
        var Ea = env.__ZN30btKinematicCharacterController16setMaxJumpHeightEf;
        var Fa = env.__ZSt18uncaught_exceptionv;
        var Ga = env.__ZN21btCollisionDispatcherC1EP24btCollisionConfiguration;
        var Ha = env.__ZN15btCompoundShape13addChildShapeERK11btTransformP16btCollisionShape;
        var Ia = env.__Z21btAlignedFreeInternalPv;
        var Ja = env.__ZN16btCylinderShapeXC1ERK9btVector3;
        var Ka = env.__ZN22btBvhTriangleMeshShapeC1EP23btStridingMeshInterfacebb;
        var La = env.__ZN17btHingeConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b;
        var Ma = env._sbrk;
        var Na = env.___cxa_begin_catch;
        var Oa = env._sinf;
        var Pa = env._sysconf;
        var Qa = env.__ZN18btStaticPlaneShapeC1ERK9btVector3f;
        var Ra = env.__ZN12btAxisSweep3C1ERK9btVector3S2_tP22btOverlappingPairCacheb;
        var Sa = env.__ZN30btKinematicCharacterControllerC1EP24btPairCachingGhostObjectP13btConvexShapefi;
        var Ta = env.__ZN21btConeTwistConstraintC1ER11btRigidBodyS1_RK11btTransformS4_;
        var Ua = env.__ZN21btConeTwistConstraintC1ER11btRigidBodyRK11btTransform;
        var Va = env.__ZN14btCapsuleShapeC1Eff;
        var Wa = env.__ZN15btCompoundShape23removeChildShapeByIndexEi;
        var Xa = env._pthread_cleanup_push;
        var Ya = env.__ZN15btCapsuleShapeZC1Eff;
        var Za = env.___syscall140;
        var _a = env.__ZN30btKinematicCharacterController11setMaxSlopeEf;
        var $a = env.__ZN16btCollisionWorld15contactPairTestEP17btCollisionObjectS1_RNS_21ContactResultCallbackE;
        var ab = env.___syscall146;
        var bb = env.__ZNK16btCollisionWorld15convexSweepTestEPK13btConvexShapeRK11btTransformS5_RNS_20ConvexResultCallbackEf;
        var cb = env._pthread_cleanup_pop;
        var db = env.__ZN16btRaycastVehicleC1ERKNS_15btVehicleTuningEP11btRigidBodyP18btVehicleRaycaster;
        var eb = env.__ZNK16btRaycastVehicle19getWheelTransformWSEi;
        var fb = env.__ZN15btCylinderShapeC1ERK9btVector3;
        var gb = env.__ZN11btRigidBody12setMassPropsEfRK9btVector3;
        var hb = env.__ZN20btPersistentManifoldC1Ev;
        var ib = env.__ZN16btRaycastVehicle16applyEngineForceEfi;
        var jb = env.___cxa_find_matching_catch;
        var kb = env.__ZN15btCompoundShapeC1Ebi;
        var lb = env.___cxa_guard_release;
        var mb = env.__ZN11btRigidBody19updateInertiaTensorEv;
        var nb = env.__ZN30btKinematicCharacterController12setFallSpeedEf;
        var ob = env.__ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyRK11btTransformb;
        var pb = env.___resumeException;
        var qb = env.__ZN15btCapsuleShapeXC1Eff;
        var rb = env.__ZN16btCylinderShapeZC1ERK9btVector3;
        var sb = env.__ZN29btGeneric6DofSpringConstraint12setStiffnessEif;
        var tb = env.__ZN30btKinematicCharacterController10setGravityEf;
        var ub = env._pthread_once;
        var vb = env.__ZN12btConeShapeXC1Eff;
        var wb = env.__ZN21btConeTwistConstraint14setMotorTargetERK12btQuaternion;
        var xb = env.__ZN11btConeShapeC1Eff;
        var yb = env.___syscall6;
        var zb = env._time;
        var Ab = env.__ZN16btRaycastVehicle12getWheelInfoEi;
        var Bb = env._emscripten_asm_const_8;
        var Cb = env.__ZN29btGeneric6DofSpringConstraint12enableSpringEib;
        var Db = env.__ZN17btHingeConstraintC1ER11btRigidBodyS1_RK9btVector3S4_S4_S4_b;
        var Eb = env.__ZN18btSliderConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b;
        var Fb = env.__ZN29btGeneric6DofSpringConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b;
        var Gb = env.__ZN18btSliderConstraintC1ER11btRigidBodyRK11btTransformb;
        var Hb = env.__ZNK30btKinematicCharacterController10getGravityEv;
        var Ib = env.___cxa_allocate_exception;
        var Jb = env.__ZN23btPoint2PointConstraintC1ER11btRigidBodyRK9btVector3;
        var Kb = env.__ZN23btPoint2PointConstraintC1ER11btRigidBodyS1_RK9btVector3S4_;
        var Lb = env.__ZN11btRigidBodyC1ERKNS_27btRigidBodyConstructionInfoE;
        var Mb = env.__ZN23btGeneric6DofConstraintC1ER11btRigidBodyRK11btTransformb;
        var Nb = env.__ZNK30btKinematicCharacterController11getMaxSlopeEv;
        var Ob = env._pthread_getspecific;
        var Pb = env._emscripten_memcpy_big;
        var Qb = env.__Z22btAlignedAllocInternalji;
        var Rb = env.__ZN21btConeTwistConstraint31setMotorTargetInConstraintSpaceERK12btQuaternion;
        var Sb = env.__ZN30btKinematicCharacterController12setJumpSpeedEf;
        var Tb = env._sqrtf;
        var Ub = env.__ZN31btDefaultCollisionConfigurationC1ERK34btDefaultCollisionConstructionInfo;
        var Vb = env.__ZN16btDbvtBroadphaseC1EP22btOverlappingPairCache;
        var Wb = env._abort;
        var Xb = env.__ZN11btRigidBody10setDampingEff;
        var Yb = env.__ZN16btRaycastVehicle20updateWheelTransformEib;
        var Zb = env.__ZNK17btCollisionObject20forceActivationStateEi;
        var _b = env._cosf;
        var $b = env.__ZN17btConvexHullShapeC1EPKfii;
        var ac = env.__ZN30btKinematicCharacterController14getGhostObjectEv;
        var bc = env.__ZN21btConvexInternalShapeC2Ev;
        var cc = env.__ZN23btGeneric6DofConstraintC1ER11btRigidBodyS1_RK11btTransformS4_b;
        var dc = env.__ZN12btConeShapeZC1Eff;
        var ec = env.__ZN11btRigidBody24setCenterOfMassTransformERK11btTransform;
        var fc = env.__ZN16btRaycastVehicle16setSteeringValueEfi;
        var gc = env.__ZNK17btCollisionObject8activateEb;
        var hc = env.__ZN14btTriangleMesh11addTriangleERK9btVector3S2_S2_b;
        var ic = env.__ZN17btHingeConstraintC1ER11btRigidBodyRK11btTransformb;
        var jc = env.__ZN29btGeneric6DofSpringConstraint10setDampingEif;
        var kc = env._pthread_self;
        var lc = env.__ZNK17btCollisionObject18setActivationStateEi;
        var mc = env.__ZN35btSequentialImpulseConstraintSolverC1Ev;
        var nc = env.__ZN24btPairCachingGhostObjectC1Ev;
        var oc = env._pthread_setspecific;
        var pc = env.___cxa_throw;
        var qc = env.__ZN16btRaycastVehicle8setBrakeEfi;
        var rc = env.__ZN14btTriangleMeshC1Ebb;
        var sc = env.__ZN23btDiscreteDynamicsWorldC1EP12btDispatcherP21btBroadphaseInterfaceP18btConstraintSolverP24btCollisionConfiguration;
        var tc = env.__ZN16btRaycastVehicle8addWheelERK9btVector3S2_S2_ffRKNS_15btVehicleTuningEb;
        var uc = env.__ZN14btAngularLimit3setEfffff;
        var vc = 0;
        function Oc(a) {
            a = a | 0;
            var b = 0;
            b = i;
            i = i + a | 0;
            i = i + 15 & -16;
            return b | 0;
        }
        function Pc() {
            return i | 0;
        }
        function Qc(a) {
            a = a | 0;
            i = a;
        }
        function Rc(a, b) {
            a = a | 0;
            b = b | 0;
            i = a;
            j = b;
        }
        function Sc(a, b) {
            a = a | 0;
            b = b | 0;
            if (!p) {
                p = a;
                q = b;
            }
        }
        function Tc(b) {
            b = b | 0;
            a[k >> 0] = a[b >> 0];
            a[k + 1 >> 0] = a[b + 1 >> 0];
            a[k + 2 >> 0] = a[b + 2 >> 0];
            a[k + 3 >> 0] = a[b + 3 >> 0];
        }
        function Uc(b) {
            b = b | 0;
            a[k >> 0] = a[b >> 0];
            a[k + 1 >> 0] = a[b + 1 >> 0];
            a[k + 2 >> 0] = a[b + 2 >> 0];
            a[k + 3 >> 0] = a[b + 3 >> 0];
            a[k + 4 >> 0] = a[b + 4 >> 0];
            a[k + 5 >> 0] = a[b + 5 >> 0];
            a[k + 6 >> 0] = a[b + 6 >> 0];
            a[k + 7 >> 0] = a[b + 7 >> 0];
        }
        function Vc(a) {
            a = a | 0;
            E = a;
        }
        function Wc() {
            return E | 0;
        }
        function Xc(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function Yc(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function Zc(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function _c(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            c[a + 164 >> 2] = c[b >> 2];
            c[a + 164 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 164 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 164 + 12 >> 2] = c[b + 12 >> 2];
            if ((!(+g[b >> 2] != 1) ? !(+g[b + 4 >> 2] != 1) : 0) ? !(+g[b + 8 >> 2] != 1) : 0) {
                d = 0;
                a = a + 180 | 0;
                c[a >> 2] = d;
                return;
            }
            a = a + 180 | 0;
            c[a >> 2] = d;
            return;
        }
        function $c(a) {
            a = a | 0;
            return c[a + 192 >> 2] | 0;
        }
        function ad(a, b) {
            a = a | 0;
            b = +b;
            g[a + 184 >> 2] = b;
            return;
        }
        function bd(a, b) {
            a = a | 0;
            b = b | 0;
            lc(a | 0, b | 0);
            return;
        }
        function cd(a, b) {
            a = a | 0;
            b = b | 0;
            Zb(a | 0, b | 0);
            return;
        }
        function dd(a) {
            a = a | 0;
            gc(a | 0, 0);
            return;
        }
        function ed(a, b) {
            a = a | 0;
            b = b | 0;
            gc(a | 0, b | 0);
            return;
        }
        function fd(a) {
            a = a | 0;
            a = c[a + 216 >> 2] | 0;
            return ((a | 0) == 2 ? 0 : (a | 0) != 5) | 0;
        }
        function gd(a) {
            a = a | 0;
            return (c[a + 204 >> 2] & 2 | 0) != 0 | 0;
        }
        function hd(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 228 >> 2] = b;
            return;
        }
        function id(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 224 >> 2] = b;
            return;
        }
        function jd(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 232 >> 2] = b;
            return;
        }
        function kd(a) {
            a = a | 0;
            return a + 4 | 0;
        }
        function ld(a) {
            a = a | 0;
            return c[a + 204 >> 2] | 0;
        }
        function md(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 204 >> 2] = b;
            return;
        }
        function nd(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            c[a + 4 >> 2] = c[b >> 2];
            c[a + 4 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 4 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 4 + 12 >> 2] = c[b + 12 >> 2];
            c[a + 20 >> 2] = c[b + 16 >> 2];
            c[a + 20 + 4 >> 2] = c[b + 16 + 4 >> 2];
            c[a + 20 + 8 >> 2] = c[b + 16 + 8 >> 2];
            c[a + 20 + 12 >> 2] = c[b + 16 + 12 >> 2];
            c[a + 36 >> 2] = c[b + 32 >> 2];
            c[a + 36 + 4 >> 2] = c[b + 32 + 4 >> 2];
            c[a + 36 + 8 >> 2] = c[b + 32 + 8 >> 2];
            c[a + 36 + 12 >> 2] = c[b + 32 + 12 >> 2];
            c[a + 52 >> 2] = c[b + 48 >> 2];
            c[a + 52 + 4 >> 2] = c[b + 48 + 4 >> 2];
            c[a + 52 + 8 >> 2] = c[b + 48 + 8 >> 2];
            c[a + 52 + 12 >> 2] = c[b + 48 + 12 >> 2];
            return;
        }
        function od(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 8 >> 2] & 3](a, b);
            return;
        }
        function pd(a, b) {
            a = a | 0;
            b = +b;
            g[a + 256 >> 2] = b;
            return;
        }
        function qd(a, b) {
            a = a | 0;
            b = +b;
            g[a + 252 >> 2] = b;
            return;
        }
        function rd(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function sd(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function td(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function ud(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function vd(a) {
            a = a | 0;
            return c[a + 24 >> 2] | 0;
        }
        function wd(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            Lc[c[(c[a >> 2] | 0) + 32 >> 2] & 3](a, b, d, e);
            return;
        }
        function xd(a) {
            a = a | 0;
            a = c[a + 68 >> 2] | 0;
            return Gc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a) | 0;
        }
        function yd(a) {
            a = a | 0;
            return a + 28 | 0;
        }
        function zd(a, b) {
            a = a | 0;
            b = b | 0;
            Lc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a, b, 1, -1);
            return;
        }
        function Ad(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            Lc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a, b, d, -1);
            return;
        }
        function Bd(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            Lc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a, b, d, e);
            return;
        }
        function Cd(a) {
            a = a | 0;
            return c[a + 68 >> 2] | 0;
        }
        function Dd(a, b, c, d, e, f) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = +f;
            bb(a | 0, b | 0, c | 0, d | 0, e | 0, +f);
            return;
        }
        function Ed(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            $a(a | 0, b | 0, c | 0, d | 0);
            return;
        }
        function Fd(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Gd(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 21 >> 0] = c & 1;
            return;
        }
        function Hd(a) {
            a = a | 0;
            return + +g[a + 16 >> 2];
        }
        function Id(a, b) {
            a = a | 0;
            b = +b;
            g[a + 16 >> 2] = b;
            return;
        }
        function Jd(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Kd(a, b) {
            a = +a;
            b = +b;
            var c = 0;
            c = Qb(60, 16) | 0;
            Va(c | 0, +a, +b);
            return c | 0;
        }
        function Ld(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function Md(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function Nd(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function Od(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function Pd(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Qd(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            var d = 0;
            d = Qb(1312, 16) | 0;
            Mb(d | 0, a | 0, b | 0, c | 0);
            return d | 0;
        }
        function Rd(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            var f = 0;
            f = Qb(1312, 16) | 0;
            cc(f | 0, a | 0, b | 0, c | 0, d | 0, e | 0);
            return f | 0;
        }
        function Sd(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 680 >> 2] = c[b >> 2];
            c[a + 680 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 680 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 680 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Td(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 696 >> 2] = c[b >> 2];
            c[a + 696 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 696 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 696 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Ud(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = 0;
            while (1) {
                if ((c | 0) == 3) break;
                g[a + 868 + (c << 6) >> 2] = +_p(+g[b + (c << 2) >> 2]);
                c = c + 1 | 0;
            }
            return;
        }
        function Vd(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = 0;
            while (1) {
                if ((c | 0) == 3) break;
                g[a + 868 + (c << 6) + 4 >> 2] = +_p(+g[b + (c << 2) >> 2]);
                c = c + 1 | 0;
            }
            return;
        }
        function Wd(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 21 >> 0] = c & 1;
            return;
        }
        function Xd(a) {
            a = a | 0;
            return + +g[a + 16 >> 2];
        }
        function Yd(a, b) {
            a = a | 0;
            b = +b;
            g[a + 16 >> 2] = b;
            return;
        }
        function Zd(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function _d(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function $d(a) {
            a = a | 0;
            return +g[a + 4 >> 2] < 1 | 0;
        }
        function ae(a) {
            a = a | 0;
            return b[a + 8 >> 1] | 0;
        }
        function be(a, c) {
            a = a | 0;
            c = c | 0;
            b[a + 8 >> 1] = c;
            return;
        }
        function ce(a) {
            a = a | 0;
            return b[a + 10 >> 1] | 0;
        }
        function de(a, c) {
            a = a | 0;
            c = c | 0;
            b[a + 10 >> 1] = c;
            return;
        }
        function ee(a) {
            a = a | 0;
            return + +g[a + 4 >> 2];
        }
        function fe(a, b) {
            a = a | 0;
            b = +b;
            g[a + 4 >> 2] = b;
            return;
        }
        function ge(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function he(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 8 >> 2] & 3](a, b);
            return;
        }
        function ie(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 12 >> 2] & 3](a, b);
            return;
        }
        function je(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function ke(a, b) {
            a = +a;
            b = +b;
            var c = 0;
            c = Qb(80, 16) | 0;
            xb(c | 0, +a, +b);
            return c | 0;
        }
        function le(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function me(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function ne(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function oe(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function pe(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function qe(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function re(a, b, d, e, f, g, h, i) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            h = h | 0;
            i = i | 0;
            return + +Bc[c[(c[a >> 2] | 0) + 12 >> 2] & 1](a, b, d, e, f, g, h, i);
        }
        function se(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function te(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function ue(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function ve(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function we(a) {
            a = a | 0;
            return Gc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a) | 0;
        }
        function xe(a, b) {
            a = a | 0;
            b = b | 0;
            return Mc[c[(c[a >> 2] | 0) + 40 >> 2] & 3](a, b) | 0;
        }
        function ye(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function ze(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 64 >> 2] & 3](a, b);
            return;
        }
        function Ae(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 68 >> 2] & 3](a, b);
            return;
        }
        function Be(b) {
            b = b | 0;
            var d = 0, e = 0;
            if ((a[8] | 0) == 0 ? (Aa(8) | 0) != 0 : 0) {
                g[72] = .6000000238418579;
                g[73] = 1;
                g[74] = .30000001192092896;
                g[75] = .01666666753590107;
                g[76] = 0;
                g[78] = 20;
                c[77] = 10;
                g[80] = .20000000298023224;
                g[81] = .800000011920929;
                g[82] = 0;
                g[79] = 1;
                c[83] = 1;
                g[84] = -.03999999910593033;
                g[85] = .10000000149011612;
                g[86] = 0;
                g[87] = .8500000238418579;
                c[88] = 260;
                c[89] = 2;
                c[90] = 128;
                g[91] = 100;
                g[92] = 1.0000000150474662e30;
                lb(8);
            }
            e = 288;
            b = b + 92 | 0;
            d = e + 84 | 0;
            do {
                c[e >> 2] = c[b >> 2];
                e = e + 4 | 0;
                b = b + 4 | 0;
            } while ((e | 0) < (d | 0));
            return 288;
        }
        function Ce(a) {
            a = a | 0;
            return c[a + 24 >> 2] | 0;
        }
        function De(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            Lc[c[(c[a >> 2] | 0) + 32 >> 2] & 3](a, b, d, e);
            return;
        }
        function Ee(a) {
            a = a | 0;
            a = c[a + 68 >> 2] | 0;
            return Gc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a) | 0;
        }
        function Fe(a) {
            a = a | 0;
            return a + 28 | 0;
        }
        function Ge(a, b) {
            a = a | 0;
            b = b | 0;
            Lc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a, b, 1, -1);
            return;
        }
        function He(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            Lc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a, b, d, -1);
            return;
        }
        function Ie(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            Lc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a, b, d, e);
            return;
        }
        function Je(a) {
            a = a | 0;
            return c[a + 68 >> 2] | 0;
        }
        function Ke(a, b, c, d, e, f) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = +f;
            bb(a | 0, b | 0, c | 0, d | 0, e | 0, +f);
            return;
        }
        function Le(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            $a(a | 0, b | 0, c | 0, d | 0);
            return;
        }
        function Me(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Ne(a) {
            a = a | 0;
            return (c[a + 8 >> 2] | 0) != 0 | 0;
        }
        function Oe(a) {
            a = a | 0;
            return b[a + 12 >> 1] | 0;
        }
        function Pe(a, c) {
            a = a | 0;
            c = c | 0;
            b[a + 12 >> 1] = c;
            return;
        }
        function Qe(a) {
            a = a | 0;
            return b[a + 14 >> 1] | 0;
        }
        function Re(a, c) {
            a = a | 0;
            c = c | 0;
            b[a + 14 >> 1] = c;
            return;
        }
        function Se(a) {
            a = a | 0;
            return c[a + 8 >> 2] | 0;
        }
        function Te(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 8 >> 2] = b;
            return;
        }
        function Ue(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Ve() {
            return Qb(16, 16) | 0;
        }
        function We(a, b, c) {
            a = +a;
            b = +b;
            c = +c;
            var d = 0;
            d = Qb(16, 16) | 0;
            g[d >> 2] = a;
            g[d + 4 >> 2] = b;
            g[d + 8 >> 2] = c;
            g[d + 12 >> 2] = 0;
            return d | 0;
        }
        function Xe(a) {
            a = a | 0;
            var b = 0, c = 0, d = 0;
            d = +g[a >> 2];
            c = +g[a + 4 >> 2];
            b = +g[a + 8 >> 2];
            return + +Q(+(d * d + c * c + b * b));
        }
        function Ye(a) {
            a = a | 0;
            return + +g[a >> 2];
        }
        function Ze(a) {
            a = a | 0;
            return + +g[a + 4 >> 2];
        }
        function _e(a) {
            a = a | 0;
            return + +g[a + 8 >> 2];
        }
        function $e(a, b) {
            a = a | 0;
            b = +b;
            g[a >> 2] = b;
            return;
        }
        function af(a, b) {
            a = a | 0;
            b = +b;
            g[a + 4 >> 2] = b;
            return;
        }
        function bf(a, b) {
            a = a | 0;
            b = +b;
            g[a + 8 >> 2] = b;
            return;
        }
        function cf(a, b, c, d) {
            a = a | 0;
            b = +b;
            c = +c;
            d = +d;
            g[a >> 2] = b;
            g[a + 4 >> 2] = c;
            g[a + 8 >> 2] = d;
            g[a + 12 >> 2] = 0;
            return;
        }
        function df(a, b) {
            a = a | 0;
            b = +b;
            g[a >> 2] = +g[a >> 2] * b;
            g[a + 4 >> 2] = +g[a + 4 >> 2] * b;
            g[a + 8 >> 2] = +g[a + 8 >> 2] * b;
            return a | 0;
        }
        function ef(a) {
            a = a | 0;
            if (!a) return;
            Ia(a | 0);
            return;
        }
        function ff(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function gf() {
            var a = 0;
            a = Qb(308, 16) | 0;
            ya(a | 0);
            return a | 0;
        }
        function hf(a) {
            a = a | 0;
            return c[a + 292 >> 2] | 0;
        }
        function jf(a, b) {
            a = a | 0;
            b = b | 0;
            return c[(c[a + 300 >> 2] | 0) + (b << 2) >> 2] | 0;
        }
        function kf(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            c[a + 164 >> 2] = c[b >> 2];
            c[a + 164 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 164 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 164 + 12 >> 2] = c[b + 12 >> 2];
            if ((!(+g[b >> 2] != 1) ? !(+g[b + 4 >> 2] != 1) : 0) ? !(+g[b + 8 >> 2] != 1) : 0) {
                d = 0;
                a = a + 180 | 0;
                c[a >> 2] = d;
                return;
            }
            a = a + 180 | 0;
            c[a >> 2] = d;
            return;
        }
        function lf(a) {
            a = a | 0;
            return c[a + 192 >> 2] | 0;
        }
        function mf(a, b) {
            a = a | 0;
            b = +b;
            g[a + 184 >> 2] = b;
            return;
        }
        function nf(a, b) {
            a = a | 0;
            b = b | 0;
            lc(a | 0, b | 0);
            return;
        }
        function of(a, b) {
            a = a | 0;
            b = b | 0;
            Zb(a | 0, b | 0);
            return;
        }
        function pf(a) {
            a = a | 0;
            gc(a | 0, 0);
            return;
        }
        function qf(a, b) {
            a = a | 0;
            b = b | 0;
            gc(a | 0, b | 0);
            return;
        }
        function rf(a) {
            a = a | 0;
            a = c[a + 216 >> 2] | 0;
            return ((a | 0) == 2 ? 0 : (a | 0) != 5) | 0;
        }
        function sf(a) {
            a = a | 0;
            return (c[a + 204 >> 2] & 2 | 0) != 0 | 0;
        }
        function tf(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 228 >> 2] = b;
            return;
        }
        function uf(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 224 >> 2] = b;
            return;
        }
        function vf(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 232 >> 2] = b;
            return;
        }
        function wf(a) {
            a = a | 0;
            return a + 4 | 0;
        }
        function xf(a) {
            a = a | 0;
            return c[a + 204 >> 2] | 0;
        }
        function yf(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 204 >> 2] = b;
            return;
        }
        function zf(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            c[a + 4 >> 2] = c[b >> 2];
            c[a + 4 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 4 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 4 + 12 >> 2] = c[b + 12 >> 2];
            c[a + 20 >> 2] = c[b + 16 >> 2];
            c[a + 20 + 4 >> 2] = c[b + 16 + 4 >> 2];
            c[a + 20 + 8 >> 2] = c[b + 16 + 8 >> 2];
            c[a + 20 + 12 >> 2] = c[b + 16 + 12 >> 2];
            c[a + 36 >> 2] = c[b + 32 >> 2];
            c[a + 36 + 4 >> 2] = c[b + 32 + 4 >> 2];
            c[a + 36 + 8 >> 2] = c[b + 32 + 8 >> 2];
            c[a + 36 + 12 >> 2] = c[b + 32 + 12 >> 2];
            c[a + 52 >> 2] = c[b + 48 >> 2];
            c[a + 52 + 4 >> 2] = c[b + 48 + 4 >> 2];
            c[a + 52 + 8 >> 2] = c[b + 48 + 8 >> 2];
            c[a + 52 + 12 >> 2] = c[b + 48 + 12 >> 2];
            return;
        }
        function Af(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 8 >> 2] & 3](a, b);
            return;
        }
        function Bf(a, b) {
            a = a | 0;
            b = +b;
            g[a + 256 >> 2] = b;
            return;
        }
        function Cf(a, b) {
            a = a | 0;
            b = +b;
            g[a + 252 >> 2] = b;
            return;
        }
        function Df(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Ef(a) {
            a = a | 0;
            return + +g[a >> 2];
        }
        function Ff(a) {
            a = a | 0;
            return + +g[a + 4 >> 2];
        }
        function Gf(a) {
            a = a | 0;
            return + +g[a + 8 >> 2];
        }
        function Hf(a) {
            a = a | 0;
            return + +g[a + 12 >> 2];
        }
        function If(a, b) {
            a = a | 0;
            b = +b;
            g[a >> 2] = b;
            return;
        }
        function Jf(a, b) {
            a = a | 0;
            b = +b;
            g[a + 4 >> 2] = b;
            return;
        }
        function Kf(a, b) {
            a = a | 0;
            b = +b;
            g[a + 8 >> 2] = b;
            return;
        }
        function Lf(a, b) {
            a = a | 0;
            b = +b;
            g[a + 12 >> 2] = b;
            return;
        }
        function Mf(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function Nf(a) {
            a = a | 0;
            var b = 0;
            b = Qb(60, 16) | 0;
            fb(b | 0, a | 0);
            return b | 0;
        }
        function Of(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function Pf(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function Qf(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function Rf(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function Sf(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Tf(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Uf(a, b, d, e) {
            a = a | 0;
            b = +b;
            d = +d;
            e = +e;
            var f = 0, h = 0, j = 0, k = 0;
            f = i;
            i = i + 32 | 0;
            k = +S(+b);
            h = +S(+d);
            j = +S(+e);
            b = +T(+b);
            d = +T(+d);
            e = +T(+e);
            g[f + 20 >> 2] = d * (b * j) - k * e;
            g[f + 16 >> 2] = d * (k * j) + b * e;
            g[f + 12 >> 2] = d * (b * e) + k * j;
            g[f + 8 >> 2] = d * (k * e) - b * j;
            g[f + 4 >> 2] = h * b;
            g[f >> 2] = h * k;
            g[a >> 2] = h * j;
            c[a + 4 >> 2] = c[f + 20 >> 2];
            c[a + 8 >> 2] = c[f + 16 >> 2];
            g[a + 12 >> 2] = 0;
            g[a + 16 >> 2] = h * e;
            c[a + 20 >> 2] = c[f + 12 >> 2];
            c[a + 24 >> 2] = c[f + 8 >> 2];
            g[a + 28 >> 2] = 0;
            g[a + 32 >> 2] = -d;
            c[a + 36 >> 2] = c[f + 4 >> 2];
            c[a + 40 >> 2] = c[f >> 2];
            g[a + 44 >> 2] = 0;
            i = f;
            return;
        }
        function Vf(a, b) {
            a = a | 0;
            b = b | 0;
            Cp(a, b);
            return;
        }
        function Wf(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function Xf() {
            var a = 0, d = 0;
            a = Bq(8) | 0;
            a: do {
                if (!a) {
                    while (1) {
                        a = c[187] | 0;
                        c[187] = a + 0;
                        if (!a) break;
                        Ic[a & 3]();
                        a = Bq(8) | 0;
                        if (a) break a;
                    }
                    a = Ib(4) | 0;
                    c[a >> 2] = 736;
                    pc(a | 0, 176, 11);
                }
            } while (0);
            d = a;
            c[d >> 2] = 0;
            c[d + 4 >> 2] = 0;
            b[a + 4 >> 1] = 1;
            b[a + 6 >> 1] = -1;
            c[a >> 2] = 708;
            return a | 0;
        }
        function Yf(a, b, d, e, f, g, h, i) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            h = h | 0;
            i = i | 0;
            return + +Bc[c[(c[a >> 2] | 0) + 12 >> 2] & 1](a, b, d, e, f, g, h, i);
        }
        function Zf(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function _f(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = Qb(80, 16) | 0;
            Ka(c | 0, a | 0, b | 0, 1);
            return c | 0;
        }
        function $f(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            var d = 0;
            d = Qb(80, 16) | 0;
            Ka(d | 0, a | 0, b | 0, c | 0);
            return d | 0;
        }
        function ag(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function bg(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function cg(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function dg() {
            var a = 0;
            a = Bq(196) | 0;
            a: do {
                if (!a) {
                    while (1) {
                        a = c[187] | 0;
                        c[187] = a + 0;
                        if (!a) break;
                        Ic[a & 3]();
                        a = Bq(196) | 0;
                        if (a) break a;
                    }
                    a = Ib(4) | 0;
                    c[a >> 2] = 736;
                    pc(a | 0, 176, 11);
                }
            } while (0);
            Vb(a | 0, 0);
            return a | 0;
        }
        function eg(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function fg(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function gg() {
            var a = 0;
            a = Qb(204, 16) | 0;
            mc(a | 0);
            return a | 0;
        }
        function hg(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function ig(a) {
            a = a | 0;
            return + +g[a >> 2];
        }
        function jg(a, b) {
            a = a | 0;
            b = +b;
            g[a >> 2] = b;
            return;
        }
        function kg(a) {
            a = a | 0;
            return c[a + 4 >> 2] | 0;
        }
        function lg(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 4 >> 2] = b;
            return;
        }
        function mg(a) {
            a = a | 0;
            return c[a + 8 >> 2] | 0;
        }
        function ng(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 8 >> 2] = b;
            return;
        }
        function og(a) {
            a = a | 0;
            return + +g[a + 12 >> 2];
        }
        function pg(a, b) {
            a = a | 0;
            b = +b;
            g[a + 12 >> 2] = b;
            return;
        }
        function qg(b) {
            b = b | 0;
            return (a[b + 16 >> 0] & 1) != 0 | 0;
        }
        function rg(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 16 >> 0] = c & 1;
            return;
        }
        function sg(b) {
            b = b | 0;
            return (a[b + 24 >> 0] & 1) != 0 | 0;
        }
        function tg(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 24 >> 0] = c & 1;
            return;
        }
        function ug(b) {
            b = b | 0;
            return (a[b + 25 >> 0] & 1) != 0 | 0;
        }
        function vg(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 25 >> 0] = c & 1;
            return;
        }
        function wg(b) {
            b = b | 0;
            return (a[b + 26 >> 0] & 1) != 0 | 0;
        }
        function xg(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 26 >> 0] = c & 1;
            return;
        }
        function yg(a) {
            a = a | 0;
            return + +g[a + 28 >> 2];
        }
        function zg(a, b) {
            a = a | 0;
            b = +b;
            g[a + 28 >> 2] = b;
            return;
        }
        function Ag(b) {
            b = b | 0;
            return (a[b + 32 >> 0] & 1) != 0 | 0;
        }
        function Bg(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 32 >> 0] = c & 1;
            return;
        }
        function Cg(a) {
            a = a | 0;
            return + +g[a + 36 >> 2];
        }
        function Dg(a, b) {
            a = a | 0;
            b = +b;
            g[a + 36 >> 2] = b;
            return;
        }
        function Eg(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function Fg(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Gg(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = Qb(116, 16) | 0;
            Ra(c | 0, a | 0, b | 0, 16384, 0, 0);
            return c | 0;
        }
        function Hg(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            var d = 0;
            d = Qb(116, 16) | 0;
            Ra(d | 0, a | 0, b | 0, c & 65535 | 0, 0, 0);
            return d | 0;
        }
        function Ig(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            var e = 0;
            e = Qb(116, 16) | 0;
            Ra(e | 0, a | 0, b | 0, c & 65535 | 0, d | 0, 0);
            return e | 0;
        }
        function Jg(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            var f = 0;
            f = Qb(116, 16) | 0;
            Ra(f | 0, a | 0, b | 0, c & 65535 | 0, d | 0, e | 0);
            return f | 0;
        }
        function Kg(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Lg() {
            var a = 0;
            a = Qb(312, 16) | 0;
            nc(a | 0);
            return a | 0;
        }
        function Mg(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            c[a + 164 >> 2] = c[b >> 2];
            c[a + 164 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 164 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 164 + 12 >> 2] = c[b + 12 >> 2];
            if ((!(+g[b >> 2] != 1) ? !(+g[b + 4 >> 2] != 1) : 0) ? !(+g[b + 8 >> 2] != 1) : 0) {
                d = 0;
                a = a + 180 | 0;
                c[a >> 2] = d;
                return;
            }
            a = a + 180 | 0;
            c[a >> 2] = d;
            return;
        }
        function Ng(a) {
            a = a | 0;
            return c[a + 192 >> 2] | 0;
        }
        function Og(a, b) {
            a = a | 0;
            b = +b;
            g[a + 184 >> 2] = b;
            return;
        }
        function Pg(a, b) {
            a = a | 0;
            b = b | 0;
            lc(a | 0, b | 0);
            return;
        }
        function Qg(a, b) {
            a = a | 0;
            b = b | 0;
            Zb(a | 0, b | 0);
            return;
        }
        function Rg(a) {
            a = a | 0;
            gc(a | 0, 0);
            return;
        }
        function Sg(a, b) {
            a = a | 0;
            b = b | 0;
            gc(a | 0, b | 0);
            return;
        }
        function Tg(a) {
            a = a | 0;
            a = c[a + 216 >> 2] | 0;
            return ((a | 0) == 2 ? 0 : (a | 0) != 5) | 0;
        }
        function Ug(a) {
            a = a | 0;
            return (c[a + 204 >> 2] & 2 | 0) != 0 | 0;
        }
        function Vg(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 228 >> 2] = b;
            return;
        }
        function Wg(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 224 >> 2] = b;
            return;
        }
        function Xg(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 232 >> 2] = b;
            return;
        }
        function Yg(a) {
            a = a | 0;
            return a + 4 | 0;
        }
        function Zg(a) {
            a = a | 0;
            return c[a + 204 >> 2] | 0;
        }
        function _g(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 204 >> 2] = b;
            return;
        }
        function $g(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            c[a + 4 >> 2] = c[b >> 2];
            c[a + 4 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 4 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 4 + 12 >> 2] = c[b + 12 >> 2];
            c[a + 20 >> 2] = c[b + 16 >> 2];
            c[a + 20 + 4 >> 2] = c[b + 16 + 4 >> 2];
            c[a + 20 + 8 >> 2] = c[b + 16 + 8 >> 2];
            c[a + 20 + 12 >> 2] = c[b + 16 + 12 >> 2];
            c[a + 36 >> 2] = c[b + 32 >> 2];
            c[a + 36 + 4 >> 2] = c[b + 32 + 4 >> 2];
            c[a + 36 + 8 >> 2] = c[b + 32 + 8 >> 2];
            c[a + 36 + 12 >> 2] = c[b + 32 + 12 >> 2];
            c[a + 52 >> 2] = c[b + 48 >> 2];
            c[a + 52 + 4 >> 2] = c[b + 48 + 4 >> 2];
            c[a + 52 + 8 >> 2] = c[b + 48 + 8 >> 2];
            c[a + 52 + 12 >> 2] = c[b + 48 + 12 >> 2];
            return;
        }
        function ah(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 8 >> 2] & 3](a, b);
            return;
        }
        function bh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 256 >> 2] = b;
            return;
        }
        function ch(a, b) {
            a = a | 0;
            b = +b;
            g[a + 252 >> 2] = b;
            return;
        }
        function dh(a) {
            a = a | 0;
            return c[a + 292 >> 2] | 0;
        }
        function eh(a, b) {
            a = a | 0;
            b = b | 0;
            return c[(c[a + 300 >> 2] | 0) + (b << 2) >> 2] | 0;
        }
        function fh(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function gh(b, d, e) {
            b = +b;
            d = d | 0;
            e = e | 0;
            var f = 0;
            f = Bq(140) | 0;
            a: do {
                if (!f) {
                    while (1) {
                        f = c[187] | 0;
                        c[187] = f + 0;
                        if (!f) break;
                        Ic[f & 3]();
                        f = Bq(140) | 0;
                        if (f) break a;
                    }
                    e = Ib(4) | 0;
                    c[e >> 2] = 736;
                    pc(e | 0, 176, 11);
                }
            } while (0);
            g[f >> 2] = b;
            c[f + 4 >> 2] = d;
            c[f + 72 >> 2] = e;
            e = f + 76 | 0;
            c[e >> 2] = 0;
            c[e + 4 >> 2] = 0;
            c[e + 8 >> 2] = 0;
            c[e + 12 >> 2] = 0;
            c[e + 16 >> 2] = 0;
            c[e + 20 >> 2] = 0;
            g[f + 100 >> 2] = .5;
            g[f + 104 >> 2] = 0;
            g[f + 108 >> 2] = 0;
            g[f + 112 >> 2] = .800000011920929;
            g[f + 116 >> 2] = 1;
            a[f + 120 >> 0] = 0;
            g[f + 124 >> 2] = .004999999888241291;
            g[f + 128 >> 2] = .009999999776482582;
            g[f + 132 >> 2] = .009999999776482582;
            g[f + 136 >> 2] = .009999999776482582;
            Gp(f + 8 | 0);
            return f | 0;
        }
        function hh(b, d, e, f) {
            b = +b;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            var h = 0;
            h = Bq(140) | 0;
            a: do {
                if (!h) {
                    while (1) {
                        h = c[187] | 0;
                        c[187] = h + 0;
                        if (!h) break;
                        Ic[h & 3]();
                        h = Bq(140) | 0;
                        if (h) break a;
                    }
                    f = Ib(4) | 0;
                    c[f >> 2] = 736;
                    pc(f | 0, 176, 11);
                }
            } while (0);
            g[h >> 2] = b;
            c[h + 4 >> 2] = d;
            c[h + 72 >> 2] = e;
            e = h + 76 | 0;
            c[e >> 2] = c[f >> 2];
            c[e + 4 >> 2] = c[f + 4 >> 2];
            c[e + 8 >> 2] = c[f + 8 >> 2];
            c[e + 12 >> 2] = c[f + 12 >> 2];
            g[h + 92 >> 2] = 0;
            g[h + 96 >> 2] = 0;
            g[h + 100 >> 2] = .5;
            g[h + 104 >> 2] = 0;
            g[h + 108 >> 2] = 0;
            g[h + 112 >> 2] = .800000011920929;
            g[h + 116 >> 2] = 1;
            a[h + 120 >> 0] = 0;
            g[h + 124 >> 2] = .004999999888241291;
            g[h + 128 >> 2] = .009999999776482582;
            g[h + 132 >> 2] = .009999999776482582;
            g[h + 136 >> 2] = .009999999776482582;
            Gp(h + 8 | 0);
            return h | 0;
        }
        function ih(a) {
            a = a | 0;
            return + +g[a + 92 >> 2];
        }
        function jh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 92 >> 2] = b;
            return;
        }
        function kh(a) {
            a = a | 0;
            return + +g[a + 96 >> 2];
        }
        function lh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 96 >> 2] = b;
            return;
        }
        function mh(a) {
            a = a | 0;
            return + +g[a + 100 >> 2];
        }
        function nh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 100 >> 2] = b;
            return;
        }
        function oh(a) {
            a = a | 0;
            return + +g[a + 104 >> 2];
        }
        function ph(a, b) {
            a = a | 0;
            b = +b;
            g[a + 104 >> 2] = b;
            return;
        }
        function qh(a) {
            a = a | 0;
            return + +g[a + 108 >> 2];
        }
        function rh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 108 >> 2] = b;
            return;
        }
        function sh(a) {
            a = a | 0;
            return + +g[a + 112 >> 2];
        }
        function th(a, b) {
            a = a | 0;
            b = +b;
            g[a + 112 >> 2] = b;
            return;
        }
        function uh(a) {
            a = a | 0;
            return + +g[a + 116 >> 2];
        }
        function vh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 116 >> 2] = b;
            return;
        }
        function wh(b) {
            b = b | 0;
            return (a[b + 120 >> 0] & 1) != 0 | 0;
        }
        function xh(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 120 >> 0] = c & 1;
            return;
        }
        function yh(a) {
            a = a | 0;
            return + +g[a + 124 >> 2];
        }
        function zh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 124 >> 2] = b;
            return;
        }
        function Ah(a) {
            a = a | 0;
            return + +g[a + 128 >> 2];
        }
        function Bh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 128 >> 2] = b;
            return;
        }
        function Ch(a) {
            a = a | 0;
            return + +g[a + 132 >> 2];
        }
        function Dh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 132 >> 2] = b;
            return;
        }
        function Eh(a) {
            a = a | 0;
            return + +g[a + 136 >> 2];
        }
        function Fh(a, b) {
            a = a | 0;
            b = +b;
            g[a + 136 >> 2] = b;
            return;
        }
        function Gh(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function Hh(a) {
            a = a | 0;
            return a + 48 | 0;
        }
        function Ih(a) {
            a = a | 0;
            return a + 32 | 0;
        }
        function Jh(a) {
            a = a | 0;
            return + +g[a + 80 >> 2];
        }
        function Kh(a) {
            a = a | 0;
            return a | 0;
        }
        function Lh(a, b) {
            a = a | 0;
            b = b | 0;
            c[a >> 2] = c[b >> 2];
            c[a + 4 >> 2] = c[b + 4 >> 2];
            c[a + 8 >> 2] = c[b + 8 >> 2];
            c[a + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Mh(a) {
            a = a | 0;
            return a + 16 | 0;
        }
        function Nh(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 16 >> 2] = c[b >> 2];
            c[a + 16 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 16 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 16 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Oh(a) {
            a = a | 0;
            return a + 32 | 0;
        }
        function Ph(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 32 >> 2] = c[b >> 2];
            c[a + 32 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 32 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 32 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Qh(a) {
            a = a | 0;
            return a + 48 | 0;
        }
        function Rh(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 48 >> 2] = c[b >> 2];
            c[a + 48 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 48 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 48 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Sh(a) {
            a = a | 0;
            return a + 64 | 0;
        }
        function Th(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 64 >> 2] = c[b >> 2];
            c[a + 64 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 64 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 64 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Uh(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function Vh(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Wh(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            var e = 0;
            e = Qb(324, 16) | 0;
            sc(e | 0, a | 0, b | 0, c | 0, d | 0);
            return e | 0;
        }
        function Xh(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 72 >> 2] & 3](a, b);
            return;
        }
        function Yh(b) {
            b = b | 0;
            var d = 0;
            d = i;
            i = i + 16 | 0;
            if ((a[16] | 0) == 0 ? (Aa(16) | 0) != 0 : 0) lb(16);
            Fc[c[(c[b >> 2] | 0) + 76 >> 2] & 3](d, b);
            c[93] = c[d >> 2];
            c[94] = c[d + 4 >> 2];
            c[95] = c[d + 8 >> 2];
            c[96] = c[d + 12 >> 2];
            i = d;
            return 372;
        }
        function Zh(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 84 >> 2] & 3](a, b);
            return;
        }
        function _h(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            Lc[c[(c[a >> 2] | 0) + 88 >> 2] & 3](a, b, d, e);
            return;
        }
        function $h(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 92 >> 2] & 3](a, b);
            return;
        }
        function ai(a, b) {
            a = a | 0;
            b = b | 0;
            Hc[c[(c[a >> 2] | 0) + 56 >> 2] & 1](a, b, 0);
            return;
        }
        function bi(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            Hc[c[(c[a >> 2] | 0) + 56 >> 2] & 1](a, b, d);
            return;
        }
        function ci(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 60 >> 2] & 3](a, b);
            return;
        }
        function di(a, b) {
            a = a | 0;
            b = +b;
            return Ec[c[(c[a >> 2] | 0) + 52 >> 2] & 0](a, b, 1, .01666666753590107) | 0;
        }
        function ei(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            return Ec[c[(c[a >> 2] | 0) + 52 >> 2] & 0](a, b, d, .01666666753590107) | 0;
        }
        function fi(a, b, d, e) {
            a = a | 0;
            b = +b;
            d = d | 0;
            e = +e;
            return Ec[c[(c[a >> 2] | 0) + 52 >> 2] & 0](a, b, d, e) | 0;
        }
        function gi(a) {
            a = a | 0;
            return c[a + 24 >> 2] | 0;
        }
        function hi(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            Lc[c[(c[a >> 2] | 0) + 32 >> 2] & 3](a, b, d, e);
            return;
        }
        function ii(a) {
            a = a | 0;
            a = c[a + 68 >> 2] | 0;
            return Gc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a) | 0;
        }
        function ji(a) {
            a = a | 0;
            return a + 28 | 0;
        }
        function ki(a, b) {
            a = a | 0;
            b = b | 0;
            Lc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a, b, 2, -3);
            return;
        }
        function li(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            Lc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a, b, d, -3);
            return;
        }
        function mi(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            Lc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a, b, d, e);
            return;
        }
        function ni(a) {
            a = a | 0;
            return c[a + 68 >> 2] | 0;
        }
        function oi(a, b, c, d, e, f) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = +f;
            bb(a | 0, b | 0, c | 0, d | 0, e | 0, +f);
            return;
        }
        function pi(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            $a(a | 0, b | 0, c | 0, d | 0);
            return;
        }
        function qi(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 64 >> 2] & 3](a, b);
            return;
        }
        function ri(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 68 >> 2] & 3](a, b);
            return;
        }
        function si(b) {
            b = b | 0;
            var d = 0, e = 0;
            if ((a[24] | 0) == 0 ? (Aa(24) | 0) != 0 : 0) {
                g[97] = .6000000238418579;
                g[98] = 1;
                g[99] = .30000001192092896;
                g[100] = .01666666753590107;
                g[101] = 0;
                g[103] = 20;
                c[102] = 10;
                g[105] = .20000000298023224;
                g[106] = .800000011920929;
                g[107] = 0;
                g[104] = 1;
                c[108] = 1;
                g[109] = -.03999999910593033;
                g[110] = .10000000149011612;
                g[111] = 0;
                g[112] = .8500000238418579;
                c[113] = 260;
                c[114] = 2;
                c[115] = 128;
                g[116] = 100;
                g[117] = 1.0000000150474662e30;
                lb(24);
            }
            e = 388;
            b = b + 92 | 0;
            d = e + 84 | 0;
            do {
                c[e >> 2] = c[b >> 2];
                e = e + 4 | 0;
                b = b + 4 | 0;
            } while ((e | 0) < (d | 0));
            return 388;
        }
        function ti(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function ui(a) {
            a = a | 0;
            var b = 0;
            b = Qb(100, 16) | 0;
            Da(b | 0, a | 0, 1);
            return b | 0;
        }
        function vi(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = Qb(100, 16) | 0;
            Da(c | 0, a | 0, b | 0);
            return c | 0;
        }
        function wi(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function xi(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function yi(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function zi(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = Qb(360, 16) | 0;
            Jb(c | 0, a | 0, b | 0);
            return c | 0;
        }
        function Ai(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            var e = 0;
            e = Qb(360, 16) | 0;
            Kb(e | 0, a | 0, b | 0, c | 0, d | 0);
            return e | 0;
        }
        function Bi(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 300 >> 2] = c[b >> 2];
            c[a + 300 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 300 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 300 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Ci(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 316 >> 2] = c[b >> 2];
            c[a + 316 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 316 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 316 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Di(a) {
            a = a | 0;
            return a + 300 | 0;
        }
        function Ei(a) {
            a = a | 0;
            return a + 316 | 0;
        }
        function Fi(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 21 >> 0] = c & 1;
            return;
        }
        function Gi(a) {
            a = a | 0;
            return + +g[a + 16 >> 2];
        }
        function Hi(a, b) {
            a = a | 0;
            b = +b;
            g[a + 16 >> 2] = b;
            return;
        }
        function Ii(a) {
            a = a | 0;
            return a + 348 | 0;
        }
        function Ji(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 348 >> 2] = c[b >> 2];
            c[a + 348 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 348 + 8 >> 2] = c[b + 8 >> 2];
            return;
        }
        function Ki(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Li(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            var d = 0;
            d = Qb(1128, 16) | 0;
            Gb(d | 0, a | 0, b | 0, c | 0);
            return d | 0;
        }
        function Mi(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            var f = 0;
            f = Qb(1128, 16) | 0;
            Eb(f | 0, a | 0, b | 0, c | 0, d | 0, e | 0);
            return f | 0;
        }
        function Ni(a, b) {
            a = a | 0;
            b = +b;
            g[a + 184 >> 2] = b;
            return;
        }
        function Oi(a, b) {
            a = a | 0;
            b = +b;
            g[a + 188 >> 2] = b;
            return;
        }
        function Pi(a, b) {
            a = a | 0;
            b = +b;
            g[a + 192 >> 2] = +_p(b);
            return;
        }
        function Qi(a, b) {
            a = a | 0;
            b = +b;
            g[a + 196 >> 2] = +_p(b);
            return;
        }
        function Ri(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 21 >> 0] = c & 1;
            return;
        }
        function Si(a) {
            a = a | 0;
            return + +g[a + 16 >> 2];
        }
        function Ti(a, b) {
            a = a | 0;
            b = +b;
            g[a + 16 >> 2] = b;
            return;
        }
        function Ui(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Vi(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = Qb(608, 16) | 0;
            Ua(c | 0, a | 0, b | 0);
            return c | 0;
        }
        function Wi(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            var e = 0;
            e = Qb(608, 16) | 0;
            Ta(e | 0, a | 0, b | 0, c | 0, d | 0);
            return e | 0;
        }
        function Xi(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = +c;
            switch (b | 0) {
              case 3:
                {
                    g[a + 452 >> 2] = c;
                    return;
                }

              case 4:
                {
                    g[a + 448 >> 2] = c;
                    return;
                }

              case 5:
                {
                    g[a + 444 >> 2] = c;
                    return;
                }

              default:
                return;
            }
        }
        function Yi(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 524 >> 0] = c & 1;
            return;
        }
        function Zi(a, b) {
            a = a | 0;
            b = +b;
            g[a + 440 >> 2] = b;
            return;
        }
        function _i(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 552 >> 0] = c & 1;
            return;
        }
        function $i(b, c) {
            b = b | 0;
            c = +c;
            g[b + 572 >> 2] = c;
            a[b + 553 >> 0] = 0;
            return;
        }
        function aj(b, c) {
            b = b | 0;
            c = +c;
            g[b + 572 >> 2] = c;
            a[b + 553 >> 0] = 1;
            return;
        }
        function bj(a, b) {
            a = a | 0;
            b = b | 0;
            wb(a | 0, b | 0);
            return;
        }
        function cj(a, b) {
            a = a | 0;
            b = b | 0;
            Rb(a | 0, b | 0);
            return;
        }
        function dj(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 21 >> 0] = c & 1;
            return;
        }
        function ej(a) {
            a = a | 0;
            return + +g[a + 16 >> 2];
        }
        function fj(a, b) {
            a = a | 0;
            b = +b;
            g[a + 16 >> 2] = b;
            return;
        }
        function gj(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function hj() {
            var a = 0, b = 0;
            b = i;
            i = i + 32 | 0;
            a = Bq(92) | 0;
            a: do {
                if (!a) {
                    while (1) {
                        a = c[187] | 0;
                        c[187] = a + 0;
                        if (!a) break;
                        Ic[a & 3]();
                        a = Bq(92) | 0;
                        if (a) break a;
                    }
                    b = Ib(4) | 0;
                    c[b >> 2] = 736;
                    pc(b | 0, 176, 11);
                }
            } while (0);
            c[b >> 2] = 0;
            c[b + 4 >> 2] = 0;
            c[b + 8 >> 2] = 4096;
            c[b + 12 >> 2] = 4096;
            c[b + 16 >> 2] = 0;
            c[b + 20 >> 2] = 1;
            Ub(a | 0, b | 0);
            i = b;
            return a | 0;
        }
        function ij(a) {
            a = a | 0;
            var b = 0;
            b = Bq(92) | 0;
            a: do {
                if (!b) {
                    while (1) {
                        b = c[187] | 0;
                        c[187] = b + 0;
                        if (!b) break;
                        Ic[b & 3]();
                        b = Bq(92) | 0;
                        if (b) break a;
                    }
                    a = Ib(4) | 0;
                    c[a >> 2] = 736;
                    pc(a | 0, 176, 11);
                }
            } while (0);
            Ub(b | 0, a | 0);
            return b | 0;
        }
        function jj(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function kj(a, b) {
            a = +a;
            b = +b;
            var c = 0;
            c = Qb(80, 16) | 0;
            dc(c | 0, +a, +b);
            return c | 0;
        }
        function lj(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function mj(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function nj(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function oj(a, b) {
            a = +a;
            b = +b;
            var c = 0;
            c = Qb(80, 16) | 0;
            vb(c | 0, +a, +b);
            return c | 0;
        }
        function pj(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function qj(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function rj(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function sj() {
            var a = 0;
            a = Qb(172, 16) | 0;
            rc(a | 0, 1, 1);
            return a | 0;
        }
        function tj(a) {
            a = a | 0;
            var b = 0;
            b = Qb(172, 16) | 0;
            rc(b | 0, a | 0, 1);
            return b | 0;
        }
        function uj(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = Qb(172, 16) | 0;
            rc(c | 0, a | 0, b | 0);
            return c | 0;
        }
        function vj(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            hc(a | 0, b | 0, c | 0, d | 0, 0);
            return;
        }
        function wj(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            hc(a | 0, b | 0, c | 0, d | 0, e | 0);
            return;
        }
        function xj(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function yj() {
            var a = 0;
            a = Qb(116, 16) | 0;
            $b(a | 0, 0, 0, 16);
            return a | 0;
        }
        function zj(a, b) {
            a = a | 0;
            b = b | 0;
            Ba(a | 0, b | 0, 1);
            return;
        }
        function Aj(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            Ba(a | 0, b | 0, c | 0);
            return;
        }
        function Bj(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function Cj(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function Dj(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function Ej(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function Fj(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Gj() {
            var a = 0;
            a = Qb(772, 16) | 0;
            hb(a | 0);
            return a | 0;
        }
        function Hj(a) {
            a = a | 0;
            return c[a + 740 >> 2] | 0;
        }
        function Ij(a) {
            a = a | 0;
            return c[a + 744 >> 2] | 0;
        }
        function Jj(a) {
            a = a | 0;
            return c[a + 748 >> 2] | 0;
        }
        function Kj(a, b) {
            a = a | 0;
            b = b | 0;
            return a + 4 + (b * 184 | 0) | 0;
        }
        function Lj(a) {
            a = a | 0;
            if (!a) return;
            Ia(a | 0);
            return;
        }
        function Mj(a) {
            a = a | 0;
            var b = 0;
            b = Qb(60, 16) | 0;
            za(b | 0, a | 0);
            return b | 0;
        }
        function Nj(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function Oj(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function Pj(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function Qj(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function Rj(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Sj(a) {
            a = a | 0;
            var b = 0;
            b = Bq(5260) | 0;
            a: do {
                if (!b) {
                    while (1) {
                        b = c[187] | 0;
                        c[187] = b + 0;
                        if (!b) break;
                        Ic[b & 3]();
                        b = Bq(5260) | 0;
                        if (b) break a;
                    }
                    a = Ib(4) | 0;
                    c[a >> 2] = 736;
                    pc(a | 0, 176, 11);
                }
            } while (0);
            Ga(b | 0, a | 0);
            return b | 0;
        }
        function Tj(a) {
            a = a | 0;
            return Gc[c[(c[a >> 2] | 0) + 36 >> 2] & 3](a) | 0;
        }
        function Uj(a, b) {
            a = a | 0;
            b = b | 0;
            return Mc[c[(c[a >> 2] | 0) + 40 >> 2] & 3](a, b) | 0;
        }
        function Vj(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Wj() {
            var a = 0;
            a = Bq(24) | 0;
            a: do {
                if (!a) {
                    while (1) {
                        a = c[187] | 0;
                        c[187] = a + 0;
                        if (!a) break;
                        Ic[a & 3]();
                        a = Bq(24) | 0;
                        if (a) break a;
                    }
                    a = Ib(4) | 0;
                    c[a >> 2] = 736;
                    pc(a | 0, 176, 11);
                }
            } while (0);
            g[a >> 2] = 5.880000114440918;
            g[a + 4 >> 2] = .8299999833106995;
            g[a + 8 >> 2] = .8799999952316284;
            g[a + 12 >> 2] = 500;
            g[a + 16 >> 2] = 10.5;
            g[a + 20 >> 2] = 6e3;
            return a | 0;
        }
        function Xj(a) {
            a = a | 0;
            return + +g[a >> 2];
        }
        function Yj(a, b) {
            a = a | 0;
            b = +b;
            g[a >> 2] = b;
            return;
        }
        function Zj(a) {
            a = a | 0;
            return + +g[a + 4 >> 2];
        }
        function _j(a, b) {
            a = a | 0;
            b = +b;
            g[a + 4 >> 2] = b;
            return;
        }
        function $j(a) {
            a = a | 0;
            return + +g[a + 8 >> 2];
        }
        function ak(a, b) {
            a = a | 0;
            b = +b;
            g[a + 8 >> 2] = b;
            return;
        }
        function bk(a) {
            a = a | 0;
            return + +g[a + 12 >> 2];
        }
        function ck(a, b) {
            a = a | 0;
            b = +b;
            g[a + 12 >> 2] = b;
            return;
        }
        function dk(a) {
            a = a | 0;
            return + +g[a + 16 >> 2];
        }
        function ek(a, b) {
            a = a | 0;
            b = +b;
            g[a + 16 >> 2] = b;
            return;
        }
        function fk(a) {
            a = a | 0;
            return + +g[a + 20 >> 2];
        }
        function gk(a, b) {
            a = a | 0;
            b = +b;
            g[a + 20 >> 2] = b;
            return;
        }
        function hk() {
            var a = 0;
            a = Qb(96, 16) | 0;
            kb(a | 0, 1, 0);
            return a | 0;
        }
        function ik(a) {
            a = a | 0;
            var b = 0;
            b = Qb(96, 16) | 0;
            kb(b | 0, a | 0, 0);
            return b | 0;
        }
        function jk(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            Ha(a | 0, b | 0, c | 0);
            return;
        }
        function kk(a, b) {
            a = a | 0;
            b = b | 0;
            Wa(a | 0, b | 0);
            return;
        }
        function lk(a) {
            a = a | 0;
            return c[a + 20 >> 2] | 0;
        }
        function mk(a, b) {
            a = a | 0;
            b = b | 0;
            return c[(c[a + 28 >> 2] | 0) + (b * 80 | 0) + 64 >> 2] | 0;
        }
        function nk(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function ok(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function pk(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function qk(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function rk(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function sk(a, d) {
            a = a | 0;
            d = d | 0;
            var e = 0, f = 0;
            e = Bq(80) | 0;
            a: do {
                if (!e) {
                    while (1) {
                        e = c[187] | 0;
                        c[187] = e + 0;
                        if (!e) break;
                        Ic[e & 3]();
                        e = Bq(80) | 0;
                        if (e) break a;
                    }
                    d = Ib(4) | 0;
                    c[d >> 2] = 736;
                    pc(d | 0, 176, 11);
                }
            } while (0);
            g[e + 4 >> 2] = 1;
            b[e + 8 >> 1] = 1;
            b[e + 10 >> 1] = -1;
            c[e >> 2] = 684;
            f = e + 12 | 0;
            c[f >> 2] = c[a >> 2];
            c[f + 4 >> 2] = c[a + 4 >> 2];
            c[f + 8 >> 2] = c[a + 8 >> 2];
            c[f + 12 >> 2] = c[a + 12 >> 2];
            a = e + 28 | 0;
            c[a >> 2] = c[d >> 2];
            c[a + 4 >> 2] = c[d + 4 >> 2];
            c[a + 8 >> 2] = c[d + 8 >> 2];
            c[a + 12 >> 2] = c[d + 12 >> 2];
            c[e + 76 >> 2] = 0;
            return e | 0;
        }
        function tk(a) {
            a = a | 0;
            return +g[a + 4 >> 2] < 1 | 0;
        }
        function uk(a) {
            a = a | 0;
            return a + 12 | 0;
        }
        function vk(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 12 >> 2] = c[b >> 2];
            c[a + 12 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 12 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 12 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function wk(a) {
            a = a | 0;
            return a + 28 | 0;
        }
        function xk(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 28 >> 2] = c[b >> 2];
            c[a + 28 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 28 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 28 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function yk(a) {
            a = a | 0;
            return a + 44 | 0;
        }
        function zk(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 44 >> 2] = c[b >> 2];
            c[a + 44 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 44 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 44 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Ak(a) {
            a = a | 0;
            return a + 60 | 0;
        }
        function Bk(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 60 >> 2] = c[b >> 2];
            c[a + 60 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 60 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 60 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Ck(a) {
            a = a | 0;
            return b[a + 8 >> 1] | 0;
        }
        function Dk(a, c) {
            a = a | 0;
            c = c | 0;
            b[a + 8 >> 1] = c;
            return;
        }
        function Ek(a) {
            a = a | 0;
            return b[a + 10 >> 1] | 0;
        }
        function Fk(a, c) {
            a = a | 0;
            c = c | 0;
            b[a + 10 >> 1] = c;
            return;
        }
        function Gk(a) {
            a = a | 0;
            return + +g[a + 4 >> 2];
        }
        function Hk(a, b) {
            a = a | 0;
            b = +b;
            g[a + 4 >> 2] = b;
            return;
        }
        function Ik(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Jk() {
            var a = 0;
            a = Qb(200, 16) | 0;
            Dp();
            Dp();
            Ep(a, 564, 564);
            return a | 0;
        }
        function Kk(a) {
            a = a | 0;
            var b = 0;
            b = Qb(200, 16) | 0;
            Dp();
            Ep(b, a, 564);
            return b | 0;
        }
        function Lk(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = Qb(200, 16) | 0;
            Ep(c, a, b);
            return c | 0;
        }
        function Mk(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 8 >> 2] & 3](a, b);
            return;
        }
        function Nk(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 12 >> 2] & 3](a, b);
            return;
        }
        function Ok(a) {
            a = a | 0;
            return a + 4 | 0;
        }
        function Pk(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 4 >> 2] = c[b >> 2];
            c[a + 4 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 4 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 4 + 12 >> 2] = c[b + 12 >> 2];
            c[a + 20 >> 2] = c[b + 16 >> 2];
            c[a + 20 + 4 >> 2] = c[b + 16 + 4 >> 2];
            c[a + 20 + 8 >> 2] = c[b + 16 + 8 >> 2];
            c[a + 20 + 12 >> 2] = c[b + 16 + 12 >> 2];
            c[a + 36 >> 2] = c[b + 32 >> 2];
            c[a + 36 + 4 >> 2] = c[b + 32 + 4 >> 2];
            c[a + 36 + 8 >> 2] = c[b + 32 + 8 >> 2];
            c[a + 36 + 12 >> 2] = c[b + 32 + 12 >> 2];
            c[a + 52 >> 2] = c[b + 48 >> 2];
            c[a + 52 + 4 >> 2] = c[b + 48 + 4 >> 2];
            c[a + 52 + 8 >> 2] = c[b + 48 + 8 >> 2];
            c[a + 52 + 12 >> 2] = c[b + 48 + 12 >> 2];
            return;
        }
        function Qk(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Rk(a, d) {
            a = a | 0;
            d = d | 0;
            var e = 0, f = 0;
            e = Bq(84) | 0;
            a: do {
                if (!e) {
                    while (1) {
                        e = c[187] | 0;
                        c[187] = e + 0;
                        if (!e) break;
                        Ic[e & 3]();
                        e = Bq(84) | 0;
                        if (e) break a;
                    }
                    d = Ib(4) | 0;
                    c[d >> 2] = 736;
                    pc(d | 0, 176, 11);
                }
            } while (0);
            g[e + 4 >> 2] = 1;
            c[e + 8 >> 2] = 0;
            b[e + 12 >> 1] = 1;
            b[e + 14 >> 1] = -1;
            c[e + 16 >> 2] = 0;
            c[e >> 2] = 524;
            f = e + 20 | 0;
            c[f >> 2] = c[a >> 2];
            c[f + 4 >> 2] = c[a + 4 >> 2];
            c[f + 8 >> 2] = c[a + 8 >> 2];
            c[f + 12 >> 2] = c[a + 12 >> 2];
            a = e + 36 | 0;
            c[a >> 2] = c[d >> 2];
            c[a + 4 >> 2] = c[d + 4 >> 2];
            c[a + 8 >> 2] = c[d + 8 >> 2];
            c[a + 12 >> 2] = c[d + 12 >> 2];
            return e | 0;
        }
        function Sk(a) {
            a = a | 0;
            return (c[a + 8 >> 2] | 0) != 0 | 0;
        }
        function Tk(a) {
            a = a | 0;
            return a + 20 | 0;
        }
        function Uk(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 20 >> 2] = c[b >> 2];
            c[a + 20 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 20 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 20 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Vk(a) {
            a = a | 0;
            return a + 36 | 0;
        }
        function Wk(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 36 >> 2] = c[b >> 2];
            c[a + 36 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 36 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 36 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Xk(a) {
            a = a | 0;
            return a + 52 | 0;
        }
        function Yk(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 52 >> 2] = c[b >> 2];
            c[a + 52 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 52 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 52 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Zk(a) {
            a = a | 0;
            return a + 68 | 0;
        }
        function _k(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 68 >> 2] = c[b >> 2];
            c[a + 68 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 68 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 68 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function $k(a) {
            a = a | 0;
            return b[a + 12 >> 1] | 0;
        }
        function al(a, c) {
            a = a | 0;
            c = c | 0;
            b[a + 12 >> 1] = c;
            return;
        }
        function bl(a) {
            a = a | 0;
            return b[a + 14 >> 1] | 0;
        }
        function cl(a, c) {
            a = a | 0;
            c = c | 0;
            b[a + 14 >> 1] = c;
            return;
        }
        function dl(a) {
            a = a | 0;
            return c[a + 8 >> 2] | 0;
        }
        function el(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 8 >> 2] = b;
            return;
        }
        function fl(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function gl(a, b) {
            a = +a;
            b = +b;
            var c = 0;
            c = Qb(60, 16) | 0;
            qb(c | 0, +a, +b);
            return c | 0;
        }
        function hl(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function il(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function jl(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function kl(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function ll(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function ml(a, b, d, e) {
            a = +a;
            b = +b;
            d = +d;
            e = +e;
            var f = 0;
            f = Bq(16) | 0;
            a: do {
                if (!f) {
                    while (1) {
                        f = c[187] | 0;
                        c[187] = f + 0;
                        if (!f) break;
                        Ic[f & 3]();
                        f = Bq(16) | 0;
                        if (f) break a;
                    }
                    f = Ib(4) | 0;
                    c[f >> 2] = 736;
                    pc(f | 0, 176, 11);
                }
            } while (0);
            g[f >> 2] = a;
            g[f + 4 >> 2] = b;
            g[f + 8 >> 2] = d;
            g[f + 12 >> 2] = e;
            return f | 0;
        }
        function nl(a, b, c, d, e) {
            a = a | 0;
            b = +b;
            c = +c;
            d = +d;
            e = +e;
            g[a >> 2] = b;
            g[a + 4 >> 2] = c;
            g[a + 8 >> 2] = d;
            g[a + 12 >> 2] = e;
            return;
        }
        function ol(a) {
            a = a | 0;
            return + +g[a >> 2];
        }
        function pl(a) {
            a = a | 0;
            return + +g[a + 4 >> 2];
        }
        function ql(a) {
            a = a | 0;
            return + +g[a + 8 >> 2];
        }
        function rl(a) {
            a = a | 0;
            return + +g[a + 12 >> 2];
        }
        function sl(a, b) {
            a = a | 0;
            b = +b;
            g[a >> 2] = b;
            return;
        }
        function tl(a, b) {
            a = a | 0;
            b = +b;
            g[a + 4 >> 2] = b;
            return;
        }
        function ul(a, b) {
            a = a | 0;
            b = +b;
            g[a + 8 >> 2] = b;
            return;
        }
        function vl(a, b) {
            a = a | 0;
            b = +b;
            g[a + 12 >> 2] = b;
            return;
        }
        function wl(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function xl(a, b) {
            a = +a;
            b = +b;
            var c = 0;
            c = Qb(60, 16) | 0;
            Ya(c | 0, +a, +b);
            return c | 0;
        }
        function yl(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function zl(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function Al(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function Bl(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function Cl(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Dl(a) {
            a = a | 0;
            var b = 0;
            b = Bq(8) | 0;
            a: do {
                if (!b) {
                    while (1) {
                        b = c[187] | 0;
                        c[187] = b + 0;
                        if (!b) break;
                        Ic[b & 3]();
                        b = Bq(8) | 0;
                        if (b) break a;
                    }
                    a = Ib(4) | 0;
                    c[a >> 2] = 736;
                    pc(a | 0, 176, 11);
                }
            } while (0);
            c[b >> 2] = o + 8;
            c[b + 4 >> 2] = a;
            return b | 0;
        }
        function El(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Fl(a) {
            a = a | 0;
            return + +g[a + 216 >> 2];
        }
        function Gl(a, b) {
            a = a | 0;
            b = +b;
            g[a + 216 >> 2] = b;
            return;
        }
        function Hl(a) {
            a = a | 0;
            return + +g[a + 228 >> 2];
        }
        function Il(a, b) {
            a = a | 0;
            b = +b;
            g[a + 228 >> 2] = b;
            return;
        }
        function Jl(a) {
            a = a | 0;
            return + +g[a + 244 >> 2];
        }
        function Kl(a, b) {
            a = a | 0;
            b = +b;
            g[a + 244 >> 2] = b;
            return;
        }
        function Ll(a) {
            a = a | 0;
            return + +g[a + 204 >> 2];
        }
        function Ml(a, b) {
            a = a | 0;
            b = +b;
            g[a + 204 >> 2] = b;
            return;
        }
        function Nl(a) {
            a = a | 0;
            return + +g[a + 212 >> 2];
        }
        function Ol(a, b) {
            a = a | 0;
            b = +b;
            g[a + 212 >> 2] = b;
            return;
        }
        function Pl(a) {
            a = a | 0;
            return + +g[a + 220 >> 2];
        }
        function Ql(a, b) {
            a = a | 0;
            b = +b;
            g[a + 220 >> 2] = b;
            return;
        }
        function Rl(a) {
            a = a | 0;
            return + +g[a + 224 >> 2];
        }
        function Sl(a, b) {
            a = a | 0;
            b = +b;
            g[a + 224 >> 2] = b;
            return;
        }
        function Tl(a) {
            a = a | 0;
            return + +g[a + 232 >> 2];
        }
        function Ul(a, b) {
            a = a | 0;
            b = +b;
            g[a + 232 >> 2] = b;
            return;
        }
        function Vl(a) {
            a = a | 0;
            return + +g[a + 248 >> 2];
        }
        function Wl(a, b) {
            a = a | 0;
            b = +b;
            g[a + 248 >> 2] = b;
            return;
        }
        function Xl(a) {
            a = a | 0;
            return + +g[a + 208 >> 2];
        }
        function Yl(a, b) {
            a = a | 0;
            b = +b;
            g[a + 208 >> 2] = b;
            return;
        }
        function Zl(a) {
            a = a | 0;
            return + +g[a + 276 >> 2];
        }
        function _l(a, b) {
            a = a | 0;
            b = +b;
            g[a + 276 >> 2] = b;
            return;
        }
        function $l(b) {
            b = b | 0;
            return (a[b + 260 >> 0] & 1) != 0 | 0;
        }
        function am(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 260 >> 0] = c & 1;
            return;
        }
        function bm(a) {
            a = a | 0;
            return a + 156 | 0;
        }
        function cm(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 156 >> 2] = c[b >> 2];
            c[a + 156 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 156 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 156 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function dm(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function em() {
            return Qb(16, 16) | 0;
        }
        function fm(a, b, c, d) {
            a = +a;
            b = +b;
            c = +c;
            d = +d;
            var e = 0;
            e = Qb(16, 16) | 0;
            g[e >> 2] = a;
            g[e + 4 >> 2] = b;
            g[e + 8 >> 2] = c;
            g[e + 12 >> 2] = d;
            return e | 0;
        }
        function gm(a) {
            a = a | 0;
            return + +g[a + 12 >> 2];
        }
        function hm(a, b, c, d, e) {
            a = a | 0;
            b = +b;
            c = +c;
            d = +d;
            e = +e;
            g[a >> 2] = b;
            g[a + 4 >> 2] = c;
            g[a + 8 >> 2] = d;
            g[a + 12 >> 2] = e;
            return;
        }
        function im(a) {
            a = a | 0;
            var b = 0, c = 0, d = 0;
            d = +g[a >> 2];
            c = +g[a + 4 >> 2];
            b = +g[a + 8 >> 2];
            return + +Q(+(d * d + c * c + b * b));
        }
        function jm(a) {
            a = a | 0;
            return + +g[a >> 2];
        }
        function km(a) {
            a = a | 0;
            return + +g[a + 4 >> 2];
        }
        function lm(a) {
            a = a | 0;
            return + +g[a + 8 >> 2];
        }
        function mm(a, b) {
            a = a | 0;
            b = +b;
            g[a >> 2] = b;
            return;
        }
        function nm(a, b) {
            a = a | 0;
            b = +b;
            g[a + 4 >> 2] = b;
            return;
        }
        function om(a, b) {
            a = a | 0;
            b = +b;
            g[a + 8 >> 2] = b;
            return;
        }
        function pm(a, b) {
            a = a | 0;
            b = +b;
            g[a >> 2] = +g[a >> 2] * b;
            g[a + 4 >> 2] = +g[a + 4 >> 2] * b;
            g[a + 8 >> 2] = +g[a + 8 >> 2] * b;
            return a | 0;
        }
        function qm(a) {
            a = a | 0;
            if (!a) return;
            Ia(a | 0);
            return;
        }
        function rm(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = +c;
            var d = 0;
            d = Qb(184, 16) | 0;
            Sa(d | 0, a | 0, b | 0, +c, 1);
            return d | 0;
        }
        function sm(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = +c;
            d = d | 0;
            var e = 0;
            e = Qb(184, 16) | 0;
            Sa(e | 0, a | 0, b | 0, +c, d | 0);
            return e | 0;
        }
        function tm(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 176 >> 2] = (b | 0) < 0 ? 0 : (b | 0) > 2 ? 2 : b;
            return;
        }
        function um(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 16 >> 2] & 3](a, b);
            return;
        }
        function vm(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = +d;
            Jc[c[(c[a >> 2] | 0) + 20 >> 2] & 0](a, b, d);
            return;
        }
        function wm(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 28 >> 2] & 3](a, b);
            return;
        }
        function xm(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 32 >> 2] & 3](a, b);
            return;
        }
        function ym(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = +d;
            Jc[c[(c[a >> 2] | 0) + 36 >> 2] & 0](a, b, d);
            return;
        }
        function zm(a, b) {
            a = a | 0;
            b = +b;
            nb(a | 0, +b);
            return;
        }
        function Am(a, b) {
            a = a | 0;
            b = +b;
            Sb(a | 0, +b);
            return;
        }
        function Bm(a, b) {
            a = a | 0;
            b = +b;
            Ea(a | 0, +b);
            return;
        }
        function Cm(a) {
            a = a | 0;
            return Gc[c[(c[a >> 2] | 0) + 40 >> 2] & 3](a) | 0;
        }
        function Dm(a) {
            a = a | 0;
            wc[c[(c[a >> 2] | 0) + 44 >> 2] & 31](a);
            return;
        }
        function Em(a, b) {
            a = a | 0;
            b = +b;
            tb(a | 0, +b);
            return;
        }
        function Fm(a) {
            a = a | 0;
            return + +Hb(a | 0);
        }
        function Gm(a, b) {
            a = a | 0;
            b = +b;
            _a(a | 0, +b);
            return;
        }
        function Hm(a) {
            a = a | 0;
            return + +Nb(a | 0);
        }
        function Im(a) {
            a = a | 0;
            return ac(a | 0) | 0;
        }
        function Jm(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 170 >> 0] = c & 1;
            return;
        }
        function Km(a) {
            a = a | 0;
            return Gc[c[(c[a >> 2] | 0) + 48 >> 2] & 3](a) | 0;
        }
        function Lm(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Mm(a, b) {
            a = a | 0;
            b = +b;
            var c = 0;
            c = Qb(88, 16) | 0;
            Qa(c | 0, a | 0, +b);
            return c | 0;
        }
        function Nm(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function Om(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function Pm(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Qm(a) {
            a = a | 0;
            return (c[a + 44 >> 2] | 0) != 0 | 0;
        }
        function Rm(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 44 >> 2] = b & 1;
            return;
        }
        function Sm(a) {
            a = a | 0;
            return ~~+g[a + 48 >> 2] | 0;
        }
        function Tm(a, b) {
            a = a | 0;
            b = b | 0;
            g[a + 48 >> 2] = +(b | 0);
            return;
        }
        function Um(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function Vm(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 60 >> 2] & 3](a, b);
            return;
        }
        function Wm(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Xm(a) {
            a = +a;
            var b = 0;
            b = Qb(56, 16) | 0;
            bc(b | 0);
            c[b >> 2] = n + 8;
            c[b + 4 >> 2] = 8;
            g[b + 32 >> 2] = a;
            g[b + 48 >> 2] = a;
            return b | 0;
        }
        function Ym(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function Zm(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function _m(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function $m(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function an(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function bn() {
            var a = 0;
            a = Bq(24) | 0;
            a: do {
                if (!a) {
                    while (1) {
                        a = c[187] | 0;
                        c[187] = a + 0;
                        if (!a) break;
                        Ic[a & 3]();
                        a = Bq(24) | 0;
                        if (a) break a;
                    }
                    a = Ib(4) | 0;
                    c[a >> 2] = 736;
                    pc(a | 0, 176, 11);
                }
            } while (0);
            c[a >> 2] = 0;
            c[a + 4 >> 2] = 0;
            c[a + 8 >> 2] = 4096;
            c[a + 12 >> 2] = 4096;
            c[a + 16 >> 2] = 0;
            c[a + 20 >> 2] = 1;
            return a | 0;
        }
        function cn(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function dn(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = Qb(768, 16) | 0;
            ic(c | 0, a | 0, b | 0, 0);
            return c | 0;
        }
        function en(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            var d = 0;
            d = Qb(768, 16) | 0;
            ic(d | 0, a | 0, b | 0, c | 0);
            return d | 0;
        }
        function fn(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            var e = 0;
            e = Qb(768, 16) | 0;
            La(e | 0, a | 0, b | 0, c | 0, d | 0, 0);
            return e | 0;
        }
        function gn(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            var f = 0;
            f = Qb(768, 16) | 0;
            La(f | 0, a | 0, b | 0, c | 0, d | 0, e | 0);
            return f | 0;
        }
        function hn(a, b, c, d, e, f) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            var g = 0;
            g = Qb(768, 16) | 0;
            Db(g | 0, a | 0, b | 0, c | 0, d | 0, e | 0, f | 0, 0);
            return g | 0;
        }
        function jn(a, b, c, d, e, f, g) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            var h = 0;
            h = Qb(768, 16) | 0;
            Db(h | 0, a | 0, b | 0, c | 0, d | 0, e | 0, f | 0, g | 0);
            return h | 0;
        }
        function kn(a, b, c, d, e) {
            a = a | 0;
            b = +b;
            c = +c;
            d = +d;
            e = +e;
            uc(a + 688 | 0, +b, +c, +d, +e, 1);
            return;
        }
        function ln(a, b, c, d, e, f) {
            a = a | 0;
            b = +b;
            c = +c;
            d = +d;
            e = +e;
            f = +f;
            uc(a + 688 | 0, +b, +c, +d, +e, +f);
            return;
        }
        function mn(b, c, d, e) {
            b = b | 0;
            c = c | 0;
            d = +d;
            e = +e;
            a[b + 737 >> 0] = c & 1;
            g[b + 680 >> 2] = d;
            g[b + 684 >> 2] = e;
            return;
        }
        function nn(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 21 >> 0] = c & 1;
            return;
        }
        function on(a) {
            a = a | 0;
            return + +g[a + 16 >> 2];
        }
        function pn(a, b) {
            a = a | 0;
            b = +b;
            g[a + 16 >> 2] = b;
            return;
        }
        function qn(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function rn() {
            var a = 0;
            a = Bq(12) | 0;
            a: do {
                if (!a) {
                    while (1) {
                        a = c[187] | 0;
                        c[187] = a + 0;
                        if (!a) break;
                        Ic[a & 3]();
                        a = Bq(12) | 0;
                        if (a) break a;
                    }
                    a = Ib(4) | 0;
                    c[a >> 2] = 736;
                    pc(a | 0, 176, 11);
                }
            } while (0);
            g[a >> 2] = .30000001192092896;
            g[a + 4 >> 2] = 1;
            g[a + 8 >> 2] = 0;
            return a | 0;
        }
        function sn(a) {
            a = a | 0;
            return + +g[a >> 2];
        }
        function tn(a, b) {
            a = a | 0;
            b = +b;
            g[a >> 2] = b;
            return;
        }
        function un(a) {
            a = a | 0;
            return + +g[a + 4 >> 2];
        }
        function vn(a, b) {
            a = a | 0;
            b = +b;
            g[a + 4 >> 2] = b;
            return;
        }
        function wn(a) {
            a = a | 0;
            return + +g[a + 8 >> 2];
        }
        function xn(a, b) {
            a = a | 0;
            b = +b;
            g[a + 8 >> 2] = b;
            return;
        }
        function yn(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function zn(a) {
            a = a | 0;
            return c[a >> 2] | 0;
        }
        function An(a, b) {
            a = a | 0;
            b = b | 0;
            c[a >> 2] = b;
            return;
        }
        function Bn(a) {
            a = a | 0;
            return c[a + 4 >> 2] | 0;
        }
        function Cn(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 4 >> 2] = b;
            return;
        }
        function Dn(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function En(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Fn(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            var d = 0;
            d = Qb(1388, 16) | 0;
            ob(d | 0, a | 0, b | 0, c | 0);
            return d | 0;
        }
        function Gn(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            var f = 0;
            f = Qb(1388, 16) | 0;
            Fb(f | 0, a | 0, b | 0, c | 0, d | 0, e | 0);
            return f | 0;
        }
        function Hn(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            Cb(a | 0, b | 0, c | 0);
            return;
        }
        function In(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = +c;
            sb(a | 0, b | 0, +c);
            return;
        }
        function Jn(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = +c;
            jc(a | 0, b | 0, +c);
            return;
        }
        function Kn(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 680 >> 2] = c[b >> 2];
            c[a + 680 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 680 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 680 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Ln(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 696 >> 2] = c[b >> 2];
            c[a + 696 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 696 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 696 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Mn(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = 0;
            while (1) {
                if ((c | 0) == 3) break;
                g[a + 868 + (c << 6) >> 2] = +_p(+g[b + (c << 2) >> 2]);
                c = c + 1 | 0;
            }
            return;
        }
        function Nn(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0;
            c = 0;
            while (1) {
                if ((c | 0) == 3) break;
                g[a + 868 + (c << 6) + 4 >> 2] = +_p(+g[b + (c << 2) >> 2]);
                c = c + 1 | 0;
            }
            return;
        }
        function On(b, c) {
            b = b | 0;
            c = c | 0;
            a[b + 21 >> 0] = c & 1;
            return;
        }
        function Pn(a) {
            a = a | 0;
            return + +g[a + 16 >> 2];
        }
        function Qn(a, b) {
            a = a | 0;
            b = +b;
            g[a + 16 >> 2] = b;
            return;
        }
        function Rn(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Sn(a, b, d, e, f) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = +f;
            var h = 0;
            h = Bq(44) | 0;
            a: do {
                if (!h) {
                    while (1) {
                        h = c[187] | 0;
                        c[187] = h + 0;
                        if (!h) break;
                        Ic[h & 3]();
                        h = Bq(44) | 0;
                        if (h) break a;
                    }
                    e = Ib(4) | 0;
                    c[e >> 2] = 736;
                    pc(e | 0, 176, 11);
                }
            } while (0);
            c[h >> 2] = a;
            c[h + 4 >> 2] = b;
            b = h + 8 | 0;
            c[b >> 2] = c[d >> 2];
            c[b + 4 >> 2] = c[d + 4 >> 2];
            c[b + 8 >> 2] = c[d + 8 >> 2];
            c[b + 12 >> 2] = c[d + 12 >> 2];
            d = h + 24 | 0;
            c[d >> 2] = c[e >> 2];
            c[d + 4 >> 2] = c[e + 4 >> 2];
            c[d + 8 >> 2] = c[e + 8 >> 2];
            c[d + 12 >> 2] = c[e + 12 >> 2];
            g[h + 40 >> 2] = f;
            return h | 0;
        }
        function Tn(a) {
            a = a | 0;
            return c[a >> 2] | 0;
        }
        function Un(a, b) {
            a = a | 0;
            b = b | 0;
            c[a >> 2] = b;
            return;
        }
        function Vn(a) {
            a = a | 0;
            return c[a + 4 >> 2] | 0;
        }
        function Wn(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 4 >> 2] = b;
            return;
        }
        function Xn(a) {
            a = a | 0;
            return a + 8 | 0;
        }
        function Yn(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 8 >> 2] = c[b >> 2];
            c[a + 8 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 8 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 8 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function Zn(a) {
            a = a | 0;
            return a + 24 | 0;
        }
        function _n(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 24 >> 2] = c[b >> 2];
            c[a + 24 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 24 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 24 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function $n(a) {
            a = a | 0;
            return + +g[a + 40 >> 2];
        }
        function ao(a, b) {
            a = a | 0;
            b = +b;
            g[a + 40 >> 2] = b;
            return;
        }
        function bo(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function co(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function eo(a) {
            a = a | 0;
            var b = 0;
            b = Qb(640, 16) | 0;
            Lb(b | 0, a | 0);
            return b | 0;
        }
        function fo(a) {
            a = a | 0;
            return a + 4 | 0;
        }
        function go(a, b) {
            a = a | 0;
            b = b | 0;
            ec(a | 0, b | 0);
            return;
        }
        function ho(a, b, c) {
            a = a | 0;
            b = +b;
            c = +c;
            g[a + 496 >> 2] = b;
            g[a + 500 >> 2] = c;
            return;
        }
        function io(a, b, c) {
            a = a | 0;
            b = +b;
            c = +c;
            Xb(a | 0, +b, +c);
            return;
        }
        function jo(a, b, c) {
            a = a | 0;
            b = +b;
            c = c | 0;
            gb(a | 0, +b, c | 0);
            return;
        }
        function ko(a, b) {
            a = a | 0;
            b = b | 0;
            var d = 0, e = 0, f = 0;
            c[a + 372 >> 2] = c[b >> 2];
            c[a + 372 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 372 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 372 + 12 >> 2] = c[b + 12 >> 2];
            f = +g[a + 368 >> 2];
            e = +g[a + 376 >> 2] * f;
            d = +g[a + 380 >> 2] * f;
            g[a + 584 >> 2] = +g[a + 372 >> 2] * f;
            g[a + 588 >> 2] = e;
            g[a + 592 >> 2] = d;
            g[a + 596 >> 2] = 0;
            return;
        }
        function lo(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0, d = 0;
            d = +g[b + 4 >> 2] * +g[a + 572 >> 2];
            c = +g[b + 8 >> 2] * +g[a + 576 >> 2];
            g[a + 452 >> 2] = +g[a + 452 >> 2] + +g[b >> 2] * +g[a + 568 >> 2];
            g[a + 456 >> 2] = +g[a + 456 >> 2] + d;
            g[a + 460 >> 2] = +g[a + 460 >> 2] + c;
            return;
        }
        function mo(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            var d = 0, e = 0, f = 0, h = 0, i = 0, j = 0, k = 0;
            d = +g[a + 372 >> 2];
            f = +g[a + 376 >> 2];
            h = +g[b + 4 >> 2] * f;
            i = +g[a + 380 >> 2];
            j = +g[b + 8 >> 2] * i;
            g[a + 436 >> 2] = +g[a + 436 >> 2] + +g[b >> 2] * d;
            g[a + 440 >> 2] = +g[a + 440 >> 2] + h;
            g[a + 444 >> 2] = +g[a + 444 >> 2] + j;
            d = +g[b >> 2] * d;
            f = +g[b + 4 >> 2] * f;
            i = +g[b + 8 >> 2] * i;
            j = +g[c + 4 >> 2];
            h = +g[c + 8 >> 2];
            k = +g[c >> 2];
            e = (h * d - k * i) * +g[a + 572 >> 2];
            d = (k * f - j * d) * +g[a + 576 >> 2];
            g[a + 452 >> 2] = +g[a + 452 >> 2] + (j * i - h * f) * +g[a + 568 >> 2];
            g[a + 456 >> 2] = +g[a + 456 >> 2] + e;
            g[a + 460 >> 2] = +g[a + 460 >> 2] + d;
            return;
        }
        function no(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0, d = 0;
            d = +g[b + 4 >> 2] * +g[a + 376 >> 2];
            c = +g[b + 8 >> 2] * +g[a + 380 >> 2];
            g[a + 436 >> 2] = +g[a + 436 >> 2] + +g[b >> 2] * +g[a + 372 >> 2];
            g[a + 440 >> 2] = +g[a + 440 >> 2] + d;
            g[a + 444 >> 2] = +g[a + 444 >> 2] + c;
            return;
        }
        function oo(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0, d = 0, e = 0, f = 0, h = 0;
            h = +g[b >> 2];
            f = +g[b + 4 >> 2];
            e = +g[b + 8 >> 2];
            d = (+g[a + 304 >> 2] * h + +g[a + 308 >> 2] * f + +g[a + 312 >> 2] * e) * +g[a + 572 >> 2];
            c = (+g[a + 320 >> 2] * h + +g[a + 324 >> 2] * f + +g[a + 328 >> 2] * e) * +g[a + 576 >> 2];
            g[a + 352 >> 2] = +g[a + 352 >> 2] + (+g[a + 288 >> 2] * h + +g[a + 292 >> 2] * f + +g[a + 296 >> 2] * e) * +g[a + 568 >> 2];
            g[a + 356 >> 2] = +g[a + 356 >> 2] + d;
            g[a + 360 >> 2] = +g[a + 360 >> 2] + c;
            return;
        }
        function po(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            var d = 0, e = 0, f = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
            if (!(+g[a + 368 >> 2] != 0)) return;
            Fp(a, b);
            f = +g[b >> 2] * +g[a + 372 >> 2];
            i = +g[b + 4 >> 2] * +g[a + 376 >> 2];
            k = +g[b + 8 >> 2] * +g[a + 380 >> 2];
            h = +g[c + 4 >> 2];
            l = +g[c + 8 >> 2];
            j = +g[c >> 2];
            e = (+g[a + 304 >> 2] * (h * k - l * i) + +g[a + 308 >> 2] * (l * f - j * k) + +g[a + 312 >> 2] * (j * i - h * f)) * +g[a + 572 >> 2];
            d = (+g[a + 320 >> 2] * (h * k - l * i) + +g[a + 324 >> 2] * (l * f - j * k) + +g[a + 328 >> 2] * (j * i - h * f)) * +g[a + 576 >> 2];
            g[a + 352 >> 2] = +g[a + 352 >> 2] + (+g[a + 288 >> 2] * (h * k - l * i) + +g[a + 292 >> 2] * (l * f - j * k) + +g[a + 296 >> 2] * (j * i - h * f)) * +g[a + 568 >> 2];
            g[a + 356 >> 2] = +g[a + 356 >> 2] + e;
            g[a + 360 >> 2] = +g[a + 360 >> 2] + d;
            return;
        }
        function qo(a, b) {
            a = a | 0;
            b = b | 0;
            Fp(a, b);
            return;
        }
        function ro(a) {
            a = a | 0;
            mb(a | 0);
            return;
        }
        function so(a) {
            a = a | 0;
            return a + 336 | 0;
        }
        function to(a) {
            a = a | 0;
            return a + 352 | 0;
        }
        function uo(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            c[a + 336 >> 2] = c[b >> 2];
            c[a + 336 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 336 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 336 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function vo(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            c[a + 352 >> 2] = c[b >> 2];
            c[a + 352 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 352 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 352 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function wo(a) {
            a = a | 0;
            return c[a + 504 >> 2] | 0;
        }
        function xo(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 504 >> 2] = b;
            if (!b) return;
            Fc[c[(c[b >> 2] | 0) + 8 >> 2] & 3](b, a + 4 | 0);
            return;
        }
        function yo(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            c[a + 568 >> 2] = c[b >> 2];
            c[a + 568 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 568 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 568 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function zo(a, b) {
            a = a | 0;
            b = b | 0;
            return ((c[b + 236 >> 2] & 2 | 0) == 0 ? 0 : b) | 0;
        }
        function Ao(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            c[a + 164 >> 2] = c[b >> 2];
            c[a + 164 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 164 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 164 + 12 >> 2] = c[b + 12 >> 2];
            if ((!(+g[b >> 2] != 1) ? !(+g[b + 4 >> 2] != 1) : 0) ? !(+g[b + 8 >> 2] != 1) : 0) {
                d = 0;
                a = a + 180 | 0;
                c[a >> 2] = d;
                return;
            }
            a = a + 180 | 0;
            c[a >> 2] = d;
            return;
        }
        function Bo(a) {
            a = a | 0;
            return c[a + 192 >> 2] | 0;
        }
        function Co(a, b) {
            a = a | 0;
            b = +b;
            g[a + 184 >> 2] = b;
            return;
        }
        function Do(a, b) {
            a = a | 0;
            b = b | 0;
            lc(a | 0, b | 0);
            return;
        }
        function Eo(a, b) {
            a = a | 0;
            b = b | 0;
            Zb(a | 0, b | 0);
            return;
        }
        function Fo(a) {
            a = a | 0;
            gc(a | 0, 0);
            return;
        }
        function Go(a, b) {
            a = a | 0;
            b = b | 0;
            gc(a | 0, b | 0);
            return;
        }
        function Ho(a) {
            a = a | 0;
            a = c[a + 216 >> 2] | 0;
            return ((a | 0) == 2 ? 0 : (a | 0) != 5) | 0;
        }
        function Io(a) {
            a = a | 0;
            return (c[a + 204 >> 2] & 2 | 0) != 0 | 0;
        }
        function Jo(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 228 >> 2] = b;
            return;
        }
        function Ko(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 224 >> 2] = b;
            return;
        }
        function Lo(a, b) {
            a = a | 0;
            b = +b;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            g[a + 232 >> 2] = b;
            return;
        }
        function Mo(a) {
            a = a | 0;
            return a + 4 | 0;
        }
        function No(a) {
            a = a | 0;
            return c[a + 204 >> 2] | 0;
        }
        function Oo(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 204 >> 2] = b;
            return;
        }
        function Po(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 284 >> 2] = (c[a + 284 >> 2] | 0) + 1;
            c[a + 4 >> 2] = c[b >> 2];
            c[a + 4 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 4 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 4 + 12 >> 2] = c[b + 12 >> 2];
            c[a + 20 >> 2] = c[b + 16 >> 2];
            c[a + 20 + 4 >> 2] = c[b + 16 + 4 >> 2];
            c[a + 20 + 8 >> 2] = c[b + 16 + 8 >> 2];
            c[a + 20 + 12 >> 2] = c[b + 16 + 12 >> 2];
            c[a + 36 >> 2] = c[b + 32 >> 2];
            c[a + 36 + 4 >> 2] = c[b + 32 + 4 >> 2];
            c[a + 36 + 8 >> 2] = c[b + 32 + 8 >> 2];
            c[a + 36 + 12 >> 2] = c[b + 32 + 12 >> 2];
            c[a + 52 >> 2] = c[b + 48 >> 2];
            c[a + 52 + 4 >> 2] = c[b + 48 + 4 >> 2];
            c[a + 52 + 8 >> 2] = c[b + 48 + 8 >> 2];
            c[a + 52 + 12 >> 2] = c[b + 48 + 12 >> 2];
            return;
        }
        function Qo(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 8 >> 2] & 3](a, b);
            return;
        }
        function Ro(a, b) {
            a = a | 0;
            b = +b;
            g[a + 256 >> 2] = b;
            return;
        }
        function So(a, b) {
            a = a | 0;
            b = +b;
            g[a + 252 >> 2] = b;
            return;
        }
        function To(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Uo(a) {
            a = a | 0;
            var b = 0;
            b = Qb(60, 16) | 0;
            Ja(b | 0, a | 0);
            return b | 0;
        }
        function Vo(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function Wo(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function Xo(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function Yo(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function Zo(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function _o(a) {
            a = a | 0;
            var b = 0;
            b = Qb(60, 16) | 0;
            rb(b | 0, a | 0);
            return b | 0;
        }
        function $o(a, b) {
            a = a | 0;
            b = +b;
            Cc[c[(c[a >> 2] | 0) + 44 >> 2] & 0](a, b);
            return;
        }
        function ap(a) {
            a = a | 0;
            return + +Dc[c[(c[a >> 2] | 0) + 48 >> 2] & 0](a);
        }
        function bp(a, b) {
            a = a | 0;
            b = b | 0;
            Fc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b);
            return;
        }
        function cp(a, b, d) {
            a = a | 0;
            b = +b;
            d = d | 0;
            yc[c[(c[a >> 2] | 0) + 32 >> 2] & 0](a, b, d);
            return;
        }
        function dp(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function ep() {
            var a = 0, b = 0;
            a = Bq(64) | 0;
            if (a) {
                b = a;
                return b | 0;
            }
            while (1) {
                a = c[187] | 0;
                c[187] = a + 0;
                if (!a) {
                    b = 4;
                    break;
                }
                Ic[a & 3]();
                a = Bq(64) | 0;
                if (a) {
                    b = 5;
                    break;
                }
            }
            if ((b | 0) == 4) {
                b = Ib(4) | 0;
                c[b >> 2] = 736;
                pc(b | 0, 176, 11);
            } else if ((b | 0) == 5) return a | 0;
            return 0;
        }
        function fp(a, b) {
            a = a | 0;
            b = b | 0;
            var d = 0, e = 0;
            d = Bq(64) | 0;
            a: do {
                if (!d) {
                    while (1) {
                        d = c[187] | 0;
                        c[187] = d + 0;
                        if (!d) break;
                        Ic[d & 3]();
                        d = Bq(64) | 0;
                        if (d) break a;
                    }
                    b = Ib(4) | 0;
                    c[b >> 2] = 736;
                    pc(b | 0, 176, 11);
                }
            } while (0);
            e = d + 48 | 0;
            Mp(d, a);
            c[e >> 2] = c[b >> 2];
            c[e + 4 >> 2] = c[b + 4 >> 2];
            c[e + 8 >> 2] = c[b + 8 >> 2];
            c[e + 12 >> 2] = c[b + 12 >> 2];
            return d | 0;
        }
        function gp(a) {
            a = a | 0;
            Gp(a);
            return;
        }
        function hp(a, b) {
            a = a | 0;
            b = b | 0;
            c[a + 48 >> 2] = c[b >> 2];
            c[a + 48 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 48 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 48 + 12 >> 2] = c[b + 12 >> 2];
            return;
        }
        function ip(a, b) {
            a = a | 0;
            b = b | 0;
            Mp(a, b);
            return;
        }
        function jp(a) {
            a = a | 0;
            return a + 48 | 0;
        }
        function kp(b) {
            b = b | 0;
            var d = 0;
            d = i;
            i = i + 16 | 0;
            if ((a[32] | 0) == 0 ? (Aa(32) | 0) != 0 : 0) lb(32);
            Cp(b, d);
            c[118] = c[d >> 2];
            c[119] = c[d + 4 >> 2];
            c[120] = c[d + 8 >> 2];
            c[121] = c[d + 12 >> 2];
            i = d;
            return 472;
        }
        function lp(a) {
            a = a | 0;
            return a | 0;
        }
        function mp(a) {
            a = a | 0;
            if (!a) return;
            Cq(a);
            return;
        }
        function np(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0;
            e = Bq(152) | 0;
            a: do {
                if (!e) {
                    while (1) {
                        e = c[187] | 0;
                        c[187] = e + 0;
                        if (!e) break;
                        Ic[e & 3]();
                        e = Bq(152) | 0;
                        if (e) break a;
                    }
                    d = Ib(4) | 0;
                    c[d >> 2] = 736;
                    pc(d | 0, 176, 11);
                }
            } while (0);
            db(e | 0, a | 0, b | 0, d | 0);
            return e | 0;
        }
        function op(a, b, c) {
            a = a | 0;
            b = +b;
            c = c | 0;
            ib(a | 0, +b, c | 0);
            return;
        }
        function pp(a, b, c) {
            a = a | 0;
            b = +b;
            c = c | 0;
            fc(a | 0, +b, c | 0);
            return;
        }
        function qp(a, b) {
            a = a | 0;
            b = b | 0;
            return eb(a | 0, b | 0) | 0;
        }
        function rp(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            Yb(a | 0, b | 0, c | 0);
            return;
        }
        function sp(a, b, c, d, e, f, g, h) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = +e;
            f = +f;
            g = g | 0;
            h = h | 0;
            return tc(a | 0, b | 0, c | 0, d | 0, +e, +f, g | 0, h | 0) | 0;
        }
        function tp(a) {
            a = a | 0;
            return c[a + 136 >> 2] | 0;
        }
        function up(a) {
            a = a | 0;
            return c[a + 116 >> 2] | 0;
        }
        function vp(a, b) {
            a = a | 0;
            b = b | 0;
            return Ab(a | 0, b | 0) | 0;
        }
        function wp(a, b, c) {
            a = a | 0;
            b = +b;
            c = c | 0;
            qc(a | 0, +b, c | 0);
            return;
        }
        function xp(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            Lc[c[(c[a >> 2] | 0) + 24 >> 2] & 3](a, b, d, e);
            return;
        }
        function yp(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function zp() {
            var a = 0, b = 0;
            a = Bq(4) | 0;
            if (a) {
                b = a;
                c[b >> 2] = 496;
                return b | 0;
            }
            while (1) {
                a = c[187] | 0;
                c[187] = a + 0;
                if (!a) {
                    b = 4;
                    break;
                }
                Ic[a & 3]();
                a = Bq(4) | 0;
                if (a) {
                    b = 5;
                    break;
                }
            }
            if ((b | 0) == 4) {
                b = Ib(4) | 0;
                c[b >> 2] = 736;
                pc(b | 0, 176, 11);
            } else if ((b | 0) == 5) {
                c[a >> 2] = 496;
                return a | 0;
            }
            return 0;
        }
        function Ap(a) {
            a = a | 0;
            if (!a) return;
            wc[c[(c[a >> 2] | 0) + 4 >> 2] & 31](a);
            return;
        }
        function Bp(a) {
            a = a | 0;
            var b = 0, d = 0;
            b = i;
            i = i + 16 | 0;
            Na(a | 0) | 0;
            if (ub(836, 2) | 0) dq(2350, b);
            a = Ob(c[208] | 0) | 0;
            if (((a | 0) != 0 ? (d = c[a >> 2] | 0, (d | 0) != 0) : 0) ? (c[d + 48 >> 2] & -256 | 0) == 1126902528 ? (c[d + 48 + 4 >> 2] | 0) == 1129074247 : 0 : 0) hq(c[d + 12 >> 2] | 0);
            d = c[181] | 0;
            c[181] = d + 0;
            hq(d);
        }
        function Cp(a, b) {
            a = a | 0;
            b = b | 0;
            var d = 0, e = 0, f = 0, h = 0, j = 0, l = 0, m = 0, n = 0;
            h = i;
            i = i + 16 | 0;
            d = +g[a >> 2];
            e = +g[a + 20 >> 2];
            f = +g[a + 40 >> 2];
            if (d + e + f > 0) {
                f = +Q(+(d + e + f + 1));
                g[h + 12 >> 2] = f * .5;
                n = (+g[a + 36 >> 2] - +g[a + 24 >> 2]) * (.5 / f);
                g[h >> 2] = n;
                d = (+g[a + 8 >> 2] - +g[a + 32 >> 2]) * (.5 / f);
                g[h + 4 >> 2] = d;
                e = (+g[a + 16 >> 2] - +g[a + 4 >> 2]) * (.5 / f);
                g[h + 8 >> 2] = e;
                a = (g[k >> 2] = n, c[k >> 2] | 0);
                m = (g[k >> 2] = d, c[k >> 2] | 0);
                l = (g[k >> 2] = e, c[k >> 2] | 0);
                j = (g[k >> 2] = f * .5, c[k >> 2] | 0);
                c[b >> 2] = a;
                a = b + 4 | 0;
                c[a >> 2] = m;
                a = b + 8 | 0;
                c[a >> 2] = l;
                a = b + 12 | 0;
                c[a >> 2] = j;
                i = h;
                return;
            } else {
                m = d < e ? e < f ? 2 : 1 : d < f ? 2 : 0;
                n = +Q(+(+g[a + (m << 4) + (m << 2) >> 2] - +g[a + ((((m + 1 | 0) >>> 0) % 3 | 0) << 4) + ((((m + 1 | 0) >>> 0) % 3 | 0) << 2) >> 2] - +g[a + ((((m + 2 | 0) >>> 0) % 3 | 0) << 4) + ((((m + 2 | 0) >>> 0) % 3 | 0) << 2) >> 2] + 1));
                g[h + (m << 2) >> 2] = n * .5;
                g[h + 12 >> 2] = (+g[a + ((((m + 2 | 0) >>> 0) % 3 | 0) << 4) + ((((m + 1 | 0) >>> 0) % 3 | 0) << 2) >> 2] - +g[a + ((((m + 1 | 0) >>> 0) % 3 | 0) << 4) + ((((m + 2 | 0) >>> 0) % 3 | 0) << 2) >> 2]) * (.5 / n);
                g[h + ((((m + 1 | 0) >>> 0) % 3 | 0) << 2) >> 2] = (+g[a + ((((m + 1 | 0) >>> 0) % 3 | 0) << 4) + (m << 2) >> 2] + +g[a + (m << 4) + ((((m + 1 | 0) >>> 0) % 3 | 0) << 2) >> 2]) * (.5 / n);
                g[h + ((((m + 2 | 0) >>> 0) % 3 | 0) << 2) >> 2] = (+g[a + ((((m + 2 | 0) >>> 0) % 3 | 0) << 4) + (m << 2) >> 2] + +g[a + (m << 4) + ((((m + 2 | 0) >>> 0) % 3 | 0) << 2) >> 2]) * (.5 / n);
                m = c[h >> 2] | 0;
                a = c[h + 4 >> 2] | 0;
                j = c[h + 8 >> 2] | 0;
                l = c[h + 12 >> 2] | 0;
                c[b >> 2] = m;
                m = b + 4 | 0;
                c[m >> 2] = a;
                m = b + 8 | 0;
                c[m >> 2] = j;
                m = b + 12 | 0;
                c[m >> 2] = l;
                i = h;
                return;
            }
        }
        function Dp() {
            var b = 0;
            b = i;
            i = i + 48 | 0;
            if (a[112] | 0) {
                i = b;
                return;
            }
            if (!(Aa(112) | 0)) {
                i = b;
                return;
            }
            if ((a[120] | 0) == 0 ? (Aa(120) | 0) != 0 : 0) {
                g[b + 32 >> 2] = 1;
                g[b + 28 >> 2] = 0;
                g[b + 24 >> 2] = 0;
                g[b + 20 >> 2] = 0;
                g[b + 16 >> 2] = 1;
                g[b + 12 >> 2] = 0;
                g[b + 8 >> 2] = 0;
                g[b + 4 >> 2] = 0;
                g[b >> 2] = 1;
                c[157] = c[b + 32 >> 2];
                c[158] = c[b + 28 >> 2];
                c[159] = c[b + 24 >> 2];
                g[160] = 0;
                c[161] = c[b + 20 >> 2];
                c[162] = c[b + 16 >> 2];
                c[163] = c[b + 12 >> 2];
                g[164] = 0;
                c[165] = c[b + 8 >> 2];
                c[166] = c[b + 4 >> 2];
                c[167] = c[b >> 2];
                g[168] = 0;
                lb(120);
            }
            c[141] = c[157];
            c[142] = c[158];
            c[143] = c[159];
            c[144] = c[160];
            c[145] = c[161];
            c[146] = c[162];
            c[147] = c[163];
            c[148] = c[164];
            c[149] = c[165];
            c[150] = c[166];
            c[151] = c[167];
            c[152] = c[168];
            c[153] = 0;
            c[154] = 0;
            c[155] = 0;
            c[156] = 0;
            lb(112);
            i = b;
            return;
        }
        function Ep(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            c[a >> 2] = 548;
            c[a + 4 >> 2] = c[b >> 2];
            c[a + 4 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 4 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 4 + 12 >> 2] = c[b + 12 >> 2];
            c[a + 20 >> 2] = c[b + 16 >> 2];
            c[a + 20 + 4 >> 2] = c[b + 16 + 4 >> 2];
            c[a + 20 + 8 >> 2] = c[b + 16 + 8 >> 2];
            c[a + 20 + 12 >> 2] = c[b + 16 + 12 >> 2];
            c[a + 36 >> 2] = c[b + 32 >> 2];
            c[a + 36 + 4 >> 2] = c[b + 32 + 4 >> 2];
            c[a + 36 + 8 >> 2] = c[b + 32 + 8 >> 2];
            c[a + 36 + 12 >> 2] = c[b + 32 + 12 >> 2];
            c[a + 52 >> 2] = c[b + 48 >> 2];
            c[a + 52 + 4 >> 2] = c[b + 48 + 4 >> 2];
            c[a + 52 + 8 >> 2] = c[b + 48 + 8 >> 2];
            c[a + 52 + 12 >> 2] = c[b + 48 + 12 >> 2];
            c[a + 68 >> 2] = c[d >> 2];
            c[a + 68 + 4 >> 2] = c[d + 4 >> 2];
            c[a + 68 + 8 >> 2] = c[d + 8 >> 2];
            c[a + 68 + 12 >> 2] = c[d + 12 >> 2];
            c[a + 84 >> 2] = c[d + 16 >> 2];
            c[a + 84 + 4 >> 2] = c[d + 16 + 4 >> 2];
            c[a + 84 + 8 >> 2] = c[d + 16 + 8 >> 2];
            c[a + 84 + 12 >> 2] = c[d + 16 + 12 >> 2];
            c[a + 100 >> 2] = c[d + 32 >> 2];
            c[a + 100 + 4 >> 2] = c[d + 32 + 4 >> 2];
            c[a + 100 + 8 >> 2] = c[d + 32 + 8 >> 2];
            c[a + 100 + 12 >> 2] = c[d + 32 + 12 >> 2];
            c[a + 116 >> 2] = c[d + 48 >> 2];
            c[a + 116 + 4 >> 2] = c[d + 48 + 4 >> 2];
            c[a + 116 + 8 >> 2] = c[d + 48 + 8 >> 2];
            c[a + 116 + 12 >> 2] = c[d + 48 + 12 >> 2];
            c[a + 132 >> 2] = c[b >> 2];
            c[a + 132 + 4 >> 2] = c[b + 4 >> 2];
            c[a + 132 + 8 >> 2] = c[b + 8 >> 2];
            c[a + 132 + 12 >> 2] = c[b + 12 >> 2];
            c[a + 148 >> 2] = c[b + 16 >> 2];
            c[a + 148 + 4 >> 2] = c[b + 16 + 4 >> 2];
            c[a + 148 + 8 >> 2] = c[b + 16 + 8 >> 2];
            c[a + 148 + 12 >> 2] = c[b + 16 + 12 >> 2];
            c[a + 164 >> 2] = c[b + 32 >> 2];
            c[a + 164 + 4 >> 2] = c[b + 32 + 4 >> 2];
            c[a + 164 + 8 >> 2] = c[b + 32 + 8 >> 2];
            c[a + 164 + 12 >> 2] = c[b + 32 + 12 >> 2];
            c[a + 180 >> 2] = c[b + 48 >> 2];
            c[a + 180 + 4 >> 2] = c[b + 48 + 4 >> 2];
            c[a + 180 + 8 >> 2] = c[b + 48 + 8 >> 2];
            c[a + 180 + 12 >> 2] = c[b + 48 + 12 >> 2];
            c[a + 196 >> 2] = 0;
            return;
        }
        function Fp(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0, d = 0, e = 0;
            e = +g[a + 368 >> 2];
            d = +g[b + 4 >> 2] * +g[a + 376 >> 2] * e;
            c = +g[b + 8 >> 2] * +g[a + 380 >> 2] * e;
            g[a + 336 >> 2] = +g[a + 336 >> 2] + +g[b >> 2] * +g[a + 372 >> 2] * e;
            g[a + 340 >> 2] = +g[a + 340 >> 2] + d;
            g[a + 344 >> 2] = +g[a + 344 >> 2] + c;
            return;
        }
        function Gp(a) {
            a = a | 0;
            var b = 0;
            b = i;
            i = i + 32 | 0;
            g[b + 20 >> 2] = 0;
            g[b + 16 >> 2] = 0;
            g[b + 12 >> 2] = 1;
            g[b + 8 >> 2] = 0;
            g[b + 4 >> 2] = 0;
            g[b >> 2] = 1;
            c[a >> 2] = 1065353216;
            c[a + 4 >> 2] = c[b + 20 >> 2];
            c[a + 8 >> 2] = c[b + 16 >> 2];
            g[a + 12 >> 2] = 0;
            c[a + 16 >> 2] = 0;
            c[a + 20 >> 2] = c[b + 12 >> 2];
            c[a + 24 >> 2] = c[b + 8 >> 2];
            g[a + 28 >> 2] = 0;
            c[a + 32 >> 2] = 0;
            c[a + 36 >> 2] = c[b + 4 >> 2];
            c[a + 40 >> 2] = c[b >> 2];
            g[a + 44 >> 2] = 0;
            c[a + 48 >> 2] = 0;
            c[a + 48 + 4 >> 2] = 0;
            c[a + 48 + 8 >> 2] = 0;
            c[a + 48 + 12 >> 2] = 0;
            i = b;
            return;
        }
        function Hp(a) {
            a = a | 0;
            return;
        }
        function Ip(a) {
            a = a | 0;
            Cq(a);
            return;
        }
        function Jp(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0;
            e = c[b >> 2] | 0;
            a = c[d >> 2] | 0;
            e = (c[e + 236 >> 2] | 0) == 4 ? e : 0;
            a = (c[a + 236 >> 2] | 0) == 4 ? a : 0;
            if (e) Hc[c[(c[e >> 2] | 0) + 28 >> 2] & 1](e, d, b);
            if (!a) return 0;
            Hc[c[(c[a >> 2] | 0) + 28 >> 2] & 1](a, b, d);
            return 0;
        }
        function Kp(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            var f = 0;
            f = c[b >> 2] | 0;
            a = c[d >> 2] | 0;
            f = (c[f + 236 >> 2] | 0) == 4 ? f : 0;
            a = (c[a + 236 >> 2] | 0) == 4 ? a : 0;
            if (f) Lc[c[(c[f >> 2] | 0) + 32 >> 2] & 3](f, d, e, b);
            if (!a) return 0;
            Lc[c[(c[a >> 2] | 0) + 32 >> 2] & 3](a, b, e, d);
            return 0;
        }
        function Lp(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            return;
        }
        function Mp(a, b) {
            a = a | 0;
            b = b | 0;
            var d = 0, e = 0, f = 0, h = 0, j = 0, k = 0, l = 0, m = 0;
            d = i;
            i = i + 32 | 0;
            j = +g[b >> 2];
            l = +g[b + 4 >> 2];
            k = +g[b + 8 >> 2];
            f = +g[b + 12 >> 2];
            m = j * (2 / (j * j + l * l + k * k + f * f));
            e = l * (2 / (j * j + l * l + k * k + f * f));
            h = k * (2 / (j * j + l * l + k * k + f * f));
            g[d + 20 >> 2] = j * e - f * h;
            g[d + 16 >> 2] = j * h + f * e;
            g[d + 12 >> 2] = 1 - (j * m + k * h);
            g[d + 8 >> 2] = l * h - f * m;
            g[d + 4 >> 2] = l * h + f * m;
            g[d >> 2] = 1 - (j * m + l * e);
            g[a >> 2] = 1 - (l * e + k * h);
            c[a + 4 >> 2] = c[d + 20 >> 2];
            c[a + 8 >> 2] = c[d + 16 >> 2];
            g[a + 12 >> 2] = 0;
            g[a + 16 >> 2] = j * e + f * h;
            c[a + 20 >> 2] = c[d + 12 >> 2];
            c[a + 24 >> 2] = c[d + 8 >> 2];
            g[a + 28 >> 2] = 0;
            g[a + 32 >> 2] = j * h - f * e;
            c[a + 36 >> 2] = c[d + 4 >> 2];
            c[a + 40 >> 2] = c[d >> 2];
            g[a + 44 >> 2] = 0;
            i = d;
            return;
        }
        function Np(a) {
            a = a | 0;
            return;
        }
        function Op(a) {
            a = a | 0;
            Cq(a);
            return;
        }
        function Pp(a, c) {
            a = a | 0;
            c = c | 0;
            if (!((b[c + 4 >> 1] & b[a + 14 >> 1]) << 16 >> 16)) {
                a = 0;
                return a | 0;
            }
            a = (b[a + 12 >> 1] & b[c + 6 >> 1]) << 16 >> 16 != 0;
            return a | 0;
        }
        function Qp(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0, f = 0, h = 0, i = 0, j = 0, k = 0;
            c[a + 4 >> 2] = c[b + 24 >> 2];
            e = c[b >> 2] | 0;
            c[a + 8 >> 2] = e;
            if (d) {
                c[a + 52 >> 2] = c[b + 8 >> 2];
                c[a + 52 + 4 >> 2] = c[b + 8 + 4 >> 2];
                c[a + 52 + 8 >> 2] = c[b + 8 + 8 >> 2];
                c[a + 52 + 12 >> 2] = c[b + 8 + 12 >> 2];
            } else {
                k = +g[b + 8 >> 2];
                j = +g[b + 12 >> 2];
                i = +g[b + 16 >> 2];
                h = +g[e + 20 >> 2] * k + +g[e + 24 >> 2] * j + +g[e + 28 >> 2] * i;
                f = +g[e + 36 >> 2] * k + +g[e + 40 >> 2] * j + +g[e + 44 >> 2] * i;
                g[a + 52 >> 2] = +g[e + 4 >> 2] * k + +g[e + 8 >> 2] * j + +g[e + 12 >> 2] * i;
                g[a + 56 >> 2] = h;
                g[a + 60 >> 2] = f;
                g[a + 64 >> 2] = 0;
            }
            k = +g[b + 24 >> 2];
            g[a + 68 >> 2] = (1 - k) * +g[a + 20 >> 2] + +g[a + 36 >> 2] * k;
            g[a + 72 >> 2] = (1 - k) * +g[a + 24 >> 2] + k * +g[a + 40 >> 2];
            g[a + 76 >> 2] = (1 - k) * +g[a + 28 >> 2] + k * +g[a + 44 >> 2];
            return + +g[b + 24 >> 2];
        }
        function Rp(a) {
            a = a | 0;
            return;
        }
        function Sp(a) {
            a = a | 0;
            Ia(a | 0);
            return;
        }
        function Tp(a, b) {
            a = a | 0;
            b = b | 0;
            var d = 0, e = 0, f = 0, h = 0, j = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0;
            d = i;
            i = i + 176 | 0;
            q = c[a + 68 >> 2] | 0;
            c[d + 128 >> 2] = q;
            o = c[a + 84 >> 2] | 0;
            c[d + 128 + 4 >> 2] = o;
            m = c[a + 100 >> 2] | 0;
            c[d + 128 + 8 >> 2] = m;
            g[d + 128 + 12 >> 2] = 0;
            l = d + 128 + 16 | 0;
            t = c[a + 72 >> 2] | 0;
            c[l >> 2] = t;
            s = c[a + 88 >> 2] | 0;
            c[d + 128 + 20 >> 2] = s;
            r = c[a + 104 >> 2] | 0;
            c[d + 128 + 24 >> 2] = r;
            g[d + 128 + 28 >> 2] = 0;
            j = d + 128 + 32 | 0;
            w = c[a + 76 >> 2] | 0;
            c[j >> 2] = w;
            v = c[a + 92 >> 2] | 0;
            c[d + 128 + 36 >> 2] = v;
            u = c[a + 108 >> 2] | 0;
            c[d + 128 + 40 >> 2] = u;
            g[d + 128 + 44 >> 2] = 0;
            p = - +g[a + 116 >> 2];
            n = - +g[a + 120 >> 2];
            h = - +g[a + 124 >> 2];
            e = (c[k >> 2] = w, +g[k >> 2]) * p;
            e = e + (c[k >> 2] = v, +g[k >> 2]) * n;
            e = e + (c[k >> 2] = u, +g[k >> 2]) * h;
            f = (c[k >> 2] = t, +g[k >> 2]) * p;
            f = f + (c[k >> 2] = s, +g[k >> 2]) * n;
            f = f + (c[k >> 2] = r, +g[k >> 2]) * h;
            p = (c[k >> 2] = q, +g[k >> 2]) * p;
            n = p + (c[k >> 2] = o, +g[k >> 2]) * n;
            h = n + (c[k >> 2] = m, +g[k >> 2]) * h;
            c[d >> 2] = c[d + 128 >> 2];
            c[d + 4 >> 2] = c[d + 128 + 4 >> 2];
            c[d + 8 >> 2] = c[d + 128 + 8 >> 2];
            c[d + 12 >> 2] = c[d + 128 + 12 >> 2];
            c[d + 16 >> 2] = c[l >> 2];
            c[d + 16 + 4 >> 2] = c[l + 4 >> 2];
            c[d + 16 + 8 >> 2] = c[l + 8 >> 2];
            c[d + 16 + 12 >> 2] = c[l + 12 >> 2];
            c[d + 32 >> 2] = c[j >> 2];
            c[d + 32 + 4 >> 2] = c[j + 4 >> 2];
            c[d + 32 + 8 >> 2] = c[j + 8 >> 2];
            c[d + 32 + 12 >> 2] = c[j + 12 >> 2];
            g[d + 48 >> 2] = h;
            g[d + 52 >> 2] = f;
            g[d + 56 >> 2] = e;
            g[d + 60 >> 2] = 0;
            Vp(d + 64 | 0, a + 4 | 0, d);
            c[b >> 2] = c[d + 64 >> 2];
            c[b + 4 >> 2] = c[d + 64 + 4 >> 2];
            c[b + 8 >> 2] = c[d + 64 + 8 >> 2];
            c[b + 12 >> 2] = c[d + 64 + 12 >> 2];
            c[b + 16 >> 2] = c[d + 64 + 16 >> 2];
            c[b + 16 + 4 >> 2] = c[d + 64 + 16 + 4 >> 2];
            c[b + 16 + 8 >> 2] = c[d + 64 + 16 + 8 >> 2];
            c[b + 16 + 12 >> 2] = c[d + 64 + 16 + 12 >> 2];
            c[b + 32 >> 2] = c[d + 64 + 32 >> 2];
            c[b + 32 + 4 >> 2] = c[d + 64 + 32 + 4 >> 2];
            c[b + 32 + 8 >> 2] = c[d + 64 + 32 + 8 >> 2];
            c[b + 32 + 12 >> 2] = c[d + 64 + 32 + 12 >> 2];
            c[b + 48 >> 2] = c[d + 64 + 48 >> 2];
            c[b + 48 + 4 >> 2] = c[d + 64 + 48 + 4 >> 2];
            c[b + 48 + 8 >> 2] = c[d + 64 + 48 + 8 >> 2];
            c[b + 48 + 12 >> 2] = c[d + 64 + 48 + 12 >> 2];
            i = d;
            return;
        }
        function Up(a, b) {
            a = a | 0;
            b = b | 0;
            var d = 0;
            d = i;
            i = i + 64 | 0;
            Vp(d, b, a + 68 | 0);
            c[a + 4 >> 2] = c[d >> 2];
            c[a + 4 + 4 >> 2] = c[d + 4 >> 2];
            c[a + 4 + 8 >> 2] = c[d + 8 >> 2];
            c[a + 4 + 12 >> 2] = c[d + 12 >> 2];
            c[a + 20 >> 2] = c[d + 16 >> 2];
            c[a + 20 + 4 >> 2] = c[d + 16 + 4 >> 2];
            c[a + 20 + 8 >> 2] = c[d + 16 + 8 >> 2];
            c[a + 20 + 12 >> 2] = c[d + 16 + 12 >> 2];
            c[a + 36 >> 2] = c[d + 32 >> 2];
            c[a + 36 + 4 >> 2] = c[d + 32 + 4 >> 2];
            c[a + 36 + 8 >> 2] = c[d + 32 + 8 >> 2];
            c[a + 36 + 12 >> 2] = c[d + 32 + 12 >> 2];
            c[a + 52 >> 2] = c[d + 48 >> 2];
            c[a + 52 + 4 >> 2] = c[d + 48 + 4 >> 2];
            c[a + 52 + 8 >> 2] = c[d + 48 + 8 >> 2];
            c[a + 52 + 12 >> 2] = c[d + 48 + 12 >> 2];
            i = d;
            return;
        }
        function Vp(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0, f = 0, h = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0;
            e = i;
            i = i + 96 | 0;
            w = +g[d >> 2];
            n = +g[b >> 2];
            v = +g[d + 16 >> 2];
            o = +g[b + 4 >> 2];
            u = +g[d + 32 >> 2];
            j = +g[b + 8 >> 2];
            g[e + 80 >> 2] = w * n + v * o + u * j;
            t = +g[d + 4 >> 2];
            s = +g[d + 20 >> 2];
            r = +g[d + 36 >> 2];
            g[e + 76 >> 2] = t * n + s * o + r * j;
            k = +g[d + 8 >> 2];
            l = +g[d + 24 >> 2];
            m = +g[d + 40 >> 2];
            g[e + 72 >> 2] = k * n + l * o + m * j;
            o = +g[b + 16 >> 2];
            n = +g[b + 20 >> 2];
            h = +g[b + 24 >> 2];
            g[e + 68 >> 2] = w * o + v * n + u * h;
            g[e + 64 >> 2] = t * o + s * n + r * h;
            g[e + 60 >> 2] = k * o + l * n + m * h;
            q = +g[b + 32 >> 2];
            p = +g[b + 36 >> 2];
            f = +g[b + 40 >> 2];
            g[e + 56 >> 2] = w * q + v * p + u * f;
            g[e + 52 >> 2] = t * q + s * p + r * f;
            g[e + 48 >> 2] = k * q + l * p + m * f;
            c[e >> 2] = c[e + 80 >> 2];
            c[e + 4 >> 2] = c[e + 76 >> 2];
            c[e + 8 >> 2] = c[e + 72 >> 2];
            g[e + 12 >> 2] = 0;
            c[e + 16 >> 2] = c[e + 68 >> 2];
            c[e + 20 >> 2] = c[e + 64 >> 2];
            c[e + 24 >> 2] = c[e + 60 >> 2];
            g[e + 28 >> 2] = 0;
            c[e + 32 >> 2] = c[e + 56 >> 2];
            c[e + 36 >> 2] = c[e + 52 >> 2];
            c[e + 40 >> 2] = c[e + 48 >> 2];
            g[e + 44 >> 2] = 0;
            m = +g[d + 48 >> 2];
            l = +g[d + 52 >> 2];
            k = +g[d + 56 >> 2];
            f = m * q + l * p + k * f + +g[b + 56 >> 2];
            h = m * o + l * n + k * h + +g[b + 52 >> 2];
            j = m * +g[b >> 2] + l * +g[b + 4 >> 2] + k * j + +g[b + 48 >> 2];
            c[a >> 2] = c[e >> 2];
            c[a + 4 >> 2] = c[e + 4 >> 2];
            c[a + 8 >> 2] = c[e + 8 >> 2];
            c[a + 12 >> 2] = c[e + 12 >> 2];
            c[a + 16 >> 2] = c[e + 16 >> 2];
            c[a + 16 + 4 >> 2] = c[e + 16 + 4 >> 2];
            c[a + 16 + 8 >> 2] = c[e + 16 + 8 >> 2];
            c[a + 16 + 12 >> 2] = c[e + 16 + 12 >> 2];
            c[a + 32 >> 2] = c[e + 32 >> 2];
            c[a + 32 + 4 >> 2] = c[e + 32 + 4 >> 2];
            c[a + 32 + 8 >> 2] = c[e + 32 + 8 >> 2];
            c[a + 32 + 12 >> 2] = c[e + 32 + 12 >> 2];
            g[a + 48 >> 2] = j;
            g[a + 52 >> 2] = h;
            g[a + 56 >> 2] = f;
            g[a + 60 >> 2] = 0;
            i = e;
            return;
        }
        function Wp(a) {
            a = a | 0;
            return;
        }
        function Xp(a) {
            a = a | 0;
            Cq(a);
            return;
        }
        function Yp(a, c) {
            a = a | 0;
            c = c | 0;
            if (!((b[c + 4 >> 1] & b[a + 10 >> 1]) << 16 >> 16)) {
                a = 0;
                return a | 0;
            }
            a = (b[a + 8 >> 1] & b[c + 6 >> 1]) << 16 >> 16 != 0;
            return a | 0;
        }
        function Zp(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0, f = 0, h = 0, i = 0, j = 0, k = 0;
            c[a + 4 >> 2] = c[b + 40 >> 2];
            e = c[b >> 2] | 0;
            c[a + 76 >> 2] = e;
            if (d) {
                c[a + 44 >> 2] = c[b + 8 >> 2];
                c[a + 44 + 4 >> 2] = c[b + 8 + 4 >> 2];
                c[a + 44 + 8 >> 2] = c[b + 8 + 8 >> 2];
                c[a + 44 + 12 >> 2] = c[b + 8 + 12 >> 2];
                a = a + 60 | 0;
                d = b + 24 | 0;
                c[a >> 2] = c[d >> 2];
                c[a + 4 >> 2] = c[d + 4 >> 2];
                c[a + 8 >> 2] = c[d + 8 >> 2];
                c[a + 12 >> 2] = c[d + 12 >> 2];
                f = +g[b + 40 >> 2];
                return +f;
            } else {
                k = +g[b + 8 >> 2];
                j = +g[b + 12 >> 2];
                i = +g[b + 16 >> 2];
                h = +g[e + 20 >> 2] * k + +g[e + 24 >> 2] * j + +g[e + 28 >> 2] * i;
                f = +g[e + 36 >> 2] * k + +g[e + 40 >> 2] * j + +g[e + 44 >> 2] * i;
                g[a + 44 >> 2] = +g[e + 4 >> 2] * k + +g[e + 8 >> 2] * j + +g[e + 12 >> 2] * i;
                g[a + 48 >> 2] = h;
                g[a + 52 >> 2] = f;
                g[a + 56 >> 2] = 0;
                a = a + 60 | 0;
                d = b + 24 | 0;
                c[a >> 2] = c[d >> 2];
                c[a + 4 >> 2] = c[d + 4 >> 2];
                c[a + 8 >> 2] = c[d + 8 >> 2];
                c[a + 12 >> 2] = c[d + 12 >> 2];
                f = +g[b + 40 >> 2];
                return +f;
            }
            return 0;
        }
        function _p(a) {
            a = +a;
            var b = 0, d = 0, e = 0, f = 0, h = 0, i = 0;
            i = (g[k >> 2] = a, c[k >> 2] | 0);
            a: do {
                if ((i >>> 23 & 255 | 0) == 255) a = a * 6.2831854820251465 / (a * 6.2831854820251465); else {
                    if (i << 1 >>> 0 <= 2173837238) {
                        a = (i << 1 | 0) == -2121130058 ? a * 0 : a;
                        break;
                    }
                    if (!(i >>> 23 & 255)) {
                        if ((i << 9 | 0) > -1) {
                            d = 0;
                            b = i << 9;
                            do {
                                d = d + -1 | 0;
                                b = b << 1;
                            } while ((b | 0) > -1);
                        } else d = 0;
                        b = d;
                        e = i << 1 - d;
                    } else {
                        b = i >>> 23 & 255;
                        e = i & 8388607 | 8388608;
                    }
                    f = e + -13176795 | 0;
                    b: do {
                        if ((b | 0) > 129) {
                            h = (f | 0) > -1;
                            d = f;
                            while (1) {
                                if (h) {
                                    if ((e | 0) == 13176795) break;
                                } else d = e;
                                e = d << 1;
                                b = b + -1 | 0;
                                if ((b | 0) > 129) {
                                    h = (e + -13176795 | 0) > -1;
                                    d = e + -13176795 | 0;
                                } else {
                                    d = e + -13176795 | 0;
                                    f = (e + -13176795 | 0) > -1;
                                    break b;
                                }
                            }
                            a = a * 0;
                            break a;
                        } else {
                            d = f;
                            f = (f | 0) > -1;
                        }
                    } while (0);
                    if (f) {
                        if ((e | 0) == 13176795) {
                            a = a * 0;
                            break;
                        }
                    } else d = e;
                    if (d >>> 0 < 8388608) do {
                        d = d << 1;
                        b = b + -1 | 0;
                    } while (d >>> 0 < 8388608);
                    if ((b | 0) > 0) b = d + -8388608 | b << 23; else b = d >>> (1 - b | 0);
                    a = (c[k >> 2] = b | i & -2147483648, +g[k >> 2]);
                }
            } while (0);
            if (a < -3.1415927410125732) {
                a = a + 6.2831854820251465;
                return +a;
            }
            if (!(a > 3.1415927410125732)) return +a;
            a = a + -6.2831854820251465;
            return +a;
        }
        function $p(a) {
            a = a | 0;
            return;
        }
        function aq(a) {
            a = a | 0;
            Cq(a);
            return;
        }
        function bq(a, c) {
            a = a | 0;
            c = c | 0;
            if (!((b[c + 4 >> 1] & b[a + 6 >> 1]) << 16 >> 16)) {
                a = 0;
                return a | 0;
            }
            a = (b[a + 4 >> 1] & b[c + 6 >> 1]) << 16 >> 16 != 0;
            return a | 0;
        }
        function cq(a, b, c, d, e, f, g, h) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            h = h | 0;
            return + +Bb(0, a | 0, b | 0, c | 0, d | 0, e | 0, f | 0, g | 0, h | 0);
        }
        function dq(b, d) {
            b = b | 0;
            d = d | 0;
            var e = 0, f = 0, g = 0;
            g = i;
            i = i + 16 | 0;
            c[g >> 2] = d;
            Mq(1384, b, g) | 0;
            b = (a[1459] | 0) == 10;
            do {
                if ((c[365] | 0) < 0) {
                    if (!b ? (e = c[351] | 0, e >>> 0 < (c[350] | 0) >>> 0) : 0) {
                        c[351] = e + 1;
                        a[e >> 0] = 10;
                        break;
                    }
                    Gq(1384, 10) | 0;
                } else {
                    if (!b ? (f = c[351] | 0, f >>> 0 < (c[350] | 0) >>> 0) : 0) {
                        c[351] = f + 1;
                        a[f >> 0] = 10;
                        break;
                    }
                    Gq(1384, 10) | 0;
                }
            } while (0);
            Wb();
        }
        function eq(a) {
            a = a | 0;
            return;
        }
        function fq(a) {
            a = a | 0;
            Cq(a);
            return;
        }
        function gq(a) {
            a = a | 0;
            return 2399;
        }
        function hq(a) {
            a = a | 0;
            var b = 0;
            b = i;
            i = i + 16 | 0;
            Ic[a & 3]();
            dq(2414, b);
        }
        function iq(a) {
            a = a | 0;
            return;
        }
        function jq(a) {
            a = a | 0;
            return;
        }
        function kq(a) {
            a = a | 0;
            return;
        }
        function lq(a) {
            a = a | 0;
            Cq(a);
            return;
        }
        function mq(a) {
            a = a | 0;
            Cq(a);
            return;
        }
        function nq(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0, f = 0, g = 0;
            g = i;
            i = i + 64 | 0;
            if ((a | 0) != (b | 0)) if ((b | 0) != 0 ? (f = qq(b, 224) | 0, (f | 0) != 0) : 0) {
                b = g;
                e = b + 56 | 0;
                do {
                    c[b >> 2] = 0;
                    b = b + 4 | 0;
                } while ((b | 0) < (e | 0));
                c[g >> 2] = f;
                c[g + 8 >> 2] = a;
                c[g + 12 >> 2] = -1;
                c[g + 48 >> 2] = 1;
                Lc[c[(c[f >> 2] | 0) + 28 >> 2] & 3](f, g, c[d >> 2] | 0, 1);
                if ((c[g + 24 >> 2] | 0) == 1) {
                    c[d >> 2] = c[g + 16 >> 2];
                    b = 1;
                } else b = 0;
            } else b = 0; else b = 1;
            i = g;
            return b | 0;
        }
        function oq(b, d, e, f) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            do {
                if ((b | 0) == (c[d + 8 >> 2] | 0)) {
                    b = c[d + 16 >> 2] | 0;
                    if (!b) {
                        c[d + 16 >> 2] = e;
                        c[d + 24 >> 2] = f;
                        c[d + 36 >> 2] = 1;
                        break;
                    }
                    if ((b | 0) != (e | 0)) {
                        c[d + 36 >> 2] = (c[d + 36 >> 2] | 0) + 1;
                        c[d + 24 >> 2] = 2;
                        a[d + 54 >> 0] = 1;
                        break;
                    }
                    if ((c[d + 24 >> 2] | 0) == 2) c[d + 24 >> 2] = f;
                }
            } while (0);
            return;
        }
        function pq(b, d, e, f) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            do {
                if ((b | 0) == (c[d + 8 >> 2] | 0)) {
                    b = c[d + 16 >> 2] | 0;
                    if (!b) {
                        c[d + 16 >> 2] = e;
                        c[d + 24 >> 2] = f;
                        c[d + 36 >> 2] = 1;
                        break;
                    }
                    if ((b | 0) != (e | 0)) {
                        c[d + 36 >> 2] = (c[d + 36 >> 2] | 0) + 1;
                        c[d + 24 >> 2] = 2;
                        a[d + 54 >> 0] = 1;
                        break;
                    }
                    if ((c[d + 24 >> 2] | 0) == 2) c[d + 24 >> 2] = f;
                } else {
                    b = c[b + 8 >> 2] | 0;
                    Lc[c[(c[b >> 2] | 0) + 28 >> 2] & 3](b, d, e, f);
                }
            } while (0);
            return;
        }
        function qq(d, e) {
            d = d | 0;
            e = e | 0;
            var f = 0, g = 0, h = 0, j = 0;
            j = i;
            i = i + 64 | 0;
            h = c[d >> 2] | 0;
            g = d + (c[h + -8 >> 2] | 0) | 0;
            h = c[h + -4 >> 2] | 0;
            c[j >> 2] = e;
            c[j + 4 >> 2] = d;
            c[j + 8 >> 2] = 208;
            d = j + 12 | 0;
            f = d + 40 | 0;
            do {
                c[d >> 2] = 0;
                d = d + 4 | 0;
            } while ((d | 0) < (f | 0));
            b[j + 12 + 40 >> 1] = 0;
            a[j + 12 + 42 >> 0] = 0;
            a: do {
                if ((h | 0) == (e | 0)) {
                    c[j + 48 >> 2] = 1;
                    zc[c[(c[e >> 2] | 0) + 20 >> 2] & 3](e, j, g, g, 1, 0);
                    d = (c[j + 24 >> 2] | 0) == 1 ? g : 0;
                } else {
                    Ac[c[(c[h >> 2] | 0) + 24 >> 2] & 3](h, j, g, 1, 0);
                    switch (c[j + 36 >> 2] | 0) {
                      case 0:
                        {
                            d = ((c[j + 40 >> 2] | 0) == 1 ? (c[j + 28 >> 2] | 0) == 1 : 0) & (c[j + 32 >> 2] | 0) == 1 ? c[j + 20 >> 2] | 0 : 0;
                            break a;
                        }

                      case 1:
                        break;

                      default:
                        {
                            d = 0;
                            break a;
                        }
                    }
                    if ((c[j + 24 >> 2] | 0) != 1 ? !(((c[j + 40 >> 2] | 0) == 0 ? (c[j + 28 >> 2] | 0) == 1 : 0) & (c[j + 32 >> 2] | 0) == 1) : 0) {
                        d = 0;
                        break;
                    }
                    d = c[j + 16 >> 2] | 0;
                }
            } while (0);
            i = j;
            return d | 0;
        }
        function rq(b, d, e, f) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            a[b + 53 >> 0] = 1;
            do {
                if ((c[b + 4 >> 2] | 0) == (e | 0)) {
                    a[b + 52 >> 0] = 1;
                    e = c[b + 16 >> 2] | 0;
                    if (!e) {
                        c[b + 16 >> 2] = d;
                        c[b + 24 >> 2] = f;
                        c[b + 36 >> 2] = 1;
                        if (!((f | 0) == 1 ? (c[b + 48 >> 2] | 0) == 1 : 0)) break;
                        a[b + 54 >> 0] = 1;
                        break;
                    }
                    if ((e | 0) != (d | 0)) {
                        c[b + 36 >> 2] = (c[b + 36 >> 2] | 0) + 1;
                        a[b + 54 >> 0] = 1;
                        break;
                    }
                    e = c[b + 24 >> 2] | 0;
                    if ((e | 0) == 2) c[b + 24 >> 2] = f; else f = e;
                    if ((f | 0) == 1 ? (c[b + 48 >> 2] | 0) == 1 : 0) a[b + 54 >> 0] = 1;
                }
            } while (0);
            return;
        }
        function sq(b, d, e, f, g) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            var h = 0;
            a: do {
                if ((b | 0) == (c[d + 8 >> 2] | 0)) {
                    if ((c[d + 4 >> 2] | 0) == (e | 0) ? (c[d + 28 >> 2] | 0) != 1 : 0) c[d + 28 >> 2] = f;
                } else {
                    if ((b | 0) != (c[d >> 2] | 0)) {
                        h = c[b + 8 >> 2] | 0;
                        Ac[c[(c[h >> 2] | 0) + 24 >> 2] & 3](h, d, e, f, g);
                        break;
                    }
                    if ((c[d + 16 >> 2] | 0) != (e | 0) ? (c[d + 20 >> 2] | 0) != (e | 0) : 0) {
                        c[d + 32 >> 2] = f;
                        if ((c[d + 44 >> 2] | 0) == 4) break;
                        a[d + 52 >> 0] = 0;
                        a[d + 53 >> 0] = 0;
                        b = c[b + 8 >> 2] | 0;
                        zc[c[(c[b >> 2] | 0) + 20 >> 2] & 3](b, d, e, e, 1, g);
                        if (a[d + 53 >> 0] | 0) {
                            if (!(a[d + 52 >> 0] | 0)) {
                                f = 1;
                                h = 13;
                            }
                        } else {
                            f = 0;
                            h = 13;
                        }
                        do {
                            if ((h | 0) == 13) {
                                c[d + 20 >> 2] = e;
                                c[d + 40 >> 2] = (c[d + 40 >> 2] | 0) + 1;
                                if ((c[d + 36 >> 2] | 0) == 1 ? (c[d + 24 >> 2] | 0) == 2 : 0) {
                                    a[d + 54 >> 0] = 1;
                                    if (f) break;
                                } else h = 16;
                                if ((h | 0) == 16 ? f : 0) break;
                                c[d + 44 >> 2] = 4;
                                break a;
                            }
                        } while (0);
                        c[d + 44 >> 2] = 3;
                        break;
                    }
                    if ((f | 0) == 1) c[d + 32 >> 2] = 1;
                }
            } while (0);
            return;
        }
        function tq(b, d, e, f, g) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            do {
                if ((b | 0) == (c[d + 8 >> 2] | 0)) {
                    if ((c[d + 4 >> 2] | 0) == (e | 0) ? (c[d + 28 >> 2] | 0) != 1 : 0) c[d + 28 >> 2] = f;
                } else if ((b | 0) == (c[d >> 2] | 0)) {
                    if ((c[d + 16 >> 2] | 0) != (e | 0) ? (c[d + 20 >> 2] | 0) != (e | 0) : 0) {
                        c[d + 32 >> 2] = f;
                        c[d + 20 >> 2] = e;
                        c[d + 40 >> 2] = (c[d + 40 >> 2] | 0) + 1;
                        if ((c[d + 36 >> 2] | 0) == 1 ? (c[d + 24 >> 2] | 0) == 2 : 0) a[d + 54 >> 0] = 1;
                        c[d + 44 >> 2] = 4;
                        break;
                    }
                    if ((f | 0) == 1) c[d + 32 >> 2] = 1;
                }
            } while (0);
            return;
        }
        function uq(a, b, d, e, f, g) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            if ((a | 0) == (c[b + 8 >> 2] | 0)) rq(b, d, e, f); else {
                a = c[a + 8 >> 2] | 0;
                zc[c[(c[a >> 2] | 0) + 20 >> 2] & 3](a, b, d, e, f, g);
            }
            return;
        }
        function vq(a, b, d, e, f, g) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            if ((a | 0) == (c[b + 8 >> 2] | 0)) rq(b, d, e, f);
            return;
        }
        function wq(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0;
            e = i;
            i = i + 16 | 0;
            c[e >> 2] = c[d >> 2];
            a = xc[c[(c[a >> 2] | 0) + 16 >> 2] & 7](a, b, e) | 0;
            if (a) c[d >> 2] = c[e >> 2];
            i = e;
            return a & 1 | 0;
        }
        function xq(a) {
            a = a | 0;
            if (!a) a = 0; else a = (qq(a, 256) | 0) != 0;
            return a & 1 | 0;
        }
        function yq() {
            var a = 0, b = 0, d = 0, e = 0;
            e = i;
            i = i + 48 | 0;
            if (ub(836, 2) | 0) dq(2350, e);
            a = Ob(c[208] | 0) | 0;
            if ((a | 0) != 0 ? (d = c[a >> 2] | 0, (d | 0) != 0) : 0) {
                a = c[d + 48 >> 2] | 0;
                b = c[d + 48 + 4 >> 2] | 0;
                if (!((a & -256 | 0) == 1126902528 & (b | 0) == 1129074247)) {
                    c[e + 32 >> 2] = 2693;
                    dq(2643, e + 32 | 0);
                }
                if ((a | 0) == 1126902529 & (b | 0) == 1129074247) a = c[d + 44 >> 2] | 0; else a = d + 80 | 0;
                c[e + 44 >> 2] = a;
                d = c[d >> 2] | 0;
                a = c[d + 4 >> 2] | 0;
                if (nq(192, d, e + 44 | 0) | 0) {
                    d = c[e + 44 >> 2] | 0;
                    d = Gc[c[(c[d >> 2] | 0) + 8 >> 2] & 3](d) | 0;
                    c[e + 8 >> 2] = 2693;
                    c[e + 8 + 4 >> 2] = a;
                    c[e + 8 + 8 >> 2] = d;
                    dq(2557, e + 8 | 0);
                } else {
                    c[e + 24 >> 2] = 2693;
                    c[e + 24 + 4 >> 2] = a;
                    dq(2602, e + 24 | 0);
                }
            }
            dq(2681, e + 40 | 0);
        }
        function zq() {
            var a = 0;
            a = i;
            i = i + 16 | 0;
            if (!(xa(832, 18) | 0)) {
                i = a;
                return;
            } else dq(2454, a);
        }
        function Aq(a) {
            a = a | 0;
            var b = 0;
            b = i;
            i = i + 16 | 0;
            Cq(a);
            if (!(oc(c[208] | 0, 0) | 0)) {
                i = b;
                return;
            } else dq(2504, b);
        }
        function Bq(a) {
            a = a | 0;
            var b = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, E = 0, F = 0, G = 0, H = 0, I = 0, J = 0;
            do {
                if (a >>> 0 < 245) {
                    m = a >>> 0 < 11 ? 16 : a + 11 & -8;
                    i = c[221] | 0;
                    if (i >>> (m >>> 3) & 3) {
                        d = (i >>> (m >>> 3) & 1 ^ 1) + (m >>> 3) << 1;
                        b = c[924 + (d + 2 << 2) >> 2] | 0;
                        e = c[b + 8 >> 2] | 0;
                        do {
                            if ((924 + (d << 2) | 0) == (e | 0)) c[221] = i & ~(1 << (i >>> (m >>> 3) & 1 ^ 1) + (m >>> 3)); else {
                                if (e >>> 0 >= (c[225] | 0) >>> 0 ? (c[e + 12 >> 2] | 0) == (b | 0) : 0) {
                                    c[e + 12 >> 2] = 924 + (d << 2);
                                    c[924 + (d + 2 << 2) >> 2] = e;
                                    break;
                                }
                                Wb();
                            }
                        } while (0);
                        I = (i >>> (m >>> 3) & 1 ^ 1) + (m >>> 3) << 3;
                        c[b + 4 >> 2] = I | 3;
                        c[b + (I | 4) >> 2] = c[b + (I | 4) >> 2] | 1;
                        b = b + 8 | 0;
                        break;
                    }
                    h = c[223] | 0;
                    if (m >>> 0 > h >>> 0) {
                        if (i >>> (m >>> 3)) {
                            f = i >>> (m >>> 3) << (m >>> 3) & (2 << (m >>> 3) | 0 - (2 << (m >>> 3)));
                            g = ((f & 0 - f) + -1 | 0) >>> (((f & 0 - f) + -1 | 0) >>> 12 & 16);
                            b = g >>> (g >>> 5 & 8) >>> (g >>> (g >>> 5 & 8) >>> 2 & 4);
                            b = (g >>> 5 & 8 | ((f & 0 - f) + -1 | 0) >>> 12 & 16 | g >>> (g >>> 5 & 8) >>> 2 & 4 | b >>> 1 & 2 | b >>> (b >>> 1 & 2) >>> 1 & 1) + (b >>> (b >>> 1 & 2) >>> (b >>> (b >>> 1 & 2) >>> 1 & 1)) | 0;
                            g = c[924 + ((b << 1) + 2 << 2) >> 2] | 0;
                            f = c[g + 8 >> 2] | 0;
                            do {
                                if ((924 + (b << 1 << 2) | 0) == (f | 0)) {
                                    c[221] = i & ~(1 << b);
                                    j = h;
                                } else {
                                    if (f >>> 0 >= (c[225] | 0) >>> 0 ? (c[f + 12 >> 2] | 0) == (g | 0) : 0) {
                                        c[f + 12 >> 2] = 924 + (b << 1 << 2);
                                        c[924 + ((b << 1) + 2 << 2) >> 2] = f;
                                        j = c[223] | 0;
                                        break;
                                    }
                                    Wb();
                                }
                            } while (0);
                            c[g + 4 >> 2] = m | 3;
                            c[g + (m | 4) >> 2] = (b << 3) - m | 1;
                            c[g + (b << 3) >> 2] = (b << 3) - m;
                            if (j) {
                                d = c[226] | 0;
                                f = j >>> 3;
                                e = c[221] | 0;
                                if (e & 1 << f) {
                                    e = c[924 + ((f << 1) + 2 << 2) >> 2] | 0;
                                    if (e >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                        l = 924 + ((f << 1) + 2 << 2) | 0;
                                        k = e;
                                    }
                                } else {
                                    c[221] = e | 1 << f;
                                    l = 924 + ((f << 1) + 2 << 2) | 0;
                                    k = 924 + (f << 1 << 2) | 0;
                                }
                                c[l >> 2] = d;
                                c[k + 12 >> 2] = d;
                                c[d + 8 >> 2] = k;
                                c[d + 12 >> 2] = 924 + (f << 1 << 2);
                            }
                            c[223] = (b << 3) - m;
                            c[226] = g + m;
                            b = g + 8 | 0;
                            break;
                        }
                        h = c[222] | 0;
                        if (h) {
                            i = ((h & 0 - h) + -1 | 0) >>> (((h & 0 - h) + -1 | 0) >>> 12 & 16);
                            a = i >>> (i >>> 5 & 8) >>> (i >>> (i >>> 5 & 8) >>> 2 & 4);
                            a = c[1188 + ((i >>> 5 & 8 | ((h & 0 - h) + -1 | 0) >>> 12 & 16 | i >>> (i >>> 5 & 8) >>> 2 & 4 | a >>> 1 & 2 | a >>> (a >>> 1 & 2) >>> 1 & 1) + (a >>> (a >>> 1 & 2) >>> (a >>> (a >>> 1 & 2) >>> 1 & 1)) << 2) >> 2] | 0;
                            i = (c[a + 4 >> 2] & -8) - m | 0;
                            e = a;
                            while (1) {
                                f = c[e + 16 >> 2] | 0;
                                if (!f) {
                                    f = c[e + 20 >> 2] | 0;
                                    if (!f) break;
                                }
                                e = (c[f + 4 >> 2] & -8) - m | 0;
                                I = e >>> 0 < i >>> 0;
                                i = I ? e : i;
                                e = f;
                                a = I ? f : a;
                            }
                            h = c[225] | 0;
                            if (a >>> 0 >= h >>> 0 ? (n = a + m | 0, a >>> 0 < n >>> 0) : 0) {
                                g = c[a + 24 >> 2] | 0;
                                f = c[a + 12 >> 2] | 0;
                                do {
                                    if ((f | 0) == (a | 0)) {
                                        e = a + 20 | 0;
                                        f = c[e >> 2] | 0;
                                        if (!f) {
                                            e = a + 16 | 0;
                                            f = c[e >> 2] | 0;
                                            if (!f) {
                                                p = 0;
                                                break;
                                            }
                                        }
                                        while (1) {
                                            d = f + 20 | 0;
                                            b = c[d >> 2] | 0;
                                            if (b) {
                                                f = b;
                                                e = d;
                                                continue;
                                            }
                                            d = f + 16 | 0;
                                            b = c[d >> 2] | 0;
                                            if (!b) break; else {
                                                f = b;
                                                e = d;
                                            }
                                        }
                                        if (e >>> 0 < h >>> 0) Wb(); else {
                                            c[e >> 2] = 0;
                                            p = f;
                                            break;
                                        }
                                    } else {
                                        e = c[a + 8 >> 2] | 0;
                                        if ((e >>> 0 >= h >>> 0 ? (c[e + 12 >> 2] | 0) == (a | 0) : 0) ? (c[f + 8 >> 2] | 0) == (a | 0) : 0) {
                                            c[e + 12 >> 2] = f;
                                            c[f + 8 >> 2] = e;
                                            p = f;
                                            break;
                                        }
                                        Wb();
                                    }
                                } while (0);
                                do {
                                    if (g) {
                                        f = c[a + 28 >> 2] | 0;
                                        if ((a | 0) == (c[1188 + (f << 2) >> 2] | 0)) {
                                            c[1188 + (f << 2) >> 2] = p;
                                            if (!p) {
                                                c[222] = c[222] & ~(1 << f);
                                                break;
                                            }
                                        } else {
                                            if (g >>> 0 < (c[225] | 0) >>> 0) Wb();
                                            if ((c[g + 16 >> 2] | 0) == (a | 0)) c[g + 16 >> 2] = p; else c[g + 20 >> 2] = p;
                                            if (!p) break;
                                        }
                                        e = c[225] | 0;
                                        if (p >>> 0 < e >>> 0) Wb();
                                        c[p + 24 >> 2] = g;
                                        f = c[a + 16 >> 2] | 0;
                                        do {
                                            if (f) if (f >>> 0 < e >>> 0) Wb(); else {
                                                c[p + 16 >> 2] = f;
                                                c[f + 24 >> 2] = p;
                                                break;
                                            }
                                        } while (0);
                                        e = c[a + 20 >> 2] | 0;
                                        if (e) if (e >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                            c[p + 20 >> 2] = e;
                                            c[e + 24 >> 2] = p;
                                            break;
                                        }
                                    }
                                } while (0);
                                if (i >>> 0 < 16) {
                                    I = i + m | 0;
                                    c[a + 4 >> 2] = I | 3;
                                    I = a + (I + 4) | 0;
                                    c[I >> 2] = c[I >> 2] | 1;
                                } else {
                                    c[a + 4 >> 2] = m | 3;
                                    c[a + (m | 4) >> 2] = i | 1;
                                    c[a + (i + m) >> 2] = i;
                                    f = c[223] | 0;
                                    if (f) {
                                        d = c[226] | 0;
                                        e = c[221] | 0;
                                        if (e & 1 << (f >>> 3)) {
                                            e = c[924 + ((f >>> 3 << 1) + 2 << 2) >> 2] | 0;
                                            if (e >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                o = 924 + ((f >>> 3 << 1) + 2 << 2) | 0;
                                                q = e;
                                            }
                                        } else {
                                            c[221] = e | 1 << (f >>> 3);
                                            o = 924 + ((f >>> 3 << 1) + 2 << 2) | 0;
                                            q = 924 + (f >>> 3 << 1 << 2) | 0;
                                        }
                                        c[o >> 2] = d;
                                        c[q + 12 >> 2] = d;
                                        c[d + 8 >> 2] = q;
                                        c[d + 12 >> 2] = 924 + (f >>> 3 << 1 << 2);
                                    }
                                    c[223] = i;
                                    c[226] = n;
                                }
                                b = a + 8 | 0;
                                break;
                            }
                            Wb();
                        } else {
                            q = m;
                            J = 154;
                        }
                    } else {
                        q = m;
                        J = 154;
                    }
                } else if (a >>> 0 <= 4294967231) {
                    q = a + 11 & -8;
                    l = c[222] | 0;
                    if (l) {
                        if ((a + 11 | 0) >>> 8) if (q >>> 0 > 16777215) k = 31; else {
                            k = (a + 11 | 0) >>> 8 << ((((a + 11 | 0) >>> 8) + 1048320 | 0) >>> 16 & 8);
                            k = 14 - ((k + 520192 | 0) >>> 16 & 4 | (((a + 11 | 0) >>> 8) + 1048320 | 0) >>> 16 & 8 | ((k << ((k + 520192 | 0) >>> 16 & 4)) + 245760 | 0) >>> 16 & 2) + (k << ((k + 520192 | 0) >>> 16 & 4) << (((k << ((k + 520192 | 0) >>> 16 & 4)) + 245760 | 0) >>> 16 & 2) >>> 15) | 0;
                            k = q >>> (k + 7 | 0) & 1 | k << 1;
                        } else k = 0;
                        h = c[1188 + (k << 2) >> 2] | 0;
                        a: do {
                            if (!h) {
                                g = 0 - q | 0;
                                f = 0;
                                h = 0;
                                J = 86;
                            } else {
                                g = 0 - q | 0;
                                f = 0;
                                i = q << ((k | 0) == 31 ? 0 : 25 - (k >>> 1) | 0);
                                d = h;
                                h = 0;
                                while (1) {
                                    e = c[d + 4 >> 2] & -8;
                                    if ((e - q | 0) >>> 0 < g >>> 0) if ((e | 0) == (q | 0)) {
                                        g = e - q | 0;
                                        a = d;
                                        h = d;
                                        J = 90;
                                        break a;
                                    } else {
                                        g = e - q | 0;
                                        h = d;
                                    }
                                    J = c[d + 20 >> 2] | 0;
                                    d = c[d + 16 + (i >>> 31 << 2) >> 2] | 0;
                                    f = (J | 0) == 0 | (J | 0) == (d | 0) ? f : J;
                                    if (!d) {
                                        J = 86;
                                        break;
                                    } else i = i << 1;
                                }
                            }
                        } while (0);
                        if ((J | 0) == 86) {
                            if ((f | 0) == 0 & (h | 0) == 0) {
                                h = 2 << k;
                                if (!(l & (h | 0 - h))) {
                                    J = 154;
                                    break;
                                }
                                p = (l & (h | 0 - h) & 0 - (l & (h | 0 - h))) + -1 | 0;
                                h = p >>> (p >>> 12 & 16) >>> (p >>> (p >>> 12 & 16) >>> 5 & 8);
                                f = h >>> (h >>> 2 & 4) >>> (h >>> (h >>> 2 & 4) >>> 1 & 2);
                                f = c[1188 + ((p >>> (p >>> 12 & 16) >>> 5 & 8 | p >>> 12 & 16 | h >>> 2 & 4 | h >>> (h >>> 2 & 4) >>> 1 & 2 | f >>> 1 & 1) + (f >>> (f >>> 1 & 1)) << 2) >> 2] | 0;
                                h = 0;
                            }
                            if (!f) {
                                o = g;
                                p = h;
                            } else {
                                a = f;
                                J = 90;
                            }
                        }
                        if ((J | 0) == 90) while (1) {
                            J = 0;
                            p = (c[a + 4 >> 2] & -8) - q | 0;
                            f = p >>> 0 < g >>> 0;
                            g = f ? p : g;
                            h = f ? a : h;
                            f = c[a + 16 >> 2] | 0;
                            if (f) {
                                a = f;
                                J = 90;
                                continue;
                            }
                            a = c[a + 20 >> 2] | 0;
                            if (!a) {
                                o = g;
                                p = h;
                                break;
                            } else J = 90;
                        }
                        if ((p | 0) != 0 ? o >>> 0 < ((c[223] | 0) - q | 0) >>> 0 : 0) {
                            h = c[225] | 0;
                            if (p >>> 0 >= h >>> 0 ? (w = p + q | 0, p >>> 0 < w >>> 0) : 0) {
                                b = c[p + 24 >> 2] | 0;
                                f = c[p + 12 >> 2] | 0;
                                do {
                                    if ((f | 0) == (p | 0)) {
                                        e = p + 20 | 0;
                                        f = c[e >> 2] | 0;
                                        if (!f) {
                                            e = p + 16 | 0;
                                            f = c[e >> 2] | 0;
                                            if (!f) {
                                                m = 0;
                                                break;
                                            }
                                        }
                                        while (1) {
                                            g = f + 20 | 0;
                                            d = c[g >> 2] | 0;
                                            if (d) {
                                                f = d;
                                                e = g;
                                                continue;
                                            }
                                            g = f + 16 | 0;
                                            d = c[g >> 2] | 0;
                                            if (!d) break; else {
                                                f = d;
                                                e = g;
                                            }
                                        }
                                        if (e >>> 0 < h >>> 0) Wb(); else {
                                            c[e >> 2] = 0;
                                            m = f;
                                            break;
                                        }
                                    } else {
                                        e = c[p + 8 >> 2] | 0;
                                        if ((e >>> 0 >= h >>> 0 ? (c[e + 12 >> 2] | 0) == (p | 0) : 0) ? (c[f + 8 >> 2] | 0) == (p | 0) : 0) {
                                            c[e + 12 >> 2] = f;
                                            c[f + 8 >> 2] = e;
                                            m = f;
                                            break;
                                        }
                                        Wb();
                                    }
                                } while (0);
                                do {
                                    if (b) {
                                        f = c[p + 28 >> 2] | 0;
                                        if ((p | 0) == (c[1188 + (f << 2) >> 2] | 0)) {
                                            c[1188 + (f << 2) >> 2] = m;
                                            if (!m) {
                                                c[222] = c[222] & ~(1 << f);
                                                break;
                                            }
                                        } else {
                                            if (b >>> 0 < (c[225] | 0) >>> 0) Wb();
                                            if ((c[b + 16 >> 2] | 0) == (p | 0)) c[b + 16 >> 2] = m; else c[b + 20 >> 2] = m;
                                            if (!m) break;
                                        }
                                        e = c[225] | 0;
                                        if (m >>> 0 < e >>> 0) Wb();
                                        c[m + 24 >> 2] = b;
                                        f = c[p + 16 >> 2] | 0;
                                        do {
                                            if (f) if (f >>> 0 < e >>> 0) Wb(); else {
                                                c[m + 16 >> 2] = f;
                                                c[f + 24 >> 2] = m;
                                                break;
                                            }
                                        } while (0);
                                        f = c[p + 20 >> 2] | 0;
                                        if (f) if (f >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                            c[m + 20 >> 2] = f;
                                            c[f + 24 >> 2] = m;
                                            break;
                                        }
                                    }
                                } while (0);
                                b: do {
                                    if (o >>> 0 >= 16) {
                                        c[p + 4 >> 2] = q | 3;
                                        c[p + (q | 4) >> 2] = o | 1;
                                        c[p + (o + q) >> 2] = o;
                                        f = o >>> 3;
                                        if (o >>> 0 < 256) {
                                            e = c[221] | 0;
                                            if (e & 1 << f) {
                                                e = c[924 + ((f << 1) + 2 << 2) >> 2] | 0;
                                                if (e >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                    s = 924 + ((f << 1) + 2 << 2) | 0;
                                                    t = e;
                                                }
                                            } else {
                                                c[221] = e | 1 << f;
                                                s = 924 + ((f << 1) + 2 << 2) | 0;
                                                t = 924 + (f << 1 << 2) | 0;
                                            }
                                            c[s >> 2] = w;
                                            c[t + 12 >> 2] = w;
                                            c[p + (q + 8) >> 2] = t;
                                            c[p + (q + 12) >> 2] = 924 + (f << 1 << 2);
                                            break;
                                        }
                                        e = o >>> 8;
                                        if (e) if (o >>> 0 > 16777215) b = 31; else {
                                            b = e << ((e + 1048320 | 0) >>> 16 & 8) << (((e << ((e + 1048320 | 0) >>> 16 & 8)) + 520192 | 0) >>> 16 & 4);
                                            b = 14 - (((e << ((e + 1048320 | 0) >>> 16 & 8)) + 520192 | 0) >>> 16 & 4 | (e + 1048320 | 0) >>> 16 & 8 | (b + 245760 | 0) >>> 16 & 2) + (b << ((b + 245760 | 0) >>> 16 & 2) >>> 15) | 0;
                                            b = o >>> (b + 7 | 0) & 1 | b << 1;
                                        } else b = 0;
                                        f = 1188 + (b << 2) | 0;
                                        c[p + (q + 28) >> 2] = b;
                                        c[p + (q + 20) >> 2] = 0;
                                        c[p + (q + 16) >> 2] = 0;
                                        e = c[222] | 0;
                                        d = 1 << b;
                                        if (!(e & d)) {
                                            c[222] = e | d;
                                            c[f >> 2] = w;
                                            c[p + (q + 24) >> 2] = f;
                                            c[p + (q + 12) >> 2] = w;
                                            c[p + (q + 8) >> 2] = w;
                                            break;
                                        }
                                        e = c[f >> 2] | 0;
                                        c: do {
                                            if ((c[e + 4 >> 2] & -8 | 0) != (o | 0)) {
                                                b = o << ((b | 0) == 31 ? 0 : 25 - (b >>> 1) | 0);
                                                while (1) {
                                                    d = e + 16 + (b >>> 31 << 2) | 0;
                                                    f = c[d >> 2] | 0;
                                                    if (!f) break;
                                                    if ((c[f + 4 >> 2] & -8 | 0) == (o | 0)) {
                                                        v = f;
                                                        break c;
                                                    } else {
                                                        b = b << 1;
                                                        e = f;
                                                    }
                                                }
                                                if (d >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                    c[d >> 2] = w;
                                                    c[p + (q + 24) >> 2] = e;
                                                    c[p + (q + 12) >> 2] = w;
                                                    c[p + (q + 8) >> 2] = w;
                                                    break b;
                                                }
                                            } else v = e;
                                        } while (0);
                                        e = v + 8 | 0;
                                        d = c[e >> 2] | 0;
                                        I = c[225] | 0;
                                        if (d >>> 0 >= I >>> 0 & v >>> 0 >= I >>> 0) {
                                            c[d + 12 >> 2] = w;
                                            c[e >> 2] = w;
                                            c[p + (q + 8) >> 2] = d;
                                            c[p + (q + 12) >> 2] = v;
                                            c[p + (q + 24) >> 2] = 0;
                                            break;
                                        } else Wb();
                                    } else {
                                        I = o + q | 0;
                                        c[p + 4 >> 2] = I | 3;
                                        I = p + (I + 4) | 0;
                                        c[I >> 2] = c[I >> 2] | 1;
                                    }
                                } while (0);
                                b = p + 8 | 0;
                                break;
                            }
                            Wb();
                        } else J = 154;
                    } else J = 154;
                } else {
                    q = -1;
                    J = 154;
                }
            } while (0);
            d: do {
                if ((J | 0) == 154) {
                    g = c[223] | 0;
                    if (g >>> 0 >= q >>> 0) {
                        b = g - q | 0;
                        d = c[226] | 0;
                        if (b >>> 0 > 15) {
                            c[226] = d + q;
                            c[223] = b;
                            c[d + (q + 4) >> 2] = b | 1;
                            c[d + g >> 2] = b;
                            c[d + 4 >> 2] = q | 3;
                        } else {
                            c[223] = 0;
                            c[226] = 0;
                            c[d + 4 >> 2] = g | 3;
                            c[d + (g + 4) >> 2] = c[d + (g + 4) >> 2] | 1;
                        }
                        b = d + 8 | 0;
                        break;
                    }
                    g = c[224] | 0;
                    if (g >>> 0 > q >>> 0) {
                        J = g - q | 0;
                        c[224] = J;
                        b = c[227] | 0;
                        c[227] = b + q;
                        c[b + (q + 4) >> 2] = J | 1;
                        c[b + 4 >> 2] = q | 3;
                        b = b + 8 | 0;
                        break;
                    }
                    do {
                        if (!(c[339] | 0)) {
                            g = Pa(30) | 0;
                            if (!(g + -1 & g)) {
                                c[341] = g;
                                c[340] = g;
                                c[342] = -1;
                                c[343] = -1;
                                c[344] = 0;
                                c[332] = 0;
                                c[339] = (zb(0) | 0) & -16 ^ 1431655768;
                                break;
                            } else Wb();
                        }
                    } while (0);
                    l = q + 48 | 0;
                    f = c[341] | 0;
                    k = q + 47 | 0;
                    j = f + k & 0 - f;
                    if (j >>> 0 > q >>> 0) {
                        h = c[331] | 0;
                        if ((h | 0) != 0 ? (w = c[329] | 0, (w + j | 0) >>> 0 <= w >>> 0 | (w + j | 0) >>> 0 > h >>> 0) : 0) {
                            b = 0;
                            break;
                        }
                        e: do {
                            if (!(c[332] & 4)) {
                                g = c[227] | 0;
                                f: do {
                                    if (g) {
                                        e = 1332;
                                        while (1) {
                                            h = c[e >> 2] | 0;
                                            if (h >>> 0 <= g >>> 0 ? (r = e + 4 | 0, (h + (c[r >> 2] | 0) | 0) >>> 0 > g >>> 0) : 0) break;
                                            h = c[e + 8 >> 2] | 0;
                                            if (!h) {
                                                J = 174;
                                                break f;
                                            } else e = h;
                                        }
                                        f = f + k - (c[224] | 0) & 0 - f;
                                        if (f >>> 0 < 2147483647) {
                                            h = Ma(f | 0) | 0;
                                            w = (h | 0) == ((c[e >> 2] | 0) + (c[r >> 2] | 0) | 0);
                                            g = w ? f : 0;
                                            if (w) {
                                                if ((h | 0) != (-1 | 0)) {
                                                    t = h;
                                                    p = g;
                                                    J = 194;
                                                    break e;
                                                }
                                            } else J = 184;
                                        } else g = 0;
                                    } else J = 174;
                                } while (0);
                                do {
                                    if ((J | 0) == 174) {
                                        e = Ma(0) | 0;
                                        if ((e | 0) != (-1 | 0)) {
                                            g = c[340] | 0;
                                            if (!(g + -1 & e)) f = j; else f = j - e + (g + -1 + e & 0 - g) | 0;
                                            h = c[329] | 0;
                                            g = h + f | 0;
                                            if (f >>> 0 > q >>> 0 & f >>> 0 < 2147483647) {
                                                w = c[331] | 0;
                                                if ((w | 0) != 0 ? g >>> 0 <= h >>> 0 | g >>> 0 > w >>> 0 : 0) {
                                                    g = 0;
                                                    break;
                                                }
                                                h = Ma(f | 0) | 0;
                                                g = (h | 0) == (e | 0) ? f : 0;
                                                if ((h | 0) == (e | 0)) {
                                                    t = e;
                                                    p = g;
                                                    J = 194;
                                                    break e;
                                                } else J = 184;
                                            } else g = 0;
                                        } else g = 0;
                                    }
                                } while (0);
                                g: do {
                                    if ((J | 0) == 184) {
                                        e = 0 - f | 0;
                                        do {
                                            if (l >>> 0 > f >>> 0 & (f >>> 0 < 2147483647 & (h | 0) != (-1 | 0)) ? (u = c[341] | 0, 
                                            u = k - f + u & 0 - u, u >>> 0 < 2147483647) : 0) if ((Ma(u | 0) | 0) == (-1 | 0)) {
                                                Ma(e | 0) | 0;
                                                break g;
                                            } else {
                                                f = u + f | 0;
                                                break;
                                            }
                                        } while (0);
                                        if ((h | 0) != (-1 | 0)) {
                                            t = h;
                                            p = f;
                                            J = 194;
                                            break e;
                                        }
                                    }
                                } while (0);
                                c[332] = c[332] | 4;
                                J = 191;
                            } else {
                                g = 0;
                                J = 191;
                            }
                        } while (0);
                        if ((((J | 0) == 191 ? j >>> 0 < 2147483647 : 0) ? (x = Ma(j | 0) | 0, y = Ma(0) | 0, 
                        x >>> 0 < y >>> 0 & ((x | 0) != (-1 | 0) & (y | 0) != (-1 | 0))) : 0) ? (z = (y - x | 0) >>> 0 > (q + 40 | 0) >>> 0, 
                        z) : 0) {
                            t = x;
                            p = z ? y - x | 0 : g;
                            J = 194;
                        }
                        if ((J | 0) == 194) {
                            f = (c[329] | 0) + p | 0;
                            c[329] = f;
                            if (f >>> 0 > (c[330] | 0) >>> 0) c[330] = f;
                            j = c[227] | 0;
                            h: do {
                                if (j) {
                                    b = 1332;
                                    while (1) {
                                        g = c[b >> 2] | 0;
                                        f = b + 4 | 0;
                                        e = c[f >> 2] | 0;
                                        if ((t | 0) == (g + e | 0)) {
                                            J = 204;
                                            break;
                                        }
                                        d = c[b + 8 >> 2] | 0;
                                        if (!d) break; else b = d;
                                    }
                                    if (((J | 0) == 204 ? (c[b + 12 >> 2] & 8 | 0) == 0 : 0) ? j >>> 0 < t >>> 0 & j >>> 0 >= g >>> 0 : 0) {
                                        c[f >> 2] = e + p;
                                        J = (c[224] | 0) + p | 0;
                                        I = (j + 8 & 7 | 0) == 0 ? 0 : 0 - (j + 8) & 7;
                                        c[227] = j + I;
                                        c[224] = J - I;
                                        c[j + (I + 4) >> 2] = J - I | 1;
                                        c[j + (J + 4) >> 2] = 40;
                                        c[228] = c[343];
                                        break;
                                    }
                                    g = c[225] | 0;
                                    if (t >>> 0 < g >>> 0) {
                                        c[225] = t;
                                        g = t;
                                    }
                                    e = t + p | 0;
                                    f = 1332;
                                    while (1) {
                                        if ((c[f >> 2] | 0) == (e | 0)) {
                                            J = 212;
                                            break;
                                        }
                                        f = c[f + 8 >> 2] | 0;
                                        if (!f) {
                                            f = 1332;
                                            break;
                                        }
                                    }
                                    if ((J | 0) == 212) if (!(c[f + 12 >> 2] & 8)) {
                                        c[f >> 2] = t;
                                        n = f + 4 | 0;
                                        c[n >> 2] = (c[n >> 2] | 0) + p;
                                        n = t + 8 | 0;
                                        n = (n & 7 | 0) == 0 ? 0 : 0 - n & 7;
                                        k = t + (p + 8) | 0;
                                        k = (k & 7 | 0) == 0 ? 0 : 0 - k & 7;
                                        f = t + (k + p) | 0;
                                        m = n + q | 0;
                                        o = t + m | 0;
                                        l = f - (t + n) - q | 0;
                                        c[t + (n + 4) >> 2] = q | 3;
                                        i: do {
                                            if ((f | 0) != (j | 0)) {
                                                if ((f | 0) == (c[226] | 0)) {
                                                    J = (c[223] | 0) + l | 0;
                                                    c[223] = J;
                                                    c[226] = o;
                                                    c[t + (m + 4) >> 2] = J | 1;
                                                    c[t + (J + m) >> 2] = J;
                                                    break;
                                                }
                                                i = p + 4 | 0;
                                                j = c[t + (i + k) >> 2] | 0;
                                                if ((j & 3 | 0) == 1) {
                                                    j: do {
                                                        if (j >>> 0 >= 256) {
                                                            a = c[t + ((k | 24) + p) >> 2] | 0;
                                                            e = c[t + (p + 12 + k) >> 2] | 0;
                                                            k: do {
                                                                if ((e | 0) == (f | 0)) {
                                                                    d = t + (i + (k | 16)) | 0;
                                                                    e = c[d >> 2] | 0;
                                                                    if (!e) {
                                                                        d = t + ((k | 16) + p) | 0;
                                                                        e = c[d >> 2] | 0;
                                                                        if (!e) {
                                                                            F = 0;
                                                                            break;
                                                                        }
                                                                    }
                                                                    while (1) {
                                                                        b = e + 20 | 0;
                                                                        h = c[b >> 2] | 0;
                                                                        if (h) {
                                                                            e = h;
                                                                            d = b;
                                                                            continue;
                                                                        }
                                                                        h = e + 16 | 0;
                                                                        b = c[h >> 2] | 0;
                                                                        if (!b) break; else {
                                                                            e = b;
                                                                            d = h;
                                                                        }
                                                                    }
                                                                    if (d >>> 0 < g >>> 0) Wb(); else {
                                                                        c[d >> 2] = 0;
                                                                        F = e;
                                                                        break;
                                                                    }
                                                                } else {
                                                                    d = c[t + ((k | 8) + p) >> 2] | 0;
                                                                    do {
                                                                        if (d >>> 0 >= g >>> 0) {
                                                                            if ((c[d + 12 >> 2] | 0) != (f | 0)) break;
                                                                            if ((c[e + 8 >> 2] | 0) != (f | 0)) break;
                                                                            c[d + 12 >> 2] = e;
                                                                            c[e + 8 >> 2] = d;
                                                                            F = e;
                                                                            break k;
                                                                        }
                                                                    } while (0);
                                                                    Wb();
                                                                }
                                                            } while (0);
                                                            if (!a) break;
                                                            g = c[t + (p + 28 + k) >> 2] | 0;
                                                            do {
                                                                if ((f | 0) != (c[1188 + (g << 2) >> 2] | 0)) {
                                                                    if (a >>> 0 < (c[225] | 0) >>> 0) Wb();
                                                                    if ((c[a + 16 >> 2] | 0) == (f | 0)) c[a + 16 >> 2] = F; else c[a + 20 >> 2] = F;
                                                                    if (!F) break j;
                                                                } else {
                                                                    c[1188 + (g << 2) >> 2] = F;
                                                                    if (F) break;
                                                                    c[222] = c[222] & ~(1 << g);
                                                                    break j;
                                                                }
                                                            } while (0);
                                                            f = c[225] | 0;
                                                            if (F >>> 0 < f >>> 0) Wb();
                                                            c[F + 24 >> 2] = a;
                                                            g = c[t + ((k | 16) + p) >> 2] | 0;
                                                            do {
                                                                if (g) if (g >>> 0 < f >>> 0) Wb(); else {
                                                                    c[F + 16 >> 2] = g;
                                                                    c[g + 24 >> 2] = F;
                                                                    break;
                                                                }
                                                            } while (0);
                                                            f = c[t + (i + (k | 16)) >> 2] | 0;
                                                            if (!f) break;
                                                            if (f >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                                c[F + 20 >> 2] = f;
                                                                c[f + 24 >> 2] = F;
                                                                break;
                                                            }
                                                        } else {
                                                            e = c[t + ((k | 8) + p) >> 2] | 0;
                                                            d = c[t + (p + 12 + k) >> 2] | 0;
                                                            do {
                                                                if ((e | 0) != (924 + (j >>> 3 << 1 << 2) | 0)) {
                                                                    if (e >>> 0 >= g >>> 0 ? (c[e + 12 >> 2] | 0) == (f | 0) : 0) break;
                                                                    Wb();
                                                                }
                                                            } while (0);
                                                            if ((d | 0) == (e | 0)) {
                                                                c[221] = c[221] & ~(1 << (j >>> 3));
                                                                break;
                                                            }
                                                            do {
                                                                if ((d | 0) == (924 + (j >>> 3 << 1 << 2) | 0)) D = d + 8 | 0; else {
                                                                    if (d >>> 0 >= g >>> 0 ? (c[d + 8 >> 2] | 0) == (f | 0) : 0) {
                                                                        D = d + 8 | 0;
                                                                        break;
                                                                    }
                                                                    Wb();
                                                                }
                                                            } while (0);
                                                            c[e + 12 >> 2] = d;
                                                            c[D >> 2] = e;
                                                        }
                                                    } while (0);
                                                    f = t + ((j & -8 | k) + p) | 0;
                                                    h = (j & -8) + l | 0;
                                                } else h = l;
                                                f = f + 4 | 0;
                                                c[f >> 2] = c[f >> 2] & -2;
                                                c[t + (m + 4) >> 2] = h | 1;
                                                c[t + (h + m) >> 2] = h;
                                                f = h >>> 3;
                                                if (h >>> 0 < 256) {
                                                    e = c[221] | 0;
                                                    do {
                                                        if (!(e & 1 << f)) {
                                                            c[221] = e | 1 << f;
                                                            G = 924 + ((f << 1) + 2 << 2) | 0;
                                                            H = 924 + (f << 1 << 2) | 0;
                                                        } else {
                                                            e = c[924 + ((f << 1) + 2 << 2) >> 2] | 0;
                                                            if (e >>> 0 >= (c[225] | 0) >>> 0) {
                                                                G = 924 + ((f << 1) + 2 << 2) | 0;
                                                                H = e;
                                                                break;
                                                            }
                                                            Wb();
                                                        }
                                                    } while (0);
                                                    c[G >> 2] = o;
                                                    c[H + 12 >> 2] = o;
                                                    c[t + (m + 8) >> 2] = H;
                                                    c[t + (m + 12) >> 2] = 924 + (f << 1 << 2);
                                                    break;
                                                }
                                                e = h >>> 8;
                                                do {
                                                    if (!e) b = 0; else {
                                                        if (h >>> 0 > 16777215) {
                                                            b = 31;
                                                            break;
                                                        }
                                                        b = e << ((e + 1048320 | 0) >>> 16 & 8) << (((e << ((e + 1048320 | 0) >>> 16 & 8)) + 520192 | 0) >>> 16 & 4);
                                                        b = 14 - (((e << ((e + 1048320 | 0) >>> 16 & 8)) + 520192 | 0) >>> 16 & 4 | (e + 1048320 | 0) >>> 16 & 8 | (b + 245760 | 0) >>> 16 & 2) + (b << ((b + 245760 | 0) >>> 16 & 2) >>> 15) | 0;
                                                        b = h >>> (b + 7 | 0) & 1 | b << 1;
                                                    }
                                                } while (0);
                                                f = 1188 + (b << 2) | 0;
                                                c[t + (m + 28) >> 2] = b;
                                                c[t + (m + 20) >> 2] = 0;
                                                c[t + (m + 16) >> 2] = 0;
                                                e = c[222] | 0;
                                                d = 1 << b;
                                                if (!(e & d)) {
                                                    c[222] = e | d;
                                                    c[f >> 2] = o;
                                                    c[t + (m + 24) >> 2] = f;
                                                    c[t + (m + 12) >> 2] = o;
                                                    c[t + (m + 8) >> 2] = o;
                                                    break;
                                                }
                                                e = c[f >> 2] | 0;
                                                l: do {
                                                    if ((c[e + 4 >> 2] & -8 | 0) != (h | 0)) {
                                                        b = h << ((b | 0) == 31 ? 0 : 25 - (b >>> 1) | 0);
                                                        while (1) {
                                                            d = e + 16 + (b >>> 31 << 2) | 0;
                                                            f = c[d >> 2] | 0;
                                                            if (!f) break;
                                                            if ((c[f + 4 >> 2] & -8 | 0) == (h | 0)) {
                                                                I = f;
                                                                break l;
                                                            } else {
                                                                b = b << 1;
                                                                e = f;
                                                            }
                                                        }
                                                        if (d >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                            c[d >> 2] = o;
                                                            c[t + (m + 24) >> 2] = e;
                                                            c[t + (m + 12) >> 2] = o;
                                                            c[t + (m + 8) >> 2] = o;
                                                            break i;
                                                        }
                                                    } else I = e;
                                                } while (0);
                                                e = I + 8 | 0;
                                                d = c[e >> 2] | 0;
                                                J = c[225] | 0;
                                                if (d >>> 0 >= J >>> 0 & I >>> 0 >= J >>> 0) {
                                                    c[d + 12 >> 2] = o;
                                                    c[e >> 2] = o;
                                                    c[t + (m + 8) >> 2] = d;
                                                    c[t + (m + 12) >> 2] = I;
                                                    c[t + (m + 24) >> 2] = 0;
                                                    break;
                                                } else Wb();
                                            } else {
                                                J = (c[224] | 0) + l | 0;
                                                c[224] = J;
                                                c[227] = o;
                                                c[t + (m + 4) >> 2] = J | 1;
                                            }
                                        } while (0);
                                        b = t + (n | 8) | 0;
                                        break d;
                                    } else f = 1332;
                                    while (1) {
                                        d = c[f >> 2] | 0;
                                        if (d >>> 0 <= j >>> 0 ? (A = c[f + 4 >> 2] | 0, (d + A | 0) >>> 0 > j >>> 0) : 0) break;
                                        f = c[f + 8 >> 2] | 0;
                                    }
                                    h = d + (A + -47 + ((d + (A + -39) & 7 | 0) == 0 ? 0 : 0 - (d + (A + -39)) & 7)) | 0;
                                    h = h >>> 0 < (j + 16 | 0) >>> 0 ? j : h;
                                    J = t + 8 | 0;
                                    J = (J & 7 | 0) == 0 ? 0 : 0 - J & 7;
                                    I = p + -40 - J | 0;
                                    c[227] = t + J;
                                    c[224] = I;
                                    c[t + (J + 4) >> 2] = I | 1;
                                    c[t + (p + -36) >> 2] = 40;
                                    c[228] = c[343];
                                    c[h + 4 >> 2] = 27;
                                    c[h + 8 >> 2] = c[333];
                                    c[h + 8 + 4 >> 2] = c[334];
                                    c[h + 8 + 8 >> 2] = c[335];
                                    c[h + 8 + 12 >> 2] = c[336];
                                    c[333] = t;
                                    c[334] = p;
                                    c[336] = 0;
                                    c[335] = h + 8;
                                    c[h + 28 >> 2] = 7;
                                    if ((h + 32 | 0) >>> 0 < (d + A | 0) >>> 0) {
                                        e = h + 28 | 0;
                                        do {
                                            J = e;
                                            e = e + 4 | 0;
                                            c[e >> 2] = 7;
                                        } while ((J + 8 | 0) >>> 0 < (d + A | 0) >>> 0);
                                    }
                                    if ((h | 0) != (j | 0)) {
                                        c[h + 4 >> 2] = c[h + 4 >> 2] & -2;
                                        c[j + 4 >> 2] = h - j | 1;
                                        c[h >> 2] = h - j;
                                        if ((h - j | 0) >>> 0 < 256) {
                                            e = c[221] | 0;
                                            if (e & 1 << ((h - j | 0) >>> 3)) {
                                                e = c[924 + (((h - j | 0) >>> 3 << 1) + 2 << 2) >> 2] | 0;
                                                if (e >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                    B = 924 + (((h - j | 0) >>> 3 << 1) + 2 << 2) | 0;
                                                    C = e;
                                                }
                                            } else {
                                                c[221] = e | 1 << ((h - j | 0) >>> 3);
                                                B = 924 + (((h - j | 0) >>> 3 << 1) + 2 << 2) | 0;
                                                C = 924 + ((h - j | 0) >>> 3 << 1 << 2) | 0;
                                            }
                                            c[B >> 2] = j;
                                            c[C + 12 >> 2] = j;
                                            c[j + 8 >> 2] = C;
                                            c[j + 12 >> 2] = 924 + ((h - j | 0) >>> 3 << 1 << 2);
                                            break;
                                        }
                                        if ((h - j | 0) >>> 8) if ((h - j | 0) >>> 0 > 16777215) f = 31; else {
                                            f = (h - j | 0) >>> 8 << ((((h - j | 0) >>> 8) + 1048320 | 0) >>> 16 & 8);
                                            f = 14 - ((f + 520192 | 0) >>> 16 & 4 | (((h - j | 0) >>> 8) + 1048320 | 0) >>> 16 & 8 | ((f << ((f + 520192 | 0) >>> 16 & 4)) + 245760 | 0) >>> 16 & 2) + (f << ((f + 520192 | 0) >>> 16 & 4) << (((f << ((f + 520192 | 0) >>> 16 & 4)) + 245760 | 0) >>> 16 & 2) >>> 15) | 0;
                                            f = (h - j | 0) >>> (f + 7 | 0) & 1 | f << 1;
                                        } else f = 0;
                                        e = 1188 + (f << 2) | 0;
                                        c[j + 28 >> 2] = f;
                                        c[j + 20 >> 2] = 0;
                                        c[j + 16 >> 2] = 0;
                                        d = c[222] | 0;
                                        b = 1 << f;
                                        if (!(d & b)) {
                                            c[222] = d | b;
                                            c[e >> 2] = j;
                                            c[j + 24 >> 2] = e;
                                            c[j + 12 >> 2] = j;
                                            c[j + 8 >> 2] = j;
                                            break;
                                        }
                                        e = c[e >> 2] | 0;
                                        m: do {
                                            if ((c[e + 4 >> 2] & -8 | 0) != (h - j | 0)) {
                                                f = h - j << ((f | 0) == 31 ? 0 : 25 - (f >>> 1) | 0);
                                                while (1) {
                                                    b = e + 16 + (f >>> 31 << 2) | 0;
                                                    d = c[b >> 2] | 0;
                                                    if (!d) break;
                                                    if ((c[d + 4 >> 2] & -8 | 0) == (h - j | 0)) {
                                                        E = d;
                                                        break m;
                                                    } else {
                                                        f = f << 1;
                                                        e = d;
                                                    }
                                                }
                                                if (b >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                    c[b >> 2] = j;
                                                    c[j + 24 >> 2] = e;
                                                    c[j + 12 >> 2] = j;
                                                    c[j + 8 >> 2] = j;
                                                    break h;
                                                }
                                            } else E = e;
                                        } while (0);
                                        d = E + 8 | 0;
                                        b = c[d >> 2] | 0;
                                        J = c[225] | 0;
                                        if (b >>> 0 >= J >>> 0 & E >>> 0 >= J >>> 0) {
                                            c[b + 12 >> 2] = j;
                                            c[d >> 2] = j;
                                            c[j + 8 >> 2] = b;
                                            c[j + 12 >> 2] = E;
                                            c[j + 24 >> 2] = 0;
                                            break;
                                        } else Wb();
                                    }
                                } else {
                                    J = c[225] | 0;
                                    if ((J | 0) == 0 | t >>> 0 < J >>> 0) c[225] = t;
                                    c[333] = t;
                                    c[334] = p;
                                    c[336] = 0;
                                    c[230] = c[339];
                                    c[229] = -1;
                                    d = 0;
                                    do {
                                        J = d << 1;
                                        c[924 + (J + 3 << 2) >> 2] = 924 + (J << 2);
                                        c[924 + (J + 2 << 2) >> 2] = 924 + (J << 2);
                                        d = d + 1 | 0;
                                    } while ((d | 0) != 32);
                                    J = t + 8 | 0;
                                    J = (J & 7 | 0) == 0 ? 0 : 0 - J & 7;
                                    I = p + -40 - J | 0;
                                    c[227] = t + J;
                                    c[224] = I;
                                    c[t + (J + 4) >> 2] = I | 1;
                                    c[t + (p + -36) >> 2] = 40;
                                    c[228] = c[343];
                                }
                            } while (0);
                            b = c[224] | 0;
                            if (b >>> 0 > q >>> 0) {
                                J = b - q | 0;
                                c[224] = J;
                                b = c[227] | 0;
                                c[227] = b + q;
                                c[b + (q + 4) >> 2] = J | 1;
                                c[b + 4 >> 2] = q | 3;
                                b = b + 8 | 0;
                                break;
                            }
                        }
                        if (!(c[210] | 0)) b = 1380; else b = c[(kc() | 0) + 60 >> 2] | 0;
                        c[b >> 2] = 12;
                        b = 0;
                    } else b = 0;
                }
            } while (0);
            return b | 0;
        }
        function Cq(a) {
            a = a | 0;
            var b = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0;
            a: do {
                if (a) {
                    i = c[225] | 0;
                    b: do {
                        if ((a + -8 | 0) >>> 0 >= i >>> 0 ? (q = c[a + -4 >> 2] | 0, (q & 3 | 0) != 1) : 0) {
                            p = a + ((q & -8) + -8) | 0;
                            do {
                                if (!(q & 1)) {
                                    k = c[a + -8 >> 2] | 0;
                                    if (!(q & 3)) break a;
                                    l = a + (-8 - k) | 0;
                                    m = k + (q & -8) | 0;
                                    if (l >>> 0 < i >>> 0) break b;
                                    if ((l | 0) == (c[226] | 0)) {
                                        f = c[a + ((q & -8) + -4) >> 2] | 0;
                                        if ((f & 3 | 0) != 3) {
                                            u = l;
                                            g = m;
                                            break;
                                        }
                                        c[223] = m;
                                        c[a + ((q & -8) + -4) >> 2] = f & -2;
                                        c[a + (-8 - k + 4) >> 2] = m | 1;
                                        c[p >> 2] = m;
                                        break a;
                                    }
                                    if (k >>> 0 < 256) {
                                        f = c[a + (-8 - k + 8) >> 2] | 0;
                                        e = c[a + (-8 - k + 12) >> 2] | 0;
                                        do {
                                            if ((f | 0) != (924 + (k >>> 3 << 1 << 2) | 0)) {
                                                if (f >>> 0 >= i >>> 0 ? (c[f + 12 >> 2] | 0) == (l | 0) : 0) break;
                                                Wb();
                                            }
                                        } while (0);
                                        if ((e | 0) == (f | 0)) {
                                            c[221] = c[221] & ~(1 << (k >>> 3));
                                            u = l;
                                            g = m;
                                            break;
                                        }
                                        do {
                                            if ((e | 0) == (924 + (k >>> 3 << 1 << 2) | 0)) d = e + 8 | 0; else {
                                                if (e >>> 0 >= i >>> 0 ? (c[e + 8 >> 2] | 0) == (l | 0) : 0) {
                                                    d = e + 8 | 0;
                                                    break;
                                                }
                                                Wb();
                                            }
                                        } while (0);
                                        c[f + 12 >> 2] = e;
                                        c[d >> 2] = f;
                                        u = l;
                                        g = m;
                                        break;
                                    }
                                    b = c[a + (-8 - k + 24) >> 2] | 0;
                                    f = c[a + (-8 - k + 12) >> 2] | 0;
                                    do {
                                        if ((f | 0) == (l | 0)) {
                                            f = c[a + (-8 - k + 20) >> 2] | 0;
                                            if (!f) {
                                                f = c[a + (-8 - k + 16) >> 2] | 0;
                                                if (!f) {
                                                    j = 0;
                                                    break;
                                                } else h = a + (-8 - k + 16) | 0;
                                            } else h = a + (-8 - k + 20) | 0;
                                            while (1) {
                                                e = f + 20 | 0;
                                                d = c[e >> 2] | 0;
                                                if (d) {
                                                    f = d;
                                                    h = e;
                                                    continue;
                                                }
                                                e = f + 16 | 0;
                                                d = c[e >> 2] | 0;
                                                if (!d) break; else {
                                                    f = d;
                                                    h = e;
                                                }
                                            }
                                            if (h >>> 0 < i >>> 0) Wb(); else {
                                                c[h >> 2] = 0;
                                                j = f;
                                                break;
                                            }
                                        } else {
                                            e = c[a + (-8 - k + 8) >> 2] | 0;
                                            if ((e >>> 0 >= i >>> 0 ? (c[e + 12 >> 2] | 0) == (l | 0) : 0) ? (c[f + 8 >> 2] | 0) == (l | 0) : 0) {
                                                c[e + 12 >> 2] = f;
                                                c[f + 8 >> 2] = e;
                                                j = f;
                                                break;
                                            }
                                            Wb();
                                        }
                                    } while (0);
                                    if (b) {
                                        f = c[a + (-8 - k + 28) >> 2] | 0;
                                        if ((l | 0) == (c[1188 + (f << 2) >> 2] | 0)) {
                                            c[1188 + (f << 2) >> 2] = j;
                                            if (!j) {
                                                c[222] = c[222] & ~(1 << f);
                                                u = l;
                                                g = m;
                                                break;
                                            }
                                        } else {
                                            if (b >>> 0 < (c[225] | 0) >>> 0) Wb();
                                            if ((c[b + 16 >> 2] | 0) == (l | 0)) c[b + 16 >> 2] = j; else c[b + 20 >> 2] = j;
                                            if (!j) {
                                                u = l;
                                                g = m;
                                                break;
                                            }
                                        }
                                        e = c[225] | 0;
                                        if (j >>> 0 < e >>> 0) Wb();
                                        c[j + 24 >> 2] = b;
                                        f = c[a + (-8 - k + 16) >> 2] | 0;
                                        do {
                                            if (f) if (f >>> 0 < e >>> 0) Wb(); else {
                                                c[j + 16 >> 2] = f;
                                                c[f + 24 >> 2] = j;
                                                break;
                                            }
                                        } while (0);
                                        f = c[a + (-8 - k + 20) >> 2] | 0;
                                        if (f) if (f >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                            c[j + 20 >> 2] = f;
                                            c[f + 24 >> 2] = j;
                                            u = l;
                                            g = m;
                                            break;
                                        } else {
                                            u = l;
                                            g = m;
                                        }
                                    } else {
                                        u = l;
                                        g = m;
                                    }
                                } else {
                                    u = a + -8 | 0;
                                    g = q & -8;
                                }
                            } while (0);
                            if (u >>> 0 < p >>> 0 ? (o = c[a + ((q & -8) + -4) >> 2] | 0, (o & 1 | 0) != 0) : 0) {
                                if (!(o & 2)) {
                                    if ((p | 0) == (c[227] | 0)) {
                                        v = (c[224] | 0) + g | 0;
                                        c[224] = v;
                                        c[227] = u;
                                        c[u + 4 >> 2] = v | 1;
                                        if ((u | 0) != (c[226] | 0)) break a;
                                        c[226] = 0;
                                        c[223] = 0;
                                        break a;
                                    }
                                    if ((p | 0) == (c[226] | 0)) {
                                        v = (c[223] | 0) + g | 0;
                                        c[223] = v;
                                        c[226] = u;
                                        c[u + 4 >> 2] = v | 1;
                                        c[u + v >> 2] = v;
                                        break a;
                                    }
                                    g = (o & -8) + g | 0;
                                    do {
                                        if (o >>> 0 >= 256) {
                                            h = c[a + ((q & -8) + 16) >> 2] | 0;
                                            f = c[a + (q & -8 | 4) >> 2] | 0;
                                            do {
                                                if ((f | 0) == (p | 0)) {
                                                    f = c[a + ((q & -8) + 12) >> 2] | 0;
                                                    if (!f) {
                                                        f = c[a + ((q & -8) + 8) >> 2] | 0;
                                                        if (!f) {
                                                            r = 0;
                                                            break;
                                                        } else b = a + ((q & -8) + 8) | 0;
                                                    } else b = a + ((q & -8) + 12) | 0;
                                                    while (1) {
                                                        e = f + 20 | 0;
                                                        d = c[e >> 2] | 0;
                                                        if (d) {
                                                            f = d;
                                                            b = e;
                                                            continue;
                                                        }
                                                        e = f + 16 | 0;
                                                        d = c[e >> 2] | 0;
                                                        if (!d) break; else {
                                                            f = d;
                                                            b = e;
                                                        }
                                                    }
                                                    if (b >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                        c[b >> 2] = 0;
                                                        r = f;
                                                        break;
                                                    }
                                                } else {
                                                    e = c[a + (q & -8) >> 2] | 0;
                                                    if ((e >>> 0 >= (c[225] | 0) >>> 0 ? (c[e + 12 >> 2] | 0) == (p | 0) : 0) ? (c[f + 8 >> 2] | 0) == (p | 0) : 0) {
                                                        c[e + 12 >> 2] = f;
                                                        c[f + 8 >> 2] = e;
                                                        r = f;
                                                        break;
                                                    }
                                                    Wb();
                                                }
                                            } while (0);
                                            if (h) {
                                                f = c[a + ((q & -8) + 20) >> 2] | 0;
                                                if ((p | 0) == (c[1188 + (f << 2) >> 2] | 0)) {
                                                    c[1188 + (f << 2) >> 2] = r;
                                                    if (!r) {
                                                        c[222] = c[222] & ~(1 << f);
                                                        break;
                                                    }
                                                } else {
                                                    if (h >>> 0 < (c[225] | 0) >>> 0) Wb();
                                                    if ((c[h + 16 >> 2] | 0) == (p | 0)) c[h + 16 >> 2] = r; else c[h + 20 >> 2] = r;
                                                    if (!r) break;
                                                }
                                                e = c[225] | 0;
                                                if (r >>> 0 < e >>> 0) Wb();
                                                c[r + 24 >> 2] = h;
                                                f = c[a + ((q & -8) + 8) >> 2] | 0;
                                                do {
                                                    if (f) if (f >>> 0 < e >>> 0) Wb(); else {
                                                        c[r + 16 >> 2] = f;
                                                        c[f + 24 >> 2] = r;
                                                        break;
                                                    }
                                                } while (0);
                                                d = c[a + ((q & -8) + 12) >> 2] | 0;
                                                if (d) if (d >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                    c[r + 20 >> 2] = d;
                                                    c[d + 24 >> 2] = r;
                                                    break;
                                                }
                                            }
                                        } else {
                                            e = c[a + (q & -8) >> 2] | 0;
                                            f = c[a + (q & -8 | 4) >> 2] | 0;
                                            do {
                                                if ((e | 0) != (924 + (o >>> 3 << 1 << 2) | 0)) {
                                                    if (e >>> 0 >= (c[225] | 0) >>> 0 ? (c[e + 12 >> 2] | 0) == (p | 0) : 0) break;
                                                    Wb();
                                                }
                                            } while (0);
                                            if ((f | 0) == (e | 0)) {
                                                c[221] = c[221] & ~(1 << (o >>> 3));
                                                break;
                                            }
                                            do {
                                                if ((f | 0) == (924 + (o >>> 3 << 1 << 2) | 0)) n = f + 8 | 0; else {
                                                    if (f >>> 0 >= (c[225] | 0) >>> 0 ? (c[f + 8 >> 2] | 0) == (p | 0) : 0) {
                                                        n = f + 8 | 0;
                                                        break;
                                                    }
                                                    Wb();
                                                }
                                            } while (0);
                                            c[e + 12 >> 2] = f;
                                            c[n >> 2] = e;
                                        }
                                    } while (0);
                                    c[u + 4 >> 2] = g | 1;
                                    c[u + g >> 2] = g;
                                    if ((u | 0) == (c[226] | 0)) {
                                        c[223] = g;
                                        break a;
                                    }
                                } else {
                                    c[a + ((q & -8) + -4) >> 2] = o & -2;
                                    c[u + 4 >> 2] = g | 1;
                                    c[u + g >> 2] = g;
                                }
                                e = g >>> 3;
                                if (g >>> 0 < 256) {
                                    d = c[221] | 0;
                                    if (d & 1 << e) {
                                        d = c[924 + ((e << 1) + 2 << 2) >> 2] | 0;
                                        if (d >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                            s = 924 + ((e << 1) + 2 << 2) | 0;
                                            t = d;
                                        }
                                    } else {
                                        c[221] = d | 1 << e;
                                        s = 924 + ((e << 1) + 2 << 2) | 0;
                                        t = 924 + (e << 1 << 2) | 0;
                                    }
                                    c[s >> 2] = u;
                                    c[t + 12 >> 2] = u;
                                    c[u + 8 >> 2] = t;
                                    c[u + 12 >> 2] = 924 + (e << 1 << 2);
                                    break a;
                                }
                                b = g >>> 8;
                                if (b) if (g >>> 0 > 16777215) f = 31; else {
                                    f = b << ((b + 1048320 | 0) >>> 16 & 8) << (((b << ((b + 1048320 | 0) >>> 16 & 8)) + 520192 | 0) >>> 16 & 4);
                                    f = 14 - (((b << ((b + 1048320 | 0) >>> 16 & 8)) + 520192 | 0) >>> 16 & 4 | (b + 1048320 | 0) >>> 16 & 8 | (f + 245760 | 0) >>> 16 & 2) + (f << ((f + 245760 | 0) >>> 16 & 2) >>> 15) | 0;
                                    f = g >>> (f + 7 | 0) & 1 | f << 1;
                                } else f = 0;
                                d = 1188 + (f << 2) | 0;
                                c[u + 28 >> 2] = f;
                                c[u + 20 >> 2] = 0;
                                c[u + 16 >> 2] = 0;
                                b = c[222] | 0;
                                e = 1 << f;
                                c: do {
                                    if (b & e) {
                                        d = c[d >> 2] | 0;
                                        d: do {
                                            if ((c[d + 4 >> 2] & -8 | 0) != (g | 0)) {
                                                f = g << ((f | 0) == 31 ? 0 : 25 - (f >>> 1) | 0);
                                                while (1) {
                                                    b = d + 16 + (f >>> 31 << 2) | 0;
                                                    e = c[b >> 2] | 0;
                                                    if (!e) break;
                                                    if ((c[e + 4 >> 2] & -8 | 0) == (g | 0)) {
                                                        v = e;
                                                        break d;
                                                    } else {
                                                        f = f << 1;
                                                        d = e;
                                                    }
                                                }
                                                if (b >>> 0 < (c[225] | 0) >>> 0) Wb(); else {
                                                    c[b >> 2] = u;
                                                    c[u + 24 >> 2] = d;
                                                    c[u + 12 >> 2] = u;
                                                    c[u + 8 >> 2] = u;
                                                    break c;
                                                }
                                            } else v = d;
                                        } while (0);
                                        b = v + 8 | 0;
                                        d = c[b >> 2] | 0;
                                        t = c[225] | 0;
                                        if (d >>> 0 >= t >>> 0 & v >>> 0 >= t >>> 0) {
                                            c[d + 12 >> 2] = u;
                                            c[b >> 2] = u;
                                            c[u + 8 >> 2] = d;
                                            c[u + 12 >> 2] = v;
                                            c[u + 24 >> 2] = 0;
                                            break;
                                        } else Wb();
                                    } else {
                                        c[222] = b | e;
                                        c[d >> 2] = u;
                                        c[u + 24 >> 2] = d;
                                        c[u + 12 >> 2] = u;
                                        c[u + 8 >> 2] = u;
                                    }
                                } while (0);
                                v = (c[229] | 0) + -1 | 0;
                                c[229] = v;
                                if (!v) b = 1340; else break a;
                                while (1) {
                                    b = c[b >> 2] | 0;
                                    if (!b) break; else b = b + 8 | 0;
                                }
                                c[229] = -1;
                                break a;
                            }
                        }
                    } while (0);
                    Wb();
                }
            } while (0);
            return;
        }
        function Dq(b) {
            b = b | 0;
            var c = 0, e = 0;
            c = 0;
            while (1) {
                if ((d[2702 + c >> 0] | 0) == (b | 0)) {
                    e = 2;
                    break;
                }
                c = c + 1 | 0;
                if ((c | 0) == 87) {
                    c = 87;
                    b = 2790;
                    e = 5;
                    break;
                }
            }
            if ((e | 0) == 2) if (!c) c = 2790; else {
                b = 2790;
                e = 5;
            }
            if ((e | 0) == 5) while (1) {
                do {
                    e = b;
                    b = b + 1 | 0;
                } while ((a[e >> 0] | 0) != 0);
                c = c + -1 | 0;
                if (!c) {
                    c = b;
                    break;
                } else e = 5;
            }
            return c | 0;
        }
        function Eq(a, b) {
            a = +a;
            b = b | 0;
            var d = 0, e = 0, f = 0;
            h[k >> 3] = a;
            d = c[k >> 2] | 0;
            e = c[k + 4 >> 2] | 0;
            f = Zq(d | 0, e | 0, 52) | 0;
            switch (f & 2047 | 0) {
              case 0:
                {
                    if (a != 0) {
                        a = +Eq(a * 0x10000000000000000, b);
                        d = (c[b >> 2] | 0) + -64 | 0;
                    } else d = 0;
                    c[b >> 2] = d;
                    break;
                }

              case 2047:
                break;

              default:
                {
                    c[b >> 2] = (f & 2047) + -1022;
                    c[k >> 2] = d;
                    c[k + 4 >> 2] = e & -2146435073 | 1071644672;
                    a = +h[k >> 3];
                }
            }
            return +a;
        }
        function Fq(b, d) {
            b = b | 0;
            d = d | 0;
            do {
                if (!b) b = 1; else {
                    if (d >>> 0 < 128) {
                        a[b >> 0] = d;
                        b = 1;
                        break;
                    }
                    if (d >>> 0 < 2048) {
                        a[b >> 0] = d >>> 6 | 192;
                        a[b + 1 >> 0] = d & 63 | 128;
                        b = 2;
                        break;
                    }
                    if (d >>> 0 < 55296 | (d & -8192 | 0) == 57344) {
                        a[b >> 0] = d >>> 12 | 224;
                        a[b + 1 >> 0] = d >>> 6 & 63 | 128;
                        a[b + 2 >> 0] = d & 63 | 128;
                        b = 3;
                        break;
                    }
                    if ((d + -65536 | 0) >>> 0 < 1048576) {
                        a[b >> 0] = d >>> 18 | 240;
                        a[b + 1 >> 0] = d >>> 12 & 63 | 128;
                        a[b + 2 >> 0] = d >>> 6 & 63 | 128;
                        a[b + 3 >> 0] = d & 63 | 128;
                        b = 4;
                        break;
                    }
                    if (!(c[210] | 0)) b = 1380; else b = c[(kc() | 0) + 60 >> 2] | 0;
                    c[b >> 2] = 84;
                    b = -1;
                }
            } while (0);
            return b | 0;
        }
        function Gq(b, e) {
            b = b | 0;
            e = e | 0;
            var f = 0, g = 0, h = 0;
            h = i;
            i = i + 16 | 0;
            a[h >> 0] = e;
            f = c[b + 16 >> 2] | 0;
            if (!f) if (!(Kq(b) | 0)) {
                f = c[b + 16 >> 2] | 0;
                g = 4;
            } else f = -1; else g = 4;
            do {
                if ((g | 0) == 4) {
                    g = c[b + 20 >> 2] | 0;
                    if (g >>> 0 < f >>> 0 ? (e & 255 | 0) != (a[b + 75 >> 0] | 0) : 0) {
                        c[b + 20 >> 2] = g + 1;
                        a[g >> 0] = e;
                        f = e & 255;
                        break;
                    }
                    if ((xc[c[b + 36 >> 2] & 7](b, h, 1) | 0) == 1) f = d[h >> 0] | 0; else f = -1;
                }
            } while (0);
            i = h;
            return f | 0;
        }
        function Hq(a) {
            a = a | 0;
            var b = 0, d = 0;
            d = i;
            i = i + 16 | 0;
            c[d >> 2] = c[a + 60 >> 2];
            a = yb(6, d | 0) | 0;
            if (a >>> 0 > 4294963200) {
                if (!(c[210] | 0)) b = 1380; else b = c[(kc() | 0) + 60 >> 2] | 0;
                c[b >> 2] = 0 - a;
                a = -1;
            }
            i = d;
            return a | 0;
        }
        function Iq(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0, f = 0;
            f = i;
            i = i + 32 | 0;
            c[f >> 2] = c[a + 60 >> 2];
            c[f + 4 >> 2] = 0;
            c[f + 8 >> 2] = b;
            c[f + 12 >> 2] = f + 20;
            c[f + 16 >> 2] = d;
            a = Za(140, f | 0) | 0;
            if (a >>> 0 <= 4294963200) if ((a | 0) < 0) e = 7; else b = c[f + 20 >> 2] | 0; else {
                if (!(c[210] | 0)) b = 1380; else b = c[(kc() | 0) + 60 >> 2] | 0;
                c[b >> 2] = 0 - a;
                e = 7;
            }
            if ((e | 0) == 7) {
                c[f + 20 >> 2] = -1;
                b = -1;
            }
            i = f;
            return b | 0;
        }
        function Jq(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0, f = 0, g = 0, h = 0, j = 0, k = 0;
            k = i;
            i = i + 48 | 0;
            g = c[a + 28 >> 2] | 0;
            c[k + 32 >> 2] = g;
            g = (c[a + 20 >> 2] | 0) - g | 0;
            c[k + 32 + 4 >> 2] = g;
            c[k + 32 + 8 >> 2] = b;
            c[k + 32 + 12 >> 2] = d;
            j = k + 32 | 0;
            f = 2;
            g = g + d | 0;
            while (1) {
                if (!(c[210] | 0)) {
                    c[k + 16 >> 2] = c[a + 60 >> 2];
                    c[k + 16 + 4 >> 2] = j;
                    c[k + 16 + 8 >> 2] = f;
                    b = ab(146, k + 16 | 0) | 0;
                    if (b >>> 0 > 4294963200) {
                        if (!(c[210] | 0)) e = 1380; else e = c[(kc() | 0) + 60 >> 2] | 0;
                        c[e >> 2] = 0 - b;
                        b = -1;
                    }
                } else {
                    Xa(19, a | 0);
                    c[k >> 2] = c[a + 60 >> 2];
                    c[k + 4 >> 2] = j;
                    c[k + 8 >> 2] = f;
                    b = ab(146, k | 0) | 0;
                    if (b >>> 0 > 4294963200) {
                        if (!(c[210] | 0)) e = 1380; else e = c[(kc() | 0) + 60 >> 2] | 0;
                        c[e >> 2] = 0 - b;
                        b = -1;
                    }
                    cb(0);
                }
                if ((g | 0) == (b | 0)) {
                    b = 13;
                    break;
                }
                if ((b | 0) < 0) {
                    b = 15;
                    break;
                }
                g = g - b | 0;
                e = c[j + 4 >> 2] | 0;
                if (b >>> 0 <= e >>> 0) if ((f | 0) == 2) {
                    c[a + 28 >> 2] = (c[a + 28 >> 2] | 0) + b;
                    h = e;
                    e = j;
                    f = 2;
                } else {
                    h = e;
                    e = j;
                } else {
                    h = c[a + 44 >> 2] | 0;
                    c[a + 28 >> 2] = h;
                    c[a + 20 >> 2] = h;
                    h = c[j + 12 >> 2] | 0;
                    b = b - e | 0;
                    e = j + 8 | 0;
                    f = f + -1 | 0;
                }
                c[e >> 2] = (c[e >> 2] | 0) + b;
                c[e + 4 >> 2] = h - b;
                j = e;
            }
            if ((b | 0) == 13) {
                j = c[a + 44 >> 2] | 0;
                c[a + 16 >> 2] = j + (c[a + 48 >> 2] | 0);
                c[a + 28 >> 2] = j;
                c[a + 20 >> 2] = j;
            } else if ((b | 0) == 15) {
                c[a + 16 >> 2] = 0;
                c[a + 28 >> 2] = 0;
                c[a + 20 >> 2] = 0;
                c[a >> 2] = c[a >> 2] | 32;
                if ((f | 0) == 2) d = 0; else d = d - (c[j + 4 >> 2] | 0) | 0;
            }
            i = k;
            return d | 0;
        }
        function Kq(b) {
            b = b | 0;
            var d = 0;
            d = a[b + 74 >> 0] | 0;
            a[b + 74 >> 0] = d + 255 | d;
            d = c[b >> 2] | 0;
            if (!(d & 8)) {
                c[b + 8 >> 2] = 0;
                c[b + 4 >> 2] = 0;
                d = c[b + 44 >> 2] | 0;
                c[b + 28 >> 2] = d;
                c[b + 20 >> 2] = d;
                c[b + 16 >> 2] = d + (c[b + 48 >> 2] | 0);
                d = 0;
            } else {
                c[b >> 2] = d | 32;
                d = -1;
            }
            return d | 0;
        }
        function Lq(b, d, e) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            var f = 0, g = 0, h = 0;
            f = c[e + 16 >> 2] | 0;
            if (!f) if (!(Kq(e) | 0)) {
                f = c[e + 16 >> 2] | 0;
                g = 4;
            } else f = 0; else g = 4;
            a: do {
                if ((g | 0) == 4) {
                    h = c[e + 20 >> 2] | 0;
                    if ((f - h | 0) >>> 0 < d >>> 0) {
                        f = xc[c[e + 36 >> 2] & 7](e, b, d) | 0;
                        break;
                    }
                    b: do {
                        if ((a[e + 75 >> 0] | 0) > -1) {
                            f = d;
                            while (1) {
                                if (!f) {
                                    g = h;
                                    f = 0;
                                    break b;
                                }
                                g = f + -1 | 0;
                                if ((a[b + g >> 0] | 0) == 10) break; else f = g;
                            }
                            if ((xc[c[e + 36 >> 2] & 7](e, b, f) | 0) >>> 0 < f >>> 0) break a;
                            d = d - f | 0;
                            b = b + f | 0;
                            g = c[e + 20 >> 2] | 0;
                        } else {
                            g = h;
                            f = 0;
                        }
                    } while (0);
                    Wq(g | 0, b | 0, d | 0) | 0;
                    c[e + 20 >> 2] = (c[e + 20 >> 2] | 0) + d;
                    f = f + d | 0;
                }
            } while (0);
            return f | 0;
        }
        function Mq(b, d, e) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            var f = 0, g = 0, h = 0;
            h = i;
            i = i + 224 | 0;
            f = h + 96 | 0;
            g = f + 40 | 0;
            do {
                c[f >> 2] = 0;
                f = f + 4 | 0;
            } while ((f | 0) < (g | 0));
            c[h + 80 >> 2] = c[e >> 2];
            if ((Pq(0, d, h + 80 | 0, h, h + 96 | 0) | 0) < 0) f = -1; else {
                g = c[b >> 2] | 0;
                if ((a[b + 74 >> 0] | 0) < 1) c[b >> 2] = g & -33;
                if (!(c[b + 48 >> 2] | 0)) {
                    e = c[b + 44 >> 2] | 0;
                    c[b + 44 >> 2] = h + 136;
                    c[b + 28 >> 2] = h + 136;
                    c[b + 20 >> 2] = h + 136;
                    c[b + 48 >> 2] = 80;
                    c[b + 16 >> 2] = h + 136 + 80;
                    f = Pq(b, d, h + 80 | 0, h, h + 96 | 0) | 0;
                    if (e) {
                        xc[c[b + 36 >> 2] & 7](b, 0, 0) | 0;
                        f = (c[b + 20 >> 2] | 0) == 0 ? -1 : f;
                        c[b + 44 >> 2] = e;
                        c[b + 48 >> 2] = 0;
                        c[b + 16 >> 2] = 0;
                        c[b + 28 >> 2] = 0;
                        c[b + 20 >> 2] = 0;
                    }
                } else f = Pq(b, d, h + 80 | 0, h, h + 96 | 0) | 0;
                d = c[b >> 2] | 0;
                c[b >> 2] = d | g & 32;
                f = (d & 32 | 0) == 0 ? f : -1;
            }
            i = h;
            return f | 0;
        }
        function Nq(b, d, e) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            var f = 0, g = 0, h = 0;
            a: do {
                if ((e | 0) != 0 & (b & 3 | 0) != 0) {
                    f = e;
                    while (1) {
                        if ((a[b >> 0] | 0) == (d & 255) << 24 >> 24) break a;
                        b = b + 1 | 0;
                        e = f + -1 | 0;
                        if ((e | 0) != 0 & (b & 3 | 0) != 0) f = e; else {
                            f = e;
                            e = (e | 0) != 0;
                            g = 5;
                            break;
                        }
                    }
                } else {
                    f = e;
                    e = (e | 0) != 0;
                    g = 5;
                }
            } while (0);
            b: do {
                if ((g | 0) == 5) if (e) {
                    if ((a[b >> 0] | 0) != (d & 255) << 24 >> 24) {
                        e = aa(d & 255, 16843009) | 0;
                        c: do {
                            if (f >>> 0 > 3) while (1) {
                                h = c[b >> 2] ^ e;
                                if ((h & -2139062144 ^ -2139062144) & h + -16843009) break;
                                b = b + 4 | 0;
                                f = f + -4 | 0;
                                if (f >>> 0 <= 3) {
                                    g = 11;
                                    break c;
                                }
                            } else g = 11;
                        } while (0);
                        if ((g | 0) == 11) if (!f) {
                            f = 0;
                            break;
                        }
                        while (1) {
                            if ((a[b >> 0] | 0) == (d & 255) << 24 >> 24) break b;
                            b = b + 1 | 0;
                            f = f + -1 | 0;
                            if (!f) {
                                f = 0;
                                break;
                            }
                        }
                    }
                } else f = 0;
            } while (0);
            return ((f | 0) != 0 ? b : 0) | 0;
        }
        function Oq(a) {
            a = a | 0;
            return;
        }
        function Pq(e, f, g, j, l) {
            e = e | 0;
            f = f | 0;
            g = g | 0;
            j = j | 0;
            l = l | 0;
            var m = 0, n = 0, o = 0, p = 0, q = 0, r = 0, s = 0, t = 0, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0, A = 0, B = 0, C = 0, D = 0, F = 0, G = 0, H = 0, I = 0, J = 0, K = 0, L = 0, M = 0, N = 0;
            N = i;
            i = i + 624 | 0;
            K = N + 536 + 40 | 0;
            M = N + 576 + 12 | 0;
            L = N + 588 + 9 | 0;
            m = 0;
            n = 0;
            s = 0;
            a: while (1) {
                do {
                    if ((m | 0) > -1) {
                        if ((n | 0) <= (2147483647 - m | 0)) {
                            m = n + m | 0;
                            break;
                        }
                        if (!(c[210] | 0)) m = 1380; else m = c[(kc() | 0) + 60 >> 2] | 0;
                        c[m >> 2] = 75;
                        m = -1;
                    }
                } while (0);
                n = a[f >> 0] | 0;
                if (!(n << 24 >> 24)) {
                    J = 249;
                    break;
                } else o = f;
                b: while (1) {
                    switch (n << 24 >> 24) {
                      case 37:
                        {
                            n = o;
                            J = 11;
                            break b;
                        }

                      case 0:
                        {
                            n = o;
                            break b;
                        }

                      default:
                        {}
                    }
                    I = o + 1 | 0;
                    n = a[I >> 0] | 0;
                    o = I;
                }
                c: do {
                    if ((J | 0) == 11) while (1) {
                        J = 0;
                        if ((a[n + 1 >> 0] | 0) != 37) break c;
                        o = o + 1 | 0;
                        n = n + 2 | 0;
                        if ((a[n >> 0] | 0) == 37) J = 11; else break;
                    }
                } while (0);
                B = o - f | 0;
                if ((e | 0) != 0 ? (c[e >> 2] & 32 | 0) == 0 : 0) Lq(f, B, e) | 0;
                if ((o | 0) != (f | 0)) {
                    f = n;
                    n = B;
                    continue;
                }
                q = n + 1 | 0;
                o = a[q >> 0] | 0;
                if (((o << 24 >> 24) + -48 | 0) >>> 0 < 10) {
                    I = (a[n + 2 >> 0] | 0) == 36;
                    q = I ? n + 3 | 0 : q;
                    n = a[q >> 0] | 0;
                    A = I ? (o << 24 >> 24) + -48 | 0 : -1;
                    s = I ? 1 : s;
                } else {
                    n = o;
                    A = -1;
                }
                o = n << 24 >> 24;
                d: do {
                    if ((o & -32 | 0) == 32) {
                        r = 0;
                        do {
                            if (!(1 << o + -32 & 75913)) break d;
                            r = 1 << (n << 24 >> 24) + -32 | r;
                            q = q + 1 | 0;
                            n = a[q >> 0] | 0;
                            o = n << 24 >> 24;
                        } while ((o & -32 | 0) == 32);
                    } else r = 0;
                } while (0);
                do {
                    if (n << 24 >> 24 == 42) {
                        n = q + 1 | 0;
                        o = (a[n >> 0] | 0) + -48 | 0;
                        if (o >>> 0 < 10 ? (a[q + 2 >> 0] | 0) == 36 : 0) {
                            c[l + (o << 2) >> 2] = 10;
                            s = 1;
                            q = q + 3 | 0;
                            o = c[j + ((a[n >> 0] | 0) + -48 << 3) >> 2] | 0;
                        } else {
                            if (s) {
                                m = -1;
                                break a;
                            }
                            if (!e) {
                                z = r;
                                q = n;
                                s = 0;
                                I = 0;
                                break;
                            }
                            s = (c[g >> 2] | 0) + (4 - 1) & ~(4 - 1);
                            o = c[s >> 2] | 0;
                            c[g >> 2] = s + 4;
                            s = 0;
                            q = n;
                        }
                        if ((o | 0) < 0) {
                            z = r | 8192;
                            I = 0 - o | 0;
                        } else {
                            z = r;
                            I = o;
                        }
                    } else {
                        o = (n << 24 >> 24) + -48 | 0;
                        if (o >>> 0 < 10) {
                            n = 0;
                            do {
                                n = (n * 10 | 0) + o | 0;
                                q = q + 1 | 0;
                                o = (a[q >> 0] | 0) + -48 | 0;
                            } while (o >>> 0 < 10);
                            if ((n | 0) < 0) {
                                m = -1;
                                break a;
                            } else {
                                z = r;
                                I = n;
                            }
                        } else {
                            z = r;
                            I = 0;
                        }
                    }
                } while (0);
                e: do {
                    if ((a[q >> 0] | 0) == 46) {
                        o = q + 1 | 0;
                        r = a[o >> 0] | 0;
                        if (r << 24 >> 24 != 42) {
                            if (((r << 24 >> 24) + -48 | 0) >>> 0 < 10) {
                                n = 0;
                                r = (r << 24 >> 24) + -48 | 0;
                            } else {
                                v = 0;
                                break;
                            }
                            while (1) {
                                n = (n * 10 | 0) + r | 0;
                                o = o + 1 | 0;
                                r = (a[o >> 0] | 0) + -48 | 0;
                                if (r >>> 0 >= 10) {
                                    v = n;
                                    break e;
                                }
                            }
                        }
                        n = q + 2 | 0;
                        o = (a[n >> 0] | 0) + -48 | 0;
                        if (o >>> 0 < 10 ? (a[q + 3 >> 0] | 0) == 36 : 0) {
                            c[l + (o << 2) >> 2] = 10;
                            o = q + 4 | 0;
                            v = c[j + ((a[n >> 0] | 0) + -48 << 3) >> 2] | 0;
                            break;
                        }
                        if (s) {
                            m = -1;
                            break a;
                        }
                        if (e) {
                            o = (c[g >> 2] | 0) + (4 - 1) & ~(4 - 1);
                            v = c[o >> 2] | 0;
                            c[g >> 2] = o + 4;
                            o = n;
                        } else {
                            o = n;
                            v = 0;
                        }
                    } else {
                        o = q;
                        v = -1;
                    }
                } while (0);
                u = 0;
                while (1) {
                    r = (a[o >> 0] | 0) + -65 | 0;
                    if (r >>> 0 > 57) {
                        m = -1;
                        break a;
                    }
                    H = o + 1 | 0;
                    r = a[4602 + (u * 58 | 0) + r >> 0] | 0;
                    if (((r & 255) + -1 | 0) >>> 0 < 8) {
                        o = H;
                        u = r & 255;
                    } else break;
                }
                if (!(r << 24 >> 24)) {
                    m = -1;
                    break;
                }
                n = (A | 0) > -1;
                do {
                    if (r << 24 >> 24 == 19) if (n) {
                        m = -1;
                        break a;
                    } else J = 54; else {
                        if (n) {
                            c[l + (A << 2) >> 2] = r & 255;
                            G = j + (A << 3) | 0;
                            J = c[G + 4 >> 2] | 0;
                            c[N >> 2] = c[G >> 2];
                            c[N + 4 >> 2] = J;
                            J = 54;
                            break;
                        }
                        if (!e) {
                            m = 0;
                            break a;
                        }
                        Qq(N, r & 255, g);
                    }
                } while (0);
                if ((J | 0) == 54 ? (J = 0, (e | 0) == 0) : 0) {
                    f = H;
                    n = B;
                    continue;
                }
                x = a[o >> 0] | 0;
                x = (u | 0) != 0 & (x & 15 | 0) == 3 ? x & -33 : x;
                y = z & -65537;
                G = (z & 8192 | 0) == 0 ? z : y;
                f: do {
                    switch (x | 0) {
                      case 110:
                        switch (u | 0) {
                          case 0:
                            {
                                c[c[N >> 2] >> 2] = m;
                                f = H;
                                n = B;
                                continue a;
                            }

                          case 1:
                            {
                                c[c[N >> 2] >> 2] = m;
                                f = H;
                                n = B;
                                continue a;
                            }

                          case 2:
                            {
                                f = c[N >> 2] | 0;
                                c[f >> 2] = m;
                                c[f + 4 >> 2] = ((m | 0) < 0) << 31 >> 31;
                                f = H;
                                n = B;
                                continue a;
                            }

                          case 3:
                            {
                                b[c[N >> 2] >> 1] = m;
                                f = H;
                                n = B;
                                continue a;
                            }

                          case 4:
                            {
                                a[c[N >> 2] >> 0] = m;
                                f = H;
                                n = B;
                                continue a;
                            }

                          case 6:
                            {
                                c[c[N >> 2] >> 2] = m;
                                f = H;
                                n = B;
                                continue a;
                            }

                          case 7:
                            {
                                f = c[N >> 2] | 0;
                                c[f >> 2] = m;
                                c[f + 4 >> 2] = ((m | 0) < 0) << 31 >> 31;
                                f = H;
                                n = B;
                                continue a;
                            }

                          default:
                            {
                                f = H;
                                n = B;
                                continue a;
                            }
                        }

                      case 112:
                        {
                            u = G | 8;
                            q = v >>> 0 > 8 ? v : 8;
                            x = 120;
                            J = 66;
                            break;
                        }

                      case 88:
                      case 120:
                        {
                            u = G;
                            q = v;
                            J = 66;
                            break;
                        }

                      case 111:
                        {
                            o = c[N >> 2] | 0;
                            n = c[N + 4 >> 2] | 0;
                            if ((o | 0) == 0 & (n | 0) == 0) f = K; else {
                                f = K;
                                do {
                                    f = f + -1 | 0;
                                    a[f >> 0] = o & 7 | 48;
                                    o = Zq(o | 0, n | 0, 3) | 0;
                                    n = E;
                                } while (!((o | 0) == 0 & (n | 0) == 0));
                            }
                            if (!(G & 8)) {
                                u = G;
                                r = 0;
                                q = 5082;
                                J = 79;
                            } else {
                                r = K - f + 1 | 0;
                                u = G;
                                v = (v | 0) < (r | 0) ? r : v;
                                r = 0;
                                q = 5082;
                                J = 79;
                            }
                            break;
                        }

                      case 105:
                      case 100:
                        {
                            o = c[N >> 2] | 0;
                            n = c[N + 4 >> 2] | 0;
                            if ((n | 0) < 0) {
                                o = Uq(0, 0, o | 0, n | 0) | 0;
                                n = E;
                                c[N >> 2] = o;
                                c[N + 4 >> 2] = n;
                                r = 1;
                                q = 5082;
                                J = 78;
                                break f;
                            }
                            if (!(G & 2048)) {
                                r = G & 1;
                                q = (G & 1 | 0) == 0 ? 5082 : 5084;
                                J = 78;
                            } else {
                                r = 1;
                                q = 5083;
                                J = 78;
                            }
                            break;
                        }

                      case 117:
                        {
                            o = c[N >> 2] | 0;
                            n = c[N + 4 >> 2] | 0;
                            r = 0;
                            q = 5082;
                            J = 78;
                            break;
                        }

                      case 99:
                        {
                            a[N + 536 + 39 >> 0] = c[N >> 2];
                            f = N + 536 + 39 | 0;
                            u = 1;
                            x = 0;
                            w = 5082;
                            o = K;
                            break;
                        }

                      case 109:
                        {
                            if (!(c[210] | 0)) n = 1380; else n = c[(kc() | 0) + 60 >> 2] | 0;
                            r = Dq(c[n >> 2] | 0) | 0;
                            J = 86;
                            break;
                        }

                      case 115:
                        {
                            r = c[N >> 2] | 0;
                            r = (r | 0) != 0 ? r : 5092;
                            J = 86;
                            break;
                        }

                      case 67:
                        {
                            c[N + 8 >> 2] = c[N >> 2];
                            c[N + 8 + 4 >> 2] = 0;
                            c[N >> 2] = N + 8;
                            n = N + 8 | 0;
                            r = -1;
                            J = 91;
                            break;
                        }

                      case 83:
                        if (!v) {
                            Sq(e, 32, I, 0, G);
                            o = 0;
                            J = 102;
                            break f;
                        } else {
                            n = c[N >> 2] | 0;
                            r = v;
                            J = 91;
                            break f;
                        }

                      case 65:
                      case 71:
                      case 70:
                      case 69:
                      case 97:
                      case 103:
                      case 102:
                      case 101:
                        {
                            p = +h[N >> 3];
                            c[N + 16 >> 2] = 0;
                            h[k >> 3] = p;
                            if ((c[k + 4 >> 2] | 0) >= 0) if (!(G & 2048)) {
                                D = G & 1;
                                F = (G & 1 | 0) == 0 ? 5100 : 5105;
                            } else {
                                D = 1;
                                F = 5102;
                            } else {
                                p = -p;
                                D = 1;
                                F = 5099;
                            }
                            h[k >> 3] = p;
                            C = c[k + 4 >> 2] & 2146435072;
                            do {
                                if (C >>> 0 < 2146435072 | (C | 0) == 2146435072 & 0 < 0) {
                                    p = +Eq(p, N + 16 | 0) * 2;
                                    if (p != 0) c[N + 16 >> 2] = (c[N + 16 >> 2] | 0) + -1;
                                    if ((x | 32 | 0) == 97) {
                                        y = (x & 32 | 0) == 0 ? F : F + 9 | 0;
                                        z = D | 2;
                                        o = 12 - v | 0;
                                        do {
                                            if (!(v >>> 0 > 11 | (o | 0) == 0)) {
                                                t = 8;
                                                do {
                                                    o = o + -1 | 0;
                                                    t = t * 16;
                                                } while ((o | 0) != 0);
                                                if ((a[y >> 0] | 0) == 45) {
                                                    p = -(t + (-p - t));
                                                    break;
                                                } else {
                                                    p = p + t - t;
                                                    break;
                                                }
                                            }
                                        } while (0);
                                        o = c[N + 16 >> 2] | 0;
                                        r = (o | 0) < 0 ? 0 - o | 0 : o;
                                        r = Rq(r, ((r | 0) < 0) << 31 >> 31, N + 576 + 12 | 0) | 0;
                                        if ((r | 0) == (N + 576 + 12 | 0)) {
                                            a[N + 576 + 11 >> 0] = 48;
                                            r = N + 576 + 11 | 0;
                                        }
                                        a[r + -1 >> 0] = (o >> 31 & 2) + 43;
                                        f = r + -2 | 0;
                                        a[f >> 0] = x + 15;
                                        r = (v | 0) < 1;
                                        n = N + 588 | 0;
                                        do {
                                            F = ~~p;
                                            u = n + 1 | 0;
                                            a[n >> 0] = d[5066 + F >> 0] | x & 32;
                                            p = (p - +(F | 0)) * 16;
                                            do {
                                                if ((u - (N + 588) | 0) == 1) {
                                                    if ((G & 8 | 0) == 0 & (r & p == 0)) {
                                                        n = u;
                                                        break;
                                                    }
                                                    a[u >> 0] = 46;
                                                    n = n + 2 | 0;
                                                } else n = u;
                                            } while (0);
                                        } while (p != 0);
                                        o = ((v | 0) != 0 ? (-2 - (N + 588) + n | 0) < (v | 0) : 0) ? M + 2 + v - f | 0 : M - (N + 588) - f + n | 0;
                                        Sq(e, 32, I, o + z | 0, G);
                                        if (!(c[e >> 2] & 32)) Lq(y, z, e) | 0;
                                        Sq(e, 48, I, o + z | 0, G ^ 65536);
                                        if (!(c[e >> 2] & 32)) Lq(N + 588 | 0, n - (N + 588) | 0, e) | 0;
                                        Sq(e, 48, o - (n - (N + 588) + (M - f)) | 0, 0, 0);
                                        if (!(c[e >> 2] & 32)) Lq(f, M - f | 0, e) | 0;
                                        Sq(e, 32, I, o + z | 0, G ^ 8192);
                                        n = (o + z | 0) < (I | 0) ? I : o + z | 0;
                                        break;
                                    }
                                    o = (v | 0) < 0 ? 6 : v;
                                    if (p != 0) {
                                        n = (c[N + 16 >> 2] | 0) + -28 | 0;
                                        c[N + 16 >> 2] = n;
                                        p = p * 268435456;
                                    } else n = c[N + 16 >> 2] | 0;
                                    C = (n | 0) < 0 ? N + 24 | 0 : N + 24 + 288 | 0;
                                    u = C;
                                    do {
                                        B = ~~p >>> 0;
                                        c[u >> 2] = B;
                                        u = u + 4 | 0;
                                        p = (p - +(B >>> 0)) * 1e9;
                                    } while (p != 0);
                                    n = c[N + 16 >> 2] | 0;
                                    if ((n | 0) > 0) {
                                        r = C;
                                        do {
                                            v = (n | 0) > 29 ? 29 : n;
                                            n = u + -4 | 0;
                                            do {
                                                if (n >>> 0 >= r >>> 0) {
                                                    f = 0;
                                                    do {
                                                        A = Yq(c[n >> 2] | 0, 0, v | 0) | 0;
                                                        A = Vq(A | 0, E | 0, f | 0, 0) | 0;
                                                        B = E;
                                                        z = fr(A | 0, B | 0, 1e9, 0) | 0;
                                                        c[n >> 2] = z;
                                                        f = er(A | 0, B | 0, 1e9, 0) | 0;
                                                        n = n + -4 | 0;
                                                    } while (n >>> 0 >= r >>> 0);
                                                    if (!f) break;
                                                    r = r + -4 | 0;
                                                    c[r >> 2] = f;
                                                }
                                            } while (0);
                                            while (1) {
                                                if (u >>> 0 <= r >>> 0) break;
                                                n = u + -4 | 0;
                                                if (!(c[n >> 2] | 0)) u = n; else break;
                                            }
                                            n = (c[N + 16 >> 2] | 0) - v | 0;
                                            c[N + 16 >> 2] = n;
                                        } while ((n | 0) > 0);
                                    } else r = C;
                                    if ((n | 0) < 0) do {
                                        v = 0 - n | 0;
                                        v = (v | 0) > 9 ? 9 : v;
                                        do {
                                            if (r >>> 0 < u >>> 0) {
                                                f = 0;
                                                n = r;
                                                do {
                                                    B = c[n >> 2] | 0;
                                                    c[n >> 2] = (B >>> v) + f;
                                                    f = aa(B & (1 << v) + -1, 1e9 >>> v) | 0;
                                                    n = n + 4 | 0;
                                                } while (n >>> 0 < u >>> 0);
                                                r = (c[r >> 2] | 0) == 0 ? r + 4 | 0 : r;
                                                if (!f) break;
                                                c[u >> 2] = f;
                                                u = u + 4 | 0;
                                            } else r = (c[r >> 2] | 0) == 0 ? r + 4 | 0 : r;
                                        } while (0);
                                        n = (x | 32 | 0) == 102 ? C : r;
                                        u = (u - n >> 2 | 0) > (((o + 25 | 0) / 9 | 0) + 1 | 0) ? n + (((o + 25 | 0) / 9 | 0) + 1 << 2) | 0 : u;
                                        n = (c[N + 16 >> 2] | 0) + v | 0;
                                        c[N + 16 >> 2] = n;
                                    } while ((n | 0) < 0);
                                    do {
                                        if (r >>> 0 < u >>> 0) {
                                            n = (C - r >> 2) * 9 | 0;
                                            v = c[r >> 2] | 0;
                                            if (v >>> 0 < 10) break; else f = 10;
                                            do {
                                                f = f * 10 | 0;
                                                n = n + 1 | 0;
                                            } while (v >>> 0 >= f >>> 0);
                                        } else n = 0;
                                    } while (0);
                                    w = o - ((x | 32 | 0) != 102 ? n : 0) + (((o | 0) != 0 & (x | 32 | 0) == 103) << 31 >> 31) | 0;
                                    if ((w | 0) < (((u - C >> 2) * 9 | 0) + -9 | 0)) {
                                        f = C + (((w + 9216 | 0) / 9 | 0) + -1023 << 2) | 0;
                                        if ((((w + 9216 | 0) % 9 | 0) + 1 | 0) < 9) {
                                            v = 10;
                                            q = ((w + 9216 | 0) % 9 | 0) + 1 | 0;
                                            do {
                                                v = v * 10 | 0;
                                                q = q + 1 | 0;
                                            } while ((q | 0) != 9);
                                        } else v = 10;
                                        q = c[f >> 2] | 0;
                                        z = (q >>> 0) % (v >>> 0) | 0;
                                        if (!((z | 0) == 0 ? (C + (((w + 9216 | 0) / 9 | 0) + -1022 << 2) | 0) == (u | 0) : 0)) J = 167;
                                        do {
                                            if ((J | 0) == 167) {
                                                J = 0;
                                                p = (((q >>> 0) / (v >>> 0) | 0) & 1 | 0) == 0 ? 9007199254740992 : 9007199254740994;
                                                y = (v | 0) / 2 | 0;
                                                do {
                                                    if (z >>> 0 < y >>> 0) t = .5; else {
                                                        if ((z | 0) == (y | 0) ? (C + (((w + 9216 | 0) / 9 | 0) + -1022 << 2) | 0) == (u | 0) : 0) {
                                                            t = 1;
                                                            break;
                                                        }
                                                        t = 1.5;
                                                    }
                                                } while (0);
                                                do {
                                                    if (D) {
                                                        if ((a[F >> 0] | 0) != 45) break;
                                                        p = -p;
                                                        t = -t;
                                                    }
                                                } while (0);
                                                c[f >> 2] = q - z;
                                                if (!(p + t != p)) break;
                                                B = q - z + v | 0;
                                                c[f >> 2] = B;
                                                if (B >>> 0 > 999999999) {
                                                    n = f;
                                                    while (1) {
                                                        f = n + -4 | 0;
                                                        c[n >> 2] = 0;
                                                        if (f >>> 0 < r >>> 0) {
                                                            r = r + -4 | 0;
                                                            c[r >> 2] = 0;
                                                        }
                                                        B = (c[f >> 2] | 0) + 1 | 0;
                                                        c[f >> 2] = B;
                                                        if (B >>> 0 > 999999999) n = f; else break;
                                                    }
                                                }
                                                n = (C - r >> 2) * 9 | 0;
                                                q = c[r >> 2] | 0;
                                                if (q >>> 0 < 10) break; else v = 10;
                                                do {
                                                    v = v * 10 | 0;
                                                    n = n + 1 | 0;
                                                } while (q >>> 0 >= v >>> 0);
                                            }
                                        } while (0);
                                        A = f + 4 | 0;
                                        B = r;
                                        u = u >>> 0 > A >>> 0 ? A : u;
                                    } else B = r;
                                    f = 0 - n | 0;
                                    while (1) {
                                        if (u >>> 0 <= B >>> 0) {
                                            w = 0;
                                            break;
                                        }
                                        r = u + -4 | 0;
                                        if (!(c[r >> 2] | 0)) u = r; else {
                                            w = 1;
                                            break;
                                        }
                                    }
                                    do {
                                        if ((x | 32 | 0) == 103) {
                                            if ((((o | 0) != 0 ^ 1) + o | 0) > (n | 0) & (n | 0) > -5) {
                                                x = x + -1 | 0;
                                                o = ((o | 0) != 0 ^ 1) + o + -1 - n | 0;
                                            } else {
                                                x = x + -2 | 0;
                                                o = ((o | 0) != 0 ^ 1) + o + -1 | 0;
                                            }
                                            if (G & 8) {
                                                y = G & 8;
                                                break;
                                            }
                                            do {
                                                if (w) {
                                                    v = c[u + -4 >> 2] | 0;
                                                    if (!v) {
                                                        r = 9;
                                                        break;
                                                    }
                                                    if (!((v >>> 0) % 10 | 0)) {
                                                        y = 10;
                                                        r = 0;
                                                    } else {
                                                        r = 0;
                                                        break;
                                                    }
                                                    do {
                                                        y = y * 10 | 0;
                                                        r = r + 1 | 0;
                                                    } while (((v >>> 0) % (y >>> 0) | 0 | 0) == 0);
                                                } else r = 9;
                                            } while (0);
                                            v = ((u - C >> 2) * 9 | 0) + -9 | 0;
                                            if ((x | 32 | 0) == 102) {
                                                y = v - r | 0;
                                                y = (y | 0) < 0 ? 0 : y;
                                                o = (o | 0) < (y | 0) ? o : y;
                                                y = 0;
                                                break;
                                            } else {
                                                y = v + n - r | 0;
                                                y = (y | 0) < 0 ? 0 : y;
                                                o = (o | 0) < (y | 0) ? o : y;
                                                y = 0;
                                                break;
                                            }
                                        } else y = G & 8;
                                    } while (0);
                                    q = o | y;
                                    z = (x | 32 | 0) == 102;
                                    if (z) {
                                        v = (n | 0) > 0 ? n : 0;
                                        x = 0;
                                    } else {
                                        v = (n | 0) < 0 ? f : n;
                                        v = Rq(v, ((v | 0) < 0) << 31 >> 31, N + 576 + 12 | 0) | 0;
                                        if ((M - v | 0) < 2) do {
                                            v = v + -1 | 0;
                                            a[v >> 0] = 48;
                                        } while ((M - v | 0) < 2);
                                        a[v + -1 >> 0] = (n >> 31 & 2) + 43;
                                        A = v + -2 | 0;
                                        a[A >> 0] = x;
                                        v = M - A | 0;
                                        x = A;
                                    }
                                    A = D + 1 + o + ((q | 0) != 0 & 1) + v | 0;
                                    Sq(e, 32, I, A, G);
                                    if (!(c[e >> 2] & 32)) Lq(F, D, e) | 0;
                                    Sq(e, 48, I, A, G ^ 65536);
                                    do {
                                        if (z) {
                                            v = B >>> 0 > C >>> 0 ? C : B;
                                            f = v;
                                            do {
                                                r = Rq(c[f >> 2] | 0, 0, L) | 0;
                                                do {
                                                    if ((f | 0) == (v | 0)) {
                                                        if ((r | 0) != (L | 0)) break;
                                                        a[N + 588 + 8 >> 0] = 48;
                                                        r = N + 588 + 8 | 0;
                                                    } else {
                                                        if (r >>> 0 <= (N + 588 | 0) >>> 0) break;
                                                        do {
                                                            r = r + -1 | 0;
                                                            a[r >> 0] = 48;
                                                        } while (r >>> 0 > (N + 588 | 0) >>> 0);
                                                    }
                                                } while (0);
                                                if (!(c[e >> 2] & 32)) Lq(r, L - r | 0, e) | 0;
                                                f = f + 4 | 0;
                                            } while (f >>> 0 <= C >>> 0);
                                            do {
                                                if (q) {
                                                    if (c[e >> 2] & 32) break;
                                                    Lq(5134, 1, e) | 0;
                                                }
                                            } while (0);
                                            if ((o | 0) > 0 & f >>> 0 < u >>> 0) {
                                                n = o;
                                                r = f;
                                                while (1) {
                                                    o = Rq(c[r >> 2] | 0, 0, L) | 0;
                                                    if (o >>> 0 > (N + 588 | 0) >>> 0) do {
                                                        o = o + -1 | 0;
                                                        a[o >> 0] = 48;
                                                    } while (o >>> 0 > (N + 588 | 0) >>> 0);
                                                    if (!(c[e >> 2] & 32)) Lq(o, (n | 0) > 9 ? 9 : n, e) | 0;
                                                    r = r + 4 | 0;
                                                    o = n + -9 | 0;
                                                    if (!((n | 0) > 9 & r >>> 0 < u >>> 0)) break; else n = o;
                                                }
                                            }
                                            Sq(e, 48, o + 9 | 0, 9, 0);
                                        } else {
                                            n = w ? u : B + 4 | 0;
                                            if ((o | 0) > -1) {
                                                v = (y | 0) == 0;
                                                y = B;
                                                do {
                                                    r = Rq(c[y >> 2] | 0, 0, L) | 0;
                                                    if ((r | 0) == (L | 0)) {
                                                        a[N + 588 + 8 >> 0] = 48;
                                                        r = N + 588 + 8 | 0;
                                                    }
                                                    do {
                                                        if ((y | 0) == (B | 0)) {
                                                            u = r + 1 | 0;
                                                            if (!(c[e >> 2] & 32)) Lq(r, 1, e) | 0;
                                                            if (v & (o | 0) < 1) {
                                                                r = u;
                                                                break;
                                                            }
                                                            if (c[e >> 2] & 32) {
                                                                r = u;
                                                                break;
                                                            }
                                                            Lq(5134, 1, e) | 0;
                                                            r = u;
                                                        } else {
                                                            if (r >>> 0 <= (N + 588 | 0) >>> 0) break;
                                                            do {
                                                                r = r + -1 | 0;
                                                                a[r >> 0] = 48;
                                                            } while (r >>> 0 > (N + 588 | 0) >>> 0);
                                                        }
                                                    } while (0);
                                                    u = L - r | 0;
                                                    if (!(c[e >> 2] & 32)) Lq(r, (o | 0) > (u | 0) ? u : o, e) | 0;
                                                    o = o - u | 0;
                                                    y = y + 4 | 0;
                                                } while (y >>> 0 < n >>> 0 & (o | 0) > -1);
                                            }
                                            Sq(e, 48, o + 18 | 0, 18, 0);
                                            if (c[e >> 2] & 32) break;
                                            Lq(x, M - x | 0, e) | 0;
                                        }
                                    } while (0);
                                    Sq(e, 32, I, A, G ^ 8192);
                                    n = (A | 0) < (I | 0) ? I : A;
                                } else {
                                    n = p != p | 0 != 0;
                                    r = n ? 0 : D;
                                    Sq(e, 32, I, r + 3 | 0, y);
                                    o = c[e >> 2] | 0;
                                    if (!(o & 32)) {
                                        Lq(F, r, e) | 0;
                                        o = c[e >> 2] | 0;
                                    }
                                    if (!(o & 32)) Lq(n ? (x & 32 | 0) != 0 ? 5126 : 5130 : (x & 32 | 0) != 0 ? 5118 : 5122, 3, e) | 0;
                                    Sq(e, 32, I, r + 3 | 0, G ^ 8192);
                                    n = (r + 3 | 0) < (I | 0) ? I : r + 3 | 0;
                                }
                            } while (0);
                            f = H;
                            continue a;
                        }

                      default:
                        {
                            y = G;
                            u = v;
                            x = 0;
                            w = 5082;
                            o = K;
                        }
                    }
                } while (0);
                g: do {
                    if ((J | 0) == 66) {
                        o = c[N >> 2] | 0;
                        n = c[N + 4 >> 2] | 0;
                        r = x & 32;
                        if (!((o | 0) == 0 & (n | 0) == 0)) {
                            f = K;
                            do {
                                f = f + -1 | 0;
                                a[f >> 0] = d[5066 + (o & 15) >> 0] | r;
                                o = Zq(o | 0, n | 0, 4) | 0;
                                n = E;
                            } while (!((o | 0) == 0 & (n | 0) == 0));
                            if ((u & 8 | 0) == 0 | (c[N >> 2] | 0) == 0 & (c[N + 4 >> 2] | 0) == 0) {
                                v = q;
                                r = 0;
                                q = 5082;
                                J = 79;
                            } else {
                                v = q;
                                r = 2;
                                q = 5082 + (x >> 4) | 0;
                                J = 79;
                            }
                        } else {
                            f = K;
                            v = q;
                            r = 0;
                            q = 5082;
                            J = 79;
                        }
                    } else if ((J | 0) == 78) {
                        f = Rq(o, n, K) | 0;
                        u = G;
                        J = 79;
                    } else if ((J | 0) == 86) {
                        J = 0;
                        o = Nq(r, 0, v) | 0;
                        f = r;
                        u = (o | 0) == 0 ? v : o - r | 0;
                        x = 0;
                        w = 5082;
                        o = (o | 0) == 0 ? r + v | 0 : o;
                    } else if ((J | 0) == 91) {
                        J = 0;
                        f = 0;
                        o = 0;
                        u = n;
                        while (1) {
                            q = c[u >> 2] | 0;
                            if (!q) break;
                            o = Fq(N + 528 | 0, q) | 0;
                            if ((o | 0) < 0 | o >>> 0 > (r - f | 0) >>> 0) break;
                            f = o + f | 0;
                            if (r >>> 0 > f >>> 0) u = u + 4 | 0; else break;
                        }
                        if ((o | 0) < 0) {
                            m = -1;
                            break a;
                        }
                        Sq(e, 32, I, f, G);
                        if (!f) {
                            o = 0;
                            J = 102;
                        } else {
                            q = 0;
                            while (1) {
                                o = c[n >> 2] | 0;
                                if (!o) {
                                    o = f;
                                    J = 102;
                                    break g;
                                }
                                o = Fq(N + 528 | 0, o) | 0;
                                q = o + q | 0;
                                if ((q | 0) > (f | 0)) {
                                    o = f;
                                    J = 102;
                                    break g;
                                }
                                if (!(c[e >> 2] & 32)) Lq(N + 528 | 0, o, e) | 0;
                                if (q >>> 0 >= f >>> 0) {
                                    o = f;
                                    J = 102;
                                    break;
                                } else n = n + 4 | 0;
                            }
                        }
                    }
                } while (0);
                if ((J | 0) == 102) {
                    J = 0;
                    Sq(e, 32, I, o, G ^ 8192);
                    f = H;
                    n = (I | 0) > (o | 0) ? I : o;
                    continue;
                }
                if ((J | 0) == 79) {
                    J = 0;
                    n = (v | 0) > -1 ? u & -65537 : u;
                    o = (c[N >> 2] | 0) != 0 | (c[N + 4 >> 2] | 0) != 0;
                    if ((v | 0) != 0 | o) {
                        u = (o & 1 ^ 1) + (K - f) | 0;
                        y = n;
                        u = (v | 0) > (u | 0) ? v : u;
                        x = r;
                        w = q;
                        o = K;
                    } else {
                        f = K;
                        y = n;
                        u = 0;
                        x = r;
                        w = q;
                        o = K;
                    }
                }
                q = o - f | 0;
                o = (u | 0) < (q | 0) ? q : u;
                r = x + o | 0;
                n = (I | 0) < (r | 0) ? r : I;
                Sq(e, 32, n, r, y);
                if (!(c[e >> 2] & 32)) Lq(w, x, e) | 0;
                Sq(e, 48, n, r, y ^ 65536);
                Sq(e, 48, o, q, 0);
                if (!(c[e >> 2] & 32)) Lq(f, q, e) | 0;
                Sq(e, 32, n, r, y ^ 8192);
                f = H;
            }
            h: do {
                if ((J | 0) == 249) if (!e) if (!s) m = 0; else {
                    m = 1;
                    while (1) {
                        f = c[l + (m << 2) >> 2] | 0;
                        if (!f) {
                            f = 0;
                            break;
                        }
                        Qq(j + (m << 3) | 0, f, g);
                        m = m + 1 | 0;
                        if ((m | 0) >= 10) {
                            m = 1;
                            break h;
                        }
                    }
                    while (1) {
                        m = m + 1 | 0;
                        if (f) {
                            m = -1;
                            break h;
                        }
                        if ((m | 0) >= 10) {
                            m = 1;
                            break h;
                        }
                        f = c[l + (m << 2) >> 2] | 0;
                    }
                }
            } while (0);
            i = N;
            return m | 0;
        }
        function Qq(a, b, d) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            var e = 0, f = 0, g = 0;
            a: do {
                if (b >>> 0 <= 20) do {
                    switch (b | 0) {
                      case 9:
                        {
                            e = (c[d >> 2] | 0) + (4 - 1) & ~(4 - 1);
                            b = c[e >> 2] | 0;
                            c[d >> 2] = e + 4;
                            c[a >> 2] = b;
                            break a;
                        }

                      case 10:
                        {
                            b = (c[d >> 2] | 0) + (4 - 1) & ~(4 - 1);
                            e = c[b >> 2] | 0;
                            c[d >> 2] = b + 4;
                            c[a >> 2] = e;
                            c[a + 4 >> 2] = ((e | 0) < 0) << 31 >> 31;
                            break a;
                        }

                      case 11:
                        {
                            b = (c[d >> 2] | 0) + (4 - 1) & ~(4 - 1);
                            e = c[b >> 2] | 0;
                            c[d >> 2] = b + 4;
                            c[a >> 2] = e;
                            c[a + 4 >> 2] = 0;
                            break a;
                        }

                      case 12:
                        {
                            f = (c[d >> 2] | 0) + (8 - 1) & ~(8 - 1);
                            b = c[f >> 2] | 0;
                            e = c[f + 4 >> 2] | 0;
                            c[d >> 2] = f + 8;
                            c[a >> 2] = b;
                            c[a + 4 >> 2] = e;
                            break a;
                        }

                      case 13:
                        {
                            e = (c[d >> 2] | 0) + (4 - 1) & ~(4 - 1);
                            f = c[e >> 2] | 0;
                            c[d >> 2] = e + 4;
                            c[a >> 2] = (f & 65535) << 16 >> 16;
                            c[a + 4 >> 2] = (((f & 65535) << 16 >> 16 | 0) < 0) << 31 >> 31;
                            break a;
                        }

                      case 14:
                        {
                            e = (c[d >> 2] | 0) + (4 - 1) & ~(4 - 1);
                            f = c[e >> 2] | 0;
                            c[d >> 2] = e + 4;
                            c[a >> 2] = f & 65535;
                            c[a + 4 >> 2] = 0;
                            break a;
                        }

                      case 15:
                        {
                            e = (c[d >> 2] | 0) + (4 - 1) & ~(4 - 1);
                            f = c[e >> 2] | 0;
                            c[d >> 2] = e + 4;
                            c[a >> 2] = (f & 255) << 24 >> 24;
                            c[a + 4 >> 2] = (((f & 255) << 24 >> 24 | 0) < 0) << 31 >> 31;
                            break a;
                        }

                      case 16:
                        {
                            e = (c[d >> 2] | 0) + (4 - 1) & ~(4 - 1);
                            f = c[e >> 2] | 0;
                            c[d >> 2] = e + 4;
                            c[a >> 2] = f & 255;
                            c[a + 4 >> 2] = 0;
                            break a;
                        }

                      case 17:
                        {
                            f = (c[d >> 2] | 0) + (8 - 1) & ~(8 - 1);
                            g = +h[f >> 3];
                            c[d >> 2] = f + 8;
                            h[a >> 3] = g;
                            break a;
                        }

                      case 18:
                        {
                            f = (c[d >> 2] | 0) + (8 - 1) & ~(8 - 1);
                            g = +h[f >> 3];
                            c[d >> 2] = f + 8;
                            h[a >> 3] = g;
                            break a;
                        }

                      default:
                        break a;
                    }
                } while (0);
            } while (0);
            return;
        }
        function Rq(b, c, d) {
            b = b | 0;
            c = c | 0;
            d = d | 0;
            var e = 0;
            if (c >>> 0 > 0 | (c | 0) == 0 & b >>> 0 > 4294967295) while (1) {
                e = fr(b | 0, c | 0, 10, 0) | 0;
                d = d + -1 | 0;
                a[d >> 0] = e | 48;
                e = b;
                b = er(b | 0, c | 0, 10, 0) | 0;
                if (!(c >>> 0 > 9 | (c | 0) == 9 & e >>> 0 > 4294967295)) break; else c = E;
            }
            if (b) while (1) {
                d = d + -1 | 0;
                a[d >> 0] = (b >>> 0) % 10 | 0 | 48;
                if (b >>> 0 < 10) break; else b = (b >>> 0) / 10 | 0;
            }
            return d | 0;
        }
        function Sq(a, b, d, e, f) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            var g = 0, h = 0;
            h = i;
            i = i + 256 | 0;
            do {
                if ((d | 0) > (e | 0) & (f & 73728 | 0) == 0) {
                    Xq(h | 0, b | 0, ((d - e | 0) >>> 0 > 256 ? 256 : d - e | 0) | 0) | 0;
                    b = c[a >> 2] | 0;
                    if ((d - e | 0) >>> 0 > 255) {
                        g = d - e | 0;
                        f = b;
                        b = (b & 32 | 0) == 0;
                        do {
                            if (b) {
                                Lq(h, 256, a) | 0;
                                f = c[a >> 2] | 0;
                            }
                            g = g + -256 | 0;
                            b = (f & 32 | 0) == 0;
                        } while (g >>> 0 > 255);
                        if (b) b = d - e & 255; else break;
                    } else if (!(b & 32)) b = d - e | 0; else break;
                    Lq(h, b, a) | 0;
                }
            } while (0);
            i = h;
            return;
        }
        function Tq() {}
        function Uq(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            d = b - d - (c >>> 0 > a >>> 0 | 0) >>> 0;
            return (E = d, a - c >>> 0 | 0) | 0;
        }
        function Vq(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            return (E = b + d + (a + c >>> 0 >>> 0 < a >>> 0 | 0) >>> 0, a + c >>> 0 | 0) | 0;
        }
        function Wq(b, d, e) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            var f = 0;
            if ((e | 0) >= 4096) return Pb(b | 0, d | 0, e | 0) | 0;
            f = b | 0;
            if ((b & 3) == (d & 3)) {
                while (b & 3) {
                    if (!e) return f | 0;
                    a[b >> 0] = a[d >> 0] | 0;
                    b = b + 1 | 0;
                    d = d + 1 | 0;
                    e = e - 1 | 0;
                }
                while ((e | 0) >= 4) {
                    c[b >> 2] = c[d >> 2];
                    b = b + 4 | 0;
                    d = d + 4 | 0;
                    e = e - 4 | 0;
                }
            }
            while ((e | 0) > 0) {
                a[b >> 0] = a[d >> 0] | 0;
                b = b + 1 | 0;
                d = d + 1 | 0;
                e = e - 1 | 0;
            }
            return f | 0;
        }
        function Xq(b, d, e) {
            b = b | 0;
            d = d | 0;
            e = e | 0;
            var f = 0, g = 0, h = 0;
            f = b + e | 0;
            if ((e | 0) >= 20) {
                d = d & 255;
                g = b & 3;
                h = d | d << 8 | d << 16 | d << 24;
                if (g) {
                    g = b + 4 - g | 0;
                    while ((b | 0) < (g | 0)) {
                        a[b >> 0] = d;
                        b = b + 1 | 0;
                    }
                }
                while ((b | 0) < (f & ~3 | 0)) {
                    c[b >> 2] = h;
                    b = b + 4 | 0;
                }
            }
            while ((b | 0) < (f | 0)) {
                a[b >> 0] = d;
                b = b + 1 | 0;
            }
            return b - e | 0;
        }
        function Yq(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            if ((c | 0) < 32) {
                E = b << c | (a & (1 << c) - 1 << 32 - c) >>> 32 - c;
                return a << c;
            }
            E = a << c - 32;
            return 0;
        }
        function Zq(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            if ((c | 0) < 32) {
                E = b >>> c;
                return a >>> c | (b & (1 << c) - 1) << 32 - c;
            }
            E = 0;
            return b >>> c - 32 | 0;
        }
        function _q(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            if ((c | 0) < 32) {
                E = b >> c;
                return a >>> c | (b & (1 << c) - 1) << 32 - c;
            }
            E = (b | 0) < 0 ? -1 : 0;
            return b >> c - 32 | 0;
        }
        function $q(b) {
            b = b | 0;
            var c = 0;
            c = a[m + (b & 255) >> 0] | 0;
            if ((c | 0) < 8) return c | 0;
            c = a[m + (b >> 8 & 255) >> 0] | 0;
            if ((c | 0) < 8) return c + 8 | 0;
            c = a[m + (b >> 16 & 255) >> 0] | 0;
            if ((c | 0) < 8) return c + 16 | 0;
            return (a[m + (b >>> 24) >> 0] | 0) + 24 | 0;
        }
        function ar(a, b) {
            a = a | 0;
            b = b | 0;
            var c = 0, d = 0, e = 0;
            c = aa(b & 65535, a & 65535) | 0;
            e = (c >>> 16) + (aa(b & 65535, a >>> 16) | 0) | 0;
            d = aa(b >>> 16, a & 65535) | 0;
            return (E = (e >>> 16) + (aa(b >>> 16, a >>> 16) | 0) + (((e & 65535) + d | 0) >>> 16) | 0, 
            e + d << 16 | c & 65535 | 0) | 0;
        }
        function br(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            var e = 0, f = 0, g = 0, h = 0;
            g = b >> 31 | ((b | 0) < 0 ? -1 : 0) << 1;
            e = ((b | 0) < 0 ? -1 : 0) >> 31 | ((b | 0) < 0 ? -1 : 0) << 1;
            h = d >> 31 | ((d | 0) < 0 ? -1 : 0) << 1;
            f = ((d | 0) < 0 ? -1 : 0) >> 31 | ((d | 0) < 0 ? -1 : 0) << 1;
            a = Uq(g ^ a, e ^ b, g, e) | 0;
            b = E;
            return Uq((gr(a, b, Uq(h ^ c, f ^ d, h, f) | 0, E, 0) | 0) ^ (h ^ g), E ^ (f ^ e), h ^ g, f ^ e) | 0;
        }
        function cr(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            var f = 0, g = 0, h = 0, j = 0, k = 0;
            f = i;
            i = i + 16 | 0;
            h = b >> 31 | ((b | 0) < 0 ? -1 : 0) << 1;
            g = ((b | 0) < 0 ? -1 : 0) >> 31 | ((b | 0) < 0 ? -1 : 0) << 1;
            k = e >> 31 | ((e | 0) < 0 ? -1 : 0) << 1;
            j = ((e | 0) < 0 ? -1 : 0) >> 31 | ((e | 0) < 0 ? -1 : 0) << 1;
            a = Uq(h ^ a, g ^ b, h, g) | 0;
            b = E;
            gr(a, b, Uq(k ^ d, j ^ e, k, j) | 0, E, f | 0) | 0;
            e = Uq(c[f >> 2] ^ h, c[f + 4 >> 2] ^ g, h, g) | 0;
            d = E;
            i = f;
            return (E = d, e) | 0;
        }
        function dr(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            var e = 0, f = 0;
            e = ar(a, c) | 0;
            f = E;
            return (E = (aa(b, c) | 0) + (aa(d, a) | 0) + f | f & 0, e | 0 | 0) | 0;
        }
        function er(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            return gr(a, b, c, d, 0) | 0;
        }
        function fr(a, b, d, e) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            var f = 0;
            f = i;
            i = i + 16 | 0;
            gr(a, b, d, e, f | 0) | 0;
            i = f;
            return (E = c[f + 4 >> 2] | 0, c[f >> 2] | 0) | 0;
        }
        function gr(a, b, d, e, f) {
            a = a | 0;
            b = b | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            var g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p = 0;
            if (!b) if (!e) {
                if (f) {
                    c[f >> 2] = (a >>> 0) % (d >>> 0);
                    c[f + 4 >> 2] = 0;
                }
                e = 0;
                f = (a >>> 0) / (d >>> 0) >>> 0;
                return (E = e, f) | 0;
            } else {
                if (!f) {
                    e = 0;
                    f = 0;
                    return (E = e, f) | 0;
                }
                c[f >> 2] = a | 0;
                c[f + 4 >> 2] = b & 0;
                e = 0;
                f = 0;
                return (E = e, f) | 0;
            }
            do {
                if (d) {
                    if (e) {
                        h = (ca(e | 0) | 0) - (ca(b | 0) | 0) | 0;
                        if (h >>> 0 <= 31) {
                            j = h + 1 | 0;
                            i = a >>> ((h + 1 | 0) >>> 0) & h - 31 >> 31 | b << 31 - h;
                            m = b >>> ((h + 1 | 0) >>> 0) & h - 31 >> 31;
                            g = 0;
                            h = a << 31 - h;
                            break;
                        }
                        if (!f) {
                            e = 0;
                            f = 0;
                            return (E = e, f) | 0;
                        }
                        c[f >> 2] = a | 0;
                        c[f + 4 >> 2] = b | b & 0;
                        e = 0;
                        f = 0;
                        return (E = e, f) | 0;
                    }
                    if (d - 1 & d) {
                        h = (ca(d | 0) | 0) + 33 - (ca(b | 0) | 0) | 0;
                        j = h;
                        i = 32 - h - 1 >> 31 & b >>> ((h - 32 | 0) >>> 0) | (b << 32 - h | a >>> (h >>> 0)) & h - 32 >> 31;
                        m = h - 32 >> 31 & b >>> (h >>> 0);
                        g = a << 64 - h & 32 - h >> 31;
                        h = (b << 64 - h | a >>> ((h - 32 | 0) >>> 0)) & 32 - h >> 31 | a << 32 - h & h - 33 >> 31;
                        break;
                    }
                    if (f) {
                        c[f >> 2] = d - 1 & a;
                        c[f + 4 >> 2] = 0;
                    }
                    if ((d | 0) == 1) {
                        e = b | b & 0;
                        f = a | 0 | 0;
                        return (E = e, f) | 0;
                    } else {
                        f = $q(d | 0) | 0;
                        e = b >>> (f >>> 0) | 0;
                        f = b << 32 - f | a >>> (f >>> 0) | 0;
                        return (E = e, f) | 0;
                    }
                } else {
                    if (!e) {
                        if (f) {
                            c[f >> 2] = (b >>> 0) % (d >>> 0);
                            c[f + 4 >> 2] = 0;
                        }
                        e = 0;
                        f = (b >>> 0) / (d >>> 0) >>> 0;
                        return (E = e, f) | 0;
                    }
                    if (!a) {
                        if (f) {
                            c[f >> 2] = 0;
                            c[f + 4 >> 2] = (b >>> 0) % (e >>> 0);
                        }
                        d = 0;
                        f = (b >>> 0) / (e >>> 0) >>> 0;
                        return (E = d, f) | 0;
                    }
                    if (!(e - 1 & e)) {
                        if (f) {
                            c[f >> 2] = a | 0;
                            c[f + 4 >> 2] = e - 1 & b | b & 0;
                        }
                        d = 0;
                        f = b >>> (($q(e | 0) | 0) >>> 0);
                        return (E = d, f) | 0;
                    }
                    h = (ca(e | 0) | 0) - (ca(b | 0) | 0) | 0;
                    if (h >>> 0 <= 30) {
                        j = h + 1 | 0;
                        i = b << 31 - h | a >>> ((h + 1 | 0) >>> 0);
                        m = b >>> ((h + 1 | 0) >>> 0);
                        g = 0;
                        h = a << 31 - h;
                        break;
                    }
                    if (!f) {
                        e = 0;
                        f = 0;
                        return (E = e, f) | 0;
                    }
                    c[f >> 2] = a | 0;
                    c[f + 4 >> 2] = b | b & 0;
                    e = 0;
                    f = 0;
                    return (E = e, f) | 0;
                }
            } while (0);
            if (!j) {
                j = h;
                b = m;
                h = 0;
                a = 0;
            } else {
                k = Vq(d | 0 | 0, e | e & 0 | 0, -1, -1) | 0;
                l = E;
                b = m;
                a = 0;
                do {
                    p = h;
                    h = g >>> 31 | h << 1;
                    g = a | g << 1;
                    p = i << 1 | p >>> 31 | 0;
                    o = i >>> 31 | b << 1 | 0;
                    Uq(k, l, p, o) | 0;
                    m = E;
                    n = m >> 31 | ((m | 0) < 0 ? -1 : 0) << 1;
                    a = n & 1;
                    i = Uq(p, o, n & (d | 0), (((m | 0) < 0 ? -1 : 0) >> 31 | ((m | 0) < 0 ? -1 : 0) << 1) & (e | e & 0)) | 0;
                    b = E;
                    j = j - 1 | 0;
                } while ((j | 0) != 0);
                j = h;
                h = 0;
            }
            if (f) {
                c[f >> 2] = i;
                c[f + 4 >> 2] = b;
            }
            o = (g | 0) >>> 31 | j << 1 | (0 << 1 | g >>> 31) & 0 | h;
            p = (g << 1 | 0 >>> 31) & -2 | a;
            return (E = o, p) | 0;
        }
        function hr(a, b) {
            a = a | 0;
            b = b | 0;
            wc[a & 31](b | 0);
        }
        function ir(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            return xc[a & 7](b | 0, c | 0, d | 0) | 0;
        }
        function jr(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = +c;
            d = d | 0;
            yc[a & 0](b | 0, +c, d | 0);
        }
        function kr(a, b, c, d, e, f, g) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            zc[a & 3](b | 0, c | 0, d | 0, e | 0, f | 0, g | 0);
        }
        function lr(a, b, c, d, e, f) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            Ac[a & 3](b | 0, c | 0, d | 0, e | 0, f | 0);
        }
        function mr(a, b, c, d, e, f, g, h, i) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            h = h | 0;
            i = i | 0;
            return +Bc[a & 1](b | 0, c | 0, d | 0, e | 0, f | 0, g | 0, h | 0, i | 0);
        }
        function nr(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = +c;
            Cc[a & 0](b | 0, +c);
        }
        function or(a, b) {
            a = a | 0;
            b = b | 0;
            return +Dc[a & 0](b | 0);
        }
        function pr(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = +c;
            d = d | 0;
            e = +e;
            return Ec[a & 0](b | 0, +c, d | 0, +e) | 0;
        }
        function qr(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            Fc[a & 3](b | 0, c | 0);
        }
        function rr(a, b) {
            a = a | 0;
            b = b | 0;
            return Gc[a & 3](b | 0) | 0;
        }
        function sr(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            Hc[a & 1](b | 0, c | 0, d | 0);
        }
        function tr(a) {
            a = a | 0;
            Ic[a & 3]();
        }
        function ur(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = +d;
            Jc[a & 0](b | 0, c | 0, +d);
        }
        function vr(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            return Kc[a & 1](b | 0, c | 0, d | 0, e | 0) | 0;
        }
        function wr(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            Lc[a & 3](b | 0, c | 0, d | 0, e | 0);
        }
        function xr(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            return Mc[a & 3](b | 0, c | 0) | 0;
        }
        function yr(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            return +Nc[a & 3](b | 0, c | 0, d | 0);
        }
        function zr(a) {
            a = a | 0;
            da(0);
        }
        function Ar(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            da(1);
            return 0;
        }
        function Br(a, b, c) {
            a = a | 0;
            b = +b;
            c = c | 0;
            da(2);
        }
        function Cr(a, b, c, d, e, f) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            da(3);
        }
        function Dr(a, b, c, d, e) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            da(4);
        }
        function Er(a, b, c, d, e, f, g, h) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            e = e | 0;
            f = f | 0;
            g = g | 0;
            h = h | 0;
            da(5);
            return 0;
        }
        function Fr(a, b) {
            a = a | 0;
            b = +b;
            da(6);
        }
        function Gr(a) {
            a = a | 0;
            da(7);
            return 0;
        }
        function Hr(a, b, c, d) {
            a = a | 0;
            b = +b;
            c = c | 0;
            d = +d;
            da(8);
            return 0;
        }
        function Ir(a, b) {
            a = a | 0;
            b = b | 0;
            da(9);
        }
        function Jr(a) {
            a = a | 0;
            da(10);
            return 0;
        }
        function Kr(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            da(11);
        }
        function Lr() {
            da(12);
        }
        function Mr(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = +c;
            da(13);
        }
        function Nr(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            da(14);
            return 0;
        }
        function Or(a, b, c, d) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            d = d | 0;
            da(15);
        }
        function Pr(a, b) {
            a = a | 0;
            b = b | 0;
            da(16);
            return 0;
        }
        function Qr(a, b, c) {
            a = a | 0;
            b = b | 0;
            c = c | 0;
            da(17);
            return 0;
        }
        var wc = [ zr, Hp, Ip, Np, Op, Rp, Sp, Wp, Xp, $p, aq, eq, fq, iq, lq, jq, kq, mq, Aq, Oq, zr, zr, zr, zr, zr, zr, zr, zr, zr, zr, zr, zr ];
        var xc = [ Ar, Jp, nq, Jq, Iq, Ar, Ar, Ar ];
        var yc = [ Br ];
        var zc = [ Cr, vq, uq, Cr ];
        var Ac = [ Dr, tq, sq, Dr ];
        var Bc = [ Er, cq ];
        var Cc = [ Fr ];
        var Dc = [ Gr ];
        var Ec = [ Hr ];
        var Fc = [ Ir, Tp, Up, Ir ];
        var Gc = [ Jr, gq, Hq, Jr ];
        var Hc = [ Kr, Lp ];
        var Ic = [ Lr, yq, zq, Lr ];
        var Jc = [ Mr ];
        var Kc = [ Nr, Kp ];
        var Lc = [ Or, oq, pq, Or ];
        var Mc = [ Pr, Pp, Yp, bq ];
        var Nc = [ Qr, Qp, Zp, Qr ];
        return {
            _emscripten_bind_btCylinderShape___destroy___0: Sf,
            _emscripten_bind_btGeneric6DofConstraint_enableFeedback_1: Wd,
            _emscripten_bind_btHingeConstraint_setBreakingImpulseThreshold_1: pn,
            _emscripten_bind_btDispatcherInfo_set_m_useContinuous_1: rg,
            _emscripten_bind_btCollisionObject_isActive_0: fd,
            _emscripten_bind_btVehicleTuning_set_m_frictionSlip_1: ek,
            _emscripten_bind_btDiscreteDynamicsWorld_btDiscreteDynamicsWorld_4: Wh,
            _emscripten_bind_btCapsuleShapeX_getMargin_0: il,
            _emscripten_bind_btCompoundShape_getMargin_0: ok,
            _emscripten_bind_btGhostObject_setCcdSweptSphereRadius_1: Cf,
            _emscripten_bind_btConstraintSetting_get_m_tau_0: sn,
            _emscripten_bind_btWheelInfo_get_m_rollInfluence_0: Jl,
            _emscripten_bind_btTypedConstraint_setBreakingImpulseThreshold_1: Id,
            _emscripten_bind_btQuaternion_setX_1: sl,
            _emscripten_bind_btCylinderShapeZ_getMargin_0: ap,
            _emscripten_bind_btDispatcherInfo_get_m_timeOfImpact_0: og,
            _emscripten_bind_btQuaternion_setZ_1: ul,
            _emscripten_bind_btCapsuleShapeZ_getMargin_0: zl,
            _emscripten_bind_btKinematicCharacterController_setMaxSlope_1: Gm,
            _emscripten_bind_btQuadWord_z_0: Gf,
            _emscripten_bind_btVehicleTuning_get_m_suspensionStiffness_0: Xj,
            _emscripten_bind_btWheelInfo_get_m_suspensionRestLength1_0: Ll,
            _emscripten_bind_btWheelInfo_get_m_suspensionStiffness_0: Fl,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_angularSleepingThreshold_1: vh,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_angularDamping_0: kh,
            _emscripten_bind_btCollisionDispatcher___destroy___0: Vj,
            _emscripten_bind_btRigidBody_applyCentralImpulse_1: qo,
            _emscripten_bind_btConvexHullShape_getMargin_0: Cj,
            _emscripten_bind_btDefaultMotionState_getWorldTransform_1: Mk,
            _emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_1: di,
            _emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_3: fi,
            _emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_2: ei,
            _emscripten_bind_btVector3_op_mul_1: df,
            _emscripten_bind_btDynamicsWorld_rayTest_3: De,
            _emscripten_bind_btRaycastVehicle_updateWheelTransform_2: rp,
            _emscripten_bind_btQuadWord_x_0: Ef,
            _emscripten_bind_btCollisionObject_isKinematicObject_0: gd,
            _emscripten_bind_btWheelInfo_set_m_chassisConnectionPointCS_1: cm,
            _emscripten_bind_ConvexResultCallback___destroy___0: ge,
            _emscripten_bind_btGeneric6DofSpringConstraint_setLinearUpperLimit_1: Ln,
            _emscripten_bind_ClosestConvexResultCallback_set_m_hitNormalWorld_1: zk,
            _emscripten_bind_btRigidBody_getCenterOfMassTransform_0: fo,
            _emscripten_bind_btGhostObject_isKinematicObject_0: sf,
            _emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_5: Gn,
            _emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_3: Fn,
            _emscripten_bind_btCollisionObject_activate_1: ed,
            _emscripten_bind_btCollisionObject_activate_0: dd,
            _emscripten_bind_btKinematicCharacterController_setUpAxis_1: tm,
            _emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterGroup_1: al,
            _emscripten_bind_btDispatcherInfo_set_m_timeOfImpact_1: pg,
            _emscripten_bind_btCollisionDispatcher_btCollisionDispatcher_1: Sj,
            _emscripten_bind_btVector3_setX_1: $e,
            _emscripten_bind_btCollisionConfiguration___destroy___0: Fg,
            _emscripten_bind_btCapsuleShapeZ_setMargin_1: yl,
            _emscripten_bind_btQuaternion_btQuaternion_4: ml,
            _emscripten_bind_btSphereShape___destroy___0: an,
            _emscripten_bind_btManifoldPoint_set_m_positionWorldOnB_1: Ph,
            _emscripten_bind_btManifoldPoint_set_m_localPointB_1: Nh,
            _emscripten_bind_btVector3_setZ_1: bf,
            _emscripten_bind_btKinematicCharacterController_setUseGhostSweepTest_1: Jm,
            _emscripten_bind_btQuaternion_setValue_4: nl,
            _emscripten_bind_btDispatcherInfo_set_m_dispatchFunc_1: ng,
            _emscripten_bind_LocalShapeInfo___destroy___0: Dn,
            _emscripten_bind_btWheelInfo_get_m_bIsFrontWheel_0: $l,
            _emscripten_bind_btQuadWord_setY_1: Jf,
            _emscripten_bind_btRigidBody_isKinematicObject_0: Io,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_restitution_1: rh,
            _emscripten_bind_btDefaultMotionState_get_m_graphicsWorldTrans_0: Ok,
            _emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_3: _h,
            _emscripten_bind_btPairCachingGhostObject_btPairCachingGhostObject_0: Lg,
            _emscripten_bind_btDiscreteDynamicsWorld_getSolverInfo_0: si,
            _emscripten_bind_btCylinderShape_setMargin_1: Of,
            _emscripten_bind_btCollisionWorld___destroy___0: Fd,
            _emscripten_bind_LocalConvexResult_get_m_hitPointLocal_0: Zn,
            _emscripten_bind_btBoxShape_btBoxShape_1: Mj,
            _emscripten_bind_btPersistentManifold_getBody1_0: Ij,
            _emscripten_bind_ClosestRayResultCallback_set_m_collisionObject_1: el,
            _emscripten_bind_btKinematicCharacterController_setGravity_1: Em,
            _emscripten_bind_btConstraintSetting_set_m_impulseClamp_1: xn,
            _emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_5: Rd,
            _emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_3: Qd,
            _emscripten_bind_btQuaternion_setY_1: tl,
            _emscripten_bind_btConvexShape_setLocalScaling_1: oe,
            _emscripten_bind_ClosestRayResultCallback_get_m_hitPointWorld_0: Zk,
            _emscripten_bind_btVector4_setValue_4: hm,
            _emscripten_bind_btBvhTriangleMeshShape_setLocalScaling_1: ag,
            _emscripten_bind_btPoint2PointConstraint_setBreakingImpulseThreshold_1: Hi,
            _emscripten_bind_btDynamicsWorld_getDispatchInfo_0: Fe,
            _emscripten_bind_btCompoundShape_removeChildShapeByIndex_1: kk,
            _emscripten_bind_btVector3_length_0: Xe,
            _emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_2: vi,
            _emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_1: ui,
            _emscripten_bind_ClosestConvexResultCallback_set_m_hitPointWorld_1: Bk,
            _emscripten_bind_RayResultCallback_set_m_collisionFilterMask_1: Re,
            _emscripten_bind_btBoxShape_getMargin_0: Oj,
            _emscripten_bind_btPairCachingGhostObject___destroy___0: fh,
            _emscripten_bind_btPairCachingGhostObject_activate_0: Rg,
            _emscripten_bind_btPairCachingGhostObject_activate_1: Sg,
            _emscripten_bind_btContactSolverInfo_get_m_splitImpulsePenetrationThreshold_0: Sm,
            _emscripten_bind_btDynamicsWorld_getDispatcher_0: Ce,
            _emscripten_bind_btPairCachingGhostObject_forceActivationState_1: Qg,
            _emscripten_bind_btDefaultMotionState___destroy___0: Qk,
            _emscripten_bind_btDispatcherInfo_get_m_stepCount_0: kg,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_angularDamping_1: lh,
            _emscripten_bind_btQuadWord_setW_1: Lf,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_friction_0: mh,
            _emscripten_bind_btCapsuleShapeX_btCapsuleShapeX_2: gl,
            _emscripten_bind_LocalShapeInfo_set_m_shapePart_1: An,
            _emscripten_bind_btRigidBody_setLinearFactor_1: ko,
            _emscripten_bind_btDispatcherInfo_set_m_useConvexConservativeDistanceUtil_1: Bg,
            _emscripten_bind_btRaycastVehicle_setSteeringValue_2: pp,
            _emscripten_bind_btPoint2PointConstraint___destroy___0: Ki,
            _emscripten_bind_btGeneric6DofConstraint_setAngularUpperLimit_1: Vd,
            _emscripten_bind_btDiscreteDynamicsWorld_addConstraint_2: bi,
            _emscripten_bind_btDiscreteDynamicsWorld_addConstraint_1: ai,
            _emscripten_bind_btRigidBody_setRestitution_1: Jo,
            _emscripten_bind_LocalConvexResult___destroy___0: bo,
            _malloc: Bq,
            _emscripten_bind_btDispatcherInfo_get_m_useEpa_0: wg,
            _emscripten_bind_btTransform_btTransform_2: fp,
            _emscripten_bind_btTransform_btTransform_0: ep,
            _emscripten_bind_btWheelInfo_set_m_wheelsRadius_1: Ol,
            _emscripten_bind_btDispatcherInfo_set_m_enableSPU_1: vg,
            _emscripten_bind_btRaycastVehicle_setCoordinateSystem_3: xp,
            _emscripten_bind_btCollisionObject_setActivationState_1: bd,
            _emscripten_bind_btPersistentManifold___destroy___0: Lj,
            _emscripten_bind_btConstraintSetting_get_m_impulseClamp_0: wn,
            _emscripten_bind_btCylinderShapeZ___destroy___0: dp,
            _emscripten_bind_btMatrix3x3___destroy___0: Wf,
            _emscripten_bind_btGeneric6DofSpringConstraint_setBreakingImpulseThreshold_1: Qn,
            _emscripten_bind_btCollisionShape_calculateLocalInertia_2: Yc,
            _emscripten_bind_ConvexResultCallback_hasHit_0: $d,
            _emscripten_bind_btCollisionWorld_convexSweepTest_5: Dd,
            _emscripten_bind_ClosestRayResultCallback_set_m_hitPointWorld_1: _k,
            _emscripten_bind_btCapsuleShapeX_calculateLocalInertia_2: kl,
            _emscripten_bind_btConstraintSetting_set_m_damping_1: vn,
            _emscripten_bind_btVehicleRaycaster___destroy___0: ff,
            _emscripten_bind_btRigidBody_setCcdMotionThreshold_1: Ro,
            _emscripten_bind_btConvexHullShape_setMargin_1: Bj,
            _emscripten_bind_btRigidBody_applyForce_2: mo,
            _emscripten_bind_btConeShapeZ_calculateLocalInertia_2: mj,
            _emscripten_bind_btConstraintSetting_set_m_tau_1: tn,
            _emscripten_bind_btConvexHullShape_calculateLocalInertia_2: Ej,
            _emscripten_bind_btSphereShape_calculateLocalInertia_2: $m,
            _emscripten_bind_btConeShape_setLocalScaling_1: le,
            _emscripten_bind_btWheelInfo_get_m_chassisConnectionPointCS_0: bm,
            _emscripten_bind_btCollisionDispatcher_getManifoldByIndexInternal_1: Uj,
            _emscripten_bind_ClosestRayResultCallback_get_m_rayToWorld_0: Vk,
            _emscripten_bind_btGhostObject_setFriction_1: uf,
            _emscripten_bind_btCollisionWorld_rayTest_3: wd,
            _emscripten_bind_btRigidBody_setCcdSweptSphereRadius_1: So,
            _emscripten_bind_btCylinderShapeZ_setMargin_1: $o,
            _emscripten_bind_btRigidBody_setFriction_1: Ko,
            _emscripten_bind_LocalConvexResult_set_m_hitPointLocal_1: _n,
            _emscripten_bind_btGhostObject_setWorldTransform_1: zf,
            _emscripten_bind_btDiscreteDynamicsWorld_removeRigidBody_1: $h,
            _emscripten_bind_btConvexHullShape___destroy___0: Fj,
            _emscripten_bind_btDiscreteDynamicsWorld_getBroadphase_0: ni,
            _emscripten_bind_btVector4_setX_1: mm,
            _emscripten_bind_btKinematicCharacterController_jump_0: Dm,
            _emscripten_bind_btConeTwistConstraint_setMaxMotorImpulseNormalized_1: aj,
            _emscripten_bind_btConvexTriangleMeshShape_setLocalScaling_1: wi,
            _emscripten_bind_btRigidBody_upcast_1: zo,
            _emscripten_bind_btTransform_setOrigin_1: hp,
            _emscripten_bind_btVector4_setZ_1: om,
            _emscripten_bind_btQuadWord_y_0: Ff,
            ___cxa_can_catch: wq,
            _emscripten_bind_btTransform_getBasis_0: lp,
            _emscripten_bind_btPairCachingGhostObject_setFriction_1: Wg,
            _emscripten_bind_btDispatcherInfo_set_m_useEpa_1: xg,
            _emscripten_bind_btCollisionDispatcher_getNumManifolds_0: Tj,
            _emscripten_bind_btWheelInfo_set_m_bIsFrontWheel_1: am,
            _emscripten_bind_ClosestRayResultCallback___destroy___0: fl,
            _emscripten_bind_ClosestConvexResultCallback_get_m_convexFromWorld_0: uk,
            _emscripten_bind_btCylinderShapeX_setMargin_1: Vo,
            _emscripten_bind_btQuadWord_w_0: Hf,
            _emscripten_bind_btGhostObject_setCcdMotionThreshold_1: Bf,
            _emscripten_bind_btPairCachingGhostObject_getCollisionFlags_0: Zg,
            _emscripten_bind_btBvhTriangleMeshShape_calculateLocalInertia_2: bg,
            _emscripten_bind_btCompoundShape_getNumChildShapes_0: lk,
            _emscripten_bind_btGhostObject_btGhostObject_0: gf,
            _emscripten_bind_ClosestConvexResultCallback_ClosestConvexResultCallback_2: sk,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingFactor_1: Fh,
            _emscripten_bind_btManifoldPoint_set_m_localPointA_1: Lh,
            _emscripten_bind_btCollisionObject_setCollisionShape_1: od,
            _emscripten_bind_btWheelInfo___destroy___0: dm,
            _emscripten_bind_btTransform_setRotation_1: ip,
            _emscripten_bind_btPairCachingGhostObject_getNumOverlappingObjects_0: dh,
            _emscripten_bind_btPoint2PointConstraint_enableFeedback_1: Fi,
            _emscripten_bind_btQuadWord_setZ_1: Kf,
            _emscripten_bind_btAxisSweep3_btAxisSweep3_2: Gg,
            _emscripten_bind_btAxisSweep3_btAxisSweep3_3: Hg,
            _emscripten_bind_btBoxShape_calculateLocalInertia_2: Qj,
            _emscripten_bind_btVector3_setY_1: af,
            _emscripten_bind_btAxisSweep3_btAxisSweep3_4: Ig,
            _emscripten_bind_btAxisSweep3_btAxisSweep3_5: Jg,
            _emscripten_bind_btQuadWord_setX_1: If,
            _emscripten_bind_btDefaultMotionState_set_m_graphicsWorldTrans_1: Pk,
            _emscripten_bind_btRigidBody_isActive_0: Ho,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalLinearDampingThresholdSqr_0: Ah,
            _emscripten_bind_btVehicleTuning_set_m_suspensionStiffness_1: Yj,
            _emscripten_bind_btOverlappingPairCache___destroy___0: Wm,
            _emscripten_bind_btConstraintSetting___destroy___0: yn,
            _emscripten_bind_btRaycastVehicle___destroy___0: yp,
            _emscripten_bind_btPersistentManifold_getBody0_0: Hj,
            _emscripten_bind_btConeShapeX_btConeShapeX_2: oj,
            _emscripten_bind_btConeTwistConstraint_enableFeedback_1: dj,
            _emscripten_bind_btCapsuleShapeZ_setLocalScaling_1: Al,
            _emscripten_bind_ClosestConvexResultCallback_get_m_closestHitFraction_0: Gk,
            _emscripten_bind_btSliderConstraint_setUpperLinLimit_1: Oi,
            _emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_2: Vi,
            _emscripten_bind_btConcaveShape___destroy___0: ud,
            _emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_4: Wi,
            _emscripten_bind_btQuaternion_x_0: ol,
            _emscripten_bind_LocalConvexResult_set_m_hitNormalLocal_1: Yn,
            _emscripten_bind_btConcaveShape_setLocalScaling_1: sd,
            _emscripten_bind_btDiscreteDynamicsWorld_getDispatchInfo_0: ji,
            _emscripten_bind_btConeShapeX_setLocalScaling_1: pj,
            _emscripten_bind_btCylinderShapeZ_setLocalScaling_1: bp,
            _emscripten_bind_btConvexHullShape_btConvexHullShape_0: yj,
            _emscripten_bind_btWheelInfo_set_m_maxSuspensionForce_1: Wl,
            _emscripten_bind_btConstraintSetting_get_m_damping_0: un,
            _emscripten_bind_btGhostObject___destroy___0: Df,
            _emscripten_bind_btGhostObject_setContactProcessingThreshold_1: mf,
            _emscripten_bind_btCollisionWorld_getBroadphase_0: Cd,
            _emscripten_bind_btContactSolverInfo_set_m_splitImpulse_1: Rm,
            _emscripten_bind_btDefaultMotionState_btDefaultMotionState_2: Lk,
            _emscripten_bind_btDefaultMotionState_btDefaultMotionState_0: Jk,
            _emscripten_bind_btDefaultMotionState_btDefaultMotionState_1: Kk,
            _emscripten_bind_btCompoundShape_getChildShape_1: mk,
            _emscripten_bind_btKinematicCharacterController_canJump_0: Cm,
            _emscripten_bind_btDiscreteDynamicsWorld_addAction_1: qi,
            _emscripten_bind_btRaycastVehicle_btRaycastVehicle_3: np,
            _emscripten_bind_btMotionState_setWorldTransform_1: ie,
            _emscripten_bind_btCylinderShape_setLocalScaling_1: Qf,
            _emscripten_bind_btPairCachingGhostObject_getWorldTransform_0: Yg,
            _emscripten_bind_btCompoundShape_calculateLocalInertia_2: qk,
            _emscripten_bind_btCollisionWorld_getDispatchInfo_0: yd,
            _emscripten_bind_btRigidBody_setCollisionShape_1: Qo,
            _emscripten_bind_btConeShapeX___destroy___0: rj,
            _emscripten_bind_btCollisionObject_getCollisionFlags_0: ld,
            _emscripten_bind_btDispatcherInfo_set_m_enableSatConvex_1: tg,
            _emscripten_bind_btConeTwistConstraint_enableMotor_1: _i,
            _emscripten_bind_btWheelInfo_set_m_wheelsDampingCompression_1: Ql,
            _emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_4: sm,
            _emscripten_bind_btPairCachingGhostObject_setRestitution_1: Vg,
            _emscripten_bind_btBroadphaseInterface___destroy___0: Vh,
            _emscripten_bind_btSliderConstraint_getBreakingImpulseThreshold_0: Si,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDampingFactor_1: zh,
            _emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_3: rm,
            _emscripten_bind_btCollisionObject_setContactProcessingThreshold_1: ad,
            _emscripten_bind_btCompoundShape___destroy___0: rk,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingFactor_0: Eh,
            _emscripten_bind_btCapsuleShapeX_setMargin_1: hl,
            _emscripten_bind_btSequentialImpulseConstraintSolver___destroy___0: hg,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalLinearDampingThresholdSqr_1: Bh,
            _emscripten_bind_btRigidBody_getCollisionFlags_0: No,
            _emscripten_bind_btCollisionShape_setLocalScaling_1: Xc,
            _emscripten_bind_btRigidBody_applyTorque_1: lo,
            _emscripten_bind_LocalConvexResult_get_m_hitCollisionObject_0: Tn,
            _emscripten_bind_btMatrix3x3_setEulerZYX_3: Uf,
            _emscripten_bind_btDispatcherInfo_get_m_convexConservativeDistanceThreshold_0: Cg,
            _emscripten_bind_ClosestRayResultCallback_get_m_hitNormalWorld_0: Xk,
            _emscripten_bind_btRigidBody_setMotionState_1: xo,
            _emscripten_bind_RayResultCallback_get_m_collisionFilterMask_0: Qe,
            _emscripten_bind_btCollisionWorld_getDispatcher_0: vd,
            _emscripten_bind_btCollisionObject_setRollingFriction_1: jd,
            _emscripten_bind_RayResultCallback_set_m_collisionFilterGroup_1: Pe,
            _emscripten_bind_btTriangleMesh_btTriangleMesh_1: tj,
            _i64Subtract: Uq,
            _emscripten_bind_btCylinderShapeX_getMargin_0: Wo,
            _emscripten_bind_btRigidBody_setDamping_2: io,
            _emscripten_bind_btRigidBody_btRigidBody_1: eo,
            _emscripten_bind_btGhostObject_setCollisionFlags_1: yf,
            _emscripten_bind_btMatrix3x3_getRotation_1: Vf,
            _emscripten_bind_btConeTwistConstraint_setMaxMotorImpulse_1: $i,
            _emscripten_bind_btPersistentManifold_getNumContacts_0: Jj,
            _emscripten_bind_btCylinderShapeX_setLocalScaling_1: Xo,
            _emscripten_bind_btDbvtBroadphase_btDbvtBroadphase_0: dg,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDamping_0: wh,
            _emscripten_bind_btCompoundShape_setLocalScaling_1: pk,
            _emscripten_bind_btOverlappingPairCallback___destroy___0: co,
            _emscripten_bind_btManifoldPoint_get_m_positionWorldOnB_0: Oh,
            _emscripten_bind_btCylinderShape_calculateLocalInertia_2: Rf,
            _emscripten_bind_btPairCachingGhostObject_setCcdSweptSphereRadius_1: ch,
            _emscripten_bind_btHingeConstraint_enableAngularMotor_3: mn,
            _emscripten_bind_btRigidBody_setContactProcessingThreshold_1: Co,
            _emscripten_bind_btRigidBody_getLinearVelocity_0: so,
            _emscripten_bind_btRigidBody_applyImpulse_2: po,
            _emscripten_bind_btConcaveShape_calculateLocalInertia_2: td,
            _emscripten_bind_btRigidBody_setWorldTransform_1: Po,
            _emscripten_bind_btRigidBody_setAngularVelocity_1: vo,
            _emscripten_bind_btCapsuleShape___destroy___0: Pd,
            _emscripten_bind_ContactResultCallback_addSingleResult_7: re,
            _emscripten_bind_btTriangleMeshShape_calculateLocalInertia_2: ue,
            _free: Cq,
            _emscripten_bind_btPairCachingGhostObject_setContactProcessingThreshold_1: Og,
            _emscripten_bind_btGeneric6DofConstraint_setLinearUpperLimit_1: Td,
            _emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterMask_0: bl,
            _emscripten_bind_RayResultCallback_hasHit_0: Ne,
            _bitshift64Shl: Yq,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingThresholdSqr_0: Ch,
            _emscripten_bind_btRaycastVehicle_getWheelTransformWS_1: qp,
            _emscripten_bind_ClosestConvexResultCallback_get_m_convexToWorld_0: wk,
            _emscripten_bind_btWheelInfo_get_m_frictionSlip_0: Hl,
            _emscripten_bind_btConeShapeZ_setLocalScaling_1: lj,
            _emscripten_bind_btPairCachingGhostObject_setActivationState_1: Pg,
            _emscripten_bind_btGeneric6DofSpringConstraint___destroy___0: Rn,
            _emscripten_bind_btRaycastVehicle_getNumWheels_0: tp,
            _emscripten_bind_btVehicleTuning_set_m_maxSuspensionTravelCm_1: ck,
            _emscripten_bind_btGhostObject_setRollingFriction_1: vf,
            _emscripten_bind_btCylinderShapeZ_btCylinderShapeZ_1: _o,
            _emscripten_bind_btPoint2PointConstraint_set_m_setting_1: Ji,
            _emscripten_bind_btCompoundShape_btCompoundShape_0: hk,
            _emscripten_bind_btCompoundShape_btCompoundShape_1: ik,
            _emscripten_bind_btOverlappingPairCache_setInternalGhostPairCallback_1: Vm,
            _emscripten_bind_btStaticPlaneShape_btStaticPlaneShape_2: Mm,
            _emscripten_bind_btSphereShape_getMargin_0: Zm,
            _emscripten_bind_btDispatcherInfo_get_m_useContinuous_0: qg,
            _emscripten_bind_btRigidBody_updateInertiaTensor_0: ro,
            _emscripten_bind_btPairCachingGhostObject_setAnisotropicFriction_2: Mg,
            _emscripten_bind_btCollisionObject_getWorldTransform_0: kd,
            _emscripten_bind_ClosestRayResultCallback_hasHit_0: Sk,
            _emscripten_bind_btDispatcherInfo_get_m_useConvexConservativeDistanceUtil_0: Ag,
            _emscripten_bind_btCompoundShape_addChildShape_2: jk,
            _emscripten_bind_btDispatcher___destroy___0: ye,
            _emscripten_bind_btVehicleTuning_get_m_suspensionCompression_0: Zj,
            _emscripten_bind_btDiscreteDynamicsWorld___destroy___0: ti,
            _emscripten_bind_btConvexShape___destroy___0: qe,
            _emscripten_bind_btCapsuleShapeX_setLocalScaling_1: jl,
            _emscripten_bind_btCollisionObject_setRestitution_1: hd,
            _emscripten_bind_btRigidBody_applyCentralForce_1: no,
            _emscripten_bind_LocalConvexResult_get_m_hitFraction_0: $n,
            _emscripten_bind_btDispatcherInfo_get_m_enableSPU_0: ug,
            _emscripten_bind_btQuaternion_w_0: rl,
            _emscripten_bind_ConvexResultCallback_get_m_collisionFilterGroup_0: ae,
            _emscripten_bind_btTransform_getRotation_0: kp,
            _emscripten_bind_btHingeConstraint_btHingeConstraint_6: hn,
            _emscripten_bind_btHingeConstraint_btHingeConstraint_7: jn,
            _emscripten_bind_LocalConvexResult_get_m_hitNormalLocal_0: Xn,
            _emscripten_bind_btHingeConstraint_btHingeConstraint_5: gn,
            _emscripten_bind_btHingeConstraint_btHingeConstraint_2: dn,
            _emscripten_bind_btHingeConstraint_btHingeConstraint_3: en,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingThresholdSqr_1: Dh,
            _emscripten_bind_btBoxShape_setMargin_1: Nj,
            _emscripten_bind_ClosestConvexResultCallback_get_m_hitNormalWorld_0: yk,
            _emscripten_bind_btTypedConstraint___destroy___0: Jd,
            _emscripten_bind_btCylinderShapeX_btCylinderShapeX_1: Uo,
            _emscripten_bind_btGeneric6DofSpringConstraint_setAngularUpperLimit_1: Nn,
            _emscripten_bind_btConeTwistConstraint_setDamping_1: Zi,
            _emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_1: Zh,
            _emscripten_bind_btVector4_length_0: im,
            _emscripten_bind_btSphereShape_btSphereShape_1: Xm,
            _emscripten_bind_btWheelInfo_get_m_wheelsSuspensionForce_0: Zl,
            _emscripten_bind_btQuaternion_y_0: pl,
            _emscripten_bind_btCollisionWorld_addCollisionObject_1: zd,
            _emscripten_bind_btCollisionWorld_addCollisionObject_2: Ad,
            _emscripten_bind_btCollisionWorld_addCollisionObject_3: Bd,
            _emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterGroup_1: Dk,
            _emscripten_bind_btConeTwistConstraint_setBreakingImpulseThreshold_1: fj,
            _emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterGroup_0: Ck,
            _emscripten_bind_btCapsuleShape_setMargin_1: Ld,
            _emscripten_bind_btDefaultVehicleRaycaster_btDefaultVehicleRaycaster_1: Dl,
            _emscripten_bind_ConcreteContactResultCallback_addSingleResult_7: Yf,
            _emscripten_bind_btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver_0: gg,
            _emscripten_bind_btActionInterface___destroy___0: Tf,
            _emscripten_bind_btDefaultMotionState_setWorldTransform_1: Nk,
            _emscripten_bind_btGeneric6DofSpringConstraint_setDamping_2: Jn,
            _emscripten_bind_RayResultCallback_get_m_collisionObject_0: Se,
            _emscripten_bind_btPoint2PointConstraint_getPivotInA_0: Di,
            _emscripten_bind_btGeneric6DofSpringConstraint_setStiffness_2: In,
            _emscripten_bind_btVector4_setY_1: nm,
            _emscripten_bind_btContactSolverInfo___destroy___0: Um,
            _emscripten_bind_btCompoundShape_setMargin_1: nk,
            _emscripten_bind_ClosestConvexResultCallback___destroy___0: Ik,
            _emscripten_bind_btDynamicsWorld_addCollisionObject_1: Ge,
            _emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterMask_0: Ek,
            _emscripten_bind_btDynamicsWorld_addCollisionObject_3: Ie,
            _emscripten_bind_btDynamicsWorld_addCollisionObject_2: He,
            _emscripten_bind_btDiscreteDynamicsWorld_getDispatcher_0: gi,
            _emscripten_bind_btWheelInfo_get_m_maxSuspensionTravelCm_0: Xl,
            _emscripten_bind_btVector4_op_mul_1: pm,
            _emscripten_bind_btCylinderShape_btCylinderShape_1: Nf,
            _emscripten_bind_btVector3___destroy___0: ef,
            _emscripten_bind_btRigidBody_setAngularFactor_1: yo,
            _emscripten_bind_btCylinderShapeZ_calculateLocalInertia_2: cp,
            _emscripten_bind_btWheelInfo_set_m_steering_1: Ul,
            _emscripten_bind_btMotionState_getWorldTransform_1: he,
            _emscripten_bind_btDynamicsWorld_getSolverInfo_0: Be,
            _emscripten_bind_btDynamicsWorld_getBroadphase_0: Je,
            _emscripten_bind_btDispatcherInfo_set_m_convexConservativeDistanceThreshold_1: Dg,
            _emscripten_bind_btVector3_x_0: Ye,
            ___cxa_is_pointer_type: xq,
            _emscripten_bind_btWheelInfo_get_m_wheelsDampingCompression_0: Pl,
            _emscripten_bind_btCollisionObject_getCollisionShape_0: $c,
            _emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_4: hh,
            _emscripten_bind_btManifoldPoint___destroy___0: Uh,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_rollingFriction_1: ph,
            _emscripten_bind_btVector3_z_0: _e,
            _emscripten_bind_btHingeConstraint_getBreakingImpulseThreshold_0: on,
            _emscripten_bind_btGhostObject_setRestitution_1: tf,
            _emscripten_bind_btDefaultCollisionConstructionInfo___destroy___0: cn,
            _emscripten_bind_btCollisionObject_setFriction_1: id,
            _emscripten_bind_btDefaultCollisionConfiguration___destroy___0: jj,
            _emscripten_bind_btRigidBody_setMassProps_2: jo,
            _emscripten_bind_btVector3_setValue_3: cf,
            _emscripten_bind_btPairCachingGhostObject_setCcdMotionThreshold_1: bh,
            _emscripten_bind_btGhostObject_getCollisionFlags_0: xf,
            _emscripten_bind_btCapsuleShapeX___destroy___0: ll,
            _emscripten_bind_btHingeConstraint_setLimit_4: kn,
            _emscripten_bind_btHingeConstraint_setLimit_5: ln,
            _emscripten_bind_btWheelInfo_set_m_maxSuspensionTravelCm_1: Yl,
            _emscripten_bind_btWheelInfo_set_m_wheelsSuspensionForce_1: _l,
            _emscripten_bind_btKinematicCharacterController_setJumpSpeed_1: Am,
            _emscripten_bind_btTypedConstraint_getBreakingImpulseThreshold_0: Hd,
            _emscripten_bind_btGhostObject_getCollisionShape_0: lf,
            _emscripten_bind_btCollisionObject_setAnisotropicFriction_2: _c,
            _emscripten_bind_btBoxShape___destroy___0: Rj,
            _emscripten_bind_btPersistentManifold_getContactPoint_1: Kj,
            _emscripten_bind_btGeneric6DofSpringConstraint_getBreakingImpulseThreshold_0: Pn,
            _emscripten_bind_ConvexResultCallback_set_m_collisionFilterGroup_1: be,
            _emscripten_bind_btGhostObject_activate_0: pf,
            _emscripten_bind_btGhostObject_activate_1: qf,
            _emscripten_bind_btGeneric6DofSpringConstraint_enableSpring_2: Hn,
            _emscripten_bind_btManifoldPoint_getPositionWorldOnB_0: Ih,
            _emscripten_bind_btManifoldPoint_get_m_positionWorldOnA_0: Qh,
            _emscripten_bind_btGeneric6DofSpringConstraint_enableFeedback_1: On,
            _emscripten_bind_btSphereShape_setMargin_1: Ym,
            _emscripten_bind_btConeShapeZ_btConeShapeZ_2: kj,
            _emscripten_bind_btPairCachingGhostObject_setRollingFriction_1: Xg,
            _emscripten_bind_btSliderConstraint_setUpperAngLimit_1: Qi,
            _emscripten_bind_btDynamicsWorld_contactPairTest_3: Le,
            _emscripten_bind_btCollisionWorld_getPairCache_0: xd,
            _emscripten_bind_btConeTwistConstraint_setMotorTarget_1: bj,
            _emscripten_bind_ClosestConvexResultCallback_set_m_convexFromWorld_1: vk,
            _emscripten_bind_btWheelInfo_set_m_rollInfluence_1: Kl,
            _emscripten_bind_btGeneric6DofConstraint_setBreakingImpulseThreshold_1: Yd,
            _emscripten_bind_btDefaultCollisionConstructionInfo_btDefaultCollisionConstructionInfo_0: bn,
            _emscripten_bind_btGhostObject_forceActivationState_1: of,
            _emscripten_bind_ConcreteContactResultCallback_ConcreteContactResultCallback_0: Xf,
            _emscripten_bind_VoidPtr___destroy___0: fg,
            _emscripten_bind_btSliderConstraint_setLowerAngLimit_1: Pi,
            _emscripten_bind_btConeShape_btConeShape_2: ke,
            _emscripten_bind_ClosestRayResultCallback_get_m_rayFromWorld_0: Tk,
            _emscripten_bind_btRaycastVehicle_getRigidBody_0: up,
            _emscripten_bind_RayResultCallback_get_m_collisionFilterGroup_0: Oe,
            _emscripten_bind_btWheelInfo_get_m_steering_0: Tl,
            _emscripten_bind_btPoint2PointConstraint_get_m_setting_0: Ii,
            _emscripten_bind_btSliderConstraint___destroy___0: Ui,
            _emscripten_bind_btCollisionShape___destroy___0: Zc,
            _emscripten_bind_ConvexResultCallback_get_m_closestHitFraction_0: ee,
            _emscripten_bind_btDispatcherInfo_get_m_dispatchFunc_0: mg,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_rollingFriction_0: oh,
            _emscripten_bind_btPairCachingGhostObject_setCollisionShape_1: ah,
            _emscripten_bind_btKinematicCharacterController_warp_1: wm,
            _emscripten_bind_btAxisSweep3___destroy___0: Kg,
            _emscripten_bind_btTriangleMesh___destroy___0: xj,
            _emscripten_bind_btKinematicCharacterController_preStep_1: xm,
            _emscripten_bind_btRaycastVehicle_applyEngineForce_2: op,
            _emscripten_bind_btRaycastVehicle_setBrake_2: wp,
            _emscripten_bind_ConcreteContactResultCallback___destroy___0: Zf,
            _emscripten_bind_btCollisionObject___destroy___0: rd,
            _emscripten_bind_btVehicleTuning_set_m_suspensionDamping_1: ak,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_linearSleepingThreshold_1: th,
            _emscripten_bind_btConeTwistConstraint_setMotorTargetInConstraintSpace_1: cj,
            _emscripten_bind_btDispatcherInfo_set_m_timeStep_1: jg,
            _emscripten_bind_btVector3_btVector3_3: We,
            _emscripten_bind_btVector3_btVector3_0: Ve,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_friction_1: nh,
            _emscripten_bind_btDiscreteDynamicsWorld_getGravity_0: Yh,
            _emscripten_bind_ClosestConvexResultCallback_get_m_hitPointWorld_0: Ak,
            _emscripten_bind_btVehicleTuning_get_m_suspensionDamping_0: $j,
            _emscripten_bind_btConeTwistConstraint___destroy___0: gj,
            _emscripten_bind_btQuadWord___destroy___0: Mf,
            _emscripten_bind_ClosestRayResultCallback_set_m_rayFromWorld_1: Uk,
            _emscripten_bind_btRigidBody_setCenterOfMassTransform_1: go,
            _emscripten_bind_btSliderConstraint_setBreakingImpulseThreshold_1: Ti,
            _emscripten_bind_btGhostObject_setAnisotropicFriction_2: kf,
            _emscripten_bind_btConstraintSolver___destroy___0: En,
            _emscripten_bind_btDbvtBroadphase___destroy___0: eg,
            _emscripten_bind_btCapsuleShape_btCapsuleShape_2: Kd,
            _emscripten_bind_btTypedConstraint_enableFeedback_1: Gd,
            _emscripten_bind_btCapsuleShape_setLocalScaling_1: Nd,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDampingFactor_0: yh,
            _emscripten_bind_btRigidBody_setAnisotropicFriction_2: Ao,
            _emscripten_bind_btTriangleMeshShape_setLocalScaling_1: te,
            _emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_3: gh,
            _emscripten_bind_ConvexResultCallback_set_m_closestHitFraction_1: fe,
            _emscripten_bind_btPersistentManifold_btPersistentManifold_0: Gj,
            _emscripten_bind_ConvexResultCallback_get_m_collisionFilterMask_0: ce,
            _emscripten_bind_ClosestRayResultCallback_ClosestRayResultCallback_2: Rk,
            _emscripten_bind_btVector4___destroy___0: qm,
            _emscripten_bind_btPairCachingGhostObject_isKinematicObject_0: Ug,
            _emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterMask_1: cl,
            _i64Add: Vq,
            _emscripten_bind_btStaticPlaneShape_calculateLocalInertia_2: Om,
            _emscripten_bind_btVehicleTuning_set_m_maxSuspensionForce_1: gk,
            _emscripten_bind_btCollisionObject_setCcdMotionThreshold_1: pd,
            _emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_0: hj,
            _emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_1: ij,
            _emscripten_bind_btQuaternion_setW_1: vl,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_angularSleepingThreshold_0: uh,
            _emscripten_bind_btPoint2PointConstraint_getPivotInB_0: Ei,
            _emscripten_bind_btKinematicCharacterController_playerStep_2: ym,
            _emscripten_bind_btDispatcherInfo___destroy___0: Eg,
            _emscripten_bind_btCapsuleShape_getMargin_0: Md,
            _emscripten_bind_btCylinderShape_getMargin_0: Pf,
            _emscripten_bind_btStaticPlaneShape_setLocalScaling_1: Nm,
            _emscripten_bind_btConvexTriangleMeshShape_calculateLocalInertia_2: xi,
            _emscripten_bind_btQuaternion___destroy___0: wl,
            _emscripten_bind_btGhostObject_getWorldTransform_0: wf,
            _emscripten_bind_btDiscreteDynamicsWorld_getPairCache_0: ii,
            _emscripten_bind_LocalConvexResult_set_m_hitFraction_1: ao,
            _emscripten_bind_btCapsuleShapeZ_calculateLocalInertia_2: Bl,
            _emscripten_bind_btDispatcherInfo_get_m_timeStep_0: ig,
            _emscripten_bind_btVehicleTuning_set_m_suspensionCompression_1: _j,
            _emscripten_bind_btDynamicsWorld___destroy___0: Me,
            _emscripten_bind_btMotionState___destroy___0: je,
            _emscripten_bind_btCollisionObject_setCollisionFlags_1: md,
            _emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_1: ki,
            _emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_2: li,
            _emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_3: mi,
            _emscripten_bind_btWheelInfo_set_m_suspensionStiffness_1: Gl,
            _emscripten_bind_btConvexTriangleMeshShape___destroy___0: yi,
            _emscripten_bind_btDispatcher_getManifoldByIndexInternal_1: xe,
            _bitshift64Lshr: Zq,
            _emscripten_bind_LocalShapeInfo_set_m_triangleIndex_1: Cn,
            _emscripten_bind_btPairCachingGhostObject_setWorldTransform_1: $g,
            _emscripten_bind_btConeTwistConstraint_setAngularOnly_1: Yi,
            _emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_4: Ai,
            _emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_2: zi,
            _emscripten_bind_btGhostObject_getNumOverlappingObjects_0: hf,
            _emscripten_bind_btConeShapeX_calculateLocalInertia_2: qj,
            _emscripten_bind_btPairCachingGhostObject_getOverlappingObject_1: eh,
            _emscripten_bind_btRigidBodyConstructionInfo___destroy___0: Gh,
            _emscripten_bind_btRigidBody_getWorldTransform_0: Mo,
            _emscripten_bind_btPoint2PointConstraint_setPivotA_1: Bi,
            _emscripten_bind_ClosestConvexResultCallback_set_m_convexToWorld_1: xk,
            _memcpy: Wq,
            _emscripten_bind_btCapsuleShape_calculateLocalInertia_2: Od,
            _emscripten_bind_btVector3_y_0: Ze,
            _emscripten_bind_btVehicleTuning_get_m_maxSuspensionForce_0: fk,
            _emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_2: _f,
            _emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_3: $f,
            _emscripten_bind_LocalShapeInfo_get_m_triangleIndex_0: Bn,
            _emscripten_bind_btGhostObject_setCollisionShape_1: Af,
            _emscripten_bind_btDispatcherInfo_set_m_allowedCcdPenetration_1: zg,
            _emscripten_bind_btRigidBody_setRollingFriction_1: Lo,
            _emscripten_bind_btContactSolverInfo_set_m_splitImpulsePenetrationThreshold_1: Tm,
            _emscripten_bind_btDiscreteDynamicsWorld_setGravity_1: Xh,
            _emscripten_bind_btGhostObject_isActive_0: rf,
            _emscripten_bind_btVector4_z_0: lm,
            _emscripten_bind_btCollisionObject_forceActivationState_1: cd,
            _emscripten_bind_btKinematicCharacterController_onGround_0: Km,
            _emscripten_bind_btRaycastVehicle_getWheelInfo_1: vp,
            _emscripten_bind_btGeneric6DofConstraint_getBreakingImpulseThreshold_0: Xd,
            _emscripten_bind_btConeTwistConstraint_setLimit_2: Xi,
            _emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterMask_1: Fk,
            _emscripten_bind_btRigidBody___destroy___0: To,
            _emscripten_bind_btStridingMeshInterface___destroy___0: _d,
            _emscripten_bind_btRigidBody_setSleepingThresholds_2: ho,
            _emscripten_bind_btCollisionObject_setWorldTransform_1: nd,
            _emscripten_bind_LocalConvexResult_get_m_localShapeInfo_0: Vn,
            _emscripten_bind_btManifoldPoint_get_m_localPointA_0: Kh,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_linearDamping_0: ih,
            _emscripten_bind_btDispatcher_getNumManifolds_0: we,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_linearSleepingThreshold_0: sh,
            _emscripten_bind_btRigidBody_activate_1: Go,
            _emscripten_bind_btRigidBody_activate_0: Fo,
            _emscripten_bind_RayResultCallback___destroy___0: Ue,
            _emscripten_bind_btGhostObject_setActivationState_1: nf,
            _emscripten_bind_btCollisionWorld_contactPairTest_3: Ed,
            _emscripten_bind_btCylinderShapeX___destroy___0: Zo,
            _emscripten_bind_btManifoldPoint_getPositionWorldOnA_0: Hh,
            _emscripten_bind_LocalConvexResult_set_m_localShapeInfo_1: Wn,
            _emscripten_bind_btDispatcherInfo_set_m_stepCount_1: lg,
            _emscripten_bind_btVector4_x_0: jm,
            _emscripten_bind_btPairCachingGhostObject_setCollisionFlags_1: _g,
            _emscripten_bind_btRigidBody_getMotionState_0: wo,
            _emscripten_bind_btKinematicCharacterController_getGhostObject_0: Im,
            _emscripten_bind_btTriangleMeshShape___destroy___0: ve,
            _emscripten_bind_btKinematicCharacterController_setWalkDirection_1: um,
            _emscripten_bind_btDynamicsWorld_removeAction_1: Ae,
            _emscripten_bind_btRigidBodyConstructionInfo_get_m_restitution_0: qh,
            _emscripten_bind_btTransform_setIdentity_0: gp,
            _emscripten_bind_btManifoldPoint_set_m_normalWorldOnB_1: Th,
            _emscripten_bind_btKinematicCharacterController_getGravity_0: Fm,
            _emscripten_bind_btConeTwistConstraint_getBreakingImpulseThreshold_0: ej,
            _emscripten_bind_btGeneric6DofConstraint_setAngularLowerLimit_1: Ud,
            _emscripten_bind_btHingeConstraint_btHingeConstraint_4: fn,
            _emscripten_bind_LocalShapeInfo_get_m_shapePart_0: zn,
            _emscripten_bind_btConeShape_calculateLocalInertia_2: me,
            _emscripten_bind_btCylinderShapeX_calculateLocalInertia_2: Yo,
            _emscripten_bind_ConvexResultCallback_set_m_collisionFilterMask_1: de,
            _emscripten_bind_btSphereShape_setLocalScaling_1: _m,
            _emscripten_bind_btVector4_w_0: gm,
            _emscripten_bind_btManifoldPoint_get_m_normalWorldOnB_0: Sh,
            _emscripten_bind_btBvhTriangleMeshShape___destroy___0: cg,
            _emscripten_bind_LocalConvexResult_LocalConvexResult_5: Sn,
            _emscripten_bind_ClosestConvexResultCallback_set_m_closestHitFraction_1: Hk,
            _emscripten_bind_btDiscreteDynamicsWorld_removeConstraint_1: ci,
            _emscripten_bind_btVector4_y_0: km,
            _emscripten_bind_btGeneric6DofConstraint___destroy___0: Zd,
            _emscripten_bind_btVehicleTuning_get_m_maxSuspensionTravelCm_0: bk,
            _emscripten_bind_btConvexHullShape_addPoint_1: zj,
            _emscripten_bind_btConvexHullShape_addPoint_2: Aj,
            _emscripten_bind_btPoint2PointConstraint_getBreakingImpulseThreshold_0: Gi,
            _emscripten_bind_btTransform_getOrigin_0: jp,
            _emscripten_bind_btHingeConstraint___destroy___0: qn,
            _emscripten_bind_btHingeConstraint_enableFeedback_1: nn,
            _emscripten_bind_btConvexShape_calculateLocalInertia_2: pe,
            _memset: Xq,
            _emscripten_bind_btGeneric6DofConstraint_setLinearLowerLimit_1: Sd,
            _emscripten_bind_btConvexHullShape_setLocalScaling_1: Dj,
            _emscripten_bind_btTriangleMesh_btTriangleMesh_0: sj,
            _emscripten_bind_btPairCachingGhostObject_getCollisionShape_0: Ng,
            _emscripten_bind_btTriangleMesh_btTriangleMesh_2: uj,
            _emscripten_bind_btTransform___destroy___0: mp,
            _emscripten_bind_btWheelInfo_set_m_frictionSlip_1: Il,
            _emscripten_bind_btRigidBody_getCollisionShape_0: Bo,
            _emscripten_bind_btManifoldPoint_set_m_positionWorldOnA_1: Rh,
            _emscripten_bind_btWheelInfo_get_m_wheelsDampingRelaxation_0: Rl,
            _emscripten_bind_btManifoldPoint_get_m_localPointB_0: Mh,
            _emscripten_bind_btDiscreteDynamicsWorld_contactPairTest_3: pi,
            _emscripten_bind_btSliderConstraint_setLowerLinLimit_1: Ni,
            _emscripten_bind_btRigidBody_getAngularVelocity_0: to,
            _emscripten_bind_btCollisionObject_setCcdSweptSphereRadius_1: qd,
            _emscripten_bind_btWheelInfo_get_m_wheelsRadius_0: Nl,
            _emscripten_bind_btRigidBody_setLinearVelocity_1: uo,
            _emscripten_bind_btVehicleTuning_btVehicleTuning_0: Wj,
            _emscripten_bind_RayResultCallback_set_m_collisionObject_1: Te,
            _emscripten_bind_ClosestRayResultCallback_set_m_rayToWorld_1: Wk,
            _emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterGroup_0: $k,
            _emscripten_bind_btWheelInfo_set_m_wheelsDampingRelaxation_1: Sl,
            _emscripten_bind_btDynamicsWorld_addAction_1: ze,
            _emscripten_bind_btDiscreteDynamicsWorld_removeAction_1: ri,
            _emscripten_bind_btDefaultVehicleRaycaster___destroy___0: El,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_linearDamping_1: jh,
            _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDamping_1: xh,
            _emscripten_bind_btKinematicCharacterController_setFallSpeed_1: zm,
            _emscripten_bind_btRigidBody_setActivationState_1: Do,
            _emscripten_bind_ClosestConvexResultCallback_hasHit_0: tk,
            _emscripten_bind_btCapsuleShapeZ___destroy___0: Cl,
            _emscripten_bind_btWheelInfo_get_m_maxSuspensionForce_0: Vl,
            _emscripten_bind_ClosestRayResultCallback_get_m_collisionObject_0: dl,
            _emscripten_bind_btTriangleMesh_addTriangle_3: vj,
            _emscripten_bind_btGhostObject_getOverlappingObject_1: jf,
            _emscripten_bind_btTriangleMesh_addTriangle_4: wj,
            _emscripten_bind_btRigidBody_applyTorqueImpulse_1: oo,
            _emscripten_bind_btRigidBody_setCollisionFlags_1: Oo,
            _emscripten_bind_btWheelInfo_set_m_suspensionRestLength1_1: Ml,
            _emscripten_bind_btConeShape___destroy___0: ne,
            _emscripten_bind_btCapsuleShapeZ_btCapsuleShapeZ_2: xl,
            _emscripten_bind_btSliderConstraint_btSliderConstraint_5: Mi,
            _emscripten_bind_btSliderConstraint_btSliderConstraint_3: Li,
            _emscripten_bind_btDispatcherInfo_get_m_allowedCcdPenetration_0: yg,
            _emscripten_bind_btDynamicsWorld_convexSweepTest_5: Ke,
            _emscripten_bind_btRigidBody_forceActivationState_1: Eo,
            _emscripten_bind_btPoint2PointConstraint_setPivotB_1: Ci,
            _emscripten_bind_btManifoldPoint_getDistance_0: Jh,
            _emscripten_bind_btGhostPairCallback___destroy___0: Ap,
            _emscripten_bind_btKinematicCharacterController_getMaxSlope_0: Hm,
            _emscripten_bind_btSliderConstraint_enableFeedback_1: Ri,
            _emscripten_bind_btRaycastVehicle_addWheel_7: sp,
            _emscripten_bind_ClosestRayResultCallback_set_m_hitNormalWorld_1: Yk,
            _emscripten_bind_ContactResultCallback___destroy___0: se,
            _emscripten_bind_btStaticPlaneShape___destroy___0: Pm,
            _emscripten_bind_btQuaternion_z_0: ql,
            _emscripten_bind_btBoxShape_setLocalScaling_1: Pj,
            _emscripten_bind_btConeShapeZ___destroy___0: nj,
            _emscripten_bind_btDynamicsWorld_getPairCache_0: Ee,
            _emscripten_bind_btDiscreteDynamicsWorld_convexSweepTest_5: oi,
            _emscripten_bind_btKinematicCharacterController_setVelocityForTimeInterval_2: vm,
            _emscripten_bind_btVector4_btVector4_0: em,
            _emscripten_bind_btDispatcherInfo_get_m_enableSatConvex_0: sg,
            _emscripten_bind_btVector4_btVector4_4: fm,
            _emscripten_bind_btKinematicCharacterController___destroy___0: Lm,
            _emscripten_bind_btGeneric6DofSpringConstraint_setLinearLowerLimit_1: Kn,
            _emscripten_bind_LocalConvexResult_set_m_hitCollisionObject_1: Un,
            _emscripten_bind_btConstraintSetting_btConstraintSetting_0: rn,
            _emscripten_bind_btGeneric6DofSpringConstraint_setAngularLowerLimit_1: Mn,
            _emscripten_bind_btDiscreteDynamicsWorld_rayTest_3: hi,
            _emscripten_bind_btContactSolverInfo_get_m_splitImpulse_0: Qm,
            _emscripten_bind_btGhostPairCallback_btGhostPairCallback_0: zp,
            _emscripten_bind_btKinematicCharacterController_setMaxJumpHeight_1: Bm,
            _emscripten_bind_btPairCachingGhostObject_isActive_0: Tg,
            _emscripten_bind_btVehicleTuning_get_m_frictionSlip_0: dk,
            runPostSets: Tq,
            stackAlloc: Oc,
            stackSave: Pc,
            stackRestore: Qc,
            establishStackSpace: Rc,
            setThrew: Sc,
            setTempRet0: Vc,
            getTempRet0: Wc,
            dynCall_vi: hr,
            dynCall_iiii: ir,
            dynCall_vidi: jr,
            dynCall_viiiiii: kr,
            dynCall_viiiii: lr,
            dynCall_diiiiiiii: mr,
            dynCall_vid: nr,
            dynCall_di: or,
            dynCall_iidid: pr,
            dynCall_vii: qr,
            dynCall_ii: rr,
            dynCall_viii: sr,
            dynCall_v: tr,
            dynCall_viid: ur,
            dynCall_iiiii: vr,
            dynCall_viiii: wr,
            dynCall_iii: xr,
            dynCall_diii: yr
        };
    }(Module.asmGlobalArg, Module.asmLibraryArg, buffer), _emscripten_bind_btCylinderShape___destroy___0 = Module._emscripten_bind_btCylinderShape___destroy___0 = asm._emscripten_bind_btCylinderShape___destroy___0, _emscripten_bind_btGeneric6DofConstraint_enableFeedback_1 = Module._emscripten_bind_btGeneric6DofConstraint_enableFeedback_1 = asm._emscripten_bind_btGeneric6DofConstraint_enableFeedback_1, _emscripten_bind_btDispatcherInfo_get_m_enableSPU_0 = Module._emscripten_bind_btDispatcherInfo_get_m_enableSPU_0 = asm._emscripten_bind_btDispatcherInfo_get_m_enableSPU_0, _emscripten_bind_btDispatcherInfo_set_m_useContinuous_1 = Module._emscripten_bind_btDispatcherInfo_set_m_useContinuous_1 = asm._emscripten_bind_btDispatcherInfo_set_m_useContinuous_1, _emscripten_bind_btCollisionObject_isActive_0 = Module._emscripten_bind_btCollisionObject_isActive_0 = asm._emscripten_bind_btCollisionObject_isActive_0, _emscripten_bind_btVehicleTuning_set_m_frictionSlip_1 = Module._emscripten_bind_btVehicleTuning_set_m_frictionSlip_1 = asm._emscripten_bind_btVehicleTuning_set_m_frictionSlip_1, _emscripten_bind_btDiscreteDynamicsWorld_btDiscreteDynamicsWorld_4 = Module._emscripten_bind_btDiscreteDynamicsWorld_btDiscreteDynamicsWorld_4 = asm._emscripten_bind_btDiscreteDynamicsWorld_btDiscreteDynamicsWorld_4, _emscripten_bind_btCapsuleShapeX_getMargin_0 = Module._emscripten_bind_btCapsuleShapeX_getMargin_0 = asm._emscripten_bind_btCapsuleShapeX_getMargin_0, _emscripten_bind_btCompoundShape_getMargin_0 = Module._emscripten_bind_btCompoundShape_getMargin_0 = asm._emscripten_bind_btCompoundShape_getMargin_0, _emscripten_bind_btContactSolverInfo___destroy___0 = Module._emscripten_bind_btContactSolverInfo___destroy___0 = asm._emscripten_bind_btContactSolverInfo___destroy___0, _emscripten_bind_btWheelInfo_get_m_rollInfluence_0 = Module._emscripten_bind_btWheelInfo_get_m_rollInfluence_0 = asm._emscripten_bind_btWheelInfo_get_m_rollInfluence_0, _emscripten_bind_btTypedConstraint_setBreakingImpulseThreshold_1 = Module._emscripten_bind_btTypedConstraint_setBreakingImpulseThreshold_1 = asm._emscripten_bind_btTypedConstraint_setBreakingImpulseThreshold_1, _emscripten_bind_btQuaternion_setX_1 = Module._emscripten_bind_btQuaternion_setX_1 = asm._emscripten_bind_btQuaternion_setX_1, _emscripten_bind_btCylinderShapeZ_getMargin_0 = Module._emscripten_bind_btCylinderShapeZ_getMargin_0 = asm._emscripten_bind_btCylinderShapeZ_getMargin_0, _emscripten_bind_btDispatcherInfo_get_m_timeOfImpact_0 = Module._emscripten_bind_btDispatcherInfo_get_m_timeOfImpact_0 = asm._emscripten_bind_btDispatcherInfo_get_m_timeOfImpact_0, _emscripten_bind_btQuaternion_setZ_1 = Module._emscripten_bind_btQuaternion_setZ_1 = asm._emscripten_bind_btQuaternion_setZ_1, _emscripten_bind_LocalConvexResult_get_m_hitNormalLocal_0 = Module._emscripten_bind_LocalConvexResult_get_m_hitNormalLocal_0 = asm._emscripten_bind_LocalConvexResult_get_m_hitNormalLocal_0, _emscripten_bind_btKinematicCharacterController_setMaxSlope_1 = Module._emscripten_bind_btKinematicCharacterController_setMaxSlope_1 = asm._emscripten_bind_btKinematicCharacterController_setMaxSlope_1, _emscripten_bind_btQuadWord_z_0 = Module._emscripten_bind_btQuadWord_z_0 = asm._emscripten_bind_btQuadWord_z_0, _emscripten_bind_btTransform_setIdentity_0 = Module._emscripten_bind_btTransform_setIdentity_0 = asm._emscripten_bind_btTransform_setIdentity_0, _emscripten_bind_btWheelInfo_get_m_suspensionRestLength1_0 = Module._emscripten_bind_btWheelInfo_get_m_suspensionRestLength1_0 = asm._emscripten_bind_btWheelInfo_get_m_suspensionRestLength1_0, _emscripten_bind_btWheelInfo_get_m_suspensionStiffness_0 = Module._emscripten_bind_btWheelInfo_get_m_suspensionStiffness_0 = asm._emscripten_bind_btWheelInfo_get_m_suspensionStiffness_0, _emscripten_bind_btRigidBodyConstructionInfo_get_m_angularDamping_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_angularDamping_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_angularDamping_0, _emscripten_bind_btCollisionDispatcher___destroy___0 = Module._emscripten_bind_btCollisionDispatcher___destroy___0 = asm._emscripten_bind_btCollisionDispatcher___destroy___0, _emscripten_bind_btRigidBody_applyCentralImpulse_1 = Module._emscripten_bind_btRigidBody_applyCentralImpulse_1 = asm._emscripten_bind_btRigidBody_applyCentralImpulse_1, _emscripten_bind_btConvexHullShape_getMargin_0 = Module._emscripten_bind_btConvexHullShape_getMargin_0 = asm._emscripten_bind_btConvexHullShape_getMargin_0, _emscripten_bind_btDefaultMotionState_getWorldTransform_1 = Module._emscripten_bind_btDefaultMotionState_getWorldTransform_1 = asm._emscripten_bind_btDefaultMotionState_getWorldTransform_1, _emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_1 = Module._emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_1 = asm._emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_1, _emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_3 = Module._emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_3 = asm._emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_3, _emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_2 = Module._emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_2 = asm._emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_2, _emscripten_bind_btVector3_op_mul_1 = Module._emscripten_bind_btVector3_op_mul_1 = asm._emscripten_bind_btVector3_op_mul_1, _emscripten_bind_btDynamicsWorld_rayTest_3 = Module._emscripten_bind_btDynamicsWorld_rayTest_3 = asm._emscripten_bind_btDynamicsWorld_rayTest_3, _emscripten_bind_btRaycastVehicle_updateWheelTransform_2 = Module._emscripten_bind_btRaycastVehicle_updateWheelTransform_2 = asm._emscripten_bind_btRaycastVehicle_updateWheelTransform_2, _emscripten_bind_btQuadWord_x_0 = Module._emscripten_bind_btQuadWord_x_0 = asm._emscripten_bind_btQuadWord_x_0, _emscripten_bind_btCollisionObject_isKinematicObject_0 = Module._emscripten_bind_btCollisionObject_isKinematicObject_0 = asm._emscripten_bind_btCollisionObject_isKinematicObject_0, _emscripten_bind_btWheelInfo_set_m_chassisConnectionPointCS_1 = Module._emscripten_bind_btWheelInfo_set_m_chassisConnectionPointCS_1 = asm._emscripten_bind_btWheelInfo_set_m_chassisConnectionPointCS_1, _emscripten_bind_ConvexResultCallback___destroy___0 = Module._emscripten_bind_ConvexResultCallback___destroy___0 = asm._emscripten_bind_ConvexResultCallback___destroy___0, _emscripten_bind_btGeneric6DofSpringConstraint_setLinearUpperLimit_1 = Module._emscripten_bind_btGeneric6DofSpringConstraint_setLinearUpperLimit_1 = asm._emscripten_bind_btGeneric6DofSpringConstraint_setLinearUpperLimit_1, _emscripten_bind_ClosestConvexResultCallback_set_m_hitNormalWorld_1 = Module._emscripten_bind_ClosestConvexResultCallback_set_m_hitNormalWorld_1 = asm._emscripten_bind_ClosestConvexResultCallback_set_m_hitNormalWorld_1, _emscripten_bind_btRigidBody_getCenterOfMassTransform_0 = Module._emscripten_bind_btRigidBody_getCenterOfMassTransform_0 = asm._emscripten_bind_btRigidBody_getCenterOfMassTransform_0, _emscripten_bind_btGhostObject_isKinematicObject_0 = Module._emscripten_bind_btGhostObject_isKinematicObject_0 = asm._emscripten_bind_btGhostObject_isKinematicObject_0, _emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_5 = Module._emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_5 = asm._emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_5, _emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_3 = Module._emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_3 = asm._emscripten_bind_btGeneric6DofSpringConstraint_btGeneric6DofSpringConstraint_3, _emscripten_bind_btCollisionObject_activate_1 = Module._emscripten_bind_btCollisionObject_activate_1 = asm._emscripten_bind_btCollisionObject_activate_1, _emscripten_bind_btCollisionObject_activate_0 = Module._emscripten_bind_btCollisionObject_activate_0 = asm._emscripten_bind_btCollisionObject_activate_0, _emscripten_bind_btKinematicCharacterController_setUpAxis_1 = Module._emscripten_bind_btKinematicCharacterController_setUpAxis_1 = asm._emscripten_bind_btKinematicCharacterController_setUpAxis_1, _emscripten_bind_btDispatcherInfo_set_m_timeOfImpact_1 = Module._emscripten_bind_btDispatcherInfo_set_m_timeOfImpact_1 = asm._emscripten_bind_btDispatcherInfo_set_m_timeOfImpact_1, _emscripten_bind_btCollisionDispatcher_btCollisionDispatcher_1 = Module._emscripten_bind_btCollisionDispatcher_btCollisionDispatcher_1 = asm._emscripten_bind_btCollisionDispatcher_btCollisionDispatcher_1, _emscripten_bind_btVector3_setX_1 = Module._emscripten_bind_btVector3_setX_1 = asm._emscripten_bind_btVector3_setX_1, _emscripten_bind_btCollisionConfiguration___destroy___0 = Module._emscripten_bind_btCollisionConfiguration___destroy___0 = asm._emscripten_bind_btCollisionConfiguration___destroy___0, _emscripten_bind_btCapsuleShapeZ_setMargin_1 = Module._emscripten_bind_btCapsuleShapeZ_setMargin_1 = asm._emscripten_bind_btCapsuleShapeZ_setMargin_1, _emscripten_bind_btQuaternion_btQuaternion_4 = Module._emscripten_bind_btQuaternion_btQuaternion_4 = asm._emscripten_bind_btQuaternion_btQuaternion_4, _emscripten_bind_btManifoldPoint_set_m_positionWorldOnB_1 = Module._emscripten_bind_btManifoldPoint_set_m_positionWorldOnB_1 = asm._emscripten_bind_btManifoldPoint_set_m_positionWorldOnB_1, _emscripten_bind_btManifoldPoint_set_m_localPointB_1 = Module._emscripten_bind_btManifoldPoint_set_m_localPointB_1 = asm._emscripten_bind_btManifoldPoint_set_m_localPointB_1, _emscripten_bind_btVector3_setZ_1 = Module._emscripten_bind_btVector3_setZ_1 = asm._emscripten_bind_btVector3_setZ_1, _emscripten_bind_btKinematicCharacterController_setUseGhostSweepTest_1 = Module._emscripten_bind_btKinematicCharacterController_setUseGhostSweepTest_1 = asm._emscripten_bind_btKinematicCharacterController_setUseGhostSweepTest_1, _emscripten_bind_btQuaternion_setValue_4 = Module._emscripten_bind_btQuaternion_setValue_4 = asm._emscripten_bind_btQuaternion_setValue_4, _emscripten_bind_btDispatcherInfo_set_m_dispatchFunc_1 = Module._emscripten_bind_btDispatcherInfo_set_m_dispatchFunc_1 = asm._emscripten_bind_btDispatcherInfo_set_m_dispatchFunc_1, _emscripten_bind_LocalShapeInfo___destroy___0 = Module._emscripten_bind_LocalShapeInfo___destroy___0 = asm._emscripten_bind_LocalShapeInfo___destroy___0, _emscripten_bind_btWheelInfo_get_m_bIsFrontWheel_0 = Module._emscripten_bind_btWheelInfo_get_m_bIsFrontWheel_0 = asm._emscripten_bind_btWheelInfo_get_m_bIsFrontWheel_0, _emscripten_bind_btQuadWord_setY_1 = Module._emscripten_bind_btQuadWord_setY_1 = asm._emscripten_bind_btQuadWord_setY_1, _emscripten_bind_btRigidBodyConstructionInfo_set_m_restitution_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_restitution_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_restitution_1, _emscripten_bind_btDefaultMotionState_get_m_graphicsWorldTrans_0 = Module._emscripten_bind_btDefaultMotionState_get_m_graphicsWorldTrans_0 = asm._emscripten_bind_btDefaultMotionState_get_m_graphicsWorldTrans_0, _emscripten_bind_btConeTwistConstraint_setDamping_1 = Module._emscripten_bind_btConeTwistConstraint_setDamping_1 = asm._emscripten_bind_btConeTwistConstraint_setDamping_1, _emscripten_bind_btPairCachingGhostObject_btPairCachingGhostObject_0 = Module._emscripten_bind_btPairCachingGhostObject_btPairCachingGhostObject_0 = asm._emscripten_bind_btPairCachingGhostObject_btPairCachingGhostObject_0, _emscripten_bind_btDiscreteDynamicsWorld_getSolverInfo_0 = Module._emscripten_bind_btDiscreteDynamicsWorld_getSolverInfo_0 = asm._emscripten_bind_btDiscreteDynamicsWorld_getSolverInfo_0, _emscripten_bind_btCylinderShape_setMargin_1 = Module._emscripten_bind_btCylinderShape_setMargin_1 = asm._emscripten_bind_btCylinderShape_setMargin_1, _emscripten_bind_btCollisionWorld___destroy___0 = Module._emscripten_bind_btCollisionWorld___destroy___0 = asm._emscripten_bind_btCollisionWorld___destroy___0, _emscripten_bind_LocalConvexResult_get_m_hitPointLocal_0 = Module._emscripten_bind_LocalConvexResult_get_m_hitPointLocal_0 = asm._emscripten_bind_LocalConvexResult_get_m_hitPointLocal_0, _emscripten_bind_btBoxShape_btBoxShape_1 = Module._emscripten_bind_btBoxShape_btBoxShape_1 = asm._emscripten_bind_btBoxShape_btBoxShape_1, _emscripten_bind_btPersistentManifold_getBody1_0 = Module._emscripten_bind_btPersistentManifold_getBody1_0 = asm._emscripten_bind_btPersistentManifold_getBody1_0, _emscripten_bind_ClosestRayResultCallback_set_m_collisionObject_1 = Module._emscripten_bind_ClosestRayResultCallback_set_m_collisionObject_1 = asm._emscripten_bind_ClosestRayResultCallback_set_m_collisionObject_1, _emscripten_bind_btKinematicCharacterController_setGravity_1 = Module._emscripten_bind_btKinematicCharacterController_setGravity_1 = asm._emscripten_bind_btKinematicCharacterController_setGravity_1, _emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_5 = Module._emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_5 = asm._emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_5, _emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_3 = Module._emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_3 = asm._emscripten_bind_btGeneric6DofConstraint_btGeneric6DofConstraint_3, _emscripten_bind_LocalShapeInfo_get_m_shapePart_0 = Module._emscripten_bind_LocalShapeInfo_get_m_shapePart_0 = asm._emscripten_bind_LocalShapeInfo_get_m_shapePart_0, _emscripten_bind_ClosestRayResultCallback_get_m_hitPointWorld_0 = Module._emscripten_bind_ClosestRayResultCallback_get_m_hitPointWorld_0 = asm._emscripten_bind_ClosestRayResultCallback_get_m_hitPointWorld_0, _emscripten_bind_btVector4_setValue_4 = Module._emscripten_bind_btVector4_setValue_4 = asm._emscripten_bind_btVector4_setValue_4, _emscripten_bind_btBvhTriangleMeshShape_setLocalScaling_1 = Module._emscripten_bind_btBvhTriangleMeshShape_setLocalScaling_1 = asm._emscripten_bind_btBvhTriangleMeshShape_setLocalScaling_1, _emscripten_bind_btPoint2PointConstraint_setBreakingImpulseThreshold_1 = Module._emscripten_bind_btPoint2PointConstraint_setBreakingImpulseThreshold_1 = asm._emscripten_bind_btPoint2PointConstraint_setBreakingImpulseThreshold_1, _emscripten_bind_btDynamicsWorld_getDispatchInfo_0 = Module._emscripten_bind_btDynamicsWorld_getDispatchInfo_0 = asm._emscripten_bind_btDynamicsWorld_getDispatchInfo_0, _emscripten_bind_btCompoundShape_removeChildShapeByIndex_1 = Module._emscripten_bind_btCompoundShape_removeChildShapeByIndex_1 = asm._emscripten_bind_btCompoundShape_removeChildShapeByIndex_1, _emscripten_bind_btVector3_length_0 = Module._emscripten_bind_btVector3_length_0 = asm._emscripten_bind_btVector3_length_0, _emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_2 = Module._emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_2 = asm._emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_2, _emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_1 = Module._emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_1 = asm._emscripten_bind_btConvexTriangleMeshShape_btConvexTriangleMeshShape_1, _emscripten_bind_ClosestConvexResultCallback_set_m_hitPointWorld_1 = Module._emscripten_bind_ClosestConvexResultCallback_set_m_hitPointWorld_1 = asm._emscripten_bind_ClosestConvexResultCallback_set_m_hitPointWorld_1, _emscripten_bind_RayResultCallback_set_m_collisionFilterMask_1 = Module._emscripten_bind_RayResultCallback_set_m_collisionFilterMask_1 = asm._emscripten_bind_RayResultCallback_set_m_collisionFilterMask_1, _emscripten_bind_btBoxShape_getMargin_0 = Module._emscripten_bind_btBoxShape_getMargin_0 = asm._emscripten_bind_btBoxShape_getMargin_0, _emscripten_bind_btPairCachingGhostObject___destroy___0 = Module._emscripten_bind_btPairCachingGhostObject___destroy___0 = asm._emscripten_bind_btPairCachingGhostObject___destroy___0, _emscripten_bind_btDynamicsWorld_addCollisionObject_3 = Module._emscripten_bind_btDynamicsWorld_addCollisionObject_3 = asm._emscripten_bind_btDynamicsWorld_addCollisionObject_3, _emscripten_bind_btPairCachingGhostObject_activate_0 = Module._emscripten_bind_btPairCachingGhostObject_activate_0 = asm._emscripten_bind_btPairCachingGhostObject_activate_0, _emscripten_bind_btPairCachingGhostObject_activate_1 = Module._emscripten_bind_btPairCachingGhostObject_activate_1 = asm._emscripten_bind_btPairCachingGhostObject_activate_1, _emscripten_bind_btContactSolverInfo_get_m_splitImpulsePenetrationThreshold_0 = Module._emscripten_bind_btContactSolverInfo_get_m_splitImpulsePenetrationThreshold_0 = asm._emscripten_bind_btContactSolverInfo_get_m_splitImpulsePenetrationThreshold_0, _emscripten_bind_btDynamicsWorld___destroy___0 = Module._emscripten_bind_btDynamicsWorld___destroy___0 = asm._emscripten_bind_btDynamicsWorld___destroy___0, _emscripten_bind_btPairCachingGhostObject_forceActivationState_1 = Module._emscripten_bind_btPairCachingGhostObject_forceActivationState_1 = asm._emscripten_bind_btPairCachingGhostObject_forceActivationState_1, _emscripten_bind_btDefaultMotionState___destroy___0 = Module._emscripten_bind_btDefaultMotionState___destroy___0 = asm._emscripten_bind_btDefaultMotionState___destroy___0, _emscripten_bind_btDispatcherInfo_get_m_stepCount_0 = Module._emscripten_bind_btDispatcherInfo_get_m_stepCount_0 = asm._emscripten_bind_btDispatcherInfo_get_m_stepCount_0, _emscripten_bind_btRigidBodyConstructionInfo_set_m_angularDamping_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_angularDamping_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_angularDamping_1, _emscripten_bind_btQuadWord_setW_1 = Module._emscripten_bind_btQuadWord_setW_1 = asm._emscripten_bind_btQuadWord_setW_1, _emscripten_bind_btRigidBodyConstructionInfo_get_m_friction_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_friction_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_friction_0, _emscripten_bind_btCapsuleShapeX_btCapsuleShapeX_2 = Module._emscripten_bind_btCapsuleShapeX_btCapsuleShapeX_2 = asm._emscripten_bind_btCapsuleShapeX_btCapsuleShapeX_2, _emscripten_bind_LocalShapeInfo_set_m_shapePart_1 = Module._emscripten_bind_LocalShapeInfo_set_m_shapePart_1 = asm._emscripten_bind_LocalShapeInfo_set_m_shapePart_1, _emscripten_bind_btRigidBody_setLinearFactor_1 = Module._emscripten_bind_btRigidBody_setLinearFactor_1 = asm._emscripten_bind_btRigidBody_setLinearFactor_1, _emscripten_bind_btDispatcherInfo_set_m_useConvexConservativeDistanceUtil_1 = Module._emscripten_bind_btDispatcherInfo_set_m_useConvexConservativeDistanceUtil_1 = asm._emscripten_bind_btDispatcherInfo_set_m_useConvexConservativeDistanceUtil_1, _emscripten_bind_btRaycastVehicle_setSteeringValue_2 = Module._emscripten_bind_btRaycastVehicle_setSteeringValue_2 = asm._emscripten_bind_btRaycastVehicle_setSteeringValue_2, _emscripten_bind_btPoint2PointConstraint___destroy___0 = Module._emscripten_bind_btPoint2PointConstraint___destroy___0 = asm._emscripten_bind_btPoint2PointConstraint___destroy___0, _emscripten_bind_btGeneric6DofConstraint_setAngularUpperLimit_1 = Module._emscripten_bind_btGeneric6DofConstraint_setAngularUpperLimit_1 = asm._emscripten_bind_btGeneric6DofConstraint_setAngularUpperLimit_1, _emscripten_bind_btDiscreteDynamicsWorld_addConstraint_2 = Module._emscripten_bind_btDiscreteDynamicsWorld_addConstraint_2 = asm._emscripten_bind_btDiscreteDynamicsWorld_addConstraint_2, _emscripten_bind_btDiscreteDynamicsWorld_addConstraint_1 = Module._emscripten_bind_btDiscreteDynamicsWorld_addConstraint_1 = asm._emscripten_bind_btDiscreteDynamicsWorld_addConstraint_1, _emscripten_bind_btRigidBodyConstructionInfo_set_m_angularSleepingThreshold_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_angularSleepingThreshold_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_angularSleepingThreshold_1, _emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterGroup_1 = Module._emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterGroup_1 = asm._emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterGroup_1, _malloc = Module._malloc = asm._malloc, _emscripten_bind_btDispatcherInfo_get_m_useEpa_0 = Module._emscripten_bind_btDispatcherInfo_get_m_useEpa_0 = asm._emscripten_bind_btDispatcherInfo_get_m_useEpa_0, _emscripten_bind_btTransform_btTransform_2 = Module._emscripten_bind_btTransform_btTransform_2 = asm._emscripten_bind_btTransform_btTransform_2, _emscripten_bind_btTransform_btTransform_0 = Module._emscripten_bind_btTransform_btTransform_0 = asm._emscripten_bind_btTransform_btTransform_0, _emscripten_bind_btWheelInfo_set_m_wheelsRadius_1 = Module._emscripten_bind_btWheelInfo_set_m_wheelsRadius_1 = asm._emscripten_bind_btWheelInfo_set_m_wheelsRadius_1, _emscripten_bind_btDispatcherInfo_set_m_enableSPU_1 = Module._emscripten_bind_btDispatcherInfo_set_m_enableSPU_1 = asm._emscripten_bind_btDispatcherInfo_set_m_enableSPU_1, _emscripten_bind_btRaycastVehicle_setCoordinateSystem_3 = Module._emscripten_bind_btRaycastVehicle_setCoordinateSystem_3 = asm._emscripten_bind_btRaycastVehicle_setCoordinateSystem_3, _emscripten_bind_btCollisionObject_setActivationState_1 = Module._emscripten_bind_btCollisionObject_setActivationState_1 = asm._emscripten_bind_btCollisionObject_setActivationState_1, _emscripten_bind_btPersistentManifold___destroy___0 = Module._emscripten_bind_btPersistentManifold___destroy___0 = asm._emscripten_bind_btPersistentManifold___destroy___0, _emscripten_bind_btConstraintSetting_get_m_impulseClamp_0 = Module._emscripten_bind_btConstraintSetting_get_m_impulseClamp_0 = asm._emscripten_bind_btConstraintSetting_get_m_impulseClamp_0, _emscripten_bind_btCylinderShapeZ___destroy___0 = Module._emscripten_bind_btCylinderShapeZ___destroy___0 = asm._emscripten_bind_btCylinderShapeZ___destroy___0, _emscripten_bind_btMatrix3x3___destroy___0 = Module._emscripten_bind_btMatrix3x3___destroy___0 = asm._emscripten_bind_btMatrix3x3___destroy___0, _emscripten_bind_btGeneric6DofSpringConstraint_setBreakingImpulseThreshold_1 = Module._emscripten_bind_btGeneric6DofSpringConstraint_setBreakingImpulseThreshold_1 = asm._emscripten_bind_btGeneric6DofSpringConstraint_setBreakingImpulseThreshold_1, _emscripten_bind_btCollisionShape_calculateLocalInertia_2 = Module._emscripten_bind_btCollisionShape_calculateLocalInertia_2 = asm._emscripten_bind_btCollisionShape_calculateLocalInertia_2, _emscripten_bind_ConvexResultCallback_hasHit_0 = Module._emscripten_bind_ConvexResultCallback_hasHit_0 = asm._emscripten_bind_ConvexResultCallback_hasHit_0, _emscripten_bind_btCollisionWorld_convexSweepTest_5 = Module._emscripten_bind_btCollisionWorld_convexSweepTest_5 = asm._emscripten_bind_btCollisionWorld_convexSweepTest_5, _emscripten_bind_ClosestRayResultCallback_set_m_hitPointWorld_1 = Module._emscripten_bind_ClosestRayResultCallback_set_m_hitPointWorld_1 = asm._emscripten_bind_ClosestRayResultCallback_set_m_hitPointWorld_1, _emscripten_bind_btCapsuleShapeX_calculateLocalInertia_2 = Module._emscripten_bind_btCapsuleShapeX_calculateLocalInertia_2 = asm._emscripten_bind_btCapsuleShapeX_calculateLocalInertia_2, _emscripten_bind_btConstraintSetting_set_m_damping_1 = Module._emscripten_bind_btConstraintSetting_set_m_damping_1 = asm._emscripten_bind_btConstraintSetting_set_m_damping_1, _emscripten_bind_btWheelInfo_set_m_bIsFrontWheel_1 = Module._emscripten_bind_btWheelInfo_set_m_bIsFrontWheel_1 = asm._emscripten_bind_btWheelInfo_set_m_bIsFrontWheel_1, _emscripten_bind_btRigidBody_setCcdMotionThreshold_1 = Module._emscripten_bind_btRigidBody_setCcdMotionThreshold_1 = asm._emscripten_bind_btRigidBody_setCcdMotionThreshold_1, _emscripten_bind_btConvexHullShape_setMargin_1 = Module._emscripten_bind_btConvexHullShape_setMargin_1 = asm._emscripten_bind_btConvexHullShape_setMargin_1, _emscripten_bind_btRigidBody_applyForce_2 = Module._emscripten_bind_btRigidBody_applyForce_2 = asm._emscripten_bind_btRigidBody_applyForce_2, _emscripten_bind_btConeShapeZ_calculateLocalInertia_2 = Module._emscripten_bind_btConeShapeZ_calculateLocalInertia_2 = asm._emscripten_bind_btConeShapeZ_calculateLocalInertia_2, _emscripten_bind_btConstraintSetting_set_m_tau_1 = Module._emscripten_bind_btConstraintSetting_set_m_tau_1 = asm._emscripten_bind_btConstraintSetting_set_m_tau_1, _emscripten_bind_btConvexHullShape_calculateLocalInertia_2 = Module._emscripten_bind_btConvexHullShape_calculateLocalInertia_2 = asm._emscripten_bind_btConvexHullShape_calculateLocalInertia_2, _emscripten_bind_btSphereShape_calculateLocalInertia_2 = Module._emscripten_bind_btSphereShape_calculateLocalInertia_2 = asm._emscripten_bind_btSphereShape_calculateLocalInertia_2, _emscripten_bind_btGeneric6DofConstraint_setAngularLowerLimit_1 = Module._emscripten_bind_btGeneric6DofConstraint_setAngularLowerLimit_1 = asm._emscripten_bind_btGeneric6DofConstraint_setAngularLowerLimit_1, _emscripten_bind_btSliderConstraint_setBreakingImpulseThreshold_1 = Module._emscripten_bind_btSliderConstraint_setBreakingImpulseThreshold_1 = asm._emscripten_bind_btSliderConstraint_setBreakingImpulseThreshold_1, _emscripten_bind_btCollisionDispatcher_getManifoldByIndexInternal_1 = Module._emscripten_bind_btCollisionDispatcher_getManifoldByIndexInternal_1 = asm._emscripten_bind_btCollisionDispatcher_getManifoldByIndexInternal_1, _emscripten_bind_LocalConvexResult_LocalConvexResult_5 = Module._emscripten_bind_LocalConvexResult_LocalConvexResult_5 = asm._emscripten_bind_LocalConvexResult_LocalConvexResult_5, _emscripten_bind_btGhostObject_setFriction_1 = Module._emscripten_bind_btGhostObject_setFriction_1 = asm._emscripten_bind_btGhostObject_setFriction_1, _emscripten_bind_btPairCachingGhostObject_getWorldTransform_0 = Module._emscripten_bind_btPairCachingGhostObject_getWorldTransform_0 = asm._emscripten_bind_btPairCachingGhostObject_getWorldTransform_0, _emscripten_bind_btRigidBody_setCcdSweptSphereRadius_1 = Module._emscripten_bind_btRigidBody_setCcdSweptSphereRadius_1 = asm._emscripten_bind_btRigidBody_setCcdSweptSphereRadius_1, _emscripten_bind_btCylinderShapeZ_setMargin_1 = Module._emscripten_bind_btCylinderShapeZ_setMargin_1 = asm._emscripten_bind_btCylinderShapeZ_setMargin_1, _emscripten_bind_btRigidBody_setFriction_1 = Module._emscripten_bind_btRigidBody_setFriction_1 = asm._emscripten_bind_btRigidBody_setFriction_1, _emscripten_bind_LocalConvexResult_set_m_hitPointLocal_1 = Module._emscripten_bind_LocalConvexResult_set_m_hitPointLocal_1 = asm._emscripten_bind_LocalConvexResult_set_m_hitPointLocal_1, _emscripten_bind_btGhostObject_setWorldTransform_1 = Module._emscripten_bind_btGhostObject_setWorldTransform_1 = asm._emscripten_bind_btGhostObject_setWorldTransform_1, _emscripten_bind_btDiscreteDynamicsWorld_removeRigidBody_1 = Module._emscripten_bind_btDiscreteDynamicsWorld_removeRigidBody_1 = asm._emscripten_bind_btDiscreteDynamicsWorld_removeRigidBody_1, _emscripten_bind_btConvexHullShape___destroy___0 = Module._emscripten_bind_btConvexHullShape___destroy___0 = asm._emscripten_bind_btConvexHullShape___destroy___0, _emscripten_bind_btDiscreteDynamicsWorld_getBroadphase_0 = Module._emscripten_bind_btDiscreteDynamicsWorld_getBroadphase_0 = asm._emscripten_bind_btDiscreteDynamicsWorld_getBroadphase_0, _emscripten_bind_btVector4_setX_1 = Module._emscripten_bind_btVector4_setX_1 = asm._emscripten_bind_btVector4_setX_1, _emscripten_bind_btKinematicCharacterController_jump_0 = Module._emscripten_bind_btKinematicCharacterController_jump_0 = asm._emscripten_bind_btKinematicCharacterController_jump_0, _emscripten_bind_btConeTwistConstraint_setMaxMotorImpulseNormalized_1 = Module._emscripten_bind_btConeTwistConstraint_setMaxMotorImpulseNormalized_1 = asm._emscripten_bind_btConeTwistConstraint_setMaxMotorImpulseNormalized_1, _emscripten_bind_btConvexTriangleMeshShape_setLocalScaling_1 = Module._emscripten_bind_btConvexTriangleMeshShape_setLocalScaling_1 = asm._emscripten_bind_btConvexTriangleMeshShape_setLocalScaling_1, _emscripten_bind_btRigidBody_upcast_1 = Module._emscripten_bind_btRigidBody_upcast_1 = asm._emscripten_bind_btRigidBody_upcast_1, _emscripten_bind_btCollisionObject_getWorldTransform_0 = Module._emscripten_bind_btCollisionObject_getWorldTransform_0 = asm._emscripten_bind_btCollisionObject_getWorldTransform_0, _emscripten_bind_btVector4_setZ_1 = Module._emscripten_bind_btVector4_setZ_1 = asm._emscripten_bind_btVector4_setZ_1, _emscripten_bind_btQuadWord_y_0 = Module._emscripten_bind_btQuadWord_y_0 = asm._emscripten_bind_btQuadWord_y_0, _emscripten_bind_btTransform_getBasis_0 = Module._emscripten_bind_btTransform_getBasis_0 = asm._emscripten_bind_btTransform_getBasis_0, _emscripten_bind_btPairCachingGhostObject_setFriction_1 = Module._emscripten_bind_btPairCachingGhostObject_setFriction_1 = asm._emscripten_bind_btPairCachingGhostObject_setFriction_1, _emscripten_bind_btDispatcherInfo_set_m_useEpa_1 = Module._emscripten_bind_btDispatcherInfo_set_m_useEpa_1 = asm._emscripten_bind_btDispatcherInfo_set_m_useEpa_1, _emscripten_bind_btCollisionDispatcher_getNumManifolds_0 = Module._emscripten_bind_btCollisionDispatcher_getNumManifolds_0 = asm._emscripten_bind_btCollisionDispatcher_getNumManifolds_0, _emscripten_bind_btVehicleRaycaster___destroy___0 = Module._emscripten_bind_btVehicleRaycaster___destroy___0 = asm._emscripten_bind_btVehicleRaycaster___destroy___0, _emscripten_bind_ClosestRayResultCallback___destroy___0 = Module._emscripten_bind_ClosestRayResultCallback___destroy___0 = asm._emscripten_bind_ClosestRayResultCallback___destroy___0, _emscripten_bind_btGeneric6DofSpringConstraint_setStiffness_2 = Module._emscripten_bind_btGeneric6DofSpringConstraint_setStiffness_2 = asm._emscripten_bind_btGeneric6DofSpringConstraint_setStiffness_2, _emscripten_bind_btCylinderShapeX_setMargin_1 = Module._emscripten_bind_btCylinderShapeX_setMargin_1 = asm._emscripten_bind_btCylinderShapeX_setMargin_1, _emscripten_bind_btQuadWord_w_0 = Module._emscripten_bind_btQuadWord_w_0 = asm._emscripten_bind_btQuadWord_w_0, _emscripten_bind_btPersistentManifold_getNumContacts_0 = Module._emscripten_bind_btPersistentManifold_getNumContacts_0 = asm._emscripten_bind_btPersistentManifold_getNumContacts_0, _emscripten_bind_btAxisSweep3___destroy___0 = Module._emscripten_bind_btAxisSweep3___destroy___0 = asm._emscripten_bind_btAxisSweep3___destroy___0, _emscripten_bind_btBvhTriangleMeshShape_calculateLocalInertia_2 = Module._emscripten_bind_btBvhTriangleMeshShape_calculateLocalInertia_2 = asm._emscripten_bind_btBvhTriangleMeshShape_calculateLocalInertia_2, _emscripten_bind_btCompoundShape_getNumChildShapes_0 = Module._emscripten_bind_btCompoundShape_getNumChildShapes_0 = asm._emscripten_bind_btCompoundShape_getNumChildShapes_0, _emscripten_bind_btGhostObject_btGhostObject_0 = Module._emscripten_bind_btGhostObject_btGhostObject_0 = asm._emscripten_bind_btGhostObject_btGhostObject_0, _emscripten_bind_ClosestConvexResultCallback_ClosestConvexResultCallback_2 = Module._emscripten_bind_ClosestConvexResultCallback_ClosestConvexResultCallback_2 = asm._emscripten_bind_ClosestConvexResultCallback_ClosestConvexResultCallback_2, _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingFactor_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingFactor_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingFactor_1, _emscripten_bind_btManifoldPoint_set_m_localPointA_1 = Module._emscripten_bind_btManifoldPoint_set_m_localPointA_1 = asm._emscripten_bind_btManifoldPoint_set_m_localPointA_1, _emscripten_bind_btCollisionObject_setCollisionShape_1 = Module._emscripten_bind_btCollisionObject_setCollisionShape_1 = asm._emscripten_bind_btCollisionObject_setCollisionShape_1, _emscripten_bind_btWheelInfo___destroy___0 = Module._emscripten_bind_btWheelInfo___destroy___0 = asm._emscripten_bind_btWheelInfo___destroy___0, _emscripten_bind_btTransform_setRotation_1 = Module._emscripten_bind_btTransform_setRotation_1 = asm._emscripten_bind_btTransform_setRotation_1, _emscripten_bind_btPairCachingGhostObject_getNumOverlappingObjects_0 = Module._emscripten_bind_btPairCachingGhostObject_getNumOverlappingObjects_0 = asm._emscripten_bind_btPairCachingGhostObject_getNumOverlappingObjects_0, _emscripten_bind_btPoint2PointConstraint_enableFeedback_1 = Module._emscripten_bind_btPoint2PointConstraint_enableFeedback_1 = asm._emscripten_bind_btPoint2PointConstraint_enableFeedback_1, _emscripten_bind_btQuadWord_setZ_1 = Module._emscripten_bind_btQuadWord_setZ_1 = asm._emscripten_bind_btQuadWord_setZ_1, _emscripten_bind_btAxisSweep3_btAxisSweep3_2 = Module._emscripten_bind_btAxisSweep3_btAxisSweep3_2 = asm._emscripten_bind_btAxisSweep3_btAxisSweep3_2, _emscripten_bind_btAxisSweep3_btAxisSweep3_3 = Module._emscripten_bind_btAxisSweep3_btAxisSweep3_3 = asm._emscripten_bind_btAxisSweep3_btAxisSweep3_3, _emscripten_bind_btConstraintSetting_set_m_impulseClamp_1 = Module._emscripten_bind_btConstraintSetting_set_m_impulseClamp_1 = asm._emscripten_bind_btConstraintSetting_set_m_impulseClamp_1, _emscripten_bind_btVector3_setY_1 = Module._emscripten_bind_btVector3_setY_1 = asm._emscripten_bind_btVector3_setY_1, _emscripten_bind_btAxisSweep3_btAxisSweep3_4 = Module._emscripten_bind_btAxisSweep3_btAxisSweep3_4 = asm._emscripten_bind_btAxisSweep3_btAxisSweep3_4, _emscripten_bind_btAxisSweep3_btAxisSweep3_5 = Module._emscripten_bind_btAxisSweep3_btAxisSweep3_5 = asm._emscripten_bind_btAxisSweep3_btAxisSweep3_5, _emscripten_bind_btQuadWord_setX_1 = Module._emscripten_bind_btQuadWord_setX_1 = asm._emscripten_bind_btQuadWord_setX_1, _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalLinearDampingThresholdSqr_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalLinearDampingThresholdSqr_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalLinearDampingThresholdSqr_0, _emscripten_bind_btVehicleTuning_set_m_suspensionStiffness_1 = Module._emscripten_bind_btVehicleTuning_set_m_suspensionStiffness_1 = asm._emscripten_bind_btVehicleTuning_set_m_suspensionStiffness_1, _emscripten_bind_btOverlappingPairCache___destroy___0 = Module._emscripten_bind_btOverlappingPairCache___destroy___0 = asm._emscripten_bind_btOverlappingPairCache___destroy___0, _emscripten_bind_btConstraintSetting___destroy___0 = Module._emscripten_bind_btConstraintSetting___destroy___0 = asm._emscripten_bind_btConstraintSetting___destroy___0, _emscripten_bind_btRaycastVehicle___destroy___0 = Module._emscripten_bind_btRaycastVehicle___destroy___0 = asm._emscripten_bind_btRaycastVehicle___destroy___0, _emscripten_bind_btPersistentManifold_getBody0_0 = Module._emscripten_bind_btPersistentManifold_getBody0_0 = asm._emscripten_bind_btPersistentManifold_getBody0_0, _emscripten_bind_btConeShapeX_btConeShapeX_2 = Module._emscripten_bind_btConeShapeX_btConeShapeX_2 = asm._emscripten_bind_btConeShapeX_btConeShapeX_2, _emscripten_bind_btQuaternion_z_0 = Module._emscripten_bind_btQuaternion_z_0 = asm._emscripten_bind_btQuaternion_z_0, _emscripten_bind_btConeTwistConstraint_enableFeedback_1 = Module._emscripten_bind_btConeTwistConstraint_enableFeedback_1 = asm._emscripten_bind_btConeTwistConstraint_enableFeedback_1, _emscripten_bind_btCapsuleShapeZ_setLocalScaling_1 = Module._emscripten_bind_btCapsuleShapeZ_setLocalScaling_1 = asm._emscripten_bind_btCapsuleShapeZ_setLocalScaling_1, _emscripten_bind_ClosestConvexResultCallback_get_m_closestHitFraction_0 = Module._emscripten_bind_ClosestConvexResultCallback_get_m_closestHitFraction_0 = asm._emscripten_bind_ClosestConvexResultCallback_get_m_closestHitFraction_0, _emscripten_bind_btSliderConstraint_setUpperLinLimit_1 = Module._emscripten_bind_btSliderConstraint_setUpperLinLimit_1 = asm._emscripten_bind_btSliderConstraint_setUpperLinLimit_1, _emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_2 = Module._emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_2 = asm._emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_2, _emscripten_bind_btConcaveShape___destroy___0 = Module._emscripten_bind_btConcaveShape___destroy___0 = asm._emscripten_bind_btConcaveShape___destroy___0, _emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_4 = Module._emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_4 = asm._emscripten_bind_btConeTwistConstraint_btConeTwistConstraint_4, _emscripten_bind_btQuaternion_x_0 = Module._emscripten_bind_btQuaternion_x_0 = asm._emscripten_bind_btQuaternion_x_0, _emscripten_bind_LocalConvexResult_set_m_hitNormalLocal_1 = Module._emscripten_bind_LocalConvexResult_set_m_hitNormalLocal_1 = asm._emscripten_bind_LocalConvexResult_set_m_hitNormalLocal_1, _emscripten_bind_btConcaveShape_setLocalScaling_1 = Module._emscripten_bind_btConcaveShape_setLocalScaling_1 = asm._emscripten_bind_btConcaveShape_setLocalScaling_1, _emscripten_bind_btDiscreteDynamicsWorld_getDispatchInfo_0 = Module._emscripten_bind_btDiscreteDynamicsWorld_getDispatchInfo_0 = asm._emscripten_bind_btDiscreteDynamicsWorld_getDispatchInfo_0, _emscripten_bind_btConeShapeX_setLocalScaling_1 = Module._emscripten_bind_btConeShapeX_setLocalScaling_1 = asm._emscripten_bind_btConeShapeX_setLocalScaling_1, _emscripten_bind_btCylinderShapeZ_setLocalScaling_1 = Module._emscripten_bind_btCylinderShapeZ_setLocalScaling_1 = asm._emscripten_bind_btCylinderShapeZ_setLocalScaling_1, _emscripten_bind_btConvexHullShape_btConvexHullShape_0 = Module._emscripten_bind_btConvexHullShape_btConvexHullShape_0 = asm._emscripten_bind_btConvexHullShape_btConvexHullShape_0, _emscripten_bind_btWheelInfo_set_m_maxSuspensionForce_1 = Module._emscripten_bind_btWheelInfo_set_m_maxSuspensionForce_1 = asm._emscripten_bind_btWheelInfo_set_m_maxSuspensionForce_1, _emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterMask_1 = Module._emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterMask_1 = asm._emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterMask_1, _emscripten_bind_btGhostObject___destroy___0 = Module._emscripten_bind_btGhostObject___destroy___0 = asm._emscripten_bind_btGhostObject___destroy___0, _emscripten_bind_btGhostObject_setContactProcessingThreshold_1 = Module._emscripten_bind_btGhostObject_setContactProcessingThreshold_1 = asm._emscripten_bind_btGhostObject_setContactProcessingThreshold_1, _emscripten_bind_btRigidBody_applyCentralForce_1 = Module._emscripten_bind_btRigidBody_applyCentralForce_1 = asm._emscripten_bind_btRigidBody_applyCentralForce_1, _emscripten_bind_btQuaternion___destroy___0 = Module._emscripten_bind_btQuaternion___destroy___0 = asm._emscripten_bind_btQuaternion___destroy___0, _emscripten_bind_btStaticPlaneShape_calculateLocalInertia_2 = Module._emscripten_bind_btStaticPlaneShape_calculateLocalInertia_2 = asm._emscripten_bind_btStaticPlaneShape_calculateLocalInertia_2, _emscripten_bind_btDefaultMotionState_btDefaultMotionState_2 = Module._emscripten_bind_btDefaultMotionState_btDefaultMotionState_2 = asm._emscripten_bind_btDefaultMotionState_btDefaultMotionState_2, _emscripten_bind_btDefaultMotionState_btDefaultMotionState_0 = Module._emscripten_bind_btDefaultMotionState_btDefaultMotionState_0 = asm._emscripten_bind_btDefaultMotionState_btDefaultMotionState_0, _emscripten_bind_btDefaultMotionState_btDefaultMotionState_1 = Module._emscripten_bind_btDefaultMotionState_btDefaultMotionState_1 = asm._emscripten_bind_btDefaultMotionState_btDefaultMotionState_1, _emscripten_bind_btCompoundShape_getChildShape_1 = Module._emscripten_bind_btCompoundShape_getChildShape_1 = asm._emscripten_bind_btCompoundShape_getChildShape_1, _emscripten_bind_btKinematicCharacterController_canJump_0 = Module._emscripten_bind_btKinematicCharacterController_canJump_0 = asm._emscripten_bind_btKinematicCharacterController_canJump_0, _emscripten_bind_btRigidBody_isActive_0 = Module._emscripten_bind_btRigidBody_isActive_0 = asm._emscripten_bind_btRigidBody_isActive_0, _emscripten_bind_btRaycastVehicle_btRaycastVehicle_3 = Module._emscripten_bind_btRaycastVehicle_btRaycastVehicle_3 = asm._emscripten_bind_btRaycastVehicle_btRaycastVehicle_3, _emscripten_bind_btMotionState_setWorldTransform_1 = Module._emscripten_bind_btMotionState_setWorldTransform_1 = asm._emscripten_bind_btMotionState_setWorldTransform_1, _emscripten_bind_btCylinderShape_setLocalScaling_1 = Module._emscripten_bind_btCylinderShape_setLocalScaling_1 = asm._emscripten_bind_btCylinderShape_setLocalScaling_1, _emscripten_bind_btCollisionWorld_rayTest_3 = Module._emscripten_bind_btCollisionWorld_rayTest_3 = asm._emscripten_bind_btCollisionWorld_rayTest_3, _emscripten_bind_btCompoundShape_calculateLocalInertia_2 = Module._emscripten_bind_btCompoundShape_calculateLocalInertia_2 = asm._emscripten_bind_btCompoundShape_calculateLocalInertia_2, _emscripten_bind_btCollisionWorld_getDispatchInfo_0 = Module._emscripten_bind_btCollisionWorld_getDispatchInfo_0 = asm._emscripten_bind_btCollisionWorld_getDispatchInfo_0, _emscripten_bind_btRigidBody_setCollisionShape_1 = Module._emscripten_bind_btRigidBody_setCollisionShape_1 = asm._emscripten_bind_btRigidBody_setCollisionShape_1, _emscripten_bind_btConeShapeX___destroy___0 = Module._emscripten_bind_btConeShapeX___destroy___0 = asm._emscripten_bind_btConeShapeX___destroy___0, _emscripten_bind_btCollisionObject_getCollisionFlags_0 = Module._emscripten_bind_btCollisionObject_getCollisionFlags_0 = asm._emscripten_bind_btCollisionObject_getCollisionFlags_0, _emscripten_bind_btDispatcherInfo_set_m_enableSatConvex_1 = Module._emscripten_bind_btDispatcherInfo_set_m_enableSatConvex_1 = asm._emscripten_bind_btDispatcherInfo_set_m_enableSatConvex_1, _emscripten_bind_btConeTwistConstraint_enableMotor_1 = Module._emscripten_bind_btConeTwistConstraint_enableMotor_1 = asm._emscripten_bind_btConeTwistConstraint_enableMotor_1, _emscripten_bind_btWheelInfo_set_m_wheelsDampingCompression_1 = Module._emscripten_bind_btWheelInfo_set_m_wheelsDampingCompression_1 = asm._emscripten_bind_btWheelInfo_set_m_wheelsDampingCompression_1, _emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_0 = Module._emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_0 = asm._emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_0, _emscripten_bind_btPairCachingGhostObject_setRestitution_1 = Module._emscripten_bind_btPairCachingGhostObject_setRestitution_1 = asm._emscripten_bind_btPairCachingGhostObject_setRestitution_1, _emscripten_bind_btSphereShape___destroy___0 = Module._emscripten_bind_btSphereShape___destroy___0 = asm._emscripten_bind_btSphereShape___destroy___0, _emscripten_bind_btSliderConstraint_getBreakingImpulseThreshold_0 = Module._emscripten_bind_btSliderConstraint_getBreakingImpulseThreshold_0 = asm._emscripten_bind_btSliderConstraint_getBreakingImpulseThreshold_0, _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDampingFactor_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDampingFactor_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDampingFactor_1, _emscripten_bind_btCollisionObject_setContactProcessingThreshold_1 = Module._emscripten_bind_btCollisionObject_setContactProcessingThreshold_1 = asm._emscripten_bind_btCollisionObject_setContactProcessingThreshold_1, _emscripten_bind_btGhostObject_setCcdMotionThreshold_1 = Module._emscripten_bind_btGhostObject_setCcdMotionThreshold_1 = asm._emscripten_bind_btGhostObject_setCcdMotionThreshold_1, _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingFactor_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingFactor_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingFactor_0, _emscripten_bind_LocalConvexResult___destroy___0 = Module._emscripten_bind_LocalConvexResult___destroy___0 = asm._emscripten_bind_LocalConvexResult___destroy___0, _emscripten_bind_btSequentialImpulseConstraintSolver___destroy___0 = Module._emscripten_bind_btSequentialImpulseConstraintSolver___destroy___0 = asm._emscripten_bind_btSequentialImpulseConstraintSolver___destroy___0, _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalLinearDampingThresholdSqr_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalLinearDampingThresholdSqr_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalLinearDampingThresholdSqr_1, _emscripten_bind_btCollisionWorld_addCollisionObject_3 = Module._emscripten_bind_btCollisionWorld_addCollisionObject_3 = asm._emscripten_bind_btCollisionWorld_addCollisionObject_3, _emscripten_bind_btRigidBody_getCollisionFlags_0 = Module._emscripten_bind_btRigidBody_getCollisionFlags_0 = asm._emscripten_bind_btRigidBody_getCollisionFlags_0, _emscripten_bind_btCollisionShape_setLocalScaling_1 = Module._emscripten_bind_btCollisionShape_setLocalScaling_1 = asm._emscripten_bind_btCollisionShape_setLocalScaling_1, _emscripten_bind_btRigidBody_applyTorque_1 = Module._emscripten_bind_btRigidBody_applyTorque_1 = asm._emscripten_bind_btRigidBody_applyTorque_1, _emscripten_bind_LocalConvexResult_get_m_hitCollisionObject_0 = Module._emscripten_bind_LocalConvexResult_get_m_hitCollisionObject_0 = asm._emscripten_bind_LocalConvexResult_get_m_hitCollisionObject_0, _emscripten_bind_btMatrix3x3_setEulerZYX_3 = Module._emscripten_bind_btMatrix3x3_setEulerZYX_3 = asm._emscripten_bind_btMatrix3x3_setEulerZYX_3, _emscripten_bind_btRigidBody_setRollingFriction_1 = Module._emscripten_bind_btRigidBody_setRollingFriction_1 = asm._emscripten_bind_btRigidBody_setRollingFriction_1, _emscripten_bind_btDispatcherInfo_get_m_convexConservativeDistanceThreshold_0 = Module._emscripten_bind_btDispatcherInfo_get_m_convexConservativeDistanceThreshold_0 = asm._emscripten_bind_btDispatcherInfo_get_m_convexConservativeDistanceThreshold_0, _emscripten_bind_btConvexHullShape_setLocalScaling_1 = Module._emscripten_bind_btConvexHullShape_setLocalScaling_1 = asm._emscripten_bind_btConvexHullShape_setLocalScaling_1, _emscripten_bind_btRigidBody_setMotionState_1 = Module._emscripten_bind_btRigidBody_setMotionState_1 = asm._emscripten_bind_btRigidBody_setMotionState_1, _emscripten_bind_RayResultCallback_get_m_collisionFilterMask_0 = Module._emscripten_bind_RayResultCallback_get_m_collisionFilterMask_0 = asm._emscripten_bind_RayResultCallback_get_m_collisionFilterMask_0, _emscripten_bind_btCollisionWorld_getDispatcher_0 = Module._emscripten_bind_btCollisionWorld_getDispatcher_0 = asm._emscripten_bind_btCollisionWorld_getDispatcher_0, _emscripten_bind_btCollisionObject_setRollingFriction_1 = Module._emscripten_bind_btCollisionObject_setRollingFriction_1 = asm._emscripten_bind_btCollisionObject_setRollingFriction_1, _emscripten_bind_RayResultCallback_set_m_collisionFilterGroup_1 = Module._emscripten_bind_RayResultCallback_set_m_collisionFilterGroup_1 = asm._emscripten_bind_RayResultCallback_set_m_collisionFilterGroup_1, _emscripten_bind_btPairCachingGhostObject_getCollisionShape_0 = Module._emscripten_bind_btPairCachingGhostObject_getCollisionShape_0 = asm._emscripten_bind_btPairCachingGhostObject_getCollisionShape_0, _i64Subtract = Module._i64Subtract = asm._i64Subtract, _emscripten_bind_btCylinderShapeX_getMargin_0 = Module._emscripten_bind_btCylinderShapeX_getMargin_0 = asm._emscripten_bind_btCylinderShapeX_getMargin_0, _emscripten_bind_btRigidBody_setDamping_2 = Module._emscripten_bind_btRigidBody_setDamping_2 = asm._emscripten_bind_btRigidBody_setDamping_2, _emscripten_bind_btDynamicsWorld_getDispatcher_0 = Module._emscripten_bind_btDynamicsWorld_getDispatcher_0 = asm._emscripten_bind_btDynamicsWorld_getDispatcher_0, _emscripten_bind_btGhostObject_setCollisionFlags_1 = Module._emscripten_bind_btGhostObject_setCollisionFlags_1 = asm._emscripten_bind_btGhostObject_setCollisionFlags_1, _emscripten_bind_btMatrix3x3_getRotation_1 = Module._emscripten_bind_btMatrix3x3_getRotation_1 = asm._emscripten_bind_btMatrix3x3_getRotation_1, _emscripten_bind_btConeTwistConstraint_setMaxMotorImpulse_1 = Module._emscripten_bind_btConeTwistConstraint_setMaxMotorImpulse_1 = asm._emscripten_bind_btConeTwistConstraint_setMaxMotorImpulse_1, _emscripten_bind_btCylinderShapeX_setLocalScaling_1 = Module._emscripten_bind_btCylinderShapeX_setLocalScaling_1 = asm._emscripten_bind_btCylinderShapeX_setLocalScaling_1, _emscripten_bind_btDbvtBroadphase_btDbvtBroadphase_0 = Module._emscripten_bind_btDbvtBroadphase_btDbvtBroadphase_0 = asm._emscripten_bind_btDbvtBroadphase_btDbvtBroadphase_0, _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDamping_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDamping_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDamping_0, _emscripten_bind_btCompoundShape_setLocalScaling_1 = Module._emscripten_bind_btCompoundShape_setLocalScaling_1 = asm._emscripten_bind_btCompoundShape_setLocalScaling_1, _emscripten_bind_btOverlappingPairCallback___destroy___0 = Module._emscripten_bind_btOverlappingPairCallback___destroy___0 = asm._emscripten_bind_btOverlappingPairCallback___destroy___0, _emscripten_bind_btManifoldPoint_get_m_positionWorldOnB_0 = Module._emscripten_bind_btManifoldPoint_get_m_positionWorldOnB_0 = asm._emscripten_bind_btManifoldPoint_get_m_positionWorldOnB_0, _emscripten_bind_btCylinderShape_calculateLocalInertia_2 = Module._emscripten_bind_btCylinderShape_calculateLocalInertia_2 = asm._emscripten_bind_btCylinderShape_calculateLocalInertia_2, _emscripten_bind_btPairCachingGhostObject_setCcdSweptSphereRadius_1 = Module._emscripten_bind_btPairCachingGhostObject_setCcdSweptSphereRadius_1 = asm._emscripten_bind_btPairCachingGhostObject_setCcdSweptSphereRadius_1, _emscripten_bind_btRigidBody_getCollisionShape_0 = Module._emscripten_bind_btRigidBody_getCollisionShape_0 = asm._emscripten_bind_btRigidBody_getCollisionShape_0, _emscripten_bind_btRigidBody_setContactProcessingThreshold_1 = Module._emscripten_bind_btRigidBody_setContactProcessingThreshold_1 = asm._emscripten_bind_btRigidBody_setContactProcessingThreshold_1, _emscripten_bind_btRigidBody_getLinearVelocity_0 = Module._emscripten_bind_btRigidBody_getLinearVelocity_0 = asm._emscripten_bind_btRigidBody_getLinearVelocity_0, _emscripten_bind_btRigidBody_applyImpulse_2 = Module._emscripten_bind_btRigidBody_applyImpulse_2 = asm._emscripten_bind_btRigidBody_applyImpulse_2, _emscripten_bind_btConcaveShape_calculateLocalInertia_2 = Module._emscripten_bind_btConcaveShape_calculateLocalInertia_2 = asm._emscripten_bind_btConcaveShape_calculateLocalInertia_2, _emscripten_bind_btRigidBody_setWorldTransform_1 = Module._emscripten_bind_btRigidBody_setWorldTransform_1 = asm._emscripten_bind_btRigidBody_setWorldTransform_1, _emscripten_bind_btRigidBody_setAngularVelocity_1 = Module._emscripten_bind_btRigidBody_setAngularVelocity_1 = asm._emscripten_bind_btRigidBody_setAngularVelocity_1, _emscripten_bind_btCapsuleShape___destroy___0 = Module._emscripten_bind_btCapsuleShape___destroy___0 = asm._emscripten_bind_btCapsuleShape___destroy___0, _emscripten_bind_btConvexShape_setLocalScaling_1 = Module._emscripten_bind_btConvexShape_setLocalScaling_1 = asm._emscripten_bind_btConvexShape_setLocalScaling_1, _emscripten_bind_btTriangleMeshShape_calculateLocalInertia_2 = Module._emscripten_bind_btTriangleMeshShape_calculateLocalInertia_2 = asm._emscripten_bind_btTriangleMeshShape_calculateLocalInertia_2, _emscripten_bind_btGhostObject_getWorldTransform_0 = Module._emscripten_bind_btGhostObject_getWorldTransform_0 = asm._emscripten_bind_btGhostObject_getWorldTransform_0, _emscripten_bind_btPairCachingGhostObject_setContactProcessingThreshold_1 = Module._emscripten_bind_btPairCachingGhostObject_setContactProcessingThreshold_1 = asm._emscripten_bind_btPairCachingGhostObject_setContactProcessingThreshold_1, _emscripten_bind_btCompoundShape___destroy___0 = Module._emscripten_bind_btCompoundShape___destroy___0 = asm._emscripten_bind_btCompoundShape___destroy___0, _emscripten_bind_btGeneric6DofConstraint_setLinearUpperLimit_1 = Module._emscripten_bind_btGeneric6DofConstraint_setLinearUpperLimit_1 = asm._emscripten_bind_btGeneric6DofConstraint_setLinearUpperLimit_1, _emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterMask_0 = Module._emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterMask_0 = asm._emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterMask_0, _emscripten_bind_RayResultCallback_hasHit_0 = Module._emscripten_bind_RayResultCallback_hasHit_0 = asm._emscripten_bind_RayResultCallback_hasHit_0, _bitshift64Shl = Module._bitshift64Shl = asm._bitshift64Shl, _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingThresholdSqr_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingThresholdSqr_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingThresholdSqr_0, _emscripten_bind_btVehicleTuning_get_m_suspensionDamping_0 = Module._emscripten_bind_btVehicleTuning_get_m_suspensionDamping_0 = asm._emscripten_bind_btVehicleTuning_get_m_suspensionDamping_0, _emscripten_bind_btRaycastVehicle_getWheelTransformWS_1 = Module._emscripten_bind_btRaycastVehicle_getWheelTransformWS_1 = asm._emscripten_bind_btRaycastVehicle_getWheelTransformWS_1, _emscripten_bind_ClosestConvexResultCallback_get_m_convexToWorld_0 = Module._emscripten_bind_ClosestConvexResultCallback_get_m_convexToWorld_0 = asm._emscripten_bind_ClosestConvexResultCallback_get_m_convexToWorld_0, _emscripten_bind_btWheelInfo_get_m_frictionSlip_0 = Module._emscripten_bind_btWheelInfo_get_m_frictionSlip_0 = asm._emscripten_bind_btWheelInfo_get_m_frictionSlip_0, _emscripten_bind_btConeShapeZ_setLocalScaling_1 = Module._emscripten_bind_btConeShapeZ_setLocalScaling_1 = asm._emscripten_bind_btConeShapeZ_setLocalScaling_1, _emscripten_bind_btPairCachingGhostObject_setActivationState_1 = Module._emscripten_bind_btPairCachingGhostObject_setActivationState_1 = asm._emscripten_bind_btPairCachingGhostObject_setActivationState_1, _emscripten_bind_btGeneric6DofSpringConstraint___destroy___0 = Module._emscripten_bind_btGeneric6DofSpringConstraint___destroy___0 = asm._emscripten_bind_btGeneric6DofSpringConstraint___destroy___0, _emscripten_bind_btRaycastVehicle_getNumWheels_0 = Module._emscripten_bind_btRaycastVehicle_getNumWheels_0 = asm._emscripten_bind_btRaycastVehicle_getNumWheels_0, _emscripten_bind_btVehicleTuning_set_m_maxSuspensionTravelCm_1 = Module._emscripten_bind_btVehicleTuning_set_m_maxSuspensionTravelCm_1 = asm._emscripten_bind_btVehicleTuning_set_m_maxSuspensionTravelCm_1, _emscripten_bind_btGhostObject_setRollingFriction_1 = Module._emscripten_bind_btGhostObject_setRollingFriction_1 = asm._emscripten_bind_btGhostObject_setRollingFriction_1, _emscripten_bind_btCylinderShapeZ_btCylinderShapeZ_1 = Module._emscripten_bind_btCylinderShapeZ_btCylinderShapeZ_1 = asm._emscripten_bind_btCylinderShapeZ_btCylinderShapeZ_1, _emscripten_bind_btRigidBody_getAngularVelocity_0 = Module._emscripten_bind_btRigidBody_getAngularVelocity_0 = asm._emscripten_bind_btRigidBody_getAngularVelocity_0, _emscripten_bind_btCompoundShape_btCompoundShape_0 = Module._emscripten_bind_btCompoundShape_btCompoundShape_0 = asm._emscripten_bind_btCompoundShape_btCompoundShape_0, _emscripten_bind_btCompoundShape_btCompoundShape_1 = Module._emscripten_bind_btCompoundShape_btCompoundShape_1 = asm._emscripten_bind_btCompoundShape_btCompoundShape_1, _emscripten_bind_btOverlappingPairCache_setInternalGhostPairCallback_1 = Module._emscripten_bind_btOverlappingPairCache_setInternalGhostPairCallback_1 = asm._emscripten_bind_btOverlappingPairCache_setInternalGhostPairCallback_1, _emscripten_bind_btStaticPlaneShape_btStaticPlaneShape_2 = Module._emscripten_bind_btStaticPlaneShape_btStaticPlaneShape_2 = asm._emscripten_bind_btStaticPlaneShape_btStaticPlaneShape_2, _emscripten_bind_btDispatcherInfo_set_m_convexConservativeDistanceThreshold_1 = Module._emscripten_bind_btDispatcherInfo_set_m_convexConservativeDistanceThreshold_1 = asm._emscripten_bind_btDispatcherInfo_set_m_convexConservativeDistanceThreshold_1, _emscripten_bind_btRigidBody_btRigidBody_1 = Module._emscripten_bind_btRigidBody_btRigidBody_1 = asm._emscripten_bind_btRigidBody_btRigidBody_1, _emscripten_bind_btRigidBody_updateInertiaTensor_0 = Module._emscripten_bind_btRigidBody_updateInertiaTensor_0 = asm._emscripten_bind_btRigidBody_updateInertiaTensor_0, _emscripten_bind_btPairCachingGhostObject_setAnisotropicFriction_2 = Module._emscripten_bind_btPairCachingGhostObject_setAnisotropicFriction_2 = asm._emscripten_bind_btPairCachingGhostObject_setAnisotropicFriction_2, _emscripten_bind_btTransform_setOrigin_1 = Module._emscripten_bind_btTransform_setOrigin_1 = asm._emscripten_bind_btTransform_setOrigin_1, _emscripten_bind_ClosestRayResultCallback_hasHit_0 = Module._emscripten_bind_ClosestRayResultCallback_hasHit_0 = asm._emscripten_bind_ClosestRayResultCallback_hasHit_0, _emscripten_bind_btCompoundShape_addChildShape_2 = Module._emscripten_bind_btCompoundShape_addChildShape_2 = asm._emscripten_bind_btCompoundShape_addChildShape_2, _emscripten_bind_btDispatcher___destroy___0 = Module._emscripten_bind_btDispatcher___destroy___0 = asm._emscripten_bind_btDispatcher___destroy___0, _emscripten_bind_btVehicleTuning_get_m_suspensionCompression_0 = Module._emscripten_bind_btVehicleTuning_get_m_suspensionCompression_0 = asm._emscripten_bind_btVehicleTuning_get_m_suspensionCompression_0, _emscripten_bind_btDiscreteDynamicsWorld___destroy___0 = Module._emscripten_bind_btDiscreteDynamicsWorld___destroy___0 = asm._emscripten_bind_btDiscreteDynamicsWorld___destroy___0, _emscripten_bind_btConvexShape___destroy___0 = Module._emscripten_bind_btConvexShape___destroy___0 = asm._emscripten_bind_btConvexShape___destroy___0, _emscripten_bind_btCapsuleShapeX_setLocalScaling_1 = Module._emscripten_bind_btCapsuleShapeX_setLocalScaling_1 = asm._emscripten_bind_btCapsuleShapeX_setLocalScaling_1, _emscripten_bind_btCollisionObject_setRestitution_1 = Module._emscripten_bind_btCollisionObject_setRestitution_1 = asm._emscripten_bind_btCollisionObject_setRestitution_1, _emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_3 = Module._emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_3 = asm._emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_3, _emscripten_bind_LocalConvexResult_get_m_hitFraction_0 = Module._emscripten_bind_LocalConvexResult_get_m_hitFraction_0 = asm._emscripten_bind_LocalConvexResult_get_m_hitFraction_0, _emscripten_bind_btHingeConstraint_setBreakingImpulseThreshold_1 = Module._emscripten_bind_btHingeConstraint_setBreakingImpulseThreshold_1 = asm._emscripten_bind_btHingeConstraint_setBreakingImpulseThreshold_1, _emscripten_bind_btQuaternion_w_0 = Module._emscripten_bind_btQuaternion_w_0 = asm._emscripten_bind_btQuaternion_w_0, _emscripten_bind_ConvexResultCallback_get_m_collisionFilterGroup_0 = Module._emscripten_bind_ConvexResultCallback_get_m_collisionFilterGroup_0 = asm._emscripten_bind_ConvexResultCallback_get_m_collisionFilterGroup_0, _emscripten_bind_btTransform_getRotation_0 = Module._emscripten_bind_btTransform_getRotation_0 = asm._emscripten_bind_btTransform_getRotation_0, _emscripten_bind_btHingeConstraint_btHingeConstraint_6 = Module._emscripten_bind_btHingeConstraint_btHingeConstraint_6 = asm._emscripten_bind_btHingeConstraint_btHingeConstraint_6, _emscripten_bind_btHingeConstraint_btHingeConstraint_7 = Module._emscripten_bind_btHingeConstraint_btHingeConstraint_7 = asm._emscripten_bind_btHingeConstraint_btHingeConstraint_7, _emscripten_bind_btCapsuleShapeZ_getMargin_0 = Module._emscripten_bind_btCapsuleShapeZ_getMargin_0 = asm._emscripten_bind_btCapsuleShapeZ_getMargin_0, _emscripten_bind_btHingeConstraint_btHingeConstraint_5 = Module._emscripten_bind_btHingeConstraint_btHingeConstraint_5 = asm._emscripten_bind_btHingeConstraint_btHingeConstraint_5, _emscripten_bind_btHingeConstraint_btHingeConstraint_2 = Module._emscripten_bind_btHingeConstraint_btHingeConstraint_2 = asm._emscripten_bind_btHingeConstraint_btHingeConstraint_2, _emscripten_bind_btHingeConstraint_btHingeConstraint_3 = Module._emscripten_bind_btHingeConstraint_btHingeConstraint_3 = asm._emscripten_bind_btHingeConstraint_btHingeConstraint_3, _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingThresholdSqr_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingThresholdSqr_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingThresholdSqr_1, _emscripten_bind_btBoxShape_setMargin_1 = Module._emscripten_bind_btBoxShape_setMargin_1 = asm._emscripten_bind_btBoxShape_setMargin_1, _emscripten_bind_ClosestConvexResultCallback_get_m_hitNormalWorld_0 = Module._emscripten_bind_ClosestConvexResultCallback_get_m_hitNormalWorld_0 = asm._emscripten_bind_ClosestConvexResultCallback_get_m_hitNormalWorld_0, _emscripten_bind_btTypedConstraint___destroy___0 = Module._emscripten_bind_btTypedConstraint___destroy___0 = asm._emscripten_bind_btTypedConstraint___destroy___0, _emscripten_bind_btCylinderShapeX_btCylinderShapeX_1 = Module._emscripten_bind_btCylinderShapeX_btCylinderShapeX_1 = asm._emscripten_bind_btCylinderShapeX_btCylinderShapeX_1, _emscripten_bind_btGeneric6DofSpringConstraint_setAngularUpperLimit_1 = Module._emscripten_bind_btGeneric6DofSpringConstraint_setAngularUpperLimit_1 = asm._emscripten_bind_btGeneric6DofSpringConstraint_setAngularUpperLimit_1, _emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_3 = Module._emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_3 = asm._emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_3, _emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_1 = Module._emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_1 = asm._emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_1, _emscripten_bind_btVector3_z_0 = Module._emscripten_bind_btVector3_z_0 = asm._emscripten_bind_btVector3_z_0, _emscripten_bind_btSphereShape_btSphereShape_1 = Module._emscripten_bind_btSphereShape_btSphereShape_1 = asm._emscripten_bind_btSphereShape_btSphereShape_1, _emscripten_bind_btWheelInfo_get_m_wheelsSuspensionForce_0 = Module._emscripten_bind_btWheelInfo_get_m_wheelsSuspensionForce_0 = asm._emscripten_bind_btWheelInfo_get_m_wheelsSuspensionForce_0, _emscripten_bind_btQuaternion_y_0 = Module._emscripten_bind_btQuaternion_y_0 = asm._emscripten_bind_btQuaternion_y_0, _emscripten_bind_btCollisionWorld_addCollisionObject_1 = Module._emscripten_bind_btCollisionWorld_addCollisionObject_1 = asm._emscripten_bind_btCollisionWorld_addCollisionObject_1, _emscripten_bind_btCollisionWorld_addCollisionObject_2 = Module._emscripten_bind_btCollisionWorld_addCollisionObject_2 = asm._emscripten_bind_btCollisionWorld_addCollisionObject_2, _emscripten_bind_btRigidBody_setRestitution_1 = Module._emscripten_bind_btRigidBody_setRestitution_1 = asm._emscripten_bind_btRigidBody_setRestitution_1, _emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterGroup_1 = Module._emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterGroup_1 = asm._emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterGroup_1, _emscripten_bind_btConeTwistConstraint_setBreakingImpulseThreshold_1 = Module._emscripten_bind_btConeTwistConstraint_setBreakingImpulseThreshold_1 = asm._emscripten_bind_btConeTwistConstraint_setBreakingImpulseThreshold_1, _emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterGroup_0 = Module._emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterGroup_0 = asm._emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterGroup_0, _emscripten_bind_btCapsuleShape_setMargin_1 = Module._emscripten_bind_btCapsuleShape_setMargin_1 = asm._emscripten_bind_btCapsuleShape_setMargin_1, _emscripten_bind_btDefaultVehicleRaycaster_btDefaultVehicleRaycaster_1 = Module._emscripten_bind_btDefaultVehicleRaycaster_btDefaultVehicleRaycaster_1 = asm._emscripten_bind_btDefaultVehicleRaycaster_btDefaultVehicleRaycaster_1, _emscripten_bind_ConcreteContactResultCallback_addSingleResult_7 = Module._emscripten_bind_ConcreteContactResultCallback_addSingleResult_7 = asm._emscripten_bind_ConcreteContactResultCallback_addSingleResult_7, _emscripten_bind_btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver_0 = Module._emscripten_bind_btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver_0 = asm._emscripten_bind_btSequentialImpulseConstraintSolver_btSequentialImpulseConstraintSolver_0, _emscripten_bind_btActionInterface___destroy___0 = Module._emscripten_bind_btActionInterface___destroy___0 = asm._emscripten_bind_btActionInterface___destroy___0, _emscripten_bind_btDefaultMotionState_setWorldTransform_1 = Module._emscripten_bind_btDefaultMotionState_setWorldTransform_1 = asm._emscripten_bind_btDefaultMotionState_setWorldTransform_1, _emscripten_bind_btGeneric6DofSpringConstraint_setDamping_2 = Module._emscripten_bind_btGeneric6DofSpringConstraint_setDamping_2 = asm._emscripten_bind_btGeneric6DofSpringConstraint_setDamping_2, _emscripten_bind_RayResultCallback_get_m_collisionObject_0 = Module._emscripten_bind_RayResultCallback_get_m_collisionObject_0 = asm._emscripten_bind_RayResultCallback_get_m_collisionObject_0, _emscripten_bind_btPoint2PointConstraint_getPivotInA_0 = Module._emscripten_bind_btPoint2PointConstraint_getPivotInA_0 = asm._emscripten_bind_btPoint2PointConstraint_getPivotInA_0, _emscripten_bind_ClosestConvexResultCallback_get_m_convexFromWorld_0 = Module._emscripten_bind_ClosestConvexResultCallback_get_m_convexFromWorld_0 = asm._emscripten_bind_ClosestConvexResultCallback_get_m_convexFromWorld_0, _emscripten_bind_btVector4_setY_1 = Module._emscripten_bind_btVector4_setY_1 = asm._emscripten_bind_btVector4_setY_1, _emscripten_bind_btCompoundShape_setMargin_1 = Module._emscripten_bind_btCompoundShape_setMargin_1 = asm._emscripten_bind_btCompoundShape_setMargin_1, _emscripten_bind_btGhostObject_setRestitution_1 = Module._emscripten_bind_btGhostObject_setRestitution_1 = asm._emscripten_bind_btGhostObject_setRestitution_1, _emscripten_bind_btDynamicsWorld_addCollisionObject_1 = Module._emscripten_bind_btDynamicsWorld_addCollisionObject_1 = asm._emscripten_bind_btDynamicsWorld_addCollisionObject_1, _emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterMask_0 = Module._emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterMask_0 = asm._emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterMask_0, _emscripten_bind_btDynamicsWorld_addCollisionObject_2 = (Module.___cxa_can_catch = asm.___cxa_can_catch, 
    Module._emscripten_bind_btDynamicsWorld_addCollisionObject_2 = asm._emscripten_bind_btDynamicsWorld_addCollisionObject_2), _emscripten_bind_btDiscreteDynamicsWorld_getDispatcher_0 = Module._emscripten_bind_btDiscreteDynamicsWorld_getDispatcher_0 = asm._emscripten_bind_btDiscreteDynamicsWorld_getDispatcher_0, _emscripten_bind_btWheelInfo_get_m_maxSuspensionTravelCm_0 = Module._emscripten_bind_btWheelInfo_get_m_maxSuspensionTravelCm_0 = asm._emscripten_bind_btWheelInfo_get_m_maxSuspensionTravelCm_0, _emscripten_bind_btVector4_op_mul_1 = Module._emscripten_bind_btVector4_op_mul_1 = asm._emscripten_bind_btVector4_op_mul_1, _emscripten_bind_btCylinderShape_btCylinderShape_1 = Module._emscripten_bind_btCylinderShape_btCylinderShape_1 = asm._emscripten_bind_btCylinderShape_btCylinderShape_1, _emscripten_bind_btVector3___destroy___0 = Module._emscripten_bind_btVector3___destroy___0 = asm._emscripten_bind_btVector3___destroy___0, _emscripten_bind_btRigidBody_setAngularFactor_1 = Module._emscripten_bind_btRigidBody_setAngularFactor_1 = asm._emscripten_bind_btRigidBody_setAngularFactor_1, _emscripten_bind_btCylinderShapeZ_calculateLocalInertia_2 = Module._emscripten_bind_btCylinderShapeZ_calculateLocalInertia_2 = asm._emscripten_bind_btCylinderShapeZ_calculateLocalInertia_2, _emscripten_bind_LocalShapeInfo_set_m_triangleIndex_1 = Module._emscripten_bind_LocalShapeInfo_set_m_triangleIndex_1 = asm._emscripten_bind_LocalShapeInfo_set_m_triangleIndex_1, _emscripten_bind_btMotionState_getWorldTransform_1 = Module._emscripten_bind_btMotionState_getWorldTransform_1 = asm._emscripten_bind_btMotionState_getWorldTransform_1, _emscripten_bind_btDynamicsWorld_getSolverInfo_0 = Module._emscripten_bind_btDynamicsWorld_getSolverInfo_0 = asm._emscripten_bind_btDynamicsWorld_getSolverInfo_0, _emscripten_bind_btDynamicsWorld_getBroadphase_0 = Module._emscripten_bind_btDynamicsWorld_getBroadphase_0 = asm._emscripten_bind_btDynamicsWorld_getBroadphase_0, _emscripten_bind_btSphereShape_getMargin_0 = Module._emscripten_bind_btSphereShape_getMargin_0 = asm._emscripten_bind_btSphereShape_getMargin_0, _emscripten_bind_btVector3_x_0 = Module._emscripten_bind_btVector3_x_0 = asm._emscripten_bind_btVector3_x_0, _emscripten_bind_btWheelInfo_get_m_wheelsDampingCompression_0 = (Module.___cxa_is_pointer_type = asm.___cxa_is_pointer_type, 
    Module._emscripten_bind_btWheelInfo_get_m_wheelsDampingCompression_0 = asm._emscripten_bind_btWheelInfo_get_m_wheelsDampingCompression_0), _emscripten_bind_btCollisionObject_getCollisionShape_0 = Module._emscripten_bind_btCollisionObject_getCollisionShape_0 = asm._emscripten_bind_btCollisionObject_getCollisionShape_0, _emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_4 = Module._emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_4 = asm._emscripten_bind_btRigidBodyConstructionInfo_btRigidBodyConstructionInfo_4, _emscripten_bind_btManifoldPoint___destroy___0 = Module._emscripten_bind_btManifoldPoint___destroy___0 = asm._emscripten_bind_btManifoldPoint___destroy___0, _emscripten_bind_btRigidBodyConstructionInfo_set_m_rollingFriction_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_rollingFriction_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_rollingFriction_1, _emscripten_bind_btVector4_length_0 = Module._emscripten_bind_btVector4_length_0 = asm._emscripten_bind_btVector4_length_0, _emscripten_bind_btDefaultMotionState_set_m_graphicsWorldTrans_1 = Module._emscripten_bind_btDefaultMotionState_set_m_graphicsWorldTrans_1 = asm._emscripten_bind_btDefaultMotionState_set_m_graphicsWorldTrans_1, _emscripten_bind_ClosestConvexResultCallback___destroy___0 = Module._emscripten_bind_ClosestConvexResultCallback___destroy___0 = asm._emscripten_bind_ClosestConvexResultCallback___destroy___0, _emscripten_bind_btConeTwistConstraint_setAngularOnly_1 = Module._emscripten_bind_btConeTwistConstraint_setAngularOnly_1 = asm._emscripten_bind_btConeTwistConstraint_setAngularOnly_1, _emscripten_bind_btCollisionObject_setFriction_1 = Module._emscripten_bind_btCollisionObject_setFriction_1 = asm._emscripten_bind_btCollisionObject_setFriction_1, _emscripten_bind_btDefaultCollisionConfiguration___destroy___0 = Module._emscripten_bind_btDefaultCollisionConfiguration___destroy___0 = asm._emscripten_bind_btDefaultCollisionConfiguration___destroy___0, _emscripten_bind_btRigidBody_setMassProps_2 = Module._emscripten_bind_btRigidBody_setMassProps_2 = asm._emscripten_bind_btRigidBody_setMassProps_2, _emscripten_bind_btVector3_setValue_3 = Module._emscripten_bind_btVector3_setValue_3 = asm._emscripten_bind_btVector3_setValue_3, _emscripten_bind_btPairCachingGhostObject_setCcdMotionThreshold_1 = Module._emscripten_bind_btPairCachingGhostObject_setCcdMotionThreshold_1 = asm._emscripten_bind_btPairCachingGhostObject_setCcdMotionThreshold_1, _emscripten_bind_btGhostObject_getCollisionFlags_0 = Module._emscripten_bind_btGhostObject_getCollisionFlags_0 = asm._emscripten_bind_btGhostObject_getCollisionFlags_0, _emscripten_bind_btCapsuleShapeX___destroy___0 = Module._emscripten_bind_btCapsuleShapeX___destroy___0 = asm._emscripten_bind_btCapsuleShapeX___destroy___0, _emscripten_bind_btHingeConstraint_setLimit_4 = Module._emscripten_bind_btHingeConstraint_setLimit_4 = asm._emscripten_bind_btHingeConstraint_setLimit_4, _emscripten_bind_btHingeConstraint_setLimit_5 = Module._emscripten_bind_btHingeConstraint_setLimit_5 = asm._emscripten_bind_btHingeConstraint_setLimit_5, _emscripten_bind_btDefaultVehicleRaycaster___destroy___0 = Module._emscripten_bind_btDefaultVehicleRaycaster___destroy___0 = asm._emscripten_bind_btDefaultVehicleRaycaster___destroy___0, _emscripten_bind_btWheelInfo_get_m_wheelsDampingRelaxation_0 = Module._emscripten_bind_btWheelInfo_get_m_wheelsDampingRelaxation_0 = asm._emscripten_bind_btWheelInfo_get_m_wheelsDampingRelaxation_0, _emscripten_bind_btWheelInfo_set_m_maxSuspensionTravelCm_1 = Module._emscripten_bind_btWheelInfo_set_m_maxSuspensionTravelCm_1 = asm._emscripten_bind_btWheelInfo_set_m_maxSuspensionTravelCm_1, _emscripten_bind_btConeShape_setLocalScaling_1 = Module._emscripten_bind_btConeShape_setLocalScaling_1 = asm._emscripten_bind_btConeShape_setLocalScaling_1, _emscripten_bind_btGhostObject_getNumOverlappingObjects_0 = Module._emscripten_bind_btGhostObject_getNumOverlappingObjects_0 = asm._emscripten_bind_btGhostObject_getNumOverlappingObjects_0, _emscripten_bind_btTypedConstraint_getBreakingImpulseThreshold_0 = Module._emscripten_bind_btTypedConstraint_getBreakingImpulseThreshold_0 = asm._emscripten_bind_btTypedConstraint_getBreakingImpulseThreshold_0, _emscripten_bind_btGhostObject_getCollisionShape_0 = Module._emscripten_bind_btGhostObject_getCollisionShape_0 = asm._emscripten_bind_btGhostObject_getCollisionShape_0, _emscripten_bind_btCollisionObject_setAnisotropicFriction_2 = Module._emscripten_bind_btCollisionObject_setAnisotropicFriction_2 = asm._emscripten_bind_btCollisionObject_setAnisotropicFriction_2, _emscripten_bind_btBoxShape___destroy___0 = Module._emscripten_bind_btBoxShape___destroy___0 = asm._emscripten_bind_btBoxShape___destroy___0, _emscripten_bind_btPersistentManifold_getContactPoint_1 = Module._emscripten_bind_btPersistentManifold_getContactPoint_1 = asm._emscripten_bind_btPersistentManifold_getContactPoint_1, _emscripten_bind_btGeneric6DofSpringConstraint_getBreakingImpulseThreshold_0 = Module._emscripten_bind_btGeneric6DofSpringConstraint_getBreakingImpulseThreshold_0 = asm._emscripten_bind_btGeneric6DofSpringConstraint_getBreakingImpulseThreshold_0, _emscripten_bind_btConeShapeX_calculateLocalInertia_2 = Module._emscripten_bind_btConeShapeX_calculateLocalInertia_2 = asm._emscripten_bind_btConeShapeX_calculateLocalInertia_2, _emscripten_bind_btGhostObject_activate_0 = Module._emscripten_bind_btGhostObject_activate_0 = asm._emscripten_bind_btGhostObject_activate_0, _emscripten_bind_btGhostObject_activate_1 = Module._emscripten_bind_btGhostObject_activate_1 = asm._emscripten_bind_btGhostObject_activate_1, _emscripten_bind_btGeneric6DofSpringConstraint_enableSpring_2 = Module._emscripten_bind_btGeneric6DofSpringConstraint_enableSpring_2 = asm._emscripten_bind_btGeneric6DofSpringConstraint_enableSpring_2, _emscripten_bind_btManifoldPoint_getPositionWorldOnB_0 = Module._emscripten_bind_btManifoldPoint_getPositionWorldOnB_0 = asm._emscripten_bind_btManifoldPoint_getPositionWorldOnB_0, _emscripten_bind_btManifoldPoint_get_m_positionWorldOnA_0 = Module._emscripten_bind_btManifoldPoint_get_m_positionWorldOnA_0 = asm._emscripten_bind_btManifoldPoint_get_m_positionWorldOnA_0, _emscripten_bind_btGeneric6DofSpringConstraint_enableFeedback_1 = Module._emscripten_bind_btGeneric6DofSpringConstraint_enableFeedback_1 = asm._emscripten_bind_btGeneric6DofSpringConstraint_enableFeedback_1, _emscripten_bind_btSphereShape_setMargin_1 = Module._emscripten_bind_btSphereShape_setMargin_1 = asm._emscripten_bind_btSphereShape_setMargin_1, _emscripten_bind_btPoint2PointConstraint_get_m_setting_0 = Module._emscripten_bind_btPoint2PointConstraint_get_m_setting_0 = asm._emscripten_bind_btPoint2PointConstraint_get_m_setting_0, _emscripten_bind_btConeShapeZ_btConeShapeZ_2 = Module._emscripten_bind_btConeShapeZ_btConeShapeZ_2 = asm._emscripten_bind_btConeShapeZ_btConeShapeZ_2, _emscripten_bind_btPairCachingGhostObject_setRollingFriction_1 = Module._emscripten_bind_btPairCachingGhostObject_setRollingFriction_1 = asm._emscripten_bind_btPairCachingGhostObject_setRollingFriction_1, _emscripten_bind_btSliderConstraint_setUpperAngLimit_1 = Module._emscripten_bind_btSliderConstraint_setUpperAngLimit_1 = asm._emscripten_bind_btSliderConstraint_setUpperAngLimit_1, _emscripten_bind_btDynamicsWorld_contactPairTest_3 = Module._emscripten_bind_btDynamicsWorld_contactPairTest_3 = asm._emscripten_bind_btDynamicsWorld_contactPairTest_3, _emscripten_bind_btCollisionWorld_getPairCache_0 = Module._emscripten_bind_btCollisionWorld_getPairCache_0 = asm._emscripten_bind_btCollisionWorld_getPairCache_0, _emscripten_bind_btConeTwistConstraint_setMotorTarget_1 = Module._emscripten_bind_btConeTwistConstraint_setMotorTarget_1 = asm._emscripten_bind_btConeTwistConstraint_setMotorTarget_1, _emscripten_bind_ClosestConvexResultCallback_set_m_convexFromWorld_1 = Module._emscripten_bind_ClosestConvexResultCallback_set_m_convexFromWorld_1 = asm._emscripten_bind_ClosestConvexResultCallback_set_m_convexFromWorld_1, _emscripten_bind_btWheelInfo_set_m_rollInfluence_1 = Module._emscripten_bind_btWheelInfo_set_m_rollInfluence_1 = asm._emscripten_bind_btWheelInfo_set_m_rollInfluence_1, _emscripten_bind_btRigidBody_getWorldTransform_0 = Module._emscripten_bind_btRigidBody_getWorldTransform_0 = asm._emscripten_bind_btRigidBody_getWorldTransform_0, _emscripten_bind_btDefaultCollisionConstructionInfo_btDefaultCollisionConstructionInfo_0 = Module._emscripten_bind_btDefaultCollisionConstructionInfo_btDefaultCollisionConstructionInfo_0 = asm._emscripten_bind_btDefaultCollisionConstructionInfo_btDefaultCollisionConstructionInfo_0, _emscripten_bind_btGhostObject_forceActivationState_1 = Module._emscripten_bind_btGhostObject_forceActivationState_1 = asm._emscripten_bind_btGhostObject_forceActivationState_1, _emscripten_bind_ConcreteContactResultCallback_ConcreteContactResultCallback_0 = Module._emscripten_bind_ConcreteContactResultCallback_ConcreteContactResultCallback_0 = asm._emscripten_bind_ConcreteContactResultCallback_ConcreteContactResultCallback_0, _emscripten_bind_VoidPtr___destroy___0 = Module._emscripten_bind_VoidPtr___destroy___0 = asm._emscripten_bind_VoidPtr___destroy___0, _emscripten_bind_btSliderConstraint_setLowerAngLimit_1 = Module._emscripten_bind_btSliderConstraint_setLowerAngLimit_1 = asm._emscripten_bind_btSliderConstraint_setLowerAngLimit_1, _emscripten_bind_btConeShape_btConeShape_2 = Module._emscripten_bind_btConeShape_btConeShape_2 = asm._emscripten_bind_btConeShape_btConeShape_2, _emscripten_bind_ClosestRayResultCallback_get_m_rayFromWorld_0 = Module._emscripten_bind_ClosestRayResultCallback_get_m_rayFromWorld_0 = asm._emscripten_bind_ClosestRayResultCallback_get_m_rayFromWorld_0, _emscripten_bind_btRaycastVehicle_getRigidBody_0 = Module._emscripten_bind_btRaycastVehicle_getRigidBody_0 = asm._emscripten_bind_btRaycastVehicle_getRigidBody_0, _emscripten_bind_RayResultCallback_get_m_collisionFilterGroup_0 = Module._emscripten_bind_RayResultCallback_get_m_collisionFilterGroup_0 = asm._emscripten_bind_RayResultCallback_get_m_collisionFilterGroup_0, _emscripten_bind_btWheelInfo_get_m_steering_0 = Module._emscripten_bind_btWheelInfo_get_m_steering_0 = asm._emscripten_bind_btWheelInfo_get_m_steering_0, _emscripten_bind_btConstraintSetting_get_m_tau_0 = Module._emscripten_bind_btConstraintSetting_get_m_tau_0 = asm._emscripten_bind_btConstraintSetting_get_m_tau_0, _emscripten_bind_btWheelInfo_set_m_wheelsSuspensionForce_1 = Module._emscripten_bind_btWheelInfo_set_m_wheelsSuspensionForce_1 = asm._emscripten_bind_btWheelInfo_set_m_wheelsSuspensionForce_1, _emscripten_bind_btCollisionShape___destroy___0 = Module._emscripten_bind_btCollisionShape___destroy___0 = asm._emscripten_bind_btCollisionShape___destroy___0, _emscripten_bind_ConvexResultCallback_get_m_closestHitFraction_0 = Module._emscripten_bind_ConvexResultCallback_get_m_closestHitFraction_0 = asm._emscripten_bind_ConvexResultCallback_get_m_closestHitFraction_0, _emscripten_bind_btDispatcherInfo_get_m_dispatchFunc_0 = Module._emscripten_bind_btDispatcherInfo_get_m_dispatchFunc_0 = asm._emscripten_bind_btDispatcherInfo_get_m_dispatchFunc_0, _emscripten_bind_btRigidBodyConstructionInfo_get_m_rollingFriction_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_rollingFriction_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_rollingFriction_0, _emscripten_bind_btPairCachingGhostObject_setCollisionShape_1 = Module._emscripten_bind_btPairCachingGhostObject_setCollisionShape_1 = asm._emscripten_bind_btPairCachingGhostObject_setCollisionShape_1, _emscripten_bind_btKinematicCharacterController_warp_1 = Module._emscripten_bind_btKinematicCharacterController_warp_1 = asm._emscripten_bind_btKinematicCharacterController_warp_1, _emscripten_bind_btGhostObject_setCcdSweptSphereRadius_1 = Module._emscripten_bind_btGhostObject_setCcdSweptSphereRadius_1 = asm._emscripten_bind_btGhostObject_setCcdSweptSphereRadius_1, _emscripten_bind_btTriangleMesh___destroy___0 = Module._emscripten_bind_btTriangleMesh___destroy___0 = asm._emscripten_bind_btTriangleMesh___destroy___0, _emscripten_bind_btKinematicCharacterController_preStep_1 = Module._emscripten_bind_btKinematicCharacterController_preStep_1 = asm._emscripten_bind_btKinematicCharacterController_preStep_1, _emscripten_bind_btRaycastVehicle_applyEngineForce_2 = Module._emscripten_bind_btRaycastVehicle_applyEngineForce_2 = asm._emscripten_bind_btRaycastVehicle_applyEngineForce_2, _emscripten_bind_btRaycastVehicle_setBrake_2 = Module._emscripten_bind_btRaycastVehicle_setBrake_2 = asm._emscripten_bind_btRaycastVehicle_setBrake_2, _emscripten_bind_ConcreteContactResultCallback___destroy___0 = Module._emscripten_bind_ConcreteContactResultCallback___destroy___0 = asm._emscripten_bind_ConcreteContactResultCallback___destroy___0, _emscripten_bind_btCollisionObject___destroy___0 = Module._emscripten_bind_btCollisionObject___destroy___0 = asm._emscripten_bind_btCollisionObject___destroy___0, _emscripten_bind_btVehicleTuning_set_m_suspensionDamping_1 = Module._emscripten_bind_btVehicleTuning_set_m_suspensionDamping_1 = asm._emscripten_bind_btVehicleTuning_set_m_suspensionDamping_1, _emscripten_bind_btRigidBodyConstructionInfo_set_m_linearSleepingThreshold_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_linearSleepingThreshold_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_linearSleepingThreshold_1, _emscripten_bind_btConeTwistConstraint_setMotorTargetInConstraintSpace_1 = Module._emscripten_bind_btConeTwistConstraint_setMotorTargetInConstraintSpace_1 = asm._emscripten_bind_btConeTwistConstraint_setMotorTargetInConstraintSpace_1, _emscripten_bind_btDispatcherInfo_set_m_timeStep_1 = Module._emscripten_bind_btDispatcherInfo_set_m_timeStep_1 = asm._emscripten_bind_btDispatcherInfo_set_m_timeStep_1, _emscripten_bind_btVector3_btVector3_3 = Module._emscripten_bind_btVector3_btVector3_3 = asm._emscripten_bind_btVector3_btVector3_3, _emscripten_bind_btVector3_btVector3_0 = Module._emscripten_bind_btVector3_btVector3_0 = asm._emscripten_bind_btVector3_btVector3_0, _emscripten_bind_btRigidBodyConstructionInfo_set_m_friction_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_friction_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_friction_1, _emscripten_bind_btDiscreteDynamicsWorld_getGravity_0 = Module._emscripten_bind_btDiscreteDynamicsWorld_getGravity_0 = asm._emscripten_bind_btDiscreteDynamicsWorld_getGravity_0, _emscripten_bind_btDispatcherInfo_get_m_allowedCcdPenetration_0 = Module._emscripten_bind_btDispatcherInfo_get_m_allowedCcdPenetration_0 = asm._emscripten_bind_btDispatcherInfo_get_m_allowedCcdPenetration_0, _emscripten_bind_ClosestConvexResultCallback_get_m_hitPointWorld_0 = Module._emscripten_bind_ClosestConvexResultCallback_get_m_hitPointWorld_0 = asm._emscripten_bind_ClosestConvexResultCallback_get_m_hitPointWorld_0, _emscripten_bind_btBroadphaseInterface___destroy___0 = Module._emscripten_bind_btBroadphaseInterface___destroy___0 = asm._emscripten_bind_btBroadphaseInterface___destroy___0, _emscripten_bind_btRigidBody_isKinematicObject_0 = Module._emscripten_bind_btRigidBody_isKinematicObject_0 = asm._emscripten_bind_btRigidBody_isKinematicObject_0, _emscripten_bind_btConeTwistConstraint___destroy___0 = Module._emscripten_bind_btConeTwistConstraint___destroy___0 = asm._emscripten_bind_btConeTwistConstraint___destroy___0, _emscripten_bind_btQuadWord___destroy___0 = Module._emscripten_bind_btQuadWord___destroy___0 = asm._emscripten_bind_btQuadWord___destroy___0, _emscripten_bind_ClosestRayResultCallback_set_m_rayFromWorld_1 = Module._emscripten_bind_ClosestRayResultCallback_set_m_rayFromWorld_1 = asm._emscripten_bind_ClosestRayResultCallback_set_m_rayFromWorld_1, _emscripten_bind_btWheelInfo_get_m_chassisConnectionPointCS_0 = Module._emscripten_bind_btWheelInfo_get_m_chassisConnectionPointCS_0 = asm._emscripten_bind_btWheelInfo_get_m_chassisConnectionPointCS_0, _emscripten_bind_btGhostObject_setAnisotropicFriction_2 = Module._emscripten_bind_btGhostObject_setAnisotropicFriction_2 = asm._emscripten_bind_btGhostObject_setAnisotropicFriction_2, _emscripten_bind_btConstraintSolver___destroy___0 = Module._emscripten_bind_btConstraintSolver___destroy___0 = asm._emscripten_bind_btConstraintSolver___destroy___0, _emscripten_bind_btDbvtBroadphase___destroy___0 = Module._emscripten_bind_btDbvtBroadphase___destroy___0 = asm._emscripten_bind_btDbvtBroadphase___destroy___0, _emscripten_bind_btCapsuleShape_btCapsuleShape_2 = Module._emscripten_bind_btCapsuleShape_btCapsuleShape_2 = asm._emscripten_bind_btCapsuleShape_btCapsuleShape_2, _emscripten_bind_btTypedConstraint_enableFeedback_1 = Module._emscripten_bind_btTypedConstraint_enableFeedback_1 = asm._emscripten_bind_btTypedConstraint_enableFeedback_1, _emscripten_bind_btCapsuleShape_setLocalScaling_1 = Module._emscripten_bind_btCapsuleShape_setLocalScaling_1 = asm._emscripten_bind_btCapsuleShape_setLocalScaling_1, _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDampingFactor_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDampingFactor_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDampingFactor_0, _emscripten_bind_btRigidBody_setAnisotropicFriction_2 = Module._emscripten_bind_btRigidBody_setAnisotropicFriction_2 = asm._emscripten_bind_btRigidBody_setAnisotropicFriction_2, _emscripten_bind_btTriangleMeshShape_setLocalScaling_1 = Module._emscripten_bind_btTriangleMeshShape_setLocalScaling_1 = asm._emscripten_bind_btTriangleMeshShape_setLocalScaling_1, _emscripten_bind_ConvexResultCallback_set_m_closestHitFraction_1 = Module._emscripten_bind_ConvexResultCallback_set_m_closestHitFraction_1 = asm._emscripten_bind_ConvexResultCallback_set_m_closestHitFraction_1, _emscripten_bind_btPersistentManifold_btPersistentManifold_0 = Module._emscripten_bind_btPersistentManifold_btPersistentManifold_0 = asm._emscripten_bind_btPersistentManifold_btPersistentManifold_0, _emscripten_bind_ConvexResultCallback_get_m_collisionFilterMask_0 = Module._emscripten_bind_ConvexResultCallback_get_m_collisionFilterMask_0 = asm._emscripten_bind_ConvexResultCallback_get_m_collisionFilterMask_0, _emscripten_bind_ClosestRayResultCallback_ClosestRayResultCallback_2 = Module._emscripten_bind_ClosestRayResultCallback_ClosestRayResultCallback_2 = asm._emscripten_bind_ClosestRayResultCallback_ClosestRayResultCallback_2, _emscripten_bind_btVector4___destroy___0 = Module._emscripten_bind_btVector4___destroy___0 = asm._emscripten_bind_btVector4___destroy___0, _emscripten_bind_btPairCachingGhostObject_isKinematicObject_0 = Module._emscripten_bind_btPairCachingGhostObject_isKinematicObject_0 = asm._emscripten_bind_btPairCachingGhostObject_isKinematicObject_0, _emscripten_bind_btConstraintSetting_get_m_damping_0 = Module._emscripten_bind_btConstraintSetting_get_m_damping_0 = asm._emscripten_bind_btConstraintSetting_get_m_damping_0, _i64Add = Module._i64Add = asm._i64Add, _emscripten_bind_btContactSolverInfo_set_m_splitImpulse_1 = Module._emscripten_bind_btContactSolverInfo_set_m_splitImpulse_1 = asm._emscripten_bind_btContactSolverInfo_set_m_splitImpulse_1, _emscripten_bind_btVehicleTuning_set_m_maxSuspensionForce_1 = Module._emscripten_bind_btVehicleTuning_set_m_maxSuspensionForce_1 = asm._emscripten_bind_btVehicleTuning_set_m_maxSuspensionForce_1, _emscripten_bind_btCollisionObject_setCcdMotionThreshold_1 = Module._emscripten_bind_btCollisionObject_setCcdMotionThreshold_1 = asm._emscripten_bind_btCollisionObject_setCcdMotionThreshold_1, _emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_4 = Module._emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_4 = asm._emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_4, _emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_1 = Module._emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_1 = asm._emscripten_bind_btDefaultCollisionConfiguration_btDefaultCollisionConfiguration_1, _emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_3 = Module._emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_3 = asm._emscripten_bind_btKinematicCharacterController_btKinematicCharacterController_3, _emscripten_bind_btRigidBodyConstructionInfo_get_m_angularSleepingThreshold_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_angularSleepingThreshold_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_angularSleepingThreshold_0, _emscripten_bind_btPoint2PointConstraint_getPivotInB_0 = Module._emscripten_bind_btPoint2PointConstraint_getPivotInB_0 = asm._emscripten_bind_btPoint2PointConstraint_getPivotInB_0, _emscripten_bind_btKinematicCharacterController_playerStep_2 = Module._emscripten_bind_btKinematicCharacterController_playerStep_2 = asm._emscripten_bind_btKinematicCharacterController_playerStep_2, _emscripten_bind_btDispatcherInfo___destroy___0 = Module._emscripten_bind_btDispatcherInfo___destroy___0 = asm._emscripten_bind_btDispatcherInfo___destroy___0, _emscripten_bind_btCapsuleShape_getMargin_0 = Module._emscripten_bind_btCapsuleShape_getMargin_0 = asm._emscripten_bind_btCapsuleShape_getMargin_0, _emscripten_bind_btCylinderShape_getMargin_0 = Module._emscripten_bind_btCylinderShape_getMargin_0 = asm._emscripten_bind_btCylinderShape_getMargin_0, _emscripten_bind_btStaticPlaneShape_setLocalScaling_1 = Module._emscripten_bind_btStaticPlaneShape_setLocalScaling_1 = asm._emscripten_bind_btStaticPlaneShape_setLocalScaling_1, _emscripten_bind_btConvexTriangleMeshShape_calculateLocalInertia_2 = Module._emscripten_bind_btConvexTriangleMeshShape_calculateLocalInertia_2 = asm._emscripten_bind_btConvexTriangleMeshShape_calculateLocalInertia_2, _emscripten_bind_ContactResultCallback_addSingleResult_7 = Module._emscripten_bind_ContactResultCallback_addSingleResult_7 = asm._emscripten_bind_ContactResultCallback_addSingleResult_7, _emscripten_bind_btCapsuleShapeX_setMargin_1 = Module._emscripten_bind_btCapsuleShapeX_setMargin_1 = asm._emscripten_bind_btCapsuleShapeX_setMargin_1, _emscripten_bind_btDiscreteDynamicsWorld_getPairCache_0 = Module._emscripten_bind_btDiscreteDynamicsWorld_getPairCache_0 = asm._emscripten_bind_btDiscreteDynamicsWorld_getPairCache_0, _emscripten_bind_LocalConvexResult_set_m_hitFraction_1 = Module._emscripten_bind_LocalConvexResult_set_m_hitFraction_1 = asm._emscripten_bind_LocalConvexResult_set_m_hitFraction_1, _emscripten_bind_btCapsuleShapeZ_calculateLocalInertia_2 = Module._emscripten_bind_btCapsuleShapeZ_calculateLocalInertia_2 = asm._emscripten_bind_btCapsuleShapeZ_calculateLocalInertia_2, _emscripten_bind_btDispatcherInfo_get_m_timeStep_0 = Module._emscripten_bind_btDispatcherInfo_get_m_timeStep_0 = asm._emscripten_bind_btDispatcherInfo_get_m_timeStep_0, _emscripten_bind_btVehicleTuning_set_m_suspensionCompression_1 = Module._emscripten_bind_btVehicleTuning_set_m_suspensionCompression_1 = asm._emscripten_bind_btVehicleTuning_set_m_suspensionCompression_1, _emscripten_bind_btBoxShape_calculateLocalInertia_2 = Module._emscripten_bind_btBoxShape_calculateLocalInertia_2 = asm._emscripten_bind_btBoxShape_calculateLocalInertia_2, _emscripten_bind_btMotionState___destroy___0 = Module._emscripten_bind_btMotionState___destroy___0 = asm._emscripten_bind_btMotionState___destroy___0, _emscripten_bind_btCollisionObject_setCollisionFlags_1 = Module._emscripten_bind_btCollisionObject_setCollisionFlags_1 = asm._emscripten_bind_btCollisionObject_setCollisionFlags_1, _emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_1 = Module._emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_1 = asm._emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_1, _emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_2 = Module._emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_2 = asm._emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_2, _emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_3 = Module._emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_3 = asm._emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_3, _emscripten_bind_btWheelInfo_set_m_suspensionStiffness_1 = Module._emscripten_bind_btWheelInfo_set_m_suspensionStiffness_1 = asm._emscripten_bind_btWheelInfo_set_m_suspensionStiffness_1, _emscripten_bind_btConvexTriangleMeshShape___destroy___0 = Module._emscripten_bind_btConvexTriangleMeshShape___destroy___0 = asm._emscripten_bind_btConvexTriangleMeshShape___destroy___0, _emscripten_bind_btDispatcher_getManifoldByIndexInternal_1 = Module._emscripten_bind_btDispatcher_getManifoldByIndexInternal_1 = asm._emscripten_bind_btDispatcher_getManifoldByIndexInternal_1, _emscripten_bind_btRaycastVehicle_getWheelInfo_1 = Module._emscripten_bind_btRaycastVehicle_getWheelInfo_1 = asm._emscripten_bind_btRaycastVehicle_getWheelInfo_1, _bitshift64Lshr = Module._bitshift64Lshr = asm._bitshift64Lshr, _emscripten_bind_btWheelInfo_set_m_steering_1 = Module._emscripten_bind_btWheelInfo_set_m_steering_1 = asm._emscripten_bind_btWheelInfo_set_m_steering_1, _emscripten_bind_btPairCachingGhostObject_setWorldTransform_1 = Module._emscripten_bind_btPairCachingGhostObject_setWorldTransform_1 = asm._emscripten_bind_btPairCachingGhostObject_setWorldTransform_1, _emscripten_bind_btHingeConstraint_getBreakingImpulseThreshold_0 = Module._emscripten_bind_btHingeConstraint_getBreakingImpulseThreshold_0 = asm._emscripten_bind_btHingeConstraint_getBreakingImpulseThreshold_0, _emscripten_bind_btDefaultCollisionConstructionInfo___destroy___0 = Module._emscripten_bind_btDefaultCollisionConstructionInfo___destroy___0 = asm._emscripten_bind_btDefaultCollisionConstructionInfo___destroy___0, _emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_4 = Module._emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_4 = asm._emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_4, _emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_2 = Module._emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_2 = asm._emscripten_bind_btPoint2PointConstraint_btPoint2PointConstraint_2, _emscripten_bind_btKinematicCharacterController_setJumpSpeed_1 = Module._emscripten_bind_btKinematicCharacterController_setJumpSpeed_1 = asm._emscripten_bind_btKinematicCharacterController_setJumpSpeed_1, _emscripten_bind_ConvexResultCallback_set_m_collisionFilterGroup_1 = Module._emscripten_bind_ConvexResultCallback_set_m_collisionFilterGroup_1 = asm._emscripten_bind_ConvexResultCallback_set_m_collisionFilterGroup_1, _emscripten_bind_btPairCachingGhostObject_getOverlappingObject_1 = Module._emscripten_bind_btPairCachingGhostObject_getOverlappingObject_1 = asm._emscripten_bind_btPairCachingGhostObject_getOverlappingObject_1, _emscripten_bind_btRigidBodyConstructionInfo___destroy___0 = Module._emscripten_bind_btRigidBodyConstructionInfo___destroy___0 = asm._emscripten_bind_btRigidBodyConstructionInfo___destroy___0, _emscripten_bind_btGeneric6DofConstraint_setBreakingImpulseThreshold_1 = Module._emscripten_bind_btGeneric6DofConstraint_setBreakingImpulseThreshold_1 = asm._emscripten_bind_btGeneric6DofConstraint_setBreakingImpulseThreshold_1, _emscripten_bind_btPoint2PointConstraint_setPivotA_1 = Module._emscripten_bind_btPoint2PointConstraint_setPivotA_1 = asm._emscripten_bind_btPoint2PointConstraint_setPivotA_1, _emscripten_bind_ClosestConvexResultCallback_set_m_convexToWorld_1 = Module._emscripten_bind_ClosestConvexResultCallback_set_m_convexToWorld_1 = asm._emscripten_bind_ClosestConvexResultCallback_set_m_convexToWorld_1, _memcpy = Module._memcpy = asm._memcpy, _emscripten_bind_btCapsuleShape_calculateLocalInertia_2 = Module._emscripten_bind_btCapsuleShape_calculateLocalInertia_2 = asm._emscripten_bind_btCapsuleShape_calculateLocalInertia_2, _emscripten_bind_btVector3_y_0 = Module._emscripten_bind_btVector3_y_0 = asm._emscripten_bind_btVector3_y_0, _emscripten_bind_btVehicleTuning_get_m_maxSuspensionForce_0 = Module._emscripten_bind_btVehicleTuning_get_m_maxSuspensionForce_0 = asm._emscripten_bind_btVehicleTuning_get_m_maxSuspensionForce_0, _emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_2 = Module._emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_2 = asm._emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_2, _emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_3 = Module._emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_3 = asm._emscripten_bind_btBvhTriangleMeshShape_btBvhTriangleMeshShape_3, _emscripten_bind_LocalShapeInfo_get_m_triangleIndex_0 = Module._emscripten_bind_LocalShapeInfo_get_m_triangleIndex_0 = asm._emscripten_bind_LocalShapeInfo_get_m_triangleIndex_0, _emscripten_bind_btGhostObject_setCollisionShape_1 = Module._emscripten_bind_btGhostObject_setCollisionShape_1 = asm._emscripten_bind_btGhostObject_setCollisionShape_1, _emscripten_bind_btDispatcherInfo_set_m_allowedCcdPenetration_1 = Module._emscripten_bind_btDispatcherInfo_set_m_allowedCcdPenetration_1 = asm._emscripten_bind_btDispatcherInfo_set_m_allowedCcdPenetration_1, _emscripten_bind_btQuaternion_setW_1 = Module._emscripten_bind_btQuaternion_setW_1 = asm._emscripten_bind_btQuaternion_setW_1, _emscripten_bind_btContactSolverInfo_set_m_splitImpulsePenetrationThreshold_1 = Module._emscripten_bind_btContactSolverInfo_set_m_splitImpulsePenetrationThreshold_1 = asm._emscripten_bind_btContactSolverInfo_set_m_splitImpulsePenetrationThreshold_1, _emscripten_bind_btDiscreteDynamicsWorld_setGravity_1 = Module._emscripten_bind_btDiscreteDynamicsWorld_setGravity_1 = asm._emscripten_bind_btDiscreteDynamicsWorld_setGravity_1, _emscripten_bind_btGhostObject_isActive_0 = Module._emscripten_bind_btGhostObject_isActive_0 = asm._emscripten_bind_btGhostObject_isActive_0, _emscripten_bind_btVector4_z_0 = Module._emscripten_bind_btVector4_z_0 = asm._emscripten_bind_btVector4_z_0, _emscripten_bind_btCollisionObject_forceActivationState_1 = Module._emscripten_bind_btCollisionObject_forceActivationState_1 = asm._emscripten_bind_btCollisionObject_forceActivationState_1, _emscripten_bind_btKinematicCharacterController_onGround_0 = Module._emscripten_bind_btKinematicCharacterController_onGround_0 = asm._emscripten_bind_btKinematicCharacterController_onGround_0, _free = Module._free = asm._free, _emscripten_bind_btGeneric6DofConstraint_getBreakingImpulseThreshold_0 = Module._emscripten_bind_btGeneric6DofConstraint_getBreakingImpulseThreshold_0 = asm._emscripten_bind_btGeneric6DofConstraint_getBreakingImpulseThreshold_0, _emscripten_bind_btConeTwistConstraint_setLimit_2 = Module._emscripten_bind_btConeTwistConstraint_setLimit_2 = asm._emscripten_bind_btConeTwistConstraint_setLimit_2, _emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterMask_1 = Module._emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterMask_1 = asm._emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterMask_1, _emscripten_bind_btRigidBody___destroy___0 = Module._emscripten_bind_btRigidBody___destroy___0 = asm._emscripten_bind_btRigidBody___destroy___0, _emscripten_bind_btStridingMeshInterface___destroy___0 = Module._emscripten_bind_btStridingMeshInterface___destroy___0 = asm._emscripten_bind_btStridingMeshInterface___destroy___0, _emscripten_bind_btRigidBody_setSleepingThresholds_2 = (Module.runPostSets = asm.runPostSets, 
    Module._emscripten_bind_btRigidBody_setSleepingThresholds_2 = asm._emscripten_bind_btRigidBody_setSleepingThresholds_2), _emscripten_bind_btCollisionObject_setWorldTransform_1 = Module._emscripten_bind_btCollisionObject_setWorldTransform_1 = asm._emscripten_bind_btCollisionObject_setWorldTransform_1, _emscripten_bind_LocalConvexResult_get_m_localShapeInfo_0 = Module._emscripten_bind_LocalConvexResult_get_m_localShapeInfo_0 = asm._emscripten_bind_LocalConvexResult_get_m_localShapeInfo_0, _emscripten_bind_btManifoldPoint_get_m_localPointA_0 = Module._emscripten_bind_btManifoldPoint_get_m_localPointA_0 = asm._emscripten_bind_btManifoldPoint_get_m_localPointA_0, _emscripten_bind_btRigidBodyConstructionInfo_get_m_linearDamping_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_linearDamping_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_linearDamping_0, _emscripten_bind_btCollisionWorld_getBroadphase_0 = Module._emscripten_bind_btCollisionWorld_getBroadphase_0 = asm._emscripten_bind_btCollisionWorld_getBroadphase_0, _emscripten_bind_btDispatcher_getNumManifolds_0 = Module._emscripten_bind_btDispatcher_getNumManifolds_0 = asm._emscripten_bind_btDispatcher_getNumManifolds_0, _emscripten_bind_btRigidBodyConstructionInfo_get_m_linearSleepingThreshold_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_linearSleepingThreshold_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_linearSleepingThreshold_0, _emscripten_bind_btRigidBody_activate_1 = Module._emscripten_bind_btRigidBody_activate_1 = asm._emscripten_bind_btRigidBody_activate_1, _emscripten_bind_btRigidBody_activate_0 = Module._emscripten_bind_btRigidBody_activate_0 = asm._emscripten_bind_btRigidBody_activate_0, _emscripten_bind_RayResultCallback___destroy___0 = Module._emscripten_bind_RayResultCallback___destroy___0 = asm._emscripten_bind_RayResultCallback___destroy___0, _emscripten_bind_btGhostObject_setActivationState_1 = Module._emscripten_bind_btGhostObject_setActivationState_1 = asm._emscripten_bind_btGhostObject_setActivationState_1, _emscripten_bind_btCollisionWorld_contactPairTest_3 = Module._emscripten_bind_btCollisionWorld_contactPairTest_3 = asm._emscripten_bind_btCollisionWorld_contactPairTest_3, _emscripten_bind_btDispatcherInfo_get_m_useContinuous_0 = Module._emscripten_bind_btDispatcherInfo_get_m_useContinuous_0 = asm._emscripten_bind_btDispatcherInfo_get_m_useContinuous_0, _emscripten_bind_btCylinderShapeX___destroy___0 = Module._emscripten_bind_btCylinderShapeX___destroy___0 = asm._emscripten_bind_btCylinderShapeX___destroy___0, _emscripten_bind_btManifoldPoint_getPositionWorldOnA_0 = Module._emscripten_bind_btManifoldPoint_getPositionWorldOnA_0 = asm._emscripten_bind_btManifoldPoint_getPositionWorldOnA_0, _emscripten_bind_LocalConvexResult_set_m_localShapeInfo_1 = Module._emscripten_bind_LocalConvexResult_set_m_localShapeInfo_1 = asm._emscripten_bind_LocalConvexResult_set_m_localShapeInfo_1, _emscripten_bind_btDispatcherInfo_get_m_useConvexConservativeDistanceUtil_0 = Module._emscripten_bind_btDispatcherInfo_get_m_useConvexConservativeDistanceUtil_0 = asm._emscripten_bind_btDispatcherInfo_get_m_useConvexConservativeDistanceUtil_0, _emscripten_bind_btVector4_x_0 = Module._emscripten_bind_btVector4_x_0 = asm._emscripten_bind_btVector4_x_0, _emscripten_bind_btPairCachingGhostObject_setCollisionFlags_1 = Module._emscripten_bind_btPairCachingGhostObject_setCollisionFlags_1 = asm._emscripten_bind_btPairCachingGhostObject_setCollisionFlags_1, _emscripten_bind_btRigidBody_getMotionState_0 = Module._emscripten_bind_btRigidBody_getMotionState_0 = asm._emscripten_bind_btRigidBody_getMotionState_0, _emscripten_bind_btKinematicCharacterController_getGhostObject_0 = Module._emscripten_bind_btKinematicCharacterController_getGhostObject_0 = asm._emscripten_bind_btKinematicCharacterController_getGhostObject_0, _emscripten_bind_btTriangleMeshShape___destroy___0 = Module._emscripten_bind_btTriangleMeshShape___destroy___0 = asm._emscripten_bind_btTriangleMeshShape___destroy___0, _emscripten_bind_btKinematicCharacterController_setWalkDirection_1 = Module._emscripten_bind_btKinematicCharacterController_setWalkDirection_1 = asm._emscripten_bind_btKinematicCharacterController_setWalkDirection_1, _emscripten_bind_btDynamicsWorld_removeAction_1 = Module._emscripten_bind_btDynamicsWorld_removeAction_1 = asm._emscripten_bind_btDynamicsWorld_removeAction_1, _emscripten_bind_btRigidBodyConstructionInfo_get_m_restitution_0 = Module._emscripten_bind_btRigidBodyConstructionInfo_get_m_restitution_0 = asm._emscripten_bind_btRigidBodyConstructionInfo_get_m_restitution_0, _emscripten_bind_btVehicleTuning_get_m_suspensionStiffness_0 = Module._emscripten_bind_btVehicleTuning_get_m_suspensionStiffness_0 = asm._emscripten_bind_btVehicleTuning_get_m_suspensionStiffness_0, _emscripten_bind_btManifoldPoint_set_m_normalWorldOnB_1 = Module._emscripten_bind_btManifoldPoint_set_m_normalWorldOnB_1 = asm._emscripten_bind_btManifoldPoint_set_m_normalWorldOnB_1, _emscripten_bind_btKinematicCharacterController_getGravity_0 = Module._emscripten_bind_btKinematicCharacterController_getGravity_0 = asm._emscripten_bind_btKinematicCharacterController_getGravity_0, _emscripten_bind_btConeTwistConstraint_getBreakingImpulseThreshold_0 = Module._emscripten_bind_btConeTwistConstraint_getBreakingImpulseThreshold_0 = asm._emscripten_bind_btConeTwistConstraint_getBreakingImpulseThreshold_0, _emscripten_bind_btDiscreteDynamicsWorld_addAction_1 = Module._emscripten_bind_btDiscreteDynamicsWorld_addAction_1 = asm._emscripten_bind_btDiscreteDynamicsWorld_addAction_1, _emscripten_bind_btHingeConstraint_btHingeConstraint_4 = Module._emscripten_bind_btHingeConstraint_btHingeConstraint_4 = asm._emscripten_bind_btHingeConstraint_btHingeConstraint_4, _emscripten_bind_btQuaternion_setY_1 = Module._emscripten_bind_btQuaternion_setY_1 = asm._emscripten_bind_btQuaternion_setY_1, _emscripten_bind_btConeShape_calculateLocalInertia_2 = Module._emscripten_bind_btConeShape_calculateLocalInertia_2 = asm._emscripten_bind_btConeShape_calculateLocalInertia_2, _emscripten_bind_btCylinderShapeX_calculateLocalInertia_2 = Module._emscripten_bind_btCylinderShapeX_calculateLocalInertia_2 = asm._emscripten_bind_btCylinderShapeX_calculateLocalInertia_2, _emscripten_bind_ConvexResultCallback_set_m_collisionFilterMask_1 = Module._emscripten_bind_ConvexResultCallback_set_m_collisionFilterMask_1 = asm._emscripten_bind_ConvexResultCallback_set_m_collisionFilterMask_1, _emscripten_bind_btSphereShape_setLocalScaling_1 = Module._emscripten_bind_btSphereShape_setLocalScaling_1 = asm._emscripten_bind_btSphereShape_setLocalScaling_1, _emscripten_bind_btVector4_w_0 = Module._emscripten_bind_btVector4_w_0 = asm._emscripten_bind_btVector4_w_0, _emscripten_bind_btManifoldPoint_get_m_normalWorldOnB_0 = Module._emscripten_bind_btManifoldPoint_get_m_normalWorldOnB_0 = asm._emscripten_bind_btManifoldPoint_get_m_normalWorldOnB_0, _emscripten_bind_btBvhTriangleMeshShape___destroy___0 = Module._emscripten_bind_btBvhTriangleMeshShape___destroy___0 = asm._emscripten_bind_btBvhTriangleMeshShape___destroy___0, _emscripten_bind_ClosestRayResultCallback_get_m_rayToWorld_0 = Module._emscripten_bind_ClosestRayResultCallback_get_m_rayToWorld_0 = asm._emscripten_bind_ClosestRayResultCallback_get_m_rayToWorld_0, _emscripten_bind_ClosestConvexResultCallback_set_m_closestHitFraction_1 = Module._emscripten_bind_ClosestConvexResultCallback_set_m_closestHitFraction_1 = asm._emscripten_bind_ClosestConvexResultCallback_set_m_closestHitFraction_1, _emscripten_bind_btDiscreteDynamicsWorld_removeConstraint_1 = Module._emscripten_bind_btDiscreteDynamicsWorld_removeConstraint_1 = asm._emscripten_bind_btDiscreteDynamicsWorld_removeConstraint_1, _emscripten_bind_btVector4_y_0 = Module._emscripten_bind_btVector4_y_0 = asm._emscripten_bind_btVector4_y_0, _emscripten_bind_btGeneric6DofConstraint___destroy___0 = Module._emscripten_bind_btGeneric6DofConstraint___destroy___0 = asm._emscripten_bind_btGeneric6DofConstraint___destroy___0, _emscripten_bind_btVehicleTuning_get_m_maxSuspensionTravelCm_0 = Module._emscripten_bind_btVehicleTuning_get_m_maxSuspensionTravelCm_0 = asm._emscripten_bind_btVehicleTuning_get_m_maxSuspensionTravelCm_0, _emscripten_bind_btConvexHullShape_addPoint_1 = Module._emscripten_bind_btConvexHullShape_addPoint_1 = asm._emscripten_bind_btConvexHullShape_addPoint_1, _emscripten_bind_btConvexHullShape_addPoint_2 = Module._emscripten_bind_btConvexHullShape_addPoint_2 = asm._emscripten_bind_btConvexHullShape_addPoint_2, _emscripten_bind_btPoint2PointConstraint_getBreakingImpulseThreshold_0 = Module._emscripten_bind_btPoint2PointConstraint_getBreakingImpulseThreshold_0 = asm._emscripten_bind_btPoint2PointConstraint_getBreakingImpulseThreshold_0, _emscripten_bind_btTransform_getOrigin_0 = Module._emscripten_bind_btTransform_getOrigin_0 = asm._emscripten_bind_btTransform_getOrigin_0, _emscripten_bind_btHingeConstraint___destroy___0 = Module._emscripten_bind_btHingeConstraint___destroy___0 = asm._emscripten_bind_btHingeConstraint___destroy___0, _emscripten_bind_btHingeConstraint_enableFeedback_1 = Module._emscripten_bind_btHingeConstraint_enableFeedback_1 = asm._emscripten_bind_btHingeConstraint_enableFeedback_1, _emscripten_bind_btConvexShape_calculateLocalInertia_2 = Module._emscripten_bind_btConvexShape_calculateLocalInertia_2 = asm._emscripten_bind_btConvexShape_calculateLocalInertia_2, _memset = Module._memset = asm._memset, _emscripten_bind_btKinematicCharacterController___destroy___0 = Module._emscripten_bind_btKinematicCharacterController___destroy___0 = asm._emscripten_bind_btKinematicCharacterController___destroy___0, _emscripten_bind_ClosestRayResultCallback_get_m_hitNormalWorld_0 = Module._emscripten_bind_ClosestRayResultCallback_get_m_hitNormalWorld_0 = asm._emscripten_bind_ClosestRayResultCallback_get_m_hitNormalWorld_0, _emscripten_bind_btTriangleMesh_btTriangleMesh_0 = Module._emscripten_bind_btTriangleMesh_btTriangleMesh_0 = asm._emscripten_bind_btTriangleMesh_btTriangleMesh_0, _emscripten_bind_btTriangleMesh_btTriangleMesh_1 = Module._emscripten_bind_btTriangleMesh_btTriangleMesh_1 = asm._emscripten_bind_btTriangleMesh_btTriangleMesh_1, _emscripten_bind_btTriangleMesh_btTriangleMesh_2 = Module._emscripten_bind_btTriangleMesh_btTriangleMesh_2 = asm._emscripten_bind_btTriangleMesh_btTriangleMesh_2, _emscripten_bind_btWheelInfo_set_m_frictionSlip_1 = Module._emscripten_bind_btWheelInfo_set_m_frictionSlip_1 = asm._emscripten_bind_btWheelInfo_set_m_frictionSlip_1, _emscripten_bind_btHingeConstraint_enableAngularMotor_3 = Module._emscripten_bind_btHingeConstraint_enableAngularMotor_3 = asm._emscripten_bind_btHingeConstraint_enableAngularMotor_3, _emscripten_bind_btManifoldPoint_set_m_positionWorldOnA_1 = Module._emscripten_bind_btManifoldPoint_set_m_positionWorldOnA_1 = asm._emscripten_bind_btManifoldPoint_set_m_positionWorldOnA_1, _emscripten_bind_btRigidBody_setCenterOfMassTransform_1 = Module._emscripten_bind_btRigidBody_setCenterOfMassTransform_1 = asm._emscripten_bind_btRigidBody_setCenterOfMassTransform_1, _emscripten_bind_btManifoldPoint_get_m_localPointB_0 = Module._emscripten_bind_btManifoldPoint_get_m_localPointB_0 = asm._emscripten_bind_btManifoldPoint_get_m_localPointB_0, _emscripten_bind_btDiscreteDynamicsWorld_contactPairTest_3 = Module._emscripten_bind_btDiscreteDynamicsWorld_contactPairTest_3 = asm._emscripten_bind_btDiscreteDynamicsWorld_contactPairTest_3, _emscripten_bind_btSliderConstraint_setLowerLinLimit_1 = Module._emscripten_bind_btSliderConstraint_setLowerLinLimit_1 = asm._emscripten_bind_btSliderConstraint_setLowerLinLimit_1, _emscripten_bind_btPoint2PointConstraint_set_m_setting_1 = Module._emscripten_bind_btPoint2PointConstraint_set_m_setting_1 = asm._emscripten_bind_btPoint2PointConstraint_set_m_setting_1, _emscripten_bind_btCollisionObject_setCcdSweptSphereRadius_1 = Module._emscripten_bind_btCollisionObject_setCcdSweptSphereRadius_1 = asm._emscripten_bind_btCollisionObject_setCcdSweptSphereRadius_1, _emscripten_bind_btWheelInfo_get_m_wheelsRadius_0 = Module._emscripten_bind_btWheelInfo_get_m_wheelsRadius_0 = asm._emscripten_bind_btWheelInfo_get_m_wheelsRadius_0, _emscripten_bind_btRigidBody_setLinearVelocity_1 = Module._emscripten_bind_btRigidBody_setLinearVelocity_1 = asm._emscripten_bind_btRigidBody_setLinearVelocity_1, _emscripten_bind_btVehicleTuning_btVehicleTuning_0 = Module._emscripten_bind_btVehicleTuning_btVehicleTuning_0 = asm._emscripten_bind_btVehicleTuning_btVehicleTuning_0, _emscripten_bind_RayResultCallback_set_m_collisionObject_1 = Module._emscripten_bind_RayResultCallback_set_m_collisionObject_1 = asm._emscripten_bind_RayResultCallback_set_m_collisionObject_1, _emscripten_bind_ClosestRayResultCallback_set_m_rayToWorld_1 = Module._emscripten_bind_ClosestRayResultCallback_set_m_rayToWorld_1 = asm._emscripten_bind_ClosestRayResultCallback_set_m_rayToWorld_1, _emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterGroup_0 = Module._emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterGroup_0 = asm._emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterGroup_0, _emscripten_bind_btWheelInfo_set_m_wheelsDampingRelaxation_1 = Module._emscripten_bind_btWheelInfo_set_m_wheelsDampingRelaxation_1 = asm._emscripten_bind_btWheelInfo_set_m_wheelsDampingRelaxation_1, _emscripten_bind_btDynamicsWorld_addAction_1 = Module._emscripten_bind_btDynamicsWorld_addAction_1 = asm._emscripten_bind_btDynamicsWorld_addAction_1, _emscripten_bind_btDiscreteDynamicsWorld_removeAction_1 = Module._emscripten_bind_btDiscreteDynamicsWorld_removeAction_1 = asm._emscripten_bind_btDiscreteDynamicsWorld_removeAction_1, _emscripten_bind_btPairCachingGhostObject_getCollisionFlags_0 = Module._emscripten_bind_btPairCachingGhostObject_getCollisionFlags_0 = asm._emscripten_bind_btPairCachingGhostObject_getCollisionFlags_0, _emscripten_bind_btRigidBodyConstructionInfo_set_m_linearDamping_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_linearDamping_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_linearDamping_1, _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDamping_1 = Module._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDamping_1 = asm._emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDamping_1, _emscripten_bind_btKinematicCharacterController_setFallSpeed_1 = Module._emscripten_bind_btKinematicCharacterController_setFallSpeed_1 = asm._emscripten_bind_btKinematicCharacterController_setFallSpeed_1, _emscripten_bind_btRigidBody_setActivationState_1 = Module._emscripten_bind_btRigidBody_setActivationState_1 = asm._emscripten_bind_btRigidBody_setActivationState_1, _emscripten_bind_ClosestConvexResultCallback_hasHit_0 = Module._emscripten_bind_ClosestConvexResultCallback_hasHit_0 = asm._emscripten_bind_ClosestConvexResultCallback_hasHit_0, _emscripten_bind_btCapsuleShapeZ___destroy___0 = Module._emscripten_bind_btCapsuleShapeZ___destroy___0 = asm._emscripten_bind_btCapsuleShapeZ___destroy___0, _emscripten_bind_btWheelInfo_get_m_maxSuspensionForce_0 = Module._emscripten_bind_btWheelInfo_get_m_maxSuspensionForce_0 = asm._emscripten_bind_btWheelInfo_get_m_maxSuspensionForce_0, _emscripten_bind_ClosestRayResultCallback_get_m_collisionObject_0 = Module._emscripten_bind_ClosestRayResultCallback_get_m_collisionObject_0 = asm._emscripten_bind_ClosestRayResultCallback_get_m_collisionObject_0, _emscripten_bind_btTriangleMesh_addTriangle_3 = Module._emscripten_bind_btTriangleMesh_addTriangle_3 = asm._emscripten_bind_btTriangleMesh_addTriangle_3, _emscripten_bind_btGhostObject_getOverlappingObject_1 = Module._emscripten_bind_btGhostObject_getOverlappingObject_1 = asm._emscripten_bind_btGhostObject_getOverlappingObject_1, _emscripten_bind_btTriangleMesh_addTriangle_4 = Module._emscripten_bind_btTriangleMesh_addTriangle_4 = asm._emscripten_bind_btTriangleMesh_addTriangle_4, _emscripten_bind_btRigidBody_applyTorqueImpulse_1 = Module._emscripten_bind_btRigidBody_applyTorqueImpulse_1 = asm._emscripten_bind_btRigidBody_applyTorqueImpulse_1, _emscripten_bind_btRigidBody_setCollisionFlags_1 = Module._emscripten_bind_btRigidBody_setCollisionFlags_1 = asm._emscripten_bind_btRigidBody_setCollisionFlags_1, _emscripten_bind_btWheelInfo_set_m_suspensionRestLength1_1 = Module._emscripten_bind_btWheelInfo_set_m_suspensionRestLength1_1 = asm._emscripten_bind_btWheelInfo_set_m_suspensionRestLength1_1, _emscripten_bind_btConeShape___destroy___0 = Module._emscripten_bind_btConeShape___destroy___0 = asm._emscripten_bind_btConeShape___destroy___0, _emscripten_bind_btCapsuleShapeZ_btCapsuleShapeZ_2 = Module._emscripten_bind_btCapsuleShapeZ_btCapsuleShapeZ_2 = asm._emscripten_bind_btCapsuleShapeZ_btCapsuleShapeZ_2, _emscripten_bind_btSliderConstraint_btSliderConstraint_5 = Module._emscripten_bind_btSliderConstraint_btSliderConstraint_5 = asm._emscripten_bind_btSliderConstraint_btSliderConstraint_5, _emscripten_bind_btSliderConstraint_btSliderConstraint_3 = Module._emscripten_bind_btSliderConstraint_btSliderConstraint_3 = asm._emscripten_bind_btSliderConstraint_btSliderConstraint_3, _emscripten_bind_btTransform___destroy___0 = Module._emscripten_bind_btTransform___destroy___0 = asm._emscripten_bind_btTransform___destroy___0, _emscripten_bind_btDynamicsWorld_convexSweepTest_5 = Module._emscripten_bind_btDynamicsWorld_convexSweepTest_5 = asm._emscripten_bind_btDynamicsWorld_convexSweepTest_5, _emscripten_bind_btSliderConstraint___destroy___0 = Module._emscripten_bind_btSliderConstraint___destroy___0 = asm._emscripten_bind_btSliderConstraint___destroy___0, _emscripten_bind_btRigidBody_forceActivationState_1 = Module._emscripten_bind_btRigidBody_forceActivationState_1 = asm._emscripten_bind_btRigidBody_forceActivationState_1, _emscripten_bind_btPoint2PointConstraint_setPivotB_1 = Module._emscripten_bind_btPoint2PointConstraint_setPivotB_1 = asm._emscripten_bind_btPoint2PointConstraint_setPivotB_1, _emscripten_bind_btManifoldPoint_getDistance_0 = Module._emscripten_bind_btManifoldPoint_getDistance_0 = asm._emscripten_bind_btManifoldPoint_getDistance_0, _emscripten_bind_btGhostPairCallback___destroy___0 = Module._emscripten_bind_btGhostPairCallback___destroy___0 = asm._emscripten_bind_btGhostPairCallback___destroy___0, _emscripten_bind_btKinematicCharacterController_getMaxSlope_0 = Module._emscripten_bind_btKinematicCharacterController_getMaxSlope_0 = asm._emscripten_bind_btKinematicCharacterController_getMaxSlope_0, _emscripten_bind_btSliderConstraint_enableFeedback_1 = Module._emscripten_bind_btSliderConstraint_enableFeedback_1 = asm._emscripten_bind_btSliderConstraint_enableFeedback_1, _emscripten_bind_btRaycastVehicle_addWheel_7 = Module._emscripten_bind_btRaycastVehicle_addWheel_7 = asm._emscripten_bind_btRaycastVehicle_addWheel_7, _emscripten_bind_btPairCachingGhostObject_isActive_0 = Module._emscripten_bind_btPairCachingGhostObject_isActive_0 = asm._emscripten_bind_btPairCachingGhostObject_isActive_0, _emscripten_bind_ContactResultCallback___destroy___0 = Module._emscripten_bind_ContactResultCallback___destroy___0 = asm._emscripten_bind_ContactResultCallback___destroy___0, _emscripten_bind_btStaticPlaneShape___destroy___0 = Module._emscripten_bind_btStaticPlaneShape___destroy___0 = asm._emscripten_bind_btStaticPlaneShape___destroy___0, _emscripten_bind_btDispatcherInfo_set_m_stepCount_1 = Module._emscripten_bind_btDispatcherInfo_set_m_stepCount_1 = asm._emscripten_bind_btDispatcherInfo_set_m_stepCount_1, _emscripten_bind_btBoxShape_setLocalScaling_1 = Module._emscripten_bind_btBoxShape_setLocalScaling_1 = asm._emscripten_bind_btBoxShape_setLocalScaling_1, _emscripten_bind_btConeShapeZ___destroy___0 = Module._emscripten_bind_btConeShapeZ___destroy___0 = asm._emscripten_bind_btConeShapeZ___destroy___0, _emscripten_bind_btDynamicsWorld_getPairCache_0 = Module._emscripten_bind_btDynamicsWorld_getPairCache_0 = asm._emscripten_bind_btDynamicsWorld_getPairCache_0, _emscripten_bind_btDiscreteDynamicsWorld_convexSweepTest_5 = Module._emscripten_bind_btDiscreteDynamicsWorld_convexSweepTest_5 = asm._emscripten_bind_btDiscreteDynamicsWorld_convexSweepTest_5, _emscripten_bind_btKinematicCharacterController_setVelocityForTimeInterval_2 = Module._emscripten_bind_btKinematicCharacterController_setVelocityForTimeInterval_2 = asm._emscripten_bind_btKinematicCharacterController_setVelocityForTimeInterval_2, _emscripten_bind_btVector4_btVector4_0 = Module._emscripten_bind_btVector4_btVector4_0 = asm._emscripten_bind_btVector4_btVector4_0, _emscripten_bind_btDispatcherInfo_get_m_enableSatConvex_0 = Module._emscripten_bind_btDispatcherInfo_get_m_enableSatConvex_0 = asm._emscripten_bind_btDispatcherInfo_get_m_enableSatConvex_0, _emscripten_bind_btVector4_btVector4_4 = Module._emscripten_bind_btVector4_btVector4_4 = asm._emscripten_bind_btVector4_btVector4_4, _emscripten_bind_btGeneric6DofConstraint_setLinearLowerLimit_1 = Module._emscripten_bind_btGeneric6DofConstraint_setLinearLowerLimit_1 = asm._emscripten_bind_btGeneric6DofConstraint_setLinearLowerLimit_1, _emscripten_bind_btGeneric6DofSpringConstraint_setLinearLowerLimit_1 = Module._emscripten_bind_btGeneric6DofSpringConstraint_setLinearLowerLimit_1 = asm._emscripten_bind_btGeneric6DofSpringConstraint_setLinearLowerLimit_1, _emscripten_bind_LocalConvexResult_set_m_hitCollisionObject_1 = Module._emscripten_bind_LocalConvexResult_set_m_hitCollisionObject_1 = asm._emscripten_bind_LocalConvexResult_set_m_hitCollisionObject_1, _emscripten_bind_btConstraintSetting_btConstraintSetting_0 = Module._emscripten_bind_btConstraintSetting_btConstraintSetting_0 = asm._emscripten_bind_btConstraintSetting_btConstraintSetting_0, _emscripten_bind_btGeneric6DofSpringConstraint_setAngularLowerLimit_1 = Module._emscripten_bind_btGeneric6DofSpringConstraint_setAngularLowerLimit_1 = asm._emscripten_bind_btGeneric6DofSpringConstraint_setAngularLowerLimit_1, _emscripten_bind_btDiscreteDynamicsWorld_rayTest_3 = Module._emscripten_bind_btDiscreteDynamicsWorld_rayTest_3 = asm._emscripten_bind_btDiscreteDynamicsWorld_rayTest_3, _emscripten_bind_btContactSolverInfo_get_m_splitImpulse_0 = Module._emscripten_bind_btContactSolverInfo_get_m_splitImpulse_0 = asm._emscripten_bind_btContactSolverInfo_get_m_splitImpulse_0, _emscripten_bind_btGhostPairCallback_btGhostPairCallback_0 = Module._emscripten_bind_btGhostPairCallback_btGhostPairCallback_0 = asm._emscripten_bind_btGhostPairCallback_btGhostPairCallback_0, _emscripten_bind_btKinematicCharacterController_setMaxJumpHeight_1 = Module._emscripten_bind_btKinematicCharacterController_setMaxJumpHeight_1 = asm._emscripten_bind_btKinematicCharacterController_setMaxJumpHeight_1, _emscripten_bind_ClosestRayResultCallback_set_m_hitNormalWorld_1 = Module._emscripten_bind_ClosestRayResultCallback_set_m_hitNormalWorld_1 = asm._emscripten_bind_ClosestRayResultCallback_set_m_hitNormalWorld_1, _emscripten_bind_btVehicleTuning_get_m_frictionSlip_0 = Module._emscripten_bind_btVehicleTuning_get_m_frictionSlip_0 = asm._emscripten_bind_btVehicleTuning_get_m_frictionSlip_0;
    Module.dynCall_vi = asm.dynCall_vi, Module.dynCall_iiii = asm.dynCall_iiii, Module.dynCall_vidi = asm.dynCall_vidi, 
    Module.dynCall_viiiiii = asm.dynCall_viiiiii, Module.dynCall_viiiii = asm.dynCall_viiiii, 
    Module.dynCall_diiiiiiii = asm.dynCall_diiiiiiii, Module.dynCall_vid = asm.dynCall_vid, 
    Module.dynCall_di = asm.dynCall_di, Module.dynCall_iidid = asm.dynCall_iidid, Module.dynCall_vii = asm.dynCall_vii, 
    Module.dynCall_ii = asm.dynCall_ii, Module.dynCall_viii = asm.dynCall_viii, Module.dynCall_v = asm.dynCall_v, 
    Module.dynCall_viid = asm.dynCall_viid, Module.dynCall_iiiii = asm.dynCall_iiiii, 
    Module.dynCall_viiii = asm.dynCall_viiii, Module.dynCall_iii = asm.dynCall_iii, 
    Module.dynCall_diii = asm.dynCall_diii;
    Runtime.stackAlloc = asm.stackAlloc, Runtime.stackSave = asm.stackSave, Runtime.stackRestore = asm.stackRestore, 
    Runtime.establishStackSpace = asm.establishStackSpace, Runtime.setTempRet0 = asm.setTempRet0, 
    Runtime.getTempRet0 = asm.getTempRet0, ExitStatus.prototype = new Error(), ExitStatus.prototype.constructor = ExitStatus;
    var initialStackTop, preloadStartTime = null, calledMain = !1;
    dependenciesFulfilled = function runCaller() {
        Module.calledRun || run(), Module.calledRun || (dependenciesFulfilled = runCaller);
    }, Module.callMain = Module.callMain = function(args) {
        function pad() {
            for (var i = 0; i < 3; i++) argv.push(0);
        }
        assert(0 == runDependencies, "cannot call main when async dependencies remain! (listen on __ATMAIN__)"), 
        assert(0 == __ATPRERUN__.length, "cannot call main when preRun functions remain to be called"), 
        args = args || [], ensureInitRuntime();
        var argc = args.length + 1, argv = [ allocate(intArrayFromString(Module.thisProgram), "i8", 0) ];
        pad();
        for (var i = 0; i < argc - 1; i += 1) argv.push(allocate(intArrayFromString(args[i]), "i8", 0)), 
        pad();
        argv.push(0), argv = allocate(argv, "i32", 0), initialStackTop = Runtime.stackSave();
        try {
            exit(Module._main(argc, argv, 0), !0);
        } catch (e) {
            if (e instanceof ExitStatus) return;
            if ("SimulateInfiniteLoop" == e) return Module.noExitRuntime = !0, void Runtime.stackRestore(initialStackTop);
            throw e && "object" == typeof e && e.stack && Module.printErr("exception thrown: " + [ e, e.stack ]), 
            e;
        } finally {
            calledMain = !0;
        }
    }, Module.run = Module.run = run, Module.exit = Module.exit = exit;
    var abortDecorators = [];
    if (Module.abort = Module.abort = abort, Module.preInit) for ("function" == typeof Module.preInit && (Module.preInit = [ Module.preInit ]); Module.preInit.length > 0; ) Module.preInit.pop()();
    var shouldRunNow = !0;
    Module.noInitialRun && (shouldRunNow = !1), Module.noExitRuntime = !0, run(), WrapperObject.prototype = Object.create(WrapperObject.prototype), 
    WrapperObject.prototype.constructor = WrapperObject, WrapperObject.prototype.__class__ = WrapperObject, 
    WrapperObject.__cache__ = {}, Module.WrapperObject = WrapperObject, Module.getCache = getCache, 
    Module.wrapPointer = wrapPointer, Module.castObject = castObject, Module.NULL = wrapPointer(0), 
    Module.destroy = destroy, Module.compare = compare, Module.getPointer = getPointer, 
    Module.getClass = getClass;
    return btCollisionShape.prototype = Object.create(WrapperObject.prototype), btCollisionShape.prototype.constructor = btCollisionShape, 
    btCollisionShape.prototype.__class__ = btCollisionShape, btCollisionShape.__cache__ = {}, 
    Module.btCollisionShape = btCollisionShape, btCollisionShape.prototype.setLocalScaling = btCollisionShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionShape_setLocalScaling_1(self, arg0);
    }, btCollisionShape.prototype.calculateLocalInertia = btCollisionShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCollisionShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btCollisionShape.prototype.__destroy__ = btCollisionShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCollisionShape___destroy___0(self);
    }, btCollisionObject.prototype = Object.create(WrapperObject.prototype), btCollisionObject.prototype.constructor = btCollisionObject, 
    btCollisionObject.prototype.__class__ = btCollisionObject, btCollisionObject.__cache__ = {}, 
    Module.btCollisionObject = btCollisionObject, btCollisionObject.prototype.setAnisotropicFriction = btCollisionObject.prototype.setAnisotropicFriction = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCollisionObject_setAnisotropicFriction_2(self, arg0, arg1);
    }, btCollisionObject.prototype.getCollisionShape = btCollisionObject.prototype.getCollisionShape = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btCollisionObject_getCollisionShape_0(self), btCollisionShape);
    }, btCollisionObject.prototype.setContactProcessingThreshold = btCollisionObject.prototype.setContactProcessingThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setContactProcessingThreshold_1(self, arg0);
    }, btCollisionObject.prototype.setActivationState = btCollisionObject.prototype.setActivationState = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setActivationState_1(self, arg0);
    }, btCollisionObject.prototype.forceActivationState = btCollisionObject.prototype.forceActivationState = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_forceActivationState_1(self, arg0);
    }, btCollisionObject.prototype.activate = btCollisionObject.prototype.activate = function(arg0) {
        var self = this.ptr;
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), void 0 === arg0) return void _emscripten_bind_btCollisionObject_activate_0(self);
        _emscripten_bind_btCollisionObject_activate_1(self, arg0);
    }, btCollisionObject.prototype.isActive = btCollisionObject.prototype.isActive = function() {
        var self = this.ptr;
        return _emscripten_bind_btCollisionObject_isActive_0(self);
    }, btCollisionObject.prototype.isKinematicObject = btCollisionObject.prototype.isKinematicObject = function() {
        var self = this.ptr;
        return _emscripten_bind_btCollisionObject_isKinematicObject_0(self);
    }, btCollisionObject.prototype.setRestitution = btCollisionObject.prototype.setRestitution = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setRestitution_1(self, arg0);
    }, btCollisionObject.prototype.setFriction = btCollisionObject.prototype.setFriction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setFriction_1(self, arg0);
    }, btCollisionObject.prototype.setRollingFriction = btCollisionObject.prototype.setRollingFriction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setRollingFriction_1(self, arg0);
    }, btCollisionObject.prototype.getWorldTransform = btCollisionObject.prototype.getWorldTransform = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btCollisionObject_getWorldTransform_0(self), btTransform);
    }, btCollisionObject.prototype.getCollisionFlags = btCollisionObject.prototype.getCollisionFlags = function() {
        var self = this.ptr;
        return _emscripten_bind_btCollisionObject_getCollisionFlags_0(self);
    }, btCollisionObject.prototype.setCollisionFlags = btCollisionObject.prototype.setCollisionFlags = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setCollisionFlags_1(self, arg0);
    }, btCollisionObject.prototype.setWorldTransform = btCollisionObject.prototype.setWorldTransform = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setWorldTransform_1(self, arg0);
    }, btCollisionObject.prototype.setCollisionShape = btCollisionObject.prototype.setCollisionShape = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setCollisionShape_1(self, arg0);
    }, btCollisionObject.prototype.setCcdMotionThreshold = btCollisionObject.prototype.setCcdMotionThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setCcdMotionThreshold_1(self, arg0);
    }, btCollisionObject.prototype.setCcdSweptSphereRadius = btCollisionObject.prototype.setCcdSweptSphereRadius = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCollisionObject_setCcdSweptSphereRadius_1(self, arg0);
    }, btCollisionObject.prototype.__destroy__ = btCollisionObject.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCollisionObject___destroy___0(self);
    }, btConcaveShape.prototype = Object.create(btCollisionShape.prototype), btConcaveShape.prototype.constructor = btConcaveShape, 
    btConcaveShape.prototype.__class__ = btConcaveShape, btConcaveShape.__cache__ = {}, 
    Module.btConcaveShape = btConcaveShape, btConcaveShape.prototype.setLocalScaling = btConcaveShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConcaveShape_setLocalScaling_1(self, arg0);
    }, btConcaveShape.prototype.calculateLocalInertia = btConcaveShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btConcaveShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btConcaveShape.prototype.__destroy__ = btConcaveShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConcaveShape___destroy___0(self);
    }, btCollisionWorld.prototype = Object.create(WrapperObject.prototype), btCollisionWorld.prototype.constructor = btCollisionWorld, 
    btCollisionWorld.prototype.__class__ = btCollisionWorld, btCollisionWorld.__cache__ = {}, 
    Module.btCollisionWorld = btCollisionWorld, btCollisionWorld.prototype.getDispatcher = btCollisionWorld.prototype.getDispatcher = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btCollisionWorld_getDispatcher_0(self), btDispatcher);
    }, btCollisionWorld.prototype.rayTest = btCollisionWorld.prototype.rayTest = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btCollisionWorld_rayTest_3(self, arg0, arg1, arg2);
    }, btCollisionWorld.prototype.getPairCache = btCollisionWorld.prototype.getPairCache = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btCollisionWorld_getPairCache_0(self), btOverlappingPairCache);
    }, btCollisionWorld.prototype.getDispatchInfo = btCollisionWorld.prototype.getDispatchInfo = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btCollisionWorld_getDispatchInfo_0(self), btDispatcherInfo);
    }, btCollisionWorld.prototype.addCollisionObject = btCollisionWorld.prototype.addCollisionObject = function(arg0, arg1, arg2) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), void 0 === arg1 ? void _emscripten_bind_btCollisionWorld_addCollisionObject_1(self, arg0) : void 0 === arg2 ? void _emscripten_bind_btCollisionWorld_addCollisionObject_2(self, arg0, arg1) : void _emscripten_bind_btCollisionWorld_addCollisionObject_3(self, arg0, arg1, arg2);
    }, btCollisionWorld.prototype.getBroadphase = btCollisionWorld.prototype.getBroadphase = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btCollisionWorld_getBroadphase_0(self), btBroadphaseInterface);
    }, btCollisionWorld.prototype.convexSweepTest = btCollisionWorld.prototype.convexSweepTest = function(arg0, arg1, arg2, arg3, arg4) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), _emscripten_bind_btCollisionWorld_convexSweepTest_5(self, arg0, arg1, arg2, arg3, arg4);
    }, btCollisionWorld.prototype.contactPairTest = btCollisionWorld.prototype.contactPairTest = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btCollisionWorld_contactPairTest_3(self, arg0, arg1, arg2);
    }, btCollisionWorld.prototype.__destroy__ = btCollisionWorld.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCollisionWorld___destroy___0(self);
    }, btTypedConstraint.prototype = Object.create(WrapperObject.prototype), btTypedConstraint.prototype.constructor = btTypedConstraint, 
    btTypedConstraint.prototype.__class__ = btTypedConstraint, btTypedConstraint.__cache__ = {}, 
    Module.btTypedConstraint = btTypedConstraint, btTypedConstraint.prototype.enableFeedback = btTypedConstraint.prototype.enableFeedback = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btTypedConstraint_enableFeedback_1(self, arg0);
    }, btTypedConstraint.prototype.getBreakingImpulseThreshold = btTypedConstraint.prototype.getBreakingImpulseThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btTypedConstraint_getBreakingImpulseThreshold_0(self);
    }, btTypedConstraint.prototype.setBreakingImpulseThreshold = btTypedConstraint.prototype.setBreakingImpulseThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btTypedConstraint_setBreakingImpulseThreshold_1(self, arg0);
    }, btTypedConstraint.prototype.__destroy__ = btTypedConstraint.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btTypedConstraint___destroy___0(self);
    }, btCapsuleShape.prototype = Object.create(btCollisionShape.prototype), btCapsuleShape.prototype.constructor = btCapsuleShape, 
    btCapsuleShape.prototype.__class__ = btCapsuleShape, btCapsuleShape.__cache__ = {}, 
    Module.btCapsuleShape = btCapsuleShape, btCapsuleShape.prototype.setMargin = btCapsuleShape.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCapsuleShape_setMargin_1(self, arg0);
    }, btCapsuleShape.prototype.getMargin = btCapsuleShape.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btCapsuleShape_getMargin_0(self);
    }, btCapsuleShape.prototype.setLocalScaling = btCapsuleShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCapsuleShape_setLocalScaling_1(self, arg0);
    }, btCapsuleShape.prototype.calculateLocalInertia = btCapsuleShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCapsuleShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btCapsuleShape.prototype.__destroy__ = btCapsuleShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCapsuleShape___destroy___0(self);
    }, btGeneric6DofConstraint.prototype = Object.create(btTypedConstraint.prototype), 
    btGeneric6DofConstraint.prototype.constructor = btGeneric6DofConstraint, btGeneric6DofConstraint.prototype.__class__ = btGeneric6DofConstraint, 
    btGeneric6DofConstraint.__cache__ = {}, Module.btGeneric6DofConstraint = btGeneric6DofConstraint, 
    btGeneric6DofConstraint.prototype.setLinearLowerLimit = btGeneric6DofConstraint.prototype.setLinearLowerLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofConstraint_setLinearLowerLimit_1(self, arg0);
    }, btGeneric6DofConstraint.prototype.setLinearUpperLimit = btGeneric6DofConstraint.prototype.setLinearUpperLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofConstraint_setLinearUpperLimit_1(self, arg0);
    }, btGeneric6DofConstraint.prototype.setAngularLowerLimit = btGeneric6DofConstraint.prototype.setAngularLowerLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofConstraint_setAngularLowerLimit_1(self, arg0);
    }, btGeneric6DofConstraint.prototype.setAngularUpperLimit = btGeneric6DofConstraint.prototype.setAngularUpperLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofConstraint_setAngularUpperLimit_1(self, arg0);
    }, btGeneric6DofConstraint.prototype.enableFeedback = btGeneric6DofConstraint.prototype.enableFeedback = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofConstraint_enableFeedback_1(self, arg0);
    }, btGeneric6DofConstraint.prototype.getBreakingImpulseThreshold = btGeneric6DofConstraint.prototype.getBreakingImpulseThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btGeneric6DofConstraint_getBreakingImpulseThreshold_0(self);
    }, btGeneric6DofConstraint.prototype.setBreakingImpulseThreshold = btGeneric6DofConstraint.prototype.setBreakingImpulseThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofConstraint_setBreakingImpulseThreshold_1(self, arg0);
    }, btGeneric6DofConstraint.prototype.__destroy__ = btGeneric6DofConstraint.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btGeneric6DofConstraint___destroy___0(self);
    }, btStridingMeshInterface.prototype = Object.create(WrapperObject.prototype), btStridingMeshInterface.prototype.constructor = btStridingMeshInterface, 
    btStridingMeshInterface.prototype.__class__ = btStridingMeshInterface, btStridingMeshInterface.__cache__ = {}, 
    Module.btStridingMeshInterface = btStridingMeshInterface, btStridingMeshInterface.prototype.__destroy__ = btStridingMeshInterface.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btStridingMeshInterface___destroy___0(self);
    }, ConvexResultCallback.prototype = Object.create(WrapperObject.prototype), ConvexResultCallback.prototype.constructor = ConvexResultCallback, 
    ConvexResultCallback.prototype.__class__ = ConvexResultCallback, ConvexResultCallback.__cache__ = {}, 
    Module.ConvexResultCallback = ConvexResultCallback, ConvexResultCallback.prototype.hasHit = ConvexResultCallback.prototype.hasHit = function() {
        var self = this.ptr;
        return _emscripten_bind_ConvexResultCallback_hasHit_0(self);
    }, ConvexResultCallback.prototype.get_m_collisionFilterGroup = ConvexResultCallback.prototype.get_m_collisionFilterGroup = function() {
        var self = this.ptr;
        return _emscripten_bind_ConvexResultCallback_get_m_collisionFilterGroup_0(self);
    }, ConvexResultCallback.prototype.set_m_collisionFilterGroup = ConvexResultCallback.prototype.set_m_collisionFilterGroup = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ConvexResultCallback_set_m_collisionFilterGroup_1(self, arg0);
    }, ConvexResultCallback.prototype.get_m_collisionFilterMask = ConvexResultCallback.prototype.get_m_collisionFilterMask = function() {
        var self = this.ptr;
        return _emscripten_bind_ConvexResultCallback_get_m_collisionFilterMask_0(self);
    }, ConvexResultCallback.prototype.set_m_collisionFilterMask = ConvexResultCallback.prototype.set_m_collisionFilterMask = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ConvexResultCallback_set_m_collisionFilterMask_1(self, arg0);
    }, ConvexResultCallback.prototype.get_m_closestHitFraction = ConvexResultCallback.prototype.get_m_closestHitFraction = function() {
        var self = this.ptr;
        return _emscripten_bind_ConvexResultCallback_get_m_closestHitFraction_0(self);
    }, ConvexResultCallback.prototype.set_m_closestHitFraction = ConvexResultCallback.prototype.set_m_closestHitFraction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ConvexResultCallback_set_m_closestHitFraction_1(self, arg0);
    }, ConvexResultCallback.prototype.__destroy__ = ConvexResultCallback.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_ConvexResultCallback___destroy___0(self);
    }, btMotionState.prototype = Object.create(WrapperObject.prototype), btMotionState.prototype.constructor = btMotionState, 
    btMotionState.prototype.__class__ = btMotionState, btMotionState.__cache__ = {}, 
    Module.btMotionState = btMotionState, btMotionState.prototype.getWorldTransform = btMotionState.prototype.getWorldTransform = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btMotionState_getWorldTransform_1(self, arg0);
    }, btMotionState.prototype.setWorldTransform = btMotionState.prototype.setWorldTransform = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btMotionState_setWorldTransform_1(self, arg0);
    }, btMotionState.prototype.__destroy__ = btMotionState.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btMotionState___destroy___0(self);
    }, btConeShape.prototype = Object.create(btCollisionShape.prototype), btConeShape.prototype.constructor = btConeShape, 
    btConeShape.prototype.__class__ = btConeShape, btConeShape.__cache__ = {}, Module.btConeShape = btConeShape, 
    btConeShape.prototype.setLocalScaling = btConeShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeShape_setLocalScaling_1(self, arg0);
    }, btConeShape.prototype.calculateLocalInertia = btConeShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btConeShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btConeShape.prototype.__destroy__ = btConeShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConeShape___destroy___0(self);
    }, btConvexShape.prototype = Object.create(btCollisionShape.prototype), btConvexShape.prototype.constructor = btConvexShape, 
    btConvexShape.prototype.__class__ = btConvexShape, btConvexShape.__cache__ = {}, 
    Module.btConvexShape = btConvexShape, btConvexShape.prototype.setLocalScaling = btConvexShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConvexShape_setLocalScaling_1(self, arg0);
    }, btConvexShape.prototype.calculateLocalInertia = btConvexShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btConvexShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btConvexShape.prototype.__destroy__ = btConvexShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConvexShape___destroy___0(self);
    }, ContactResultCallback.prototype = Object.create(WrapperObject.prototype), ContactResultCallback.prototype.constructor = ContactResultCallback, 
    ContactResultCallback.prototype.__class__ = ContactResultCallback, ContactResultCallback.__cache__ = {}, 
    Module.ContactResultCallback = ContactResultCallback, ContactResultCallback.prototype.addSingleResult = ContactResultCallback.prototype.addSingleResult = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), arg5 && "object" == typeof arg5 && (arg5 = arg5.ptr), 
        arg6 && "object" == typeof arg6 && (arg6 = arg6.ptr), _emscripten_bind_ContactResultCallback_addSingleResult_7(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
    }, ContactResultCallback.prototype.__destroy__ = ContactResultCallback.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_ContactResultCallback___destroy___0(self);
    }, btTriangleMeshShape.prototype = Object.create(btConcaveShape.prototype), btTriangleMeshShape.prototype.constructor = btTriangleMeshShape, 
    btTriangleMeshShape.prototype.__class__ = btTriangleMeshShape, btTriangleMeshShape.__cache__ = {}, 
    Module.btTriangleMeshShape = btTriangleMeshShape, btTriangleMeshShape.prototype.setLocalScaling = btTriangleMeshShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btTriangleMeshShape_setLocalScaling_1(self, arg0);
    }, btTriangleMeshShape.prototype.calculateLocalInertia = btTriangleMeshShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btTriangleMeshShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btTriangleMeshShape.prototype.__destroy__ = btTriangleMeshShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btTriangleMeshShape___destroy___0(self);
    }, btDispatcher.prototype = Object.create(WrapperObject.prototype), btDispatcher.prototype.constructor = btDispatcher, 
    btDispatcher.prototype.__class__ = btDispatcher, btDispatcher.__cache__ = {}, Module.btDispatcher = btDispatcher, 
    btDispatcher.prototype.getNumManifolds = btDispatcher.prototype.getNumManifolds = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcher_getNumManifolds_0(self);
    }, btDispatcher.prototype.getManifoldByIndexInternal = btDispatcher.prototype.getManifoldByIndexInternal = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btDispatcher_getManifoldByIndexInternal_1(self, arg0), btPersistentManifold);
    }, btDispatcher.prototype.__destroy__ = btDispatcher.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btDispatcher___destroy___0(self);
    }, btDynamicsWorld.prototype = Object.create(btCollisionWorld.prototype), btDynamicsWorld.prototype.constructor = btDynamicsWorld, 
    btDynamicsWorld.prototype.__class__ = btDynamicsWorld, btDynamicsWorld.__cache__ = {}, 
    Module.btDynamicsWorld = btDynamicsWorld, btDynamicsWorld.prototype.addAction = btDynamicsWorld.prototype.addAction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDynamicsWorld_addAction_1(self, arg0);
    }, btDynamicsWorld.prototype.removeAction = btDynamicsWorld.prototype.removeAction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDynamicsWorld_removeAction_1(self, arg0);
    }, btDynamicsWorld.prototype.getSolverInfo = btDynamicsWorld.prototype.getSolverInfo = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDynamicsWorld_getSolverInfo_0(self), btContactSolverInfo);
    }, btDynamicsWorld.prototype.getDispatcher = btDynamicsWorld.prototype.getDispatcher = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDynamicsWorld_getDispatcher_0(self), btDispatcher);
    }, btDynamicsWorld.prototype.rayTest = btDynamicsWorld.prototype.rayTest = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btDynamicsWorld_rayTest_3(self, arg0, arg1, arg2);
    }, btDynamicsWorld.prototype.getPairCache = btDynamicsWorld.prototype.getPairCache = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDynamicsWorld_getPairCache_0(self), btOverlappingPairCache);
    }, btDynamicsWorld.prototype.getDispatchInfo = btDynamicsWorld.prototype.getDispatchInfo = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDynamicsWorld_getDispatchInfo_0(self), btDispatcherInfo);
    }, btDynamicsWorld.prototype.addCollisionObject = btDynamicsWorld.prototype.addCollisionObject = function(arg0, arg1, arg2) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), void 0 === arg1 ? void _emscripten_bind_btDynamicsWorld_addCollisionObject_1(self, arg0) : void 0 === arg2 ? void _emscripten_bind_btDynamicsWorld_addCollisionObject_2(self, arg0, arg1) : void _emscripten_bind_btDynamicsWorld_addCollisionObject_3(self, arg0, arg1, arg2);
    }, btDynamicsWorld.prototype.getBroadphase = btDynamicsWorld.prototype.getBroadphase = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDynamicsWorld_getBroadphase_0(self), btBroadphaseInterface);
    }, btDynamicsWorld.prototype.convexSweepTest = btDynamicsWorld.prototype.convexSweepTest = function(arg0, arg1, arg2, arg3, arg4) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), _emscripten_bind_btDynamicsWorld_convexSweepTest_5(self, arg0, arg1, arg2, arg3, arg4);
    }, btDynamicsWorld.prototype.contactPairTest = btDynamicsWorld.prototype.contactPairTest = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btDynamicsWorld_contactPairTest_3(self, arg0, arg1, arg2);
    }, btDynamicsWorld.prototype.__destroy__ = btDynamicsWorld.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btDynamicsWorld___destroy___0(self);
    }, RayResultCallback.prototype = Object.create(WrapperObject.prototype), RayResultCallback.prototype.constructor = RayResultCallback, 
    RayResultCallback.prototype.__class__ = RayResultCallback, RayResultCallback.__cache__ = {}, 
    Module.RayResultCallback = RayResultCallback, RayResultCallback.prototype.hasHit = RayResultCallback.prototype.hasHit = function() {
        var self = this.ptr;
        return _emscripten_bind_RayResultCallback_hasHit_0(self);
    }, RayResultCallback.prototype.get_m_collisionFilterGroup = RayResultCallback.prototype.get_m_collisionFilterGroup = function() {
        var self = this.ptr;
        return _emscripten_bind_RayResultCallback_get_m_collisionFilterGroup_0(self);
    }, RayResultCallback.prototype.set_m_collisionFilterGroup = RayResultCallback.prototype.set_m_collisionFilterGroup = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_RayResultCallback_set_m_collisionFilterGroup_1(self, arg0);
    }, RayResultCallback.prototype.get_m_collisionFilterMask = RayResultCallback.prototype.get_m_collisionFilterMask = function() {
        var self = this.ptr;
        return _emscripten_bind_RayResultCallback_get_m_collisionFilterMask_0(self);
    }, RayResultCallback.prototype.set_m_collisionFilterMask = RayResultCallback.prototype.set_m_collisionFilterMask = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_RayResultCallback_set_m_collisionFilterMask_1(self, arg0);
    }, RayResultCallback.prototype.get_m_collisionObject = RayResultCallback.prototype.get_m_collisionObject = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_RayResultCallback_get_m_collisionObject_0(self), btCollisionObject);
    }, RayResultCallback.prototype.set_m_collisionObject = RayResultCallback.prototype.set_m_collisionObject = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_RayResultCallback_set_m_collisionObject_1(self, arg0);
    }, RayResultCallback.prototype.__destroy__ = RayResultCallback.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_RayResultCallback___destroy___0(self);
    }, btVector3.prototype = Object.create(WrapperObject.prototype), btVector3.prototype.constructor = btVector3, 
    btVector3.prototype.__class__ = btVector3, btVector3.__cache__ = {}, Module.btVector3 = btVector3, 
    btVector3.prototype.length = btVector3.prototype.length = function() {
        var self = this.ptr;
        return _emscripten_bind_btVector3_length_0(self);
    }, btVector3.prototype.x = btVector3.prototype.x = function() {
        var self = this.ptr;
        return _emscripten_bind_btVector3_x_0(self);
    }, btVector3.prototype.y = btVector3.prototype.y = function() {
        var self = this.ptr;
        return _emscripten_bind_btVector3_y_0(self);
    }, btVector3.prototype.z = btVector3.prototype.z = function() {
        var self = this.ptr;
        return _emscripten_bind_btVector3_z_0(self);
    }, btVector3.prototype.setX = btVector3.prototype.setX = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVector3_setX_1(self, arg0);
    }, btVector3.prototype.setY = btVector3.prototype.setY = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVector3_setY_1(self, arg0);
    }, btVector3.prototype.setZ = btVector3.prototype.setZ = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVector3_setZ_1(self, arg0);
    }, btVector3.prototype.setValue = btVector3.prototype.setValue = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btVector3_setValue_3(self, arg0, arg1, arg2);
    }, btVector3.prototype.op_mul = btVector3.prototype.op_mul = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btVector3_op_mul_1(self, arg0), btVector3);
    }, btVector3.prototype.__destroy__ = btVector3.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btVector3___destroy___0(self);
    }, btVehicleRaycaster.prototype = Object.create(WrapperObject.prototype), btVehicleRaycaster.prototype.constructor = btVehicleRaycaster, 
    btVehicleRaycaster.prototype.__class__ = btVehicleRaycaster, btVehicleRaycaster.__cache__ = {}, 
    Module.btVehicleRaycaster = btVehicleRaycaster, btVehicleRaycaster.prototype.__destroy__ = btVehicleRaycaster.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btVehicleRaycaster___destroy___0(self);
    }, btGhostObject.prototype = Object.create(btCollisionObject.prototype), btGhostObject.prototype.constructor = btGhostObject, 
    btGhostObject.prototype.__class__ = btGhostObject, btGhostObject.__cache__ = {}, 
    Module.btGhostObject = btGhostObject, btGhostObject.prototype.getNumOverlappingObjects = btGhostObject.prototype.getNumOverlappingObjects = function() {
        var self = this.ptr;
        return _emscripten_bind_btGhostObject_getNumOverlappingObjects_0(self);
    }, btGhostObject.prototype.getOverlappingObject = btGhostObject.prototype.getOverlappingObject = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btGhostObject_getOverlappingObject_1(self, arg0), btCollisionObject);
    }, btGhostObject.prototype.setAnisotropicFriction = btGhostObject.prototype.setAnisotropicFriction = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btGhostObject_setAnisotropicFriction_2(self, arg0, arg1);
    }, btGhostObject.prototype.getCollisionShape = btGhostObject.prototype.getCollisionShape = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btGhostObject_getCollisionShape_0(self), btCollisionShape);
    }, btGhostObject.prototype.setContactProcessingThreshold = btGhostObject.prototype.setContactProcessingThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setContactProcessingThreshold_1(self, arg0);
    }, btGhostObject.prototype.setActivationState = btGhostObject.prototype.setActivationState = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setActivationState_1(self, arg0);
    }, btGhostObject.prototype.forceActivationState = btGhostObject.prototype.forceActivationState = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_forceActivationState_1(self, arg0);
    }, btGhostObject.prototype.activate = btGhostObject.prototype.activate = function(arg0) {
        var self = this.ptr;
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), void 0 === arg0) return void _emscripten_bind_btGhostObject_activate_0(self);
        _emscripten_bind_btGhostObject_activate_1(self, arg0);
    }, btGhostObject.prototype.isActive = btGhostObject.prototype.isActive = function() {
        var self = this.ptr;
        return _emscripten_bind_btGhostObject_isActive_0(self);
    }, btGhostObject.prototype.isKinematicObject = btGhostObject.prototype.isKinematicObject = function() {
        var self = this.ptr;
        return _emscripten_bind_btGhostObject_isKinematicObject_0(self);
    }, btGhostObject.prototype.setRestitution = btGhostObject.prototype.setRestitution = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setRestitution_1(self, arg0);
    }, btGhostObject.prototype.setFriction = btGhostObject.prototype.setFriction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setFriction_1(self, arg0);
    }, btGhostObject.prototype.setRollingFriction = btGhostObject.prototype.setRollingFriction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setRollingFriction_1(self, arg0);
    }, btGhostObject.prototype.getWorldTransform = btGhostObject.prototype.getWorldTransform = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btGhostObject_getWorldTransform_0(self), btTransform);
    }, btGhostObject.prototype.getCollisionFlags = btGhostObject.prototype.getCollisionFlags = function() {
        var self = this.ptr;
        return _emscripten_bind_btGhostObject_getCollisionFlags_0(self);
    }, btGhostObject.prototype.setCollisionFlags = btGhostObject.prototype.setCollisionFlags = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setCollisionFlags_1(self, arg0);
    }, btGhostObject.prototype.setWorldTransform = btGhostObject.prototype.setWorldTransform = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setWorldTransform_1(self, arg0);
    }, btGhostObject.prototype.setCollisionShape = btGhostObject.prototype.setCollisionShape = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setCollisionShape_1(self, arg0);
    }, btGhostObject.prototype.setCcdMotionThreshold = btGhostObject.prototype.setCcdMotionThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setCcdMotionThreshold_1(self, arg0);
    }, btGhostObject.prototype.setCcdSweptSphereRadius = btGhostObject.prototype.setCcdSweptSphereRadius = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGhostObject_setCcdSweptSphereRadius_1(self, arg0);
    }, btGhostObject.prototype.__destroy__ = btGhostObject.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btGhostObject___destroy___0(self);
    }, btQuadWord.prototype = Object.create(WrapperObject.prototype), btQuadWord.prototype.constructor = btQuadWord, 
    btQuadWord.prototype.__class__ = btQuadWord, btQuadWord.__cache__ = {}, Module.btQuadWord = btQuadWord, 
    btQuadWord.prototype.x = btQuadWord.prototype.x = function() {
        var self = this.ptr;
        return _emscripten_bind_btQuadWord_x_0(self);
    }, btQuadWord.prototype.y = btQuadWord.prototype.y = function() {
        var self = this.ptr;
        return _emscripten_bind_btQuadWord_y_0(self);
    }, btQuadWord.prototype.z = btQuadWord.prototype.z = function() {
        var self = this.ptr;
        return _emscripten_bind_btQuadWord_z_0(self);
    }, btQuadWord.prototype.w = btQuadWord.prototype.w = function() {
        var self = this.ptr;
        return _emscripten_bind_btQuadWord_w_0(self);
    }, btQuadWord.prototype.setX = btQuadWord.prototype.setX = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btQuadWord_setX_1(self, arg0);
    }, btQuadWord.prototype.setY = btQuadWord.prototype.setY = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btQuadWord_setY_1(self, arg0);
    }, btQuadWord.prototype.setZ = btQuadWord.prototype.setZ = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btQuadWord_setZ_1(self, arg0);
    }, btQuadWord.prototype.setW = btQuadWord.prototype.setW = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btQuadWord_setW_1(self, arg0);
    }, btQuadWord.prototype.__destroy__ = btQuadWord.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btQuadWord___destroy___0(self);
    }, btCylinderShape.prototype = Object.create(btCollisionShape.prototype), btCylinderShape.prototype.constructor = btCylinderShape, 
    btCylinderShape.prototype.__class__ = btCylinderShape, btCylinderShape.__cache__ = {}, 
    Module.btCylinderShape = btCylinderShape, btCylinderShape.prototype.setMargin = btCylinderShape.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCylinderShape_setMargin_1(self, arg0);
    }, btCylinderShape.prototype.getMargin = btCylinderShape.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btCylinderShape_getMargin_0(self);
    }, btCylinderShape.prototype.setLocalScaling = btCylinderShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCylinderShape_setLocalScaling_1(self, arg0);
    }, btCylinderShape.prototype.calculateLocalInertia = btCylinderShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCylinderShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btCylinderShape.prototype.__destroy__ = btCylinderShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCylinderShape___destroy___0(self);
    }, btActionInterface.prototype = Object.create(WrapperObject.prototype), btActionInterface.prototype.constructor = btActionInterface, 
    btActionInterface.prototype.__class__ = btActionInterface, btActionInterface.__cache__ = {}, 
    Module.btActionInterface = btActionInterface, btActionInterface.prototype.__destroy__ = btActionInterface.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btActionInterface___destroy___0(self);
    }, btMatrix3x3.prototype = Object.create(WrapperObject.prototype), btMatrix3x3.prototype.constructor = btMatrix3x3, 
    btMatrix3x3.prototype.__class__ = btMatrix3x3, btMatrix3x3.__cache__ = {}, Module.btMatrix3x3 = btMatrix3x3, 
    btMatrix3x3.prototype.setEulerZYX = btMatrix3x3.prototype.setEulerZYX = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btMatrix3x3_setEulerZYX_3(self, arg0, arg1, arg2);
    }, btMatrix3x3.prototype.getRotation = btMatrix3x3.prototype.getRotation = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btMatrix3x3_getRotation_1(self, arg0);
    }, btMatrix3x3.prototype.__destroy__ = btMatrix3x3.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btMatrix3x3___destroy___0(self);
    }, ConcreteContactResultCallback.prototype = Object.create(ContactResultCallback.prototype), 
    ConcreteContactResultCallback.prototype.constructor = ConcreteContactResultCallback, 
    ConcreteContactResultCallback.prototype.__class__ = ConcreteContactResultCallback, 
    ConcreteContactResultCallback.__cache__ = {}, Module.ConcreteContactResultCallback = ConcreteContactResultCallback, 
    ConcreteContactResultCallback.prototype.addSingleResult = ConcreteContactResultCallback.prototype.addSingleResult = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), arg5 && "object" == typeof arg5 && (arg5 = arg5.ptr), 
        arg6 && "object" == typeof arg6 && (arg6 = arg6.ptr), _emscripten_bind_ConcreteContactResultCallback_addSingleResult_7(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
    }, ConcreteContactResultCallback.prototype.__destroy__ = ConcreteContactResultCallback.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_ConcreteContactResultCallback___destroy___0(self);
    }, btBvhTriangleMeshShape.prototype = Object.create(btTriangleMeshShape.prototype), 
    btBvhTriangleMeshShape.prototype.constructor = btBvhTriangleMeshShape, btBvhTriangleMeshShape.prototype.__class__ = btBvhTriangleMeshShape, 
    btBvhTriangleMeshShape.__cache__ = {}, Module.btBvhTriangleMeshShape = btBvhTriangleMeshShape, 
    btBvhTriangleMeshShape.prototype.setLocalScaling = btBvhTriangleMeshShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btBvhTriangleMeshShape_setLocalScaling_1(self, arg0);
    }, btBvhTriangleMeshShape.prototype.calculateLocalInertia = btBvhTriangleMeshShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btBvhTriangleMeshShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btBvhTriangleMeshShape.prototype.__destroy__ = btBvhTriangleMeshShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btBvhTriangleMeshShape___destroy___0(self);
    }, btDbvtBroadphase.prototype = Object.create(WrapperObject.prototype), btDbvtBroadphase.prototype.constructor = btDbvtBroadphase, 
    btDbvtBroadphase.prototype.__class__ = btDbvtBroadphase, btDbvtBroadphase.__cache__ = {}, 
    Module.btDbvtBroadphase = btDbvtBroadphase, btDbvtBroadphase.prototype.__destroy__ = btDbvtBroadphase.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btDbvtBroadphase___destroy___0(self);
    }, VoidPtr.prototype = Object.create(WrapperObject.prototype), VoidPtr.prototype.constructor = VoidPtr, 
    VoidPtr.prototype.__class__ = VoidPtr, VoidPtr.__cache__ = {}, Module.VoidPtr = VoidPtr, 
    VoidPtr.prototype.__destroy__ = VoidPtr.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_VoidPtr___destroy___0(self);
    }, btSequentialImpulseConstraintSolver.prototype = Object.create(WrapperObject.prototype), 
    btSequentialImpulseConstraintSolver.prototype.constructor = btSequentialImpulseConstraintSolver, 
    btSequentialImpulseConstraintSolver.prototype.__class__ = btSequentialImpulseConstraintSolver, 
    btSequentialImpulseConstraintSolver.__cache__ = {}, Module.btSequentialImpulseConstraintSolver = btSequentialImpulseConstraintSolver, 
    btSequentialImpulseConstraintSolver.prototype.__destroy__ = btSequentialImpulseConstraintSolver.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btSequentialImpulseConstraintSolver___destroy___0(self);
    }, btDispatcherInfo.prototype = Object.create(WrapperObject.prototype), btDispatcherInfo.prototype.constructor = btDispatcherInfo, 
    btDispatcherInfo.prototype.__class__ = btDispatcherInfo, btDispatcherInfo.__cache__ = {}, 
    Module.btDispatcherInfo = btDispatcherInfo, btDispatcherInfo.prototype.get_m_timeStep = btDispatcherInfo.prototype.get_m_timeStep = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_timeStep_0(self);
    }, btDispatcherInfo.prototype.set_m_timeStep = btDispatcherInfo.prototype.set_m_timeStep = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_timeStep_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_stepCount = btDispatcherInfo.prototype.get_m_stepCount = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_stepCount_0(self);
    }, btDispatcherInfo.prototype.set_m_stepCount = btDispatcherInfo.prototype.set_m_stepCount = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_stepCount_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_dispatchFunc = btDispatcherInfo.prototype.get_m_dispatchFunc = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_dispatchFunc_0(self);
    }, btDispatcherInfo.prototype.set_m_dispatchFunc = btDispatcherInfo.prototype.set_m_dispatchFunc = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_dispatchFunc_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_timeOfImpact = btDispatcherInfo.prototype.get_m_timeOfImpact = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_timeOfImpact_0(self);
    }, btDispatcherInfo.prototype.set_m_timeOfImpact = btDispatcherInfo.prototype.set_m_timeOfImpact = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_timeOfImpact_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_useContinuous = btDispatcherInfo.prototype.get_m_useContinuous = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_useContinuous_0(self);
    }, btDispatcherInfo.prototype.set_m_useContinuous = btDispatcherInfo.prototype.set_m_useContinuous = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_useContinuous_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_enableSatConvex = btDispatcherInfo.prototype.get_m_enableSatConvex = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_enableSatConvex_0(self);
    }, btDispatcherInfo.prototype.set_m_enableSatConvex = btDispatcherInfo.prototype.set_m_enableSatConvex = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_enableSatConvex_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_enableSPU = btDispatcherInfo.prototype.get_m_enableSPU = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_enableSPU_0(self);
    }, btDispatcherInfo.prototype.set_m_enableSPU = btDispatcherInfo.prototype.set_m_enableSPU = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_enableSPU_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_useEpa = btDispatcherInfo.prototype.get_m_useEpa = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_useEpa_0(self);
    }, btDispatcherInfo.prototype.set_m_useEpa = btDispatcherInfo.prototype.set_m_useEpa = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_useEpa_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_allowedCcdPenetration = btDispatcherInfo.prototype.get_m_allowedCcdPenetration = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_allowedCcdPenetration_0(self);
    }, btDispatcherInfo.prototype.set_m_allowedCcdPenetration = btDispatcherInfo.prototype.set_m_allowedCcdPenetration = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_allowedCcdPenetration_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_useConvexConservativeDistanceUtil = btDispatcherInfo.prototype.get_m_useConvexConservativeDistanceUtil = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_useConvexConservativeDistanceUtil_0(self);
    }, btDispatcherInfo.prototype.set_m_useConvexConservativeDistanceUtil = btDispatcherInfo.prototype.set_m_useConvexConservativeDistanceUtil = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_useConvexConservativeDistanceUtil_1(self, arg0);
    }, btDispatcherInfo.prototype.get_m_convexConservativeDistanceThreshold = btDispatcherInfo.prototype.get_m_convexConservativeDistanceThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btDispatcherInfo_get_m_convexConservativeDistanceThreshold_0(self);
    }, btDispatcherInfo.prototype.set_m_convexConservativeDistanceThreshold = btDispatcherInfo.prototype.set_m_convexConservativeDistanceThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDispatcherInfo_set_m_convexConservativeDistanceThreshold_1(self, arg0);
    }, btDispatcherInfo.prototype.__destroy__ = btDispatcherInfo.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btDispatcherInfo___destroy___0(self);
    }, btCollisionConfiguration.prototype = Object.create(WrapperObject.prototype), 
    btCollisionConfiguration.prototype.constructor = btCollisionConfiguration, btCollisionConfiguration.prototype.__class__ = btCollisionConfiguration, 
    btCollisionConfiguration.__cache__ = {}, Module.btCollisionConfiguration = btCollisionConfiguration, 
    btCollisionConfiguration.prototype.__destroy__ = btCollisionConfiguration.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCollisionConfiguration___destroy___0(self);
    }, btAxisSweep3.prototype = Object.create(WrapperObject.prototype), btAxisSweep3.prototype.constructor = btAxisSweep3, 
    btAxisSweep3.prototype.__class__ = btAxisSweep3, btAxisSweep3.__cache__ = {}, Module.btAxisSweep3 = btAxisSweep3, 
    btAxisSweep3.prototype.__destroy__ = btAxisSweep3.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btAxisSweep3___destroy___0(self);
    }, btPairCachingGhostObject.prototype = Object.create(btGhostObject.prototype), 
    btPairCachingGhostObject.prototype.constructor = btPairCachingGhostObject, btPairCachingGhostObject.prototype.__class__ = btPairCachingGhostObject, 
    btPairCachingGhostObject.__cache__ = {}, Module.btPairCachingGhostObject = btPairCachingGhostObject, 
    btPairCachingGhostObject.prototype.setAnisotropicFriction = btPairCachingGhostObject.prototype.setAnisotropicFriction = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btPairCachingGhostObject_setAnisotropicFriction_2(self, arg0, arg1);
    }, btPairCachingGhostObject.prototype.getCollisionShape = btPairCachingGhostObject.prototype.getCollisionShape = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btPairCachingGhostObject_getCollisionShape_0(self), btCollisionShape);
    }, btPairCachingGhostObject.prototype.setContactProcessingThreshold = btPairCachingGhostObject.prototype.setContactProcessingThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setContactProcessingThreshold_1(self, arg0);
    }, btPairCachingGhostObject.prototype.setActivationState = btPairCachingGhostObject.prototype.setActivationState = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setActivationState_1(self, arg0);
    }, btPairCachingGhostObject.prototype.forceActivationState = btPairCachingGhostObject.prototype.forceActivationState = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_forceActivationState_1(self, arg0);
    }, btPairCachingGhostObject.prototype.activate = btPairCachingGhostObject.prototype.activate = function(arg0) {
        var self = this.ptr;
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), void 0 === arg0) return void _emscripten_bind_btPairCachingGhostObject_activate_0(self);
        _emscripten_bind_btPairCachingGhostObject_activate_1(self, arg0);
    }, btPairCachingGhostObject.prototype.isActive = btPairCachingGhostObject.prototype.isActive = function() {
        var self = this.ptr;
        return _emscripten_bind_btPairCachingGhostObject_isActive_0(self);
    }, btPairCachingGhostObject.prototype.isKinematicObject = btPairCachingGhostObject.prototype.isKinematicObject = function() {
        var self = this.ptr;
        return _emscripten_bind_btPairCachingGhostObject_isKinematicObject_0(self);
    }, btPairCachingGhostObject.prototype.setRestitution = btPairCachingGhostObject.prototype.setRestitution = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setRestitution_1(self, arg0);
    }, btPairCachingGhostObject.prototype.setFriction = btPairCachingGhostObject.prototype.setFriction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setFriction_1(self, arg0);
    }, btPairCachingGhostObject.prototype.setRollingFriction = btPairCachingGhostObject.prototype.setRollingFriction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setRollingFriction_1(self, arg0);
    }, btPairCachingGhostObject.prototype.getWorldTransform = btPairCachingGhostObject.prototype.getWorldTransform = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btPairCachingGhostObject_getWorldTransform_0(self), btTransform);
    }, btPairCachingGhostObject.prototype.getCollisionFlags = btPairCachingGhostObject.prototype.getCollisionFlags = function() {
        var self = this.ptr;
        return _emscripten_bind_btPairCachingGhostObject_getCollisionFlags_0(self);
    }, btPairCachingGhostObject.prototype.setCollisionFlags = btPairCachingGhostObject.prototype.setCollisionFlags = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setCollisionFlags_1(self, arg0);
    }, btPairCachingGhostObject.prototype.setWorldTransform = btPairCachingGhostObject.prototype.setWorldTransform = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setWorldTransform_1(self, arg0);
    }, btPairCachingGhostObject.prototype.setCollisionShape = btPairCachingGhostObject.prototype.setCollisionShape = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setCollisionShape_1(self, arg0);
    }, btPairCachingGhostObject.prototype.setCcdMotionThreshold = btPairCachingGhostObject.prototype.setCcdMotionThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setCcdMotionThreshold_1(self, arg0);
    }, btPairCachingGhostObject.prototype.setCcdSweptSphereRadius = btPairCachingGhostObject.prototype.setCcdSweptSphereRadius = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPairCachingGhostObject_setCcdSweptSphereRadius_1(self, arg0);
    }, btPairCachingGhostObject.prototype.getNumOverlappingObjects = btPairCachingGhostObject.prototype.getNumOverlappingObjects = function() {
        var self = this.ptr;
        return _emscripten_bind_btPairCachingGhostObject_getNumOverlappingObjects_0(self);
    }, btPairCachingGhostObject.prototype.getOverlappingObject = btPairCachingGhostObject.prototype.getOverlappingObject = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btPairCachingGhostObject_getOverlappingObject_1(self, arg0), btCollisionObject);
    }, btPairCachingGhostObject.prototype.__destroy__ = btPairCachingGhostObject.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btPairCachingGhostObject___destroy___0(self);
    }, btRigidBodyConstructionInfo.prototype = Object.create(WrapperObject.prototype), 
    btRigidBodyConstructionInfo.prototype.constructor = btRigidBodyConstructionInfo, 
    btRigidBodyConstructionInfo.prototype.__class__ = btRigidBodyConstructionInfo, btRigidBodyConstructionInfo.__cache__ = {}, 
    Module.btRigidBodyConstructionInfo = btRigidBodyConstructionInfo, btRigidBodyConstructionInfo.prototype.get_m_linearDamping = btRigidBodyConstructionInfo.prototype.get_m_linearDamping = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_linearDamping_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_linearDamping = btRigidBodyConstructionInfo.prototype.set_m_linearDamping = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_linearDamping_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_angularDamping = btRigidBodyConstructionInfo.prototype.get_m_angularDamping = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_angularDamping_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_angularDamping = btRigidBodyConstructionInfo.prototype.set_m_angularDamping = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_angularDamping_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_friction = btRigidBodyConstructionInfo.prototype.get_m_friction = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_friction_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_friction = btRigidBodyConstructionInfo.prototype.set_m_friction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_friction_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_rollingFriction = btRigidBodyConstructionInfo.prototype.get_m_rollingFriction = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_rollingFriction_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_rollingFriction = btRigidBodyConstructionInfo.prototype.set_m_rollingFriction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_rollingFriction_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_restitution = btRigidBodyConstructionInfo.prototype.get_m_restitution = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_restitution_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_restitution = btRigidBodyConstructionInfo.prototype.set_m_restitution = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_restitution_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_linearSleepingThreshold = btRigidBodyConstructionInfo.prototype.get_m_linearSleepingThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_linearSleepingThreshold_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_linearSleepingThreshold = btRigidBodyConstructionInfo.prototype.set_m_linearSleepingThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_linearSleepingThreshold_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_angularSleepingThreshold = btRigidBodyConstructionInfo.prototype.get_m_angularSleepingThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_angularSleepingThreshold_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_angularSleepingThreshold = btRigidBodyConstructionInfo.prototype.set_m_angularSleepingThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_angularSleepingThreshold_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_additionalDamping = btRigidBodyConstructionInfo.prototype.get_m_additionalDamping = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDamping_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_additionalDamping = btRigidBodyConstructionInfo.prototype.set_m_additionalDamping = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDamping_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_additionalDampingFactor = btRigidBodyConstructionInfo.prototype.get_m_additionalDampingFactor = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalDampingFactor_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_additionalDampingFactor = btRigidBodyConstructionInfo.prototype.set_m_additionalDampingFactor = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalDampingFactor_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_additionalLinearDampingThresholdSqr = btRigidBodyConstructionInfo.prototype.get_m_additionalLinearDampingThresholdSqr = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalLinearDampingThresholdSqr_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_additionalLinearDampingThresholdSqr = btRigidBodyConstructionInfo.prototype.set_m_additionalLinearDampingThresholdSqr = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalLinearDampingThresholdSqr_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_additionalAngularDampingThresholdSqr = btRigidBodyConstructionInfo.prototype.get_m_additionalAngularDampingThresholdSqr = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingThresholdSqr_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_additionalAngularDampingThresholdSqr = btRigidBodyConstructionInfo.prototype.set_m_additionalAngularDampingThresholdSqr = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingThresholdSqr_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.get_m_additionalAngularDampingFactor = btRigidBodyConstructionInfo.prototype.get_m_additionalAngularDampingFactor = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBodyConstructionInfo_get_m_additionalAngularDampingFactor_0(self);
    }, btRigidBodyConstructionInfo.prototype.set_m_additionalAngularDampingFactor = btRigidBodyConstructionInfo.prototype.set_m_additionalAngularDampingFactor = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBodyConstructionInfo_set_m_additionalAngularDampingFactor_1(self, arg0);
    }, btRigidBodyConstructionInfo.prototype.__destroy__ = btRigidBodyConstructionInfo.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btRigidBodyConstructionInfo___destroy___0(self);
    }, btManifoldPoint.prototype = Object.create(WrapperObject.prototype), btManifoldPoint.prototype.constructor = btManifoldPoint, 
    btManifoldPoint.prototype.__class__ = btManifoldPoint, btManifoldPoint.__cache__ = {}, 
    Module.btManifoldPoint = btManifoldPoint, btManifoldPoint.prototype.getPositionWorldOnA = btManifoldPoint.prototype.getPositionWorldOnA = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btManifoldPoint_getPositionWorldOnA_0(self), btVector3);
    }, btManifoldPoint.prototype.getPositionWorldOnB = btManifoldPoint.prototype.getPositionWorldOnB = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btManifoldPoint_getPositionWorldOnB_0(self), btVector3);
    }, btManifoldPoint.prototype.getDistance = btManifoldPoint.prototype.getDistance = function() {
        var self = this.ptr;
        return _emscripten_bind_btManifoldPoint_getDistance_0(self);
    }, btManifoldPoint.prototype.get_m_localPointA = btManifoldPoint.prototype.get_m_localPointA = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btManifoldPoint_get_m_localPointA_0(self), btVector3);
    }, btManifoldPoint.prototype.set_m_localPointA = btManifoldPoint.prototype.set_m_localPointA = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btManifoldPoint_set_m_localPointA_1(self, arg0);
    }, btManifoldPoint.prototype.get_m_localPointB = btManifoldPoint.prototype.get_m_localPointB = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btManifoldPoint_get_m_localPointB_0(self), btVector3);
    }, btManifoldPoint.prototype.set_m_localPointB = btManifoldPoint.prototype.set_m_localPointB = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btManifoldPoint_set_m_localPointB_1(self, arg0);
    }, btManifoldPoint.prototype.get_m_positionWorldOnB = btManifoldPoint.prototype.get_m_positionWorldOnB = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btManifoldPoint_get_m_positionWorldOnB_0(self), btVector3);
    }, btManifoldPoint.prototype.set_m_positionWorldOnB = btManifoldPoint.prototype.set_m_positionWorldOnB = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btManifoldPoint_set_m_positionWorldOnB_1(self, arg0);
    }, btManifoldPoint.prototype.get_m_positionWorldOnA = btManifoldPoint.prototype.get_m_positionWorldOnA = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btManifoldPoint_get_m_positionWorldOnA_0(self), btVector3);
    }, btManifoldPoint.prototype.set_m_positionWorldOnA = btManifoldPoint.prototype.set_m_positionWorldOnA = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btManifoldPoint_set_m_positionWorldOnA_1(self, arg0);
    }, btManifoldPoint.prototype.get_m_normalWorldOnB = btManifoldPoint.prototype.get_m_normalWorldOnB = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btManifoldPoint_get_m_normalWorldOnB_0(self), btVector3);
    }, btManifoldPoint.prototype.set_m_normalWorldOnB = btManifoldPoint.prototype.set_m_normalWorldOnB = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btManifoldPoint_set_m_normalWorldOnB_1(self, arg0);
    }, btManifoldPoint.prototype.__destroy__ = btManifoldPoint.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btManifoldPoint___destroy___0(self);
    }, btBroadphaseInterface.prototype = Object.create(WrapperObject.prototype), btBroadphaseInterface.prototype.constructor = btBroadphaseInterface, 
    btBroadphaseInterface.prototype.__class__ = btBroadphaseInterface, btBroadphaseInterface.__cache__ = {}, 
    Module.btBroadphaseInterface = btBroadphaseInterface, btBroadphaseInterface.prototype.__destroy__ = btBroadphaseInterface.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btBroadphaseInterface___destroy___0(self);
    }, btDiscreteDynamicsWorld.prototype = Object.create(btDynamicsWorld.prototype), 
    btDiscreteDynamicsWorld.prototype.constructor = btDiscreteDynamicsWorld, btDiscreteDynamicsWorld.prototype.__class__ = btDiscreteDynamicsWorld, 
    btDiscreteDynamicsWorld.__cache__ = {}, Module.btDiscreteDynamicsWorld = btDiscreteDynamicsWorld, 
    btDiscreteDynamicsWorld.prototype.setGravity = btDiscreteDynamicsWorld.prototype.setGravity = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDiscreteDynamicsWorld_setGravity_1(self, arg0);
    }, btDiscreteDynamicsWorld.prototype.getGravity = btDiscreteDynamicsWorld.prototype.getGravity = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDiscreteDynamicsWorld_getGravity_0(self), btVector3);
    }, btDiscreteDynamicsWorld.prototype.addRigidBody = btDiscreteDynamicsWorld.prototype.addRigidBody = function(arg0, arg1, arg2) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), void 0 === arg1 ? void _emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_1(self, arg0) : void 0 === arg2 ? void _emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_2(self, arg0, arg1) : void _emscripten_bind_btDiscreteDynamicsWorld_addRigidBody_3(self, arg0, arg1, arg2);
    }, btDiscreteDynamicsWorld.prototype.removeRigidBody = btDiscreteDynamicsWorld.prototype.removeRigidBody = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDiscreteDynamicsWorld_removeRigidBody_1(self, arg0);
    }, btDiscreteDynamicsWorld.prototype.addConstraint = btDiscreteDynamicsWorld.prototype.addConstraint = function(arg0, arg1) {
        var self = this.ptr;
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        void 0 === arg1) return void _emscripten_bind_btDiscreteDynamicsWorld_addConstraint_1(self, arg0);
        _emscripten_bind_btDiscreteDynamicsWorld_addConstraint_2(self, arg0, arg1);
    }, btDiscreteDynamicsWorld.prototype.removeConstraint = btDiscreteDynamicsWorld.prototype.removeConstraint = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDiscreteDynamicsWorld_removeConstraint_1(self, arg0);
    }, btDiscreteDynamicsWorld.prototype.stepSimulation = btDiscreteDynamicsWorld.prototype.stepSimulation = function(arg0, arg1, arg2) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), void 0 === arg1 ? _emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_1(self, arg0) : void 0 === arg2 ? _emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_2(self, arg0, arg1) : _emscripten_bind_btDiscreteDynamicsWorld_stepSimulation_3(self, arg0, arg1, arg2);
    }, btDiscreteDynamicsWorld.prototype.getDispatcher = btDiscreteDynamicsWorld.prototype.getDispatcher = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDiscreteDynamicsWorld_getDispatcher_0(self), btDispatcher);
    }, btDiscreteDynamicsWorld.prototype.rayTest = btDiscreteDynamicsWorld.prototype.rayTest = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btDiscreteDynamicsWorld_rayTest_3(self, arg0, arg1, arg2);
    }, btDiscreteDynamicsWorld.prototype.getPairCache = btDiscreteDynamicsWorld.prototype.getPairCache = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDiscreteDynamicsWorld_getPairCache_0(self), btOverlappingPairCache);
    }, btDiscreteDynamicsWorld.prototype.getDispatchInfo = btDiscreteDynamicsWorld.prototype.getDispatchInfo = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDiscreteDynamicsWorld_getDispatchInfo_0(self), btDispatcherInfo);
    }, btDiscreteDynamicsWorld.prototype.addCollisionObject = btDiscreteDynamicsWorld.prototype.addCollisionObject = function(arg0, arg1, arg2) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), void 0 === arg1 ? void _emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_1(self, arg0) : void 0 === arg2 ? void _emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_2(self, arg0, arg1) : void _emscripten_bind_btDiscreteDynamicsWorld_addCollisionObject_3(self, arg0, arg1, arg2);
    }, btDiscreteDynamicsWorld.prototype.getBroadphase = btDiscreteDynamicsWorld.prototype.getBroadphase = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDiscreteDynamicsWorld_getBroadphase_0(self), btBroadphaseInterface);
    }, btDiscreteDynamicsWorld.prototype.convexSweepTest = btDiscreteDynamicsWorld.prototype.convexSweepTest = function(arg0, arg1, arg2, arg3, arg4) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), _emscripten_bind_btDiscreteDynamicsWorld_convexSweepTest_5(self, arg0, arg1, arg2, arg3, arg4);
    }, btDiscreteDynamicsWorld.prototype.contactPairTest = btDiscreteDynamicsWorld.prototype.contactPairTest = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btDiscreteDynamicsWorld_contactPairTest_3(self, arg0, arg1, arg2);
    }, btDiscreteDynamicsWorld.prototype.addAction = btDiscreteDynamicsWorld.prototype.addAction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDiscreteDynamicsWorld_addAction_1(self, arg0);
    }, btDiscreteDynamicsWorld.prototype.removeAction = btDiscreteDynamicsWorld.prototype.removeAction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDiscreteDynamicsWorld_removeAction_1(self, arg0);
    }, btDiscreteDynamicsWorld.prototype.getSolverInfo = btDiscreteDynamicsWorld.prototype.getSolverInfo = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDiscreteDynamicsWorld_getSolverInfo_0(self), btContactSolverInfo);
    }, btDiscreteDynamicsWorld.prototype.__destroy__ = btDiscreteDynamicsWorld.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btDiscreteDynamicsWorld___destroy___0(self);
    }, btConvexTriangleMeshShape.prototype = Object.create(btConvexShape.prototype), 
    btConvexTriangleMeshShape.prototype.constructor = btConvexTriangleMeshShape, btConvexTriangleMeshShape.prototype.__class__ = btConvexTriangleMeshShape, 
    btConvexTriangleMeshShape.__cache__ = {}, Module.btConvexTriangleMeshShape = btConvexTriangleMeshShape, 
    btConvexTriangleMeshShape.prototype.setLocalScaling = btConvexTriangleMeshShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConvexTriangleMeshShape_setLocalScaling_1(self, arg0);
    }, btConvexTriangleMeshShape.prototype.calculateLocalInertia = btConvexTriangleMeshShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btConvexTriangleMeshShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btConvexTriangleMeshShape.prototype.__destroy__ = btConvexTriangleMeshShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConvexTriangleMeshShape___destroy___0(self);
    }, btPoint2PointConstraint.prototype = Object.create(btTypedConstraint.prototype), 
    btPoint2PointConstraint.prototype.constructor = btPoint2PointConstraint, btPoint2PointConstraint.prototype.__class__ = btPoint2PointConstraint, 
    btPoint2PointConstraint.__cache__ = {}, Module.btPoint2PointConstraint = btPoint2PointConstraint, 
    btPoint2PointConstraint.prototype.setPivotA = btPoint2PointConstraint.prototype.setPivotA = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPoint2PointConstraint_setPivotA_1(self, arg0);
    }, btPoint2PointConstraint.prototype.setPivotB = btPoint2PointConstraint.prototype.setPivotB = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPoint2PointConstraint_setPivotB_1(self, arg0);
    }, btPoint2PointConstraint.prototype.getPivotInA = btPoint2PointConstraint.prototype.getPivotInA = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btPoint2PointConstraint_getPivotInA_0(self), btVector3);
    }, btPoint2PointConstraint.prototype.getPivotInB = btPoint2PointConstraint.prototype.getPivotInB = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btPoint2PointConstraint_getPivotInB_0(self), btVector3);
    }, btPoint2PointConstraint.prototype.enableFeedback = btPoint2PointConstraint.prototype.enableFeedback = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPoint2PointConstraint_enableFeedback_1(self, arg0);
    }, btPoint2PointConstraint.prototype.getBreakingImpulseThreshold = btPoint2PointConstraint.prototype.getBreakingImpulseThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btPoint2PointConstraint_getBreakingImpulseThreshold_0(self);
    }, btPoint2PointConstraint.prototype.setBreakingImpulseThreshold = btPoint2PointConstraint.prototype.setBreakingImpulseThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPoint2PointConstraint_setBreakingImpulseThreshold_1(self, arg0);
    }, btPoint2PointConstraint.prototype.get_m_setting = btPoint2PointConstraint.prototype.get_m_setting = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btPoint2PointConstraint_get_m_setting_0(self), btConstraintSetting);
    }, btPoint2PointConstraint.prototype.set_m_setting = btPoint2PointConstraint.prototype.set_m_setting = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btPoint2PointConstraint_set_m_setting_1(self, arg0);
    }, btPoint2PointConstraint.prototype.__destroy__ = btPoint2PointConstraint.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btPoint2PointConstraint___destroy___0(self);
    }, btSliderConstraint.prototype = Object.create(btTypedConstraint.prototype), btSliderConstraint.prototype.constructor = btSliderConstraint, 
    btSliderConstraint.prototype.__class__ = btSliderConstraint, btSliderConstraint.__cache__ = {}, 
    Module.btSliderConstraint = btSliderConstraint, btSliderConstraint.prototype.setLowerLinLimit = btSliderConstraint.prototype.setLowerLinLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btSliderConstraint_setLowerLinLimit_1(self, arg0);
    }, btSliderConstraint.prototype.setUpperLinLimit = btSliderConstraint.prototype.setUpperLinLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btSliderConstraint_setUpperLinLimit_1(self, arg0);
    }, btSliderConstraint.prototype.setLowerAngLimit = btSliderConstraint.prototype.setLowerAngLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btSliderConstraint_setLowerAngLimit_1(self, arg0);
    }, btSliderConstraint.prototype.setUpperAngLimit = btSliderConstraint.prototype.setUpperAngLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btSliderConstraint_setUpperAngLimit_1(self, arg0);
    }, btSliderConstraint.prototype.enableFeedback = btSliderConstraint.prototype.enableFeedback = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btSliderConstraint_enableFeedback_1(self, arg0);
    }, btSliderConstraint.prototype.getBreakingImpulseThreshold = btSliderConstraint.prototype.getBreakingImpulseThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btSliderConstraint_getBreakingImpulseThreshold_0(self);
    }, btSliderConstraint.prototype.setBreakingImpulseThreshold = btSliderConstraint.prototype.setBreakingImpulseThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btSliderConstraint_setBreakingImpulseThreshold_1(self, arg0);
    }, btSliderConstraint.prototype.__destroy__ = btSliderConstraint.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btSliderConstraint___destroy___0(self);
    }, btConeTwistConstraint.prototype = Object.create(btTypedConstraint.prototype), 
    btConeTwistConstraint.prototype.constructor = btConeTwistConstraint, btConeTwistConstraint.prototype.__class__ = btConeTwistConstraint, 
    btConeTwistConstraint.__cache__ = {}, Module.btConeTwistConstraint = btConeTwistConstraint, 
    btConeTwistConstraint.prototype.setLimit = btConeTwistConstraint.prototype.setLimit = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btConeTwistConstraint_setLimit_2(self, arg0, arg1);
    }, btConeTwistConstraint.prototype.setAngularOnly = btConeTwistConstraint.prototype.setAngularOnly = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeTwistConstraint_setAngularOnly_1(self, arg0);
    }, btConeTwistConstraint.prototype.setDamping = btConeTwistConstraint.prototype.setDamping = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeTwistConstraint_setDamping_1(self, arg0);
    }, btConeTwistConstraint.prototype.enableMotor = btConeTwistConstraint.prototype.enableMotor = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeTwistConstraint_enableMotor_1(self, arg0);
    }, btConeTwistConstraint.prototype.setMaxMotorImpulse = btConeTwistConstraint.prototype.setMaxMotorImpulse = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeTwistConstraint_setMaxMotorImpulse_1(self, arg0);
    }, btConeTwistConstraint.prototype.setMaxMotorImpulseNormalized = btConeTwistConstraint.prototype.setMaxMotorImpulseNormalized = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeTwistConstraint_setMaxMotorImpulseNormalized_1(self, arg0);
    }, btConeTwistConstraint.prototype.setMotorTarget = btConeTwistConstraint.prototype.setMotorTarget = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeTwistConstraint_setMotorTarget_1(self, arg0);
    }, btConeTwistConstraint.prototype.setMotorTargetInConstraintSpace = btConeTwistConstraint.prototype.setMotorTargetInConstraintSpace = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeTwistConstraint_setMotorTargetInConstraintSpace_1(self, arg0);
    }, btConeTwistConstraint.prototype.enableFeedback = btConeTwistConstraint.prototype.enableFeedback = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeTwistConstraint_enableFeedback_1(self, arg0);
    }, btConeTwistConstraint.prototype.getBreakingImpulseThreshold = btConeTwistConstraint.prototype.getBreakingImpulseThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btConeTwistConstraint_getBreakingImpulseThreshold_0(self);
    }, btConeTwistConstraint.prototype.setBreakingImpulseThreshold = btConeTwistConstraint.prototype.setBreakingImpulseThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeTwistConstraint_setBreakingImpulseThreshold_1(self, arg0);
    }, btConeTwistConstraint.prototype.__destroy__ = btConeTwistConstraint.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConeTwistConstraint___destroy___0(self);
    }, btDefaultCollisionConfiguration.prototype = Object.create(WrapperObject.prototype), 
    btDefaultCollisionConfiguration.prototype.constructor = btDefaultCollisionConfiguration, 
    btDefaultCollisionConfiguration.prototype.__class__ = btDefaultCollisionConfiguration, 
    btDefaultCollisionConfiguration.__cache__ = {}, Module.btDefaultCollisionConfiguration = btDefaultCollisionConfiguration, 
    btDefaultCollisionConfiguration.prototype.__destroy__ = btDefaultCollisionConfiguration.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btDefaultCollisionConfiguration___destroy___0(self);
    }, btConeShapeZ.prototype = Object.create(btConeShape.prototype), btConeShapeZ.prototype.constructor = btConeShapeZ, 
    btConeShapeZ.prototype.__class__ = btConeShapeZ, btConeShapeZ.__cache__ = {}, Module.btConeShapeZ = btConeShapeZ, 
    btConeShapeZ.prototype.setLocalScaling = btConeShapeZ.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeShapeZ_setLocalScaling_1(self, arg0);
    }, btConeShapeZ.prototype.calculateLocalInertia = btConeShapeZ.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btConeShapeZ_calculateLocalInertia_2(self, arg0, arg1);
    }, btConeShapeZ.prototype.__destroy__ = btConeShapeZ.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConeShapeZ___destroy___0(self);
    }, btConeShapeX.prototype = Object.create(btConeShape.prototype), btConeShapeX.prototype.constructor = btConeShapeX, 
    btConeShapeX.prototype.__class__ = btConeShapeX, btConeShapeX.__cache__ = {}, Module.btConeShapeX = btConeShapeX, 
    btConeShapeX.prototype.setLocalScaling = btConeShapeX.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConeShapeX_setLocalScaling_1(self, arg0);
    }, btConeShapeX.prototype.calculateLocalInertia = btConeShapeX.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btConeShapeX_calculateLocalInertia_2(self, arg0, arg1);
    }, btConeShapeX.prototype.__destroy__ = btConeShapeX.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConeShapeX___destroy___0(self);
    }, btTriangleMesh.prototype = Object.create(btStridingMeshInterface.prototype), 
    btTriangleMesh.prototype.constructor = btTriangleMesh, btTriangleMesh.prototype.__class__ = btTriangleMesh, 
    btTriangleMesh.__cache__ = {}, Module.btTriangleMesh = btTriangleMesh, btTriangleMesh.prototype.addTriangle = btTriangleMesh.prototype.addTriangle = function(arg0, arg1, arg2, arg3) {
        var self = this.ptr;
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        void 0 === arg3) return void _emscripten_bind_btTriangleMesh_addTriangle_3(self, arg0, arg1, arg2);
        _emscripten_bind_btTriangleMesh_addTriangle_4(self, arg0, arg1, arg2, arg3);
    }, btTriangleMesh.prototype.__destroy__ = btTriangleMesh.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btTriangleMesh___destroy___0(self);
    }, btConvexHullShape.prototype = Object.create(btCollisionShape.prototype), btConvexHullShape.prototype.constructor = btConvexHullShape, 
    btConvexHullShape.prototype.__class__ = btConvexHullShape, btConvexHullShape.__cache__ = {}, 
    Module.btConvexHullShape = btConvexHullShape, btConvexHullShape.prototype.addPoint = btConvexHullShape.prototype.addPoint = function(arg0, arg1) {
        var self = this.ptr;
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        void 0 === arg1) return void _emscripten_bind_btConvexHullShape_addPoint_1(self, arg0);
        _emscripten_bind_btConvexHullShape_addPoint_2(self, arg0, arg1);
    }, btConvexHullShape.prototype.setMargin = btConvexHullShape.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConvexHullShape_setMargin_1(self, arg0);
    }, btConvexHullShape.prototype.getMargin = btConvexHullShape.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btConvexHullShape_getMargin_0(self);
    }, btConvexHullShape.prototype.setLocalScaling = btConvexHullShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConvexHullShape_setLocalScaling_1(self, arg0);
    }, btConvexHullShape.prototype.calculateLocalInertia = btConvexHullShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btConvexHullShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btConvexHullShape.prototype.__destroy__ = btConvexHullShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConvexHullShape___destroy___0(self);
    }, btPersistentManifold.prototype = Object.create(WrapperObject.prototype), btPersistentManifold.prototype.constructor = btPersistentManifold, 
    btPersistentManifold.prototype.__class__ = btPersistentManifold, btPersistentManifold.__cache__ = {}, 
    Module.btPersistentManifold = btPersistentManifold, btPersistentManifold.prototype.getBody0 = btPersistentManifold.prototype.getBody0 = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btPersistentManifold_getBody0_0(self), btCollisionObject);
    }, btPersistentManifold.prototype.getBody1 = btPersistentManifold.prototype.getBody1 = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btPersistentManifold_getBody1_0(self), btCollisionObject);
    }, btPersistentManifold.prototype.getNumContacts = btPersistentManifold.prototype.getNumContacts = function() {
        var self = this.ptr;
        return _emscripten_bind_btPersistentManifold_getNumContacts_0(self);
    }, btPersistentManifold.prototype.getContactPoint = btPersistentManifold.prototype.getContactPoint = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btPersistentManifold_getContactPoint_1(self, arg0), btManifoldPoint);
    }, btPersistentManifold.prototype.__destroy__ = btPersistentManifold.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btPersistentManifold___destroy___0(self);
    }, btBoxShape.prototype = Object.create(btCollisionShape.prototype), btBoxShape.prototype.constructor = btBoxShape, 
    btBoxShape.prototype.__class__ = btBoxShape, btBoxShape.__cache__ = {}, Module.btBoxShape = btBoxShape, 
    btBoxShape.prototype.setMargin = btBoxShape.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btBoxShape_setMargin_1(self, arg0);
    }, btBoxShape.prototype.getMargin = btBoxShape.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btBoxShape_getMargin_0(self);
    }, btBoxShape.prototype.setLocalScaling = btBoxShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btBoxShape_setLocalScaling_1(self, arg0);
    }, btBoxShape.prototype.calculateLocalInertia = btBoxShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btBoxShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btBoxShape.prototype.__destroy__ = btBoxShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btBoxShape___destroy___0(self);
    }, btCollisionDispatcher.prototype = Object.create(btDispatcher.prototype), btCollisionDispatcher.prototype.constructor = btCollisionDispatcher, 
    btCollisionDispatcher.prototype.__class__ = btCollisionDispatcher, btCollisionDispatcher.__cache__ = {}, 
    Module.btCollisionDispatcher = btCollisionDispatcher, btCollisionDispatcher.prototype.getNumManifolds = btCollisionDispatcher.prototype.getNumManifolds = function() {
        var self = this.ptr;
        return _emscripten_bind_btCollisionDispatcher_getNumManifolds_0(self);
    }, btCollisionDispatcher.prototype.getManifoldByIndexInternal = btCollisionDispatcher.prototype.getManifoldByIndexInternal = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btCollisionDispatcher_getManifoldByIndexInternal_1(self, arg0), btPersistentManifold);
    }, btCollisionDispatcher.prototype.__destroy__ = btCollisionDispatcher.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCollisionDispatcher___destroy___0(self);
    }, btVehicleTuning.prototype = Object.create(WrapperObject.prototype), btVehicleTuning.prototype.constructor = btVehicleTuning, 
    btVehicleTuning.prototype.__class__ = btVehicleTuning, btVehicleTuning.__cache__ = {}, 
    Module.btVehicleTuning = btVehicleTuning, btVehicleTuning.prototype.get_m_suspensionStiffness = btVehicleTuning.prototype.get_m_suspensionStiffness = function() {
        var self = this.ptr;
        return _emscripten_bind_btVehicleTuning_get_m_suspensionStiffness_0(self);
    }, btVehicleTuning.prototype.set_m_suspensionStiffness = btVehicleTuning.prototype.set_m_suspensionStiffness = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVehicleTuning_set_m_suspensionStiffness_1(self, arg0);
    }, btVehicleTuning.prototype.get_m_suspensionCompression = btVehicleTuning.prototype.get_m_suspensionCompression = function() {
        var self = this.ptr;
        return _emscripten_bind_btVehicleTuning_get_m_suspensionCompression_0(self);
    }, btVehicleTuning.prototype.set_m_suspensionCompression = btVehicleTuning.prototype.set_m_suspensionCompression = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVehicleTuning_set_m_suspensionCompression_1(self, arg0);
    }, btVehicleTuning.prototype.get_m_suspensionDamping = btVehicleTuning.prototype.get_m_suspensionDamping = function() {
        var self = this.ptr;
        return _emscripten_bind_btVehicleTuning_get_m_suspensionDamping_0(self);
    }, btVehicleTuning.prototype.set_m_suspensionDamping = btVehicleTuning.prototype.set_m_suspensionDamping = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVehicleTuning_set_m_suspensionDamping_1(self, arg0);
    }, btVehicleTuning.prototype.get_m_maxSuspensionTravelCm = btVehicleTuning.prototype.get_m_maxSuspensionTravelCm = function() {
        var self = this.ptr;
        return _emscripten_bind_btVehicleTuning_get_m_maxSuspensionTravelCm_0(self);
    }, btVehicleTuning.prototype.set_m_maxSuspensionTravelCm = btVehicleTuning.prototype.set_m_maxSuspensionTravelCm = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVehicleTuning_set_m_maxSuspensionTravelCm_1(self, arg0);
    }, btVehicleTuning.prototype.get_m_frictionSlip = btVehicleTuning.prototype.get_m_frictionSlip = function() {
        var self = this.ptr;
        return _emscripten_bind_btVehicleTuning_get_m_frictionSlip_0(self);
    }, btVehicleTuning.prototype.set_m_frictionSlip = btVehicleTuning.prototype.set_m_frictionSlip = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVehicleTuning_set_m_frictionSlip_1(self, arg0);
    }, btVehicleTuning.prototype.get_m_maxSuspensionForce = btVehicleTuning.prototype.get_m_maxSuspensionForce = function() {
        var self = this.ptr;
        return _emscripten_bind_btVehicleTuning_get_m_maxSuspensionForce_0(self);
    }, btVehicleTuning.prototype.set_m_maxSuspensionForce = btVehicleTuning.prototype.set_m_maxSuspensionForce = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVehicleTuning_set_m_maxSuspensionForce_1(self, arg0);
    }, btCompoundShape.prototype = Object.create(btCollisionShape.prototype), btCompoundShape.prototype.constructor = btCompoundShape, 
    btCompoundShape.prototype.__class__ = btCompoundShape, btCompoundShape.__cache__ = {}, 
    Module.btCompoundShape = btCompoundShape, btCompoundShape.prototype.addChildShape = btCompoundShape.prototype.addChildShape = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCompoundShape_addChildShape_2(self, arg0, arg1);
    }, btCompoundShape.prototype.removeChildShapeByIndex = btCompoundShape.prototype.removeChildShapeByIndex = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCompoundShape_removeChildShapeByIndex_1(self, arg0);
    }, btCompoundShape.prototype.getNumChildShapes = btCompoundShape.prototype.getNumChildShapes = function() {
        var self = this.ptr;
        return _emscripten_bind_btCompoundShape_getNumChildShapes_0(self);
    }, btCompoundShape.prototype.getChildShape = btCompoundShape.prototype.getChildShape = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btCompoundShape_getChildShape_1(self, arg0), btCollisionShape);
    }, btCompoundShape.prototype.setMargin = btCompoundShape.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCompoundShape_setMargin_1(self, arg0);
    }, btCompoundShape.prototype.getMargin = btCompoundShape.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btCompoundShape_getMargin_0(self);
    }, btCompoundShape.prototype.setLocalScaling = btCompoundShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCompoundShape_setLocalScaling_1(self, arg0);
    }, btCompoundShape.prototype.calculateLocalInertia = btCompoundShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCompoundShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btCompoundShape.prototype.__destroy__ = btCompoundShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCompoundShape___destroy___0(self);
    }, btCollisionObjectWrapper.prototype = Object.create(WrapperObject.prototype), 
    btCollisionObjectWrapper.prototype.constructor = btCollisionObjectWrapper, btCollisionObjectWrapper.prototype.__class__ = btCollisionObjectWrapper, 
    btCollisionObjectWrapper.__cache__ = {}, Module.btCollisionObjectWrapper = btCollisionObjectWrapper, 
    ClosestConvexResultCallback.prototype = Object.create(ConvexResultCallback.prototype), 
    ClosestConvexResultCallback.prototype.constructor = ClosestConvexResultCallback, 
    ClosestConvexResultCallback.prototype.__class__ = ClosestConvexResultCallback, ClosestConvexResultCallback.__cache__ = {}, 
    Module.ClosestConvexResultCallback = ClosestConvexResultCallback, ClosestConvexResultCallback.prototype.hasHit = ClosestConvexResultCallback.prototype.hasHit = function() {
        var self = this.ptr;
        return _emscripten_bind_ClosestConvexResultCallback_hasHit_0(self);
    }, ClosestConvexResultCallback.prototype.get_m_convexFromWorld = ClosestConvexResultCallback.prototype.get_m_convexFromWorld = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_ClosestConvexResultCallback_get_m_convexFromWorld_0(self), btVector3);
    }, ClosestConvexResultCallback.prototype.set_m_convexFromWorld = ClosestConvexResultCallback.prototype.set_m_convexFromWorld = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestConvexResultCallback_set_m_convexFromWorld_1(self, arg0);
    }, ClosestConvexResultCallback.prototype.get_m_convexToWorld = ClosestConvexResultCallback.prototype.get_m_convexToWorld = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_ClosestConvexResultCallback_get_m_convexToWorld_0(self), btVector3);
    }, ClosestConvexResultCallback.prototype.set_m_convexToWorld = ClosestConvexResultCallback.prototype.set_m_convexToWorld = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestConvexResultCallback_set_m_convexToWorld_1(self, arg0);
    }, ClosestConvexResultCallback.prototype.get_m_hitNormalWorld = ClosestConvexResultCallback.prototype.get_m_hitNormalWorld = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_ClosestConvexResultCallback_get_m_hitNormalWorld_0(self), btVector3);
    }, ClosestConvexResultCallback.prototype.set_m_hitNormalWorld = ClosestConvexResultCallback.prototype.set_m_hitNormalWorld = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestConvexResultCallback_set_m_hitNormalWorld_1(self, arg0);
    }, ClosestConvexResultCallback.prototype.get_m_hitPointWorld = ClosestConvexResultCallback.prototype.get_m_hitPointWorld = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_ClosestConvexResultCallback_get_m_hitPointWorld_0(self), btVector3);
    }, ClosestConvexResultCallback.prototype.set_m_hitPointWorld = ClosestConvexResultCallback.prototype.set_m_hitPointWorld = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestConvexResultCallback_set_m_hitPointWorld_1(self, arg0);
    }, ClosestConvexResultCallback.prototype.get_m_collisionFilterGroup = ClosestConvexResultCallback.prototype.get_m_collisionFilterGroup = function() {
        var self = this.ptr;
        return _emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterGroup_0(self);
    }, ClosestConvexResultCallback.prototype.set_m_collisionFilterGroup = ClosestConvexResultCallback.prototype.set_m_collisionFilterGroup = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterGroup_1(self, arg0);
    }, ClosestConvexResultCallback.prototype.get_m_collisionFilterMask = ClosestConvexResultCallback.prototype.get_m_collisionFilterMask = function() {
        var self = this.ptr;
        return _emscripten_bind_ClosestConvexResultCallback_get_m_collisionFilterMask_0(self);
    }, ClosestConvexResultCallback.prototype.set_m_collisionFilterMask = ClosestConvexResultCallback.prototype.set_m_collisionFilterMask = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestConvexResultCallback_set_m_collisionFilterMask_1(self, arg0);
    }, ClosestConvexResultCallback.prototype.get_m_closestHitFraction = ClosestConvexResultCallback.prototype.get_m_closestHitFraction = function() {
        var self = this.ptr;
        return _emscripten_bind_ClosestConvexResultCallback_get_m_closestHitFraction_0(self);
    }, ClosestConvexResultCallback.prototype.set_m_closestHitFraction = ClosestConvexResultCallback.prototype.set_m_closestHitFraction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestConvexResultCallback_set_m_closestHitFraction_1(self, arg0);
    }, ClosestConvexResultCallback.prototype.__destroy__ = ClosestConvexResultCallback.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_ClosestConvexResultCallback___destroy___0(self);
    }, btDefaultMotionState.prototype = Object.create(btMotionState.prototype), btDefaultMotionState.prototype.constructor = btDefaultMotionState, 
    btDefaultMotionState.prototype.__class__ = btDefaultMotionState, btDefaultMotionState.__cache__ = {}, 
    Module.btDefaultMotionState = btDefaultMotionState, btDefaultMotionState.prototype.getWorldTransform = btDefaultMotionState.prototype.getWorldTransform = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDefaultMotionState_getWorldTransform_1(self, arg0);
    }, btDefaultMotionState.prototype.setWorldTransform = btDefaultMotionState.prototype.setWorldTransform = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDefaultMotionState_setWorldTransform_1(self, arg0);
    }, btDefaultMotionState.prototype.get_m_graphicsWorldTrans = btDefaultMotionState.prototype.get_m_graphicsWorldTrans = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btDefaultMotionState_get_m_graphicsWorldTrans_0(self), btTransform);
    }, btDefaultMotionState.prototype.set_m_graphicsWorldTrans = btDefaultMotionState.prototype.set_m_graphicsWorldTrans = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btDefaultMotionState_set_m_graphicsWorldTrans_1(self, arg0);
    }, btDefaultMotionState.prototype.__destroy__ = btDefaultMotionState.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btDefaultMotionState___destroy___0(self);
    }, ClosestRayResultCallback.prototype = Object.create(RayResultCallback.prototype), 
    ClosestRayResultCallback.prototype.constructor = ClosestRayResultCallback, ClosestRayResultCallback.prototype.__class__ = ClosestRayResultCallback, 
    ClosestRayResultCallback.__cache__ = {}, Module.ClosestRayResultCallback = ClosestRayResultCallback, 
    ClosestRayResultCallback.prototype.hasHit = ClosestRayResultCallback.prototype.hasHit = function() {
        var self = this.ptr;
        return _emscripten_bind_ClosestRayResultCallback_hasHit_0(self);
    }, ClosestRayResultCallback.prototype.get_m_rayFromWorld = ClosestRayResultCallback.prototype.get_m_rayFromWorld = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_ClosestRayResultCallback_get_m_rayFromWorld_0(self), btVector3);
    }, ClosestRayResultCallback.prototype.set_m_rayFromWorld = ClosestRayResultCallback.prototype.set_m_rayFromWorld = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestRayResultCallback_set_m_rayFromWorld_1(self, arg0);
    }, ClosestRayResultCallback.prototype.get_m_rayToWorld = ClosestRayResultCallback.prototype.get_m_rayToWorld = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_ClosestRayResultCallback_get_m_rayToWorld_0(self), btVector3);
    }, ClosestRayResultCallback.prototype.set_m_rayToWorld = ClosestRayResultCallback.prototype.set_m_rayToWorld = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestRayResultCallback_set_m_rayToWorld_1(self, arg0);
    }, ClosestRayResultCallback.prototype.get_m_hitNormalWorld = ClosestRayResultCallback.prototype.get_m_hitNormalWorld = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_ClosestRayResultCallback_get_m_hitNormalWorld_0(self), btVector3);
    }, ClosestRayResultCallback.prototype.set_m_hitNormalWorld = ClosestRayResultCallback.prototype.set_m_hitNormalWorld = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestRayResultCallback_set_m_hitNormalWorld_1(self, arg0);
    }, ClosestRayResultCallback.prototype.get_m_hitPointWorld = ClosestRayResultCallback.prototype.get_m_hitPointWorld = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_ClosestRayResultCallback_get_m_hitPointWorld_0(self), btVector3);
    }, ClosestRayResultCallback.prototype.set_m_hitPointWorld = ClosestRayResultCallback.prototype.set_m_hitPointWorld = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestRayResultCallback_set_m_hitPointWorld_1(self, arg0);
    }, ClosestRayResultCallback.prototype.get_m_collisionFilterGroup = ClosestRayResultCallback.prototype.get_m_collisionFilterGroup = function() {
        var self = this.ptr;
        return _emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterGroup_0(self);
    }, ClosestRayResultCallback.prototype.set_m_collisionFilterGroup = ClosestRayResultCallback.prototype.set_m_collisionFilterGroup = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterGroup_1(self, arg0);
    }, ClosestRayResultCallback.prototype.get_m_collisionFilterMask = ClosestRayResultCallback.prototype.get_m_collisionFilterMask = function() {
        var self = this.ptr;
        return _emscripten_bind_ClosestRayResultCallback_get_m_collisionFilterMask_0(self);
    }, ClosestRayResultCallback.prototype.set_m_collisionFilterMask = ClosestRayResultCallback.prototype.set_m_collisionFilterMask = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestRayResultCallback_set_m_collisionFilterMask_1(self, arg0);
    }, ClosestRayResultCallback.prototype.get_m_collisionObject = ClosestRayResultCallback.prototype.get_m_collisionObject = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_ClosestRayResultCallback_get_m_collisionObject_0(self), btCollisionObject);
    }, ClosestRayResultCallback.prototype.set_m_collisionObject = ClosestRayResultCallback.prototype.set_m_collisionObject = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_ClosestRayResultCallback_set_m_collisionObject_1(self, arg0);
    }, ClosestRayResultCallback.prototype.__destroy__ = ClosestRayResultCallback.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_ClosestRayResultCallback___destroy___0(self);
    }, btCapsuleShapeX.prototype = Object.create(btCapsuleShape.prototype), btCapsuleShapeX.prototype.constructor = btCapsuleShapeX, 
    btCapsuleShapeX.prototype.__class__ = btCapsuleShapeX, btCapsuleShapeX.__cache__ = {}, 
    Module.btCapsuleShapeX = btCapsuleShapeX, btCapsuleShapeX.prototype.setMargin = btCapsuleShapeX.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCapsuleShapeX_setMargin_1(self, arg0);
    }, btCapsuleShapeX.prototype.getMargin = btCapsuleShapeX.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btCapsuleShapeX_getMargin_0(self);
    }, btCapsuleShapeX.prototype.setLocalScaling = btCapsuleShapeX.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCapsuleShapeX_setLocalScaling_1(self, arg0);
    }, btCapsuleShapeX.prototype.calculateLocalInertia = btCapsuleShapeX.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCapsuleShapeX_calculateLocalInertia_2(self, arg0, arg1);
    }, btCapsuleShapeX.prototype.__destroy__ = btCapsuleShapeX.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCapsuleShapeX___destroy___0(self);
    }, btQuaternion.prototype = Object.create(btQuadWord.prototype), btQuaternion.prototype.constructor = btQuaternion, 
    btQuaternion.prototype.__class__ = btQuaternion, btQuaternion.__cache__ = {}, Module.btQuaternion = btQuaternion, 
    btQuaternion.prototype.setValue = btQuaternion.prototype.setValue = function(arg0, arg1, arg2, arg3) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        _emscripten_bind_btQuaternion_setValue_4(self, arg0, arg1, arg2, arg3);
    }, btQuaternion.prototype.x = btQuaternion.prototype.x = function() {
        var self = this.ptr;
        return _emscripten_bind_btQuaternion_x_0(self);
    }, btQuaternion.prototype.y = btQuaternion.prototype.y = function() {
        var self = this.ptr;
        return _emscripten_bind_btQuaternion_y_0(self);
    }, btQuaternion.prototype.z = btQuaternion.prototype.z = function() {
        var self = this.ptr;
        return _emscripten_bind_btQuaternion_z_0(self);
    }, btQuaternion.prototype.w = btQuaternion.prototype.w = function() {
        var self = this.ptr;
        return _emscripten_bind_btQuaternion_w_0(self);
    }, btQuaternion.prototype.setX = btQuaternion.prototype.setX = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btQuaternion_setX_1(self, arg0);
    }, btQuaternion.prototype.setY = btQuaternion.prototype.setY = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btQuaternion_setY_1(self, arg0);
    }, btQuaternion.prototype.setZ = btQuaternion.prototype.setZ = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btQuaternion_setZ_1(self, arg0);
    }, btQuaternion.prototype.setW = btQuaternion.prototype.setW = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btQuaternion_setW_1(self, arg0);
    }, btQuaternion.prototype.__destroy__ = btQuaternion.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btQuaternion___destroy___0(self);
    }, btCapsuleShapeZ.prototype = Object.create(btCapsuleShape.prototype), btCapsuleShapeZ.prototype.constructor = btCapsuleShapeZ, 
    btCapsuleShapeZ.prototype.__class__ = btCapsuleShapeZ, btCapsuleShapeZ.__cache__ = {}, 
    Module.btCapsuleShapeZ = btCapsuleShapeZ, btCapsuleShapeZ.prototype.setMargin = btCapsuleShapeZ.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCapsuleShapeZ_setMargin_1(self, arg0);
    }, btCapsuleShapeZ.prototype.getMargin = btCapsuleShapeZ.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btCapsuleShapeZ_getMargin_0(self);
    }, btCapsuleShapeZ.prototype.setLocalScaling = btCapsuleShapeZ.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCapsuleShapeZ_setLocalScaling_1(self, arg0);
    }, btCapsuleShapeZ.prototype.calculateLocalInertia = btCapsuleShapeZ.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCapsuleShapeZ_calculateLocalInertia_2(self, arg0, arg1);
    }, btCapsuleShapeZ.prototype.__destroy__ = btCapsuleShapeZ.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCapsuleShapeZ___destroy___0(self);
    }, btDefaultVehicleRaycaster.prototype = Object.create(btVehicleRaycaster.prototype), 
    btDefaultVehicleRaycaster.prototype.constructor = btDefaultVehicleRaycaster, btDefaultVehicleRaycaster.prototype.__class__ = btDefaultVehicleRaycaster, 
    btDefaultVehicleRaycaster.__cache__ = {}, Module.btDefaultVehicleRaycaster = btDefaultVehicleRaycaster, 
    btDefaultVehicleRaycaster.prototype.__destroy__ = btDefaultVehicleRaycaster.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btDefaultVehicleRaycaster___destroy___0(self);
    }, btWheelInfo.prototype = Object.create(WrapperObject.prototype), btWheelInfo.prototype.constructor = btWheelInfo, 
    btWheelInfo.prototype.__class__ = btWheelInfo, btWheelInfo.__cache__ = {}, Module.btWheelInfo = btWheelInfo, 
    btWheelInfo.prototype.get_m_suspensionStiffness = btWheelInfo.prototype.get_m_suspensionStiffness = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_suspensionStiffness_0(self);
    }, btWheelInfo.prototype.set_m_suspensionStiffness = btWheelInfo.prototype.set_m_suspensionStiffness = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_suspensionStiffness_1(self, arg0);
    }, btWheelInfo.prototype.get_m_frictionSlip = btWheelInfo.prototype.get_m_frictionSlip = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_frictionSlip_0(self);
    }, btWheelInfo.prototype.set_m_frictionSlip = btWheelInfo.prototype.set_m_frictionSlip = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_frictionSlip_1(self, arg0);
    }, btWheelInfo.prototype.get_m_rollInfluence = btWheelInfo.prototype.get_m_rollInfluence = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_rollInfluence_0(self);
    }, btWheelInfo.prototype.set_m_rollInfluence = btWheelInfo.prototype.set_m_rollInfluence = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_rollInfluence_1(self, arg0);
    }, btWheelInfo.prototype.get_m_suspensionRestLength1 = btWheelInfo.prototype.get_m_suspensionRestLength1 = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_suspensionRestLength1_0(self);
    }, btWheelInfo.prototype.set_m_suspensionRestLength1 = btWheelInfo.prototype.set_m_suspensionRestLength1 = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_suspensionRestLength1_1(self, arg0);
    }, btWheelInfo.prototype.get_m_wheelsRadius = btWheelInfo.prototype.get_m_wheelsRadius = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_wheelsRadius_0(self);
    }, btWheelInfo.prototype.set_m_wheelsRadius = btWheelInfo.prototype.set_m_wheelsRadius = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_wheelsRadius_1(self, arg0);
    }, btWheelInfo.prototype.get_m_wheelsDampingCompression = btWheelInfo.prototype.get_m_wheelsDampingCompression = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_wheelsDampingCompression_0(self);
    }, btWheelInfo.prototype.set_m_wheelsDampingCompression = btWheelInfo.prototype.set_m_wheelsDampingCompression = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_wheelsDampingCompression_1(self, arg0);
    }, btWheelInfo.prototype.get_m_wheelsDampingRelaxation = btWheelInfo.prototype.get_m_wheelsDampingRelaxation = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_wheelsDampingRelaxation_0(self);
    }, btWheelInfo.prototype.set_m_wheelsDampingRelaxation = btWheelInfo.prototype.set_m_wheelsDampingRelaxation = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_wheelsDampingRelaxation_1(self, arg0);
    }, btWheelInfo.prototype.get_m_steering = btWheelInfo.prototype.get_m_steering = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_steering_0(self);
    }, btWheelInfo.prototype.set_m_steering = btWheelInfo.prototype.set_m_steering = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_steering_1(self, arg0);
    }, btWheelInfo.prototype.get_m_maxSuspensionForce = btWheelInfo.prototype.get_m_maxSuspensionForce = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_maxSuspensionForce_0(self);
    }, btWheelInfo.prototype.set_m_maxSuspensionForce = btWheelInfo.prototype.set_m_maxSuspensionForce = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_maxSuspensionForce_1(self, arg0);
    }, btWheelInfo.prototype.get_m_maxSuspensionTravelCm = btWheelInfo.prototype.get_m_maxSuspensionTravelCm = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_maxSuspensionTravelCm_0(self);
    }, btWheelInfo.prototype.set_m_maxSuspensionTravelCm = btWheelInfo.prototype.set_m_maxSuspensionTravelCm = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_maxSuspensionTravelCm_1(self, arg0);
    }, btWheelInfo.prototype.get_m_wheelsSuspensionForce = btWheelInfo.prototype.get_m_wheelsSuspensionForce = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_wheelsSuspensionForce_0(self);
    }, btWheelInfo.prototype.set_m_wheelsSuspensionForce = btWheelInfo.prototype.set_m_wheelsSuspensionForce = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_wheelsSuspensionForce_1(self, arg0);
    }, btWheelInfo.prototype.get_m_bIsFrontWheel = btWheelInfo.prototype.get_m_bIsFrontWheel = function() {
        var self = this.ptr;
        return _emscripten_bind_btWheelInfo_get_m_bIsFrontWheel_0(self);
    }, btWheelInfo.prototype.set_m_bIsFrontWheel = btWheelInfo.prototype.set_m_bIsFrontWheel = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_bIsFrontWheel_1(self, arg0);
    }, btWheelInfo.prototype.get_m_chassisConnectionPointCS = btWheelInfo.prototype.get_m_chassisConnectionPointCS = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btWheelInfo_get_m_chassisConnectionPointCS_0(self), btVector3);
    }, btWheelInfo.prototype.set_m_chassisConnectionPointCS = btWheelInfo.prototype.set_m_chassisConnectionPointCS = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btWheelInfo_set_m_chassisConnectionPointCS_1(self, arg0);
    }, btWheelInfo.prototype.__destroy__ = btWheelInfo.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btWheelInfo___destroy___0(self);
    }, btVector4.prototype = Object.create(btVector3.prototype), btVector4.prototype.constructor = btVector4, 
    btVector4.prototype.__class__ = btVector4, btVector4.__cache__ = {}, Module.btVector4 = btVector4, 
    btVector4.prototype.w = btVector4.prototype.w = function() {
        var self = this.ptr;
        return _emscripten_bind_btVector4_w_0(self);
    }, btVector4.prototype.setValue = btVector4.prototype.setValue = function(arg0, arg1, arg2, arg3) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        _emscripten_bind_btVector4_setValue_4(self, arg0, arg1, arg2, arg3);
    }, btVector4.prototype.length = btVector4.prototype.length = function() {
        var self = this.ptr;
        return _emscripten_bind_btVector4_length_0(self);
    }, btVector4.prototype.x = btVector4.prototype.x = function() {
        var self = this.ptr;
        return _emscripten_bind_btVector4_x_0(self);
    }, btVector4.prototype.y = btVector4.prototype.y = function() {
        var self = this.ptr;
        return _emscripten_bind_btVector4_y_0(self);
    }, btVector4.prototype.z = btVector4.prototype.z = function() {
        var self = this.ptr;
        return _emscripten_bind_btVector4_z_0(self);
    }, btVector4.prototype.setX = btVector4.prototype.setX = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVector4_setX_1(self, arg0);
    }, btVector4.prototype.setY = btVector4.prototype.setY = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVector4_setY_1(self, arg0);
    }, btVector4.prototype.setZ = btVector4.prototype.setZ = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btVector4_setZ_1(self, arg0);
    }, btVector4.prototype.op_mul = btVector4.prototype.op_mul = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btVector4_op_mul_1(self, arg0), btVector3);
    }, btVector4.prototype.__destroy__ = btVector4.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btVector4___destroy___0(self);
    }, btKinematicCharacterController.prototype = Object.create(btActionInterface.prototype), 
    btKinematicCharacterController.prototype.constructor = btKinematicCharacterController, 
    btKinematicCharacterController.prototype.__class__ = btKinematicCharacterController, 
    btKinematicCharacterController.__cache__ = {}, Module.btKinematicCharacterController = btKinematicCharacterController, 
    btKinematicCharacterController.prototype.setUpAxis = btKinematicCharacterController.prototype.setUpAxis = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_setUpAxis_1(self, arg0);
    }, btKinematicCharacterController.prototype.setWalkDirection = btKinematicCharacterController.prototype.setWalkDirection = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_setWalkDirection_1(self, arg0);
    }, btKinematicCharacterController.prototype.setVelocityForTimeInterval = btKinematicCharacterController.prototype.setVelocityForTimeInterval = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btKinematicCharacterController_setVelocityForTimeInterval_2(self, arg0, arg1);
    }, btKinematicCharacterController.prototype.warp = btKinematicCharacterController.prototype.warp = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_warp_1(self, arg0);
    }, btKinematicCharacterController.prototype.preStep = btKinematicCharacterController.prototype.preStep = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_preStep_1(self, arg0);
    }, btKinematicCharacterController.prototype.playerStep = btKinematicCharacterController.prototype.playerStep = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btKinematicCharacterController_playerStep_2(self, arg0, arg1);
    }, btKinematicCharacterController.prototype.setFallSpeed = btKinematicCharacterController.prototype.setFallSpeed = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_setFallSpeed_1(self, arg0);
    }, btKinematicCharacterController.prototype.setJumpSpeed = btKinematicCharacterController.prototype.setJumpSpeed = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_setJumpSpeed_1(self, arg0);
    }, btKinematicCharacterController.prototype.setMaxJumpHeight = btKinematicCharacterController.prototype.setMaxJumpHeight = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_setMaxJumpHeight_1(self, arg0);
    }, btKinematicCharacterController.prototype.canJump = btKinematicCharacterController.prototype.canJump = function() {
        var self = this.ptr;
        return _emscripten_bind_btKinematicCharacterController_canJump_0(self);
    }, btKinematicCharacterController.prototype.jump = btKinematicCharacterController.prototype.jump = function() {
        var self = this.ptr;
        _emscripten_bind_btKinematicCharacterController_jump_0(self);
    }, btKinematicCharacterController.prototype.setGravity = btKinematicCharacterController.prototype.setGravity = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_setGravity_1(self, arg0);
    }, btKinematicCharacterController.prototype.getGravity = btKinematicCharacterController.prototype.getGravity = function() {
        var self = this.ptr;
        return _emscripten_bind_btKinematicCharacterController_getGravity_0(self);
    }, btKinematicCharacterController.prototype.setMaxSlope = btKinematicCharacterController.prototype.setMaxSlope = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_setMaxSlope_1(self, arg0);
    }, btKinematicCharacterController.prototype.getMaxSlope = btKinematicCharacterController.prototype.getMaxSlope = function() {
        var self = this.ptr;
        return _emscripten_bind_btKinematicCharacterController_getMaxSlope_0(self);
    }, btKinematicCharacterController.prototype.getGhostObject = btKinematicCharacterController.prototype.getGhostObject = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btKinematicCharacterController_getGhostObject_0(self), btPairCachingGhostObject);
    }, btKinematicCharacterController.prototype.setUseGhostSweepTest = btKinematicCharacterController.prototype.setUseGhostSweepTest = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btKinematicCharacterController_setUseGhostSweepTest_1(self, arg0);
    }, btKinematicCharacterController.prototype.onGround = btKinematicCharacterController.prototype.onGround = function() {
        var self = this.ptr;
        return _emscripten_bind_btKinematicCharacterController_onGround_0(self);
    }, btKinematicCharacterController.prototype.__destroy__ = btKinematicCharacterController.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btKinematicCharacterController___destroy___0(self);
    }, btStaticPlaneShape.prototype = Object.create(btConcaveShape.prototype), btStaticPlaneShape.prototype.constructor = btStaticPlaneShape, 
    btStaticPlaneShape.prototype.__class__ = btStaticPlaneShape, btStaticPlaneShape.__cache__ = {}, 
    Module.btStaticPlaneShape = btStaticPlaneShape, btStaticPlaneShape.prototype.setLocalScaling = btStaticPlaneShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btStaticPlaneShape_setLocalScaling_1(self, arg0);
    }, btStaticPlaneShape.prototype.calculateLocalInertia = btStaticPlaneShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btStaticPlaneShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btStaticPlaneShape.prototype.__destroy__ = btStaticPlaneShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btStaticPlaneShape___destroy___0(self);
    }, btContactSolverInfo.prototype = Object.create(WrapperObject.prototype), btContactSolverInfo.prototype.constructor = btContactSolverInfo, 
    btContactSolverInfo.prototype.__class__ = btContactSolverInfo, btContactSolverInfo.__cache__ = {}, 
    Module.btContactSolverInfo = btContactSolverInfo, btContactSolverInfo.prototype.get_m_splitImpulse = btContactSolverInfo.prototype.get_m_splitImpulse = function() {
        var self = this.ptr;
        return _emscripten_bind_btContactSolverInfo_get_m_splitImpulse_0(self);
    }, btContactSolverInfo.prototype.set_m_splitImpulse = btContactSolverInfo.prototype.set_m_splitImpulse = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btContactSolverInfo_set_m_splitImpulse_1(self, arg0);
    }, btContactSolverInfo.prototype.get_m_splitImpulsePenetrationThreshold = btContactSolverInfo.prototype.get_m_splitImpulsePenetrationThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btContactSolverInfo_get_m_splitImpulsePenetrationThreshold_0(self);
    }, btContactSolverInfo.prototype.set_m_splitImpulsePenetrationThreshold = btContactSolverInfo.prototype.set_m_splitImpulsePenetrationThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btContactSolverInfo_set_m_splitImpulsePenetrationThreshold_1(self, arg0);
    }, btContactSolverInfo.prototype.__destroy__ = btContactSolverInfo.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btContactSolverInfo___destroy___0(self);
    }, btOverlappingPairCache.prototype = Object.create(WrapperObject.prototype), btOverlappingPairCache.prototype.constructor = btOverlappingPairCache, 
    btOverlappingPairCache.prototype.__class__ = btOverlappingPairCache, btOverlappingPairCache.__cache__ = {}, 
    Module.btOverlappingPairCache = btOverlappingPairCache, btOverlappingPairCache.prototype.setInternalGhostPairCallback = btOverlappingPairCache.prototype.setInternalGhostPairCallback = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btOverlappingPairCache_setInternalGhostPairCallback_1(self, arg0);
    }, btOverlappingPairCache.prototype.__destroy__ = btOverlappingPairCache.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btOverlappingPairCache___destroy___0(self);
    }, btSphereShape.prototype = Object.create(btCollisionShape.prototype), btSphereShape.prototype.constructor = btSphereShape, 
    btSphereShape.prototype.__class__ = btSphereShape, btSphereShape.__cache__ = {}, 
    Module.btSphereShape = btSphereShape, btSphereShape.prototype.setMargin = btSphereShape.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btSphereShape_setMargin_1(self, arg0);
    }, btSphereShape.prototype.getMargin = btSphereShape.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btSphereShape_getMargin_0(self);
    }, btSphereShape.prototype.setLocalScaling = btSphereShape.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btSphereShape_setLocalScaling_1(self, arg0);
    }, btSphereShape.prototype.calculateLocalInertia = btSphereShape.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btSphereShape_calculateLocalInertia_2(self, arg0, arg1);
    }, btSphereShape.prototype.__destroy__ = btSphereShape.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btSphereShape___destroy___0(self);
    }, btDefaultCollisionConstructionInfo.prototype = Object.create(WrapperObject.prototype), 
    btDefaultCollisionConstructionInfo.prototype.constructor = btDefaultCollisionConstructionInfo, 
    btDefaultCollisionConstructionInfo.prototype.__class__ = btDefaultCollisionConstructionInfo, 
    btDefaultCollisionConstructionInfo.__cache__ = {}, Module.btDefaultCollisionConstructionInfo = btDefaultCollisionConstructionInfo, 
    btDefaultCollisionConstructionInfo.prototype.__destroy__ = btDefaultCollisionConstructionInfo.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btDefaultCollisionConstructionInfo___destroy___0(self);
    }, btHingeConstraint.prototype = Object.create(btTypedConstraint.prototype), btHingeConstraint.prototype.constructor = btHingeConstraint, 
    btHingeConstraint.prototype.__class__ = btHingeConstraint, btHingeConstraint.__cache__ = {}, 
    Module.btHingeConstraint = btHingeConstraint, btHingeConstraint.prototype.setLimit = btHingeConstraint.prototype.setLimit = function(arg0, arg1, arg2, arg3, arg4) {
        var self = this.ptr;
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), void 0 === arg4) return void _emscripten_bind_btHingeConstraint_setLimit_4(self, arg0, arg1, arg2, arg3);
        _emscripten_bind_btHingeConstraint_setLimit_5(self, arg0, arg1, arg2, arg3, arg4);
    }, btHingeConstraint.prototype.enableAngularMotor = btHingeConstraint.prototype.enableAngularMotor = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btHingeConstraint_enableAngularMotor_3(self, arg0, arg1, arg2);
    }, btHingeConstraint.prototype.enableFeedback = btHingeConstraint.prototype.enableFeedback = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btHingeConstraint_enableFeedback_1(self, arg0);
    }, btHingeConstraint.prototype.getBreakingImpulseThreshold = btHingeConstraint.prototype.getBreakingImpulseThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btHingeConstraint_getBreakingImpulseThreshold_0(self);
    }, btHingeConstraint.prototype.setBreakingImpulseThreshold = btHingeConstraint.prototype.setBreakingImpulseThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btHingeConstraint_setBreakingImpulseThreshold_1(self, arg0);
    }, btHingeConstraint.prototype.__destroy__ = btHingeConstraint.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btHingeConstraint___destroy___0(self);
    }, btConstraintSetting.prototype = Object.create(WrapperObject.prototype), btConstraintSetting.prototype.constructor = btConstraintSetting, 
    btConstraintSetting.prototype.__class__ = btConstraintSetting, btConstraintSetting.__cache__ = {}, 
    Module.btConstraintSetting = btConstraintSetting, btConstraintSetting.prototype.get_m_tau = btConstraintSetting.prototype.get_m_tau = function() {
        var self = this.ptr;
        return _emscripten_bind_btConstraintSetting_get_m_tau_0(self);
    }, btConstraintSetting.prototype.set_m_tau = btConstraintSetting.prototype.set_m_tau = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConstraintSetting_set_m_tau_1(self, arg0);
    }, btConstraintSetting.prototype.get_m_damping = btConstraintSetting.prototype.get_m_damping = function() {
        var self = this.ptr;
        return _emscripten_bind_btConstraintSetting_get_m_damping_0(self);
    }, btConstraintSetting.prototype.set_m_damping = btConstraintSetting.prototype.set_m_damping = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConstraintSetting_set_m_damping_1(self, arg0);
    }, btConstraintSetting.prototype.get_m_impulseClamp = btConstraintSetting.prototype.get_m_impulseClamp = function() {
        var self = this.ptr;
        return _emscripten_bind_btConstraintSetting_get_m_impulseClamp_0(self);
    }, btConstraintSetting.prototype.set_m_impulseClamp = btConstraintSetting.prototype.set_m_impulseClamp = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btConstraintSetting_set_m_impulseClamp_1(self, arg0);
    }, btConstraintSetting.prototype.__destroy__ = btConstraintSetting.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConstraintSetting___destroy___0(self);
    }, LocalShapeInfo.prototype = Object.create(WrapperObject.prototype), LocalShapeInfo.prototype.constructor = LocalShapeInfo, 
    LocalShapeInfo.prototype.__class__ = LocalShapeInfo, LocalShapeInfo.__cache__ = {}, 
    Module.LocalShapeInfo = LocalShapeInfo, LocalShapeInfo.prototype.get_m_shapePart = LocalShapeInfo.prototype.get_m_shapePart = function() {
        var self = this.ptr;
        return _emscripten_bind_LocalShapeInfo_get_m_shapePart_0(self);
    }, LocalShapeInfo.prototype.set_m_shapePart = LocalShapeInfo.prototype.set_m_shapePart = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_LocalShapeInfo_set_m_shapePart_1(self, arg0);
    }, LocalShapeInfo.prototype.get_m_triangleIndex = LocalShapeInfo.prototype.get_m_triangleIndex = function() {
        var self = this.ptr;
        return _emscripten_bind_LocalShapeInfo_get_m_triangleIndex_0(self);
    }, LocalShapeInfo.prototype.set_m_triangleIndex = LocalShapeInfo.prototype.set_m_triangleIndex = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_LocalShapeInfo_set_m_triangleIndex_1(self, arg0);
    }, LocalShapeInfo.prototype.__destroy__ = LocalShapeInfo.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_LocalShapeInfo___destroy___0(self);
    }, btConstraintSolver.prototype = Object.create(WrapperObject.prototype), btConstraintSolver.prototype.constructor = btConstraintSolver, 
    btConstraintSolver.prototype.__class__ = btConstraintSolver, btConstraintSolver.__cache__ = {}, 
    Module.btConstraintSolver = btConstraintSolver, btConstraintSolver.prototype.__destroy__ = btConstraintSolver.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btConstraintSolver___destroy___0(self);
    }, btGeneric6DofSpringConstraint.prototype = Object.create(btGeneric6DofConstraint.prototype), 
    btGeneric6DofSpringConstraint.prototype.constructor = btGeneric6DofSpringConstraint, 
    btGeneric6DofSpringConstraint.prototype.__class__ = btGeneric6DofSpringConstraint, 
    btGeneric6DofSpringConstraint.__cache__ = {}, Module.btGeneric6DofSpringConstraint = btGeneric6DofSpringConstraint, 
    btGeneric6DofSpringConstraint.prototype.enableSpring = btGeneric6DofSpringConstraint.prototype.enableSpring = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btGeneric6DofSpringConstraint_enableSpring_2(self, arg0, arg1);
    }, btGeneric6DofSpringConstraint.prototype.setStiffness = btGeneric6DofSpringConstraint.prototype.setStiffness = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btGeneric6DofSpringConstraint_setStiffness_2(self, arg0, arg1);
    }, btGeneric6DofSpringConstraint.prototype.setDamping = btGeneric6DofSpringConstraint.prototype.setDamping = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btGeneric6DofSpringConstraint_setDamping_2(self, arg0, arg1);
    }, btGeneric6DofSpringConstraint.prototype.setLinearLowerLimit = btGeneric6DofSpringConstraint.prototype.setLinearLowerLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofSpringConstraint_setLinearLowerLimit_1(self, arg0);
    }, btGeneric6DofSpringConstraint.prototype.setLinearUpperLimit = btGeneric6DofSpringConstraint.prototype.setLinearUpperLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofSpringConstraint_setLinearUpperLimit_1(self, arg0);
    }, btGeneric6DofSpringConstraint.prototype.setAngularLowerLimit = btGeneric6DofSpringConstraint.prototype.setAngularLowerLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofSpringConstraint_setAngularLowerLimit_1(self, arg0);
    }, btGeneric6DofSpringConstraint.prototype.setAngularUpperLimit = btGeneric6DofSpringConstraint.prototype.setAngularUpperLimit = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofSpringConstraint_setAngularUpperLimit_1(self, arg0);
    }, btGeneric6DofSpringConstraint.prototype.enableFeedback = btGeneric6DofSpringConstraint.prototype.enableFeedback = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofSpringConstraint_enableFeedback_1(self, arg0);
    }, btGeneric6DofSpringConstraint.prototype.getBreakingImpulseThreshold = btGeneric6DofSpringConstraint.prototype.getBreakingImpulseThreshold = function() {
        var self = this.ptr;
        return _emscripten_bind_btGeneric6DofSpringConstraint_getBreakingImpulseThreshold_0(self);
    }, btGeneric6DofSpringConstraint.prototype.setBreakingImpulseThreshold = btGeneric6DofSpringConstraint.prototype.setBreakingImpulseThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btGeneric6DofSpringConstraint_setBreakingImpulseThreshold_1(self, arg0);
    }, btGeneric6DofSpringConstraint.prototype.__destroy__ = btGeneric6DofSpringConstraint.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btGeneric6DofSpringConstraint___destroy___0(self);
    }, LocalConvexResult.prototype = Object.create(WrapperObject.prototype), LocalConvexResult.prototype.constructor = LocalConvexResult, 
    LocalConvexResult.prototype.__class__ = LocalConvexResult, LocalConvexResult.__cache__ = {}, 
    Module.LocalConvexResult = LocalConvexResult, LocalConvexResult.prototype.get_m_hitCollisionObject = LocalConvexResult.prototype.get_m_hitCollisionObject = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_LocalConvexResult_get_m_hitCollisionObject_0(self), btCollisionObject);
    }, LocalConvexResult.prototype.set_m_hitCollisionObject = LocalConvexResult.prototype.set_m_hitCollisionObject = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_LocalConvexResult_set_m_hitCollisionObject_1(self, arg0);
    }, LocalConvexResult.prototype.get_m_localShapeInfo = LocalConvexResult.prototype.get_m_localShapeInfo = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_LocalConvexResult_get_m_localShapeInfo_0(self), LocalShapeInfo);
    }, LocalConvexResult.prototype.set_m_localShapeInfo = LocalConvexResult.prototype.set_m_localShapeInfo = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_LocalConvexResult_set_m_localShapeInfo_1(self, arg0);
    }, LocalConvexResult.prototype.get_m_hitNormalLocal = LocalConvexResult.prototype.get_m_hitNormalLocal = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_LocalConvexResult_get_m_hitNormalLocal_0(self), btVector3);
    }, LocalConvexResult.prototype.set_m_hitNormalLocal = LocalConvexResult.prototype.set_m_hitNormalLocal = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_LocalConvexResult_set_m_hitNormalLocal_1(self, arg0);
    }, LocalConvexResult.prototype.get_m_hitPointLocal = LocalConvexResult.prototype.get_m_hitPointLocal = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_LocalConvexResult_get_m_hitPointLocal_0(self), btVector3);
    }, LocalConvexResult.prototype.set_m_hitPointLocal = LocalConvexResult.prototype.set_m_hitPointLocal = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_LocalConvexResult_set_m_hitPointLocal_1(self, arg0);
    }, LocalConvexResult.prototype.get_m_hitFraction = LocalConvexResult.prototype.get_m_hitFraction = function() {
        var self = this.ptr;
        return _emscripten_bind_LocalConvexResult_get_m_hitFraction_0(self);
    }, LocalConvexResult.prototype.set_m_hitFraction = LocalConvexResult.prototype.set_m_hitFraction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_LocalConvexResult_set_m_hitFraction_1(self, arg0);
    }, LocalConvexResult.prototype.__destroy__ = LocalConvexResult.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_LocalConvexResult___destroy___0(self);
    }, btOverlappingPairCallback.prototype = Object.create(WrapperObject.prototype), 
    btOverlappingPairCallback.prototype.constructor = btOverlappingPairCallback, btOverlappingPairCallback.prototype.__class__ = btOverlappingPairCallback, 
    btOverlappingPairCallback.__cache__ = {}, Module.btOverlappingPairCallback = btOverlappingPairCallback, 
    btOverlappingPairCallback.prototype.__destroy__ = btOverlappingPairCallback.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btOverlappingPairCallback___destroy___0(self);
    }, btRigidBody.prototype = Object.create(btCollisionObject.prototype), btRigidBody.prototype.constructor = btRigidBody, 
    btRigidBody.prototype.__class__ = btRigidBody, btRigidBody.__cache__ = {}, Module.btRigidBody = btRigidBody, 
    btRigidBody.prototype.getCenterOfMassTransform = btRigidBody.prototype.getCenterOfMassTransform = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btRigidBody_getCenterOfMassTransform_0(self), btTransform);
    }, btRigidBody.prototype.setCenterOfMassTransform = btRigidBody.prototype.setCenterOfMassTransform = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setCenterOfMassTransform_1(self, arg0);
    }, btRigidBody.prototype.setSleepingThresholds = btRigidBody.prototype.setSleepingThresholds = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRigidBody_setSleepingThresholds_2(self, arg0, arg1);
    }, btRigidBody.prototype.setDamping = btRigidBody.prototype.setDamping = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRigidBody_setDamping_2(self, arg0, arg1);
    }, btRigidBody.prototype.setMassProps = btRigidBody.prototype.setMassProps = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRigidBody_setMassProps_2(self, arg0, arg1);
    }, btRigidBody.prototype.setLinearFactor = btRigidBody.prototype.setLinearFactor = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setLinearFactor_1(self, arg0);
    }, btRigidBody.prototype.applyTorque = btRigidBody.prototype.applyTorque = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_applyTorque_1(self, arg0);
    }, btRigidBody.prototype.applyForce = btRigidBody.prototype.applyForce = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRigidBody_applyForce_2(self, arg0, arg1);
    }, btRigidBody.prototype.applyCentralForce = btRigidBody.prototype.applyCentralForce = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_applyCentralForce_1(self, arg0);
    }, btRigidBody.prototype.applyTorqueImpulse = btRigidBody.prototype.applyTorqueImpulse = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_applyTorqueImpulse_1(self, arg0);
    }, btRigidBody.prototype.applyImpulse = btRigidBody.prototype.applyImpulse = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRigidBody_applyImpulse_2(self, arg0, arg1);
    }, btRigidBody.prototype.applyCentralImpulse = btRigidBody.prototype.applyCentralImpulse = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_applyCentralImpulse_1(self, arg0);
    }, btRigidBody.prototype.updateInertiaTensor = btRigidBody.prototype.updateInertiaTensor = function() {
        var self = this.ptr;
        _emscripten_bind_btRigidBody_updateInertiaTensor_0(self);
    }, btRigidBody.prototype.getLinearVelocity = btRigidBody.prototype.getLinearVelocity = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btRigidBody_getLinearVelocity_0(self), btVector3);
    }, btRigidBody.prototype.getAngularVelocity = btRigidBody.prototype.getAngularVelocity = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btRigidBody_getAngularVelocity_0(self), btVector3);
    }, btRigidBody.prototype.setLinearVelocity = btRigidBody.prototype.setLinearVelocity = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setLinearVelocity_1(self, arg0);
    }, btRigidBody.prototype.setAngularVelocity = btRigidBody.prototype.setAngularVelocity = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setAngularVelocity_1(self, arg0);
    }, btRigidBody.prototype.getMotionState = btRigidBody.prototype.getMotionState = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btRigidBody_getMotionState_0(self), btMotionState);
    }, btRigidBody.prototype.setMotionState = btRigidBody.prototype.setMotionState = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setMotionState_1(self, arg0);
    }, btRigidBody.prototype.setAngularFactor = btRigidBody.prototype.setAngularFactor = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setAngularFactor_1(self, arg0);
    }, btRigidBody.prototype.upcast = btRigidBody.prototype.upcast = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btRigidBody_upcast_1(self, arg0), btRigidBody);
    }, btRigidBody.prototype.setAnisotropicFriction = btRigidBody.prototype.setAnisotropicFriction = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRigidBody_setAnisotropicFriction_2(self, arg0, arg1);
    }, btRigidBody.prototype.getCollisionShape = btRigidBody.prototype.getCollisionShape = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btRigidBody_getCollisionShape_0(self), btCollisionShape);
    }, btRigidBody.prototype.setContactProcessingThreshold = btRigidBody.prototype.setContactProcessingThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setContactProcessingThreshold_1(self, arg0);
    }, btRigidBody.prototype.setActivationState = btRigidBody.prototype.setActivationState = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setActivationState_1(self, arg0);
    }, btRigidBody.prototype.forceActivationState = btRigidBody.prototype.forceActivationState = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_forceActivationState_1(self, arg0);
    }, btRigidBody.prototype.activate = btRigidBody.prototype.activate = function(arg0) {
        var self = this.ptr;
        if (arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), void 0 === arg0) return void _emscripten_bind_btRigidBody_activate_0(self);
        _emscripten_bind_btRigidBody_activate_1(self, arg0);
    }, btRigidBody.prototype.isActive = btRigidBody.prototype.isActive = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBody_isActive_0(self);
    }, btRigidBody.prototype.isKinematicObject = btRigidBody.prototype.isKinematicObject = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBody_isKinematicObject_0(self);
    }, btRigidBody.prototype.setRestitution = btRigidBody.prototype.setRestitution = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setRestitution_1(self, arg0);
    }, btRigidBody.prototype.setFriction = btRigidBody.prototype.setFriction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setFriction_1(self, arg0);
    }, btRigidBody.prototype.setRollingFriction = btRigidBody.prototype.setRollingFriction = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setRollingFriction_1(self, arg0);
    }, btRigidBody.prototype.getWorldTransform = btRigidBody.prototype.getWorldTransform = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btRigidBody_getWorldTransform_0(self), btTransform);
    }, btRigidBody.prototype.getCollisionFlags = btRigidBody.prototype.getCollisionFlags = function() {
        var self = this.ptr;
        return _emscripten_bind_btRigidBody_getCollisionFlags_0(self);
    }, btRigidBody.prototype.setCollisionFlags = btRigidBody.prototype.setCollisionFlags = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setCollisionFlags_1(self, arg0);
    }, btRigidBody.prototype.setWorldTransform = btRigidBody.prototype.setWorldTransform = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setWorldTransform_1(self, arg0);
    }, btRigidBody.prototype.setCollisionShape = btRigidBody.prototype.setCollisionShape = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setCollisionShape_1(self, arg0);
    }, btRigidBody.prototype.setCcdMotionThreshold = btRigidBody.prototype.setCcdMotionThreshold = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setCcdMotionThreshold_1(self, arg0);
    }, btRigidBody.prototype.setCcdSweptSphereRadius = btRigidBody.prototype.setCcdSweptSphereRadius = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btRigidBody_setCcdSweptSphereRadius_1(self, arg0);
    }, btRigidBody.prototype.__destroy__ = btRigidBody.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btRigidBody___destroy___0(self);
    }, btCylinderShapeX.prototype = Object.create(btCylinderShape.prototype), btCylinderShapeX.prototype.constructor = btCylinderShapeX, 
    btCylinderShapeX.prototype.__class__ = btCylinderShapeX, btCylinderShapeX.__cache__ = {}, 
    Module.btCylinderShapeX = btCylinderShapeX, btCylinderShapeX.prototype.setMargin = btCylinderShapeX.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCylinderShapeX_setMargin_1(self, arg0);
    }, btCylinderShapeX.prototype.getMargin = btCylinderShapeX.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btCylinderShapeX_getMargin_0(self);
    }, btCylinderShapeX.prototype.setLocalScaling = btCylinderShapeX.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCylinderShapeX_setLocalScaling_1(self, arg0);
    }, btCylinderShapeX.prototype.calculateLocalInertia = btCylinderShapeX.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCylinderShapeX_calculateLocalInertia_2(self, arg0, arg1);
    }, btCylinderShapeX.prototype.__destroy__ = btCylinderShapeX.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCylinderShapeX___destroy___0(self);
    }, btCylinderShapeZ.prototype = Object.create(btCylinderShape.prototype), btCylinderShapeZ.prototype.constructor = btCylinderShapeZ, 
    btCylinderShapeZ.prototype.__class__ = btCylinderShapeZ, btCylinderShapeZ.__cache__ = {}, 
    Module.btCylinderShapeZ = btCylinderShapeZ, btCylinderShapeZ.prototype.setMargin = btCylinderShapeZ.prototype.setMargin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCylinderShapeZ_setMargin_1(self, arg0);
    }, btCylinderShapeZ.prototype.getMargin = btCylinderShapeZ.prototype.getMargin = function() {
        var self = this.ptr;
        return _emscripten_bind_btCylinderShapeZ_getMargin_0(self);
    }, btCylinderShapeZ.prototype.setLocalScaling = btCylinderShapeZ.prototype.setLocalScaling = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btCylinderShapeZ_setLocalScaling_1(self, arg0);
    }, btCylinderShapeZ.prototype.calculateLocalInertia = btCylinderShapeZ.prototype.calculateLocalInertia = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btCylinderShapeZ_calculateLocalInertia_2(self, arg0, arg1);
    }, btCylinderShapeZ.prototype.__destroy__ = btCylinderShapeZ.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btCylinderShapeZ___destroy___0(self);
    }, btTransform.prototype = Object.create(WrapperObject.prototype), btTransform.prototype.constructor = btTransform, 
    btTransform.prototype.__class__ = btTransform, btTransform.__cache__ = {}, Module.btTransform = btTransform, 
    btTransform.prototype.setIdentity = btTransform.prototype.setIdentity = function() {
        var self = this.ptr;
        _emscripten_bind_btTransform_setIdentity_0(self);
    }, btTransform.prototype.setOrigin = btTransform.prototype.setOrigin = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btTransform_setOrigin_1(self, arg0);
    }, btTransform.prototype.setRotation = btTransform.prototype.setRotation = function(arg0) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), _emscripten_bind_btTransform_setRotation_1(self, arg0);
    }, btTransform.prototype.getOrigin = btTransform.prototype.getOrigin = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btTransform_getOrigin_0(self), btVector3);
    }, btTransform.prototype.getRotation = btTransform.prototype.getRotation = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btTransform_getRotation_0(self), btQuaternion);
    }, btTransform.prototype.getBasis = btTransform.prototype.getBasis = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btTransform_getBasis_0(self), btMatrix3x3);
    }, btTransform.prototype.__destroy__ = btTransform.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btTransform___destroy___0(self);
    }, btRaycastVehicle.prototype = Object.create(btActionInterface.prototype), btRaycastVehicle.prototype.constructor = btRaycastVehicle, 
    btRaycastVehicle.prototype.__class__ = btRaycastVehicle, btRaycastVehicle.__cache__ = {}, 
    Module.btRaycastVehicle = btRaycastVehicle, btRaycastVehicle.prototype.applyEngineForce = btRaycastVehicle.prototype.applyEngineForce = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRaycastVehicle_applyEngineForce_2(self, arg0, arg1);
    }, btRaycastVehicle.prototype.setSteeringValue = btRaycastVehicle.prototype.setSteeringValue = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRaycastVehicle_setSteeringValue_2(self, arg0, arg1);
    }, btRaycastVehicle.prototype.getWheelTransformWS = btRaycastVehicle.prototype.getWheelTransformWS = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btRaycastVehicle_getWheelTransformWS_1(self, arg0), btTransform);
    }, btRaycastVehicle.prototype.updateWheelTransform = btRaycastVehicle.prototype.updateWheelTransform = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRaycastVehicle_updateWheelTransform_2(self, arg0, arg1);
    }, btRaycastVehicle.prototype.addWheel = btRaycastVehicle.prototype.addWheel = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), arg3 && "object" == typeof arg3 && (arg3 = arg3.ptr), 
        arg4 && "object" == typeof arg4 && (arg4 = arg4.ptr), arg5 && "object" == typeof arg5 && (arg5 = arg5.ptr), 
        arg6 && "object" == typeof arg6 && (arg6 = arg6.ptr), wrapPointer(_emscripten_bind_btRaycastVehicle_addWheel_7(self, arg0, arg1, arg2, arg3, arg4, arg5, arg6), btWheelInfo);
    }, btRaycastVehicle.prototype.getNumWheels = btRaycastVehicle.prototype.getNumWheels = function() {
        var self = this.ptr;
        return _emscripten_bind_btRaycastVehicle_getNumWheels_0(self);
    }, btRaycastVehicle.prototype.getRigidBody = btRaycastVehicle.prototype.getRigidBody = function() {
        var self = this.ptr;
        return wrapPointer(_emscripten_bind_btRaycastVehicle_getRigidBody_0(self), btRigidBody);
    }, btRaycastVehicle.prototype.getWheelInfo = btRaycastVehicle.prototype.getWheelInfo = function(arg0) {
        var self = this.ptr;
        return arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), wrapPointer(_emscripten_bind_btRaycastVehicle_getWheelInfo_1(self, arg0), btWheelInfo);
    }, btRaycastVehicle.prototype.setBrake = btRaycastVehicle.prototype.setBrake = function(arg0, arg1) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        _emscripten_bind_btRaycastVehicle_setBrake_2(self, arg0, arg1);
    }, btRaycastVehicle.prototype.setCoordinateSystem = btRaycastVehicle.prototype.setCoordinateSystem = function(arg0, arg1, arg2) {
        var self = this.ptr;
        arg0 && "object" == typeof arg0 && (arg0 = arg0.ptr), arg1 && "object" == typeof arg1 && (arg1 = arg1.ptr), 
        arg2 && "object" == typeof arg2 && (arg2 = arg2.ptr), _emscripten_bind_btRaycastVehicle_setCoordinateSystem_3(self, arg0, arg1, arg2);
    }, btRaycastVehicle.prototype.__destroy__ = btRaycastVehicle.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btRaycastVehicle___destroy___0(self);
    }, btGhostPairCallback.prototype = Object.create(WrapperObject.prototype), btGhostPairCallback.prototype.constructor = btGhostPairCallback, 
    btGhostPairCallback.prototype.__class__ = btGhostPairCallback, btGhostPairCallback.__cache__ = {}, 
    Module.btGhostPairCallback = btGhostPairCallback, btGhostPairCallback.prototype.__destroy__ = btGhostPairCallback.prototype.__destroy__ = function() {
        var self = this.ptr;
        _emscripten_bind_btGhostPairCallback___destroy___0(self);
    }, function() {
        function setupEnums() {}
        Module.calledRun || addOnPreMain(setupEnums);
    }(), this.Ammo = Module, Module;
};

Ammo = AmmoLib();

var saveAs = saveAs || function(view) {
    if (!(void 0 === view || "undefined" != typeof navigator && /MSIE [1-9]\./.test(navigator.userAgent))) {
        var doc = view.document, get_URL = function() {
            return view.URL || view.webkitURL || view;
        }, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"), can_use_save_link = "download" in save_link, click = function(node) {
            var event = new MouseEvent("click");
            node.dispatchEvent(event);
        }, is_safari = /constructor/i.test(view.HTMLElement) || view.safari, is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent), throw_outside = function(ex) {
            (view.setImmediate || view.setTimeout)(function() {
                throw ex;
            }, 0);
        }, revoke = function(file) {
            var revoker = function() {
                "string" == typeof file ? get_URL().revokeObjectURL(file) : file.remove();
            };
            setTimeout(revoker, 4e4);
        }, dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            for (var i = event_types.length; i--; ) {
                var listener = filesaver["on" + event_types[i]];
                if ("function" == typeof listener) try {
                    listener.call(filesaver, event || filesaver);
                } catch (ex) {
                    throw_outside(ex);
                }
            }
        }, auto_bom = function(blob) {
            return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type) ? new Blob([ String.fromCharCode(65279), blob ], {
                type: blob.type
            }) : blob;
        }, FileSaver = function(blob, name, no_auto_bom) {
            no_auto_bom || (blob = auto_bom(blob));
            var object_url, filesaver = this, type = blob.type, force = "application/octet-stream" === type, dispatch_all = function() {
                dispatch(filesaver, "writestart progress write writeend".split(" "));
            };
            if (filesaver.readyState = filesaver.INIT, can_use_save_link) return object_url = get_URL().createObjectURL(blob), 
            void setTimeout(function() {
                save_link.href = object_url, save_link.download = name, click(save_link), dispatch_all(), 
                revoke(object_url), filesaver.readyState = filesaver.DONE;
            });
            !function() {
                if ((is_chrome_ios || force && is_safari) && view.FileReader) {
                    var reader = new FileReader();
                    return reader.onloadend = function() {
                        var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, "data:attachment/file;");
                        view.open(url, "_blank") || (view.location.href = url), url = void 0, filesaver.readyState = filesaver.DONE, 
                        dispatch_all();
                    }, reader.readAsDataURL(blob), void (filesaver.readyState = filesaver.INIT);
                }
                if (object_url || (object_url = get_URL().createObjectURL(blob)), force) view.location.href = object_url; else {
                    view.open(object_url, "_blank") || (view.location.href = object_url);
                }
                filesaver.readyState = filesaver.DONE, dispatch_all(), revoke(object_url);
            }();
        }, FS_proto = FileSaver.prototype, saveAs = function(blob, name, no_auto_bom) {
            return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
        };
        return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function(blob, name, no_auto_bom) {
            return name = name || blob.name || "download", no_auto_bom || (blob = auto_bom(blob)), 
            navigator.msSaveOrOpenBlob(blob, name);
        } : (FS_proto.abort = function() {}, FS_proto.readyState = FS_proto.INIT = 0, FS_proto.WRITING = 1, 
        FS_proto.DONE = 2, FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null, 
        saveAs);
    }
}("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);

"undefined" != typeof module && module.exports ? module.exports.saveAs = saveAs : "undefined" != typeof define && null !== define && null !== define.amd && define("FileSaver.js", function() {
    return saveAs;
});

var VirtualJoystick = function(opts) {
    opts = opts || {}, this._container = opts.container || document.body, this._strokeStyle = opts.strokeStyle || "cyan", 
    this._stickEl = opts.stickElement || this._buildJoystickStick(), this._baseEl = opts.baseElement || this._buildJoystickBase(), 
    this._mouseSupport = void 0 !== opts.mouseSupport && opts.mouseSupport, this._stationaryBase = opts.stationaryBase || !1, 
    this._baseX = this._stickX = opts.baseX || 0, this._baseY = this._stickY = opts.baseY || 0, 
    this._limitStickTravel = opts.limitStickTravel || !1, this._stickRadius = void 0 !== opts.stickRadius ? opts.stickRadius : 100, 
    this._deadZone = opts.deadZone || 0, this._useCssTransform = void 0 !== opts.useCssTransform && opts.useCssTransform, 
    this._container.style.position = "relative", this._container.appendChild(this._baseEl), 
    this._baseEl.style.position = "absolute", this._baseEl.style.display = "none", this._container.appendChild(this._stickEl), 
    this._stickEl.style.position = "absolute", this._stickEl.style.display = "none", 
    this._pressed = !1, this._touchIdx = null, !0 === this._stationaryBase && (this._baseEl.style.display = "", 
    this._baseEl.style.left = this._baseX - this._baseEl.width / 2 + "px", this._baseEl.style.top = this._baseY - this._baseEl.height / 2 + "px"), 
    this._transform = !!this._useCssTransform && this._getTransformProperty(), this._has3d = this._check3D();
    var __bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    };
    this._$onTouchStart = __bind(this._onTouchStart, this), this._$onTouchEnd = __bind(this._onTouchEnd, this), 
    this._$onTouchMove = __bind(this._onTouchMove, this), this._container.addEventListener("touchstart", this._$onTouchStart, !1), 
    this._container.addEventListener("touchend", this._$onTouchEnd, !1), this._container.addEventListener("touchmove", this._$onTouchMove, !1), 
    this._mouseSupport && (this._$onMouseDown = __bind(this._onMouseDown, this), this._$onMouseUp = __bind(this._onMouseUp, this), 
    this._$onMouseMove = __bind(this._onMouseMove, this), this._container.addEventListener("mousedown", this._$onMouseDown, !1), 
    this._container.addEventListener("mouseup", this._$onMouseUp, !1), this._container.addEventListener("mousemove", this._$onMouseMove, !1));
};

VirtualJoystick.prototype.destroy = function() {
    this._container.removeChild(this._baseEl), this._container.removeChild(this._stickEl), 
    this._container.removeEventListener("touchstart", this._$onTouchStart, !1), this._container.removeEventListener("touchend", this._$onTouchEnd, !1), 
    this._container.removeEventListener("touchmove", this._$onTouchMove, !1), this._mouseSupport && (this._container.removeEventListener("mouseup", this._$onMouseUp, !1), 
    this._container.removeEventListener("mousedown", this._$onMouseDown, !1), this._container.removeEventListener("mousemove", this._$onMouseMove, !1));
}, VirtualJoystick.touchScreenAvailable = function() {
    return "createTouch" in document;
}, function(destObj) {
    destObj.addEventListener = function(event, fct) {
        return void 0 === this._events && (this._events = {}), this._events[event] = this._events[event] || [], 
        this._events[event].push(fct), fct;
    }, destObj.removeEventListener = function(event, fct) {
        void 0 === this._events && (this._events = {}), event in this._events != !1 && this._events[event].splice(this._events[event].indexOf(fct), 1);
    }, destObj.dispatchEvent = function(event) {
        if (void 0 === this._events && (this._events = {}), void 0 !== this._events[event]) for (var tmpArray = this._events[event].slice(), i = 0; i < tmpArray.length; i++) {
            var result = tmpArray[i].apply(this, Array.prototype.slice.call(arguments, 1));
            if (void 0 !== result) return result;
        }
    };
}(VirtualJoystick.prototype), VirtualJoystick.prototype.deltaX = function() {
    return this._stickX - this._baseX;
}, VirtualJoystick.prototype.deltaY = function() {
    return this._stickY - this._baseY;
}, VirtualJoystick.prototype.up = function() {
    if (!1 === this._pressed) return !1;
    var deltaX = this.deltaX(), deltaY = this.deltaY();
    return !(deltaY >= 0) && (!(Math.abs(deltaX) > 2 * Math.abs(deltaY)) && !(deltaY > -this._deadZone && deltaY < this._deadZone));
}, VirtualJoystick.prototype.down = function() {
    if (!1 === this._pressed) return !1;
    var deltaX = this.deltaX(), deltaY = this.deltaY();
    return !(deltaY <= 0) && (!(Math.abs(deltaX) > 2 * Math.abs(deltaY)) && !(deltaY > -this._deadZone && deltaY < this._deadZone));
}, VirtualJoystick.prototype.right = function() {
    if (!1 === this._pressed) return !1;
    var deltaX = this.deltaX(), deltaY = this.deltaY();
    return !(deltaX <= 0) && (!(Math.abs(deltaY) > 2 * Math.abs(deltaX)) && !(deltaX > -this._deadZone && deltaX < this._deadZone));
}, VirtualJoystick.prototype.left = function() {
    if (!1 === this._pressed) return !1;
    var deltaX = this.deltaX(), deltaY = this.deltaY();
    return !(deltaX >= 0) && (!(Math.abs(deltaY) > 2 * Math.abs(deltaX)) && !(deltaX > -this._deadZone && deltaX < this._deadZone));
}, VirtualJoystick.prototype._onUp = function() {
    this._pressed = !1, this._stickEl.style.display = "none", 0 == this._stationaryBase && (this._baseEl.style.display = "none", 
    this._baseX = this._baseY = 0, this._stickX = this._stickY = 0);
}, VirtualJoystick.prototype._onDown = function(x, y) {
    if (this._pressed = !0, 0 == this._stationaryBase && (this._baseX = x, this._baseY = y, 
    this._baseEl.style.display = "", this._move(this._baseEl.style, this._baseX - this._baseEl.width / 2, this._baseY - this._baseEl.height / 2)), 
    this._stickX = x, this._stickY = y, !0 === this._limitStickTravel) {
        var deltaX = this.deltaX(), deltaY = this.deltaY(), stickDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (stickDistance > this._stickRadius) {
            var stickNormalizedX = deltaX / stickDistance, stickNormalizedY = deltaY / stickDistance;
            this._stickX = stickNormalizedX * this._stickRadius + this._baseX, this._stickY = stickNormalizedY * this._stickRadius + this._baseY;
        }
    }
    this._stickEl.style.display = "", this._move(this._stickEl.style, this._stickX - this._stickEl.width / 2, this._stickY - this._stickEl.height / 2);
}, VirtualJoystick.prototype._onMove = function(x, y) {
    if (!0 === this._pressed) {
        if (this._stickX = x, this._stickY = y, !0 === this._limitStickTravel) {
            var deltaX = this.deltaX(), deltaY = this.deltaY(), stickDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (stickDistance > this._stickRadius) {
                var stickNormalizedX = deltaX / stickDistance, stickNormalizedY = deltaY / stickDistance;
                this._stickX = stickNormalizedX * this._stickRadius + this._baseX, this._stickY = stickNormalizedY * this._stickRadius + this._baseY;
            }
        }
        this._move(this._stickEl.style, this._stickX - this._stickEl.width / 2, this._stickY - this._stickEl.height / 2);
    }
}, VirtualJoystick.prototype._onMouseUp = function(event) {
    return this._onUp();
}, VirtualJoystick.prototype._onMouseDown = function(event) {
    event.preventDefault();
    var x = event.clientX, y = event.clientY;
    return this._onDown(x, y);
}, VirtualJoystick.prototype._onMouseMove = function(event) {
    var x = event.clientX, y = event.clientY;
    return this._onMove(x, y);
}, VirtualJoystick.prototype._onTouchStart = function(event) {
    if (null === this._touchIdx) {
        if (!1 !== this.dispatchEvent("touchStartValidation", event)) {
            this.dispatchEvent("touchStart", event), event.preventDefault();
            var touch = event.changedTouches[0];
            this._touchIdx = touch.identifier;
            var x = touch.pageX, y = touch.pageY;
            return this._onDown(x, y);
        }
    }
}, VirtualJoystick.prototype._onTouchEnd = function(event) {
    if (null !== this._touchIdx) {
        this.dispatchEvent("touchEnd", event);
        for (var touchList = event.changedTouches, i = 0; i < touchList.length && touchList[i].identifier !== this._touchIdx; i++) ;
        if (i !== touchList.length) return this._touchIdx = null, event.preventDefault(), 
        this._onUp();
    }
}, VirtualJoystick.prototype._onTouchMove = function(event) {
    if (null !== this._touchIdx) {
        for (var touchList = event.changedTouches, i = 0; i < touchList.length && touchList[i].identifier !== this._touchIdx; i++) ;
        if (i !== touchList.length) {
            var touch = touchList[i];
            event.preventDefault();
            var x = touch.pageX, y = touch.pageY;
            return this._onMove(x, y);
        }
    }
}, VirtualJoystick.prototype._buildJoystickBase = function() {
    var canvas = document.createElement("canvas");
    canvas.width = 126, canvas.height = 126;
    var ctx = canvas.getContext("2d");
    return ctx.beginPath(), ctx.strokeStyle = this._strokeStyle, ctx.lineWidth = 6, 
    ctx.arc(canvas.width / 2, canvas.width / 2, 40, 0, 2 * Math.PI, !0), ctx.stroke(), 
    ctx.beginPath(), ctx.strokeStyle = this._strokeStyle, ctx.lineWidth = 2, ctx.arc(canvas.width / 2, canvas.width / 2, 60, 0, 2 * Math.PI, !0), 
    ctx.stroke(), canvas;
}, VirtualJoystick.prototype._buildJoystickStick = function() {
    var canvas = document.createElement("canvas");
    canvas.width = 86, canvas.height = 86;
    var ctx = canvas.getContext("2d");
    return ctx.beginPath(), ctx.strokeStyle = this._strokeStyle, ctx.lineWidth = 6, 
    ctx.arc(canvas.width / 2, canvas.width / 2, 40, 0, 2 * Math.PI, !0), ctx.stroke(), 
    canvas;
}, VirtualJoystick.prototype._move = function(style, x, y) {
    this._transform ? this._has3d ? style[this._transform] = "translate3d(" + x + "px," + y + "px, 0)" : style[this._transform] = "translate(" + x + "px," + y + "px)" : (style.left = x + "px", 
    style.top = y + "px");
}, VirtualJoystick.prototype._getTransformProperty = function() {
    for (var style, styles = [ "webkitTransform", "MozTransform", "msTransform", "OTransform", "transform" ], el = document.createElement("p"), i = 0; i < styles.length; i++) if (style = styles[i], 
    null != el.style[style]) return style;
}, VirtualJoystick.prototype._check3D = function() {
    var prop = this._getTransformProperty();
    if (!prop || !window.getComputedStyle) return module.exports = !1;
    var map = {
        webkitTransform: "-webkit-transform",
        OTransform: "-o-transform",
        msTransform: "-ms-transform",
        MozTransform: "-moz-transform",
        transform: "transform"
    }, el = document.createElement("div");
    el.style[prop] = "translate3d(1px,1px,1px)", document.body.insertBefore(el, null);
    var val = getComputedStyle(el).getPropertyValue(map[prop]);
    return document.body.removeChild(el), null != val && val.length && "none" != val;
};

var Singleton, exports;

exports = void 0, void 0 !== exports && null !== exports || (exports = {}), Singleton = function() {
    function Singleton() {}
    return Singleton;
}();

var SceneManager;

SceneManager = function() {
    function SceneManager() {}
    var instance;
    return instance = null, Singleton.SceneManager = function() {
        function SceneManager() {}
        return SceneManager.prototype.scenes = [], SceneManager.prototype.currentSceneIndex = void 0, 
        SceneManager.prototype.currentScene = function() {
            if (null == this.currentSceneIndex) throw new Error("SceneManager.setScene not called");
            if (this.isEmpty()) throw new Error("Requires at least one scene");
            return this.scenes[this.currentSceneIndex];
        }, SceneManager.prototype.addScene = function(scene) {
            if (null == scene) throw new Error("missing scene param");
            if (-1 === this.scenes.indexOf(scene)) return this.scenes.push(scene);
        }, SceneManager.prototype.removeScene = function(scene) {
            var i;
            if (null == scene) throw new Error("missing scene param");
            return i = this.scenes.indexOf(scene), this.removeSceneByIndex(i);
        }, SceneManager.prototype.removeSceneByIndex = function(i) {
            if (i >= 0) return i === this.currentSceneIndex && (this.currentSceneIndex = void 0), 
            array.splice(i, 1);
        }, SceneManager.prototype.setScene = function(scene) {
            var i;
            if (null == scene) throw new Error("missing scene param");
            if (-1 === (i = this.scenes.indexOf(scene))) throw new Error("scene not added to SceneManager");
            return this.setSceneByIndex(i), this.currentScene();
        }, SceneManager.prototype.setSceneByIndex = function(i) {
            var debugMsg, scene;
            if (this.isEmpty() || !this.isValidIndex(i)) throw new Error("invalid scene index");
            this.currentSceneIndex = i, scene = this.currentScene(), debugMsg = "Changing to scene " + i;
            try {
                debugMsg += ": " + scene.constructor.name;
            } catch (error) {
                error;
            }
            return console.ce(debugMsg), scene;
        }, SceneManager.prototype.isEmpty = function() {
            return 0 === this.scenes.length;
        }, SceneManager.prototype.isValidIndex = function(i) {
            return 0 <= i && i < this.scenes.length;
        }, SceneManager.prototype.hasScene = function(scene) {
            return this.scenes.includes(scene);
        }, SceneManager.prototype.tick = function(tpf) {
            return this.currentScene().fullTick(tpf);
        }, SceneManager;
    }(), SceneManager.get = function() {
        return null != instance ? instance : instance = new Singleton.SceneManager();
    }, SceneManager.currentScene = function() {
        return this.get().currentScene();
    }, SceneManager.addScene = function(scene) {
        return this.get().addScene(scene);
    }, SceneManager;
}();

var NetworkManager;

NetworkManager = function() {
    function NetworkManager() {}
    var instance;
    return instance = null, Singleton.NetworkManager = function() {
        function NetworkManager() {}
        return NetworkManager.prototype.socket = void 0, NetworkManager.prototype.clientInputId = 0, 
        NetworkManager.prototype.connect = function(namespace) {
            return null == namespace && (namespace = "/"), this.socket = io.connect(namespace);
        }, NetworkManager.prototype.getSessionId = function() {
            if (null != this.socket) return this.socket.socket.sessionid;
        }, NetworkManager.prototype.on = function(event, func) {
            return this.socket.on(event, func);
        }, NetworkManager.prototype.rawEmit = function(name, data) {
            return null == data && (data = {}), data = this._prepareData(data), this.socket.emit(name, data);
        }, NetworkManager.prototype.fakeEmit = function(name, data) {
            return null == data && (data = {}), this._prepareData(data);
        }, NetworkManager.prototype._prepareData = function(data) {
            return null == data && (data = {}), data.timestamp = new Date().getTime(), data.clientInputId = this.clientInputId, 
            this.clientInputId += 1, data;
        }, NetworkManager.prototype.emit = function(data) {
            if (null == data && null == data.type) throw "data.type missing";
            return this.rawEmit("data", data);
        }, NetworkManager.prototype.fake = function(data) {
            if (null == data && null == data.type) throw "data.type missing";
            return this.fakeEmit("data", data);
        }, NetworkManager.prototype._hasListener = function(name) {
            return this.socket.listeners(name).any();
        }, NetworkManager;
    }(), NetworkManager.get = function() {
        return null != instance ? instance : instance = new Singleton.NetworkManager();
    }, NetworkManager.connect = function(namespace) {
        return this.get().connect(namespace);
    }, NetworkManager.getSessionId = function() {
        return this.get().getSessionId();
    }, NetworkManager.on = function(event, func) {
        return this.get().on(event, fund);
    }, NetworkManager.rawEmit = function(name, data) {
        return this.get().rawEmit(name, data);
    }, NetworkManager.fakeEmit = function(name, data) {
        return this.get().fakeEmit(name, data);
    }, NetworkManager.fake = function(data) {
        return this.get().fake(data);
    }, NetworkManager.emit = function(data) {
        return this.get().emit(data);
    }, NetworkManager;
}();

var StatsManager;

StatsManager = function() {
    function StatsManager() {}
    var instance;
    return instance = null, Singleton.StatsManager = function() {
        function StatsManager() {
            this.stats = new Stats(), this.stats.domElement.style.position = "absolute", this.stats.domElement.style.top = "0px", 
            this.rendererStats = new THREEx.RendererStats(), this.rendererStats.domElement.style.position = "absolute", 
            this.rendererStats.domElement.style.left = "0px", this.rendererStats.domElement.style.bottom = "0px";
        }
        return StatsManager.prototype.statsVisible = !1, StatsManager.prototype.toggle = function() {
            return this.statsVisible = !this.statsVisible, this.statsVisible ? (document.body.appendChild(this.stats.domElement), 
            document.body.appendChild(this.rendererStats.domElement)) : (document.body.removeChild(this.stats.domElement), 
            document.body.removeChild(this.rendererStats.domElement)), this.statsVisible;
        }, StatsManager.prototype.setVisible = function(value) {
            if (value !== this.statsVisible) return this.toggle();
        }, StatsManager.prototype.update = function(renderer) {
            if (this.statsVisible) return this.stats.update(), this.rendererStats.update(renderer);
        }, StatsManager;
    }(), StatsManager.get = function() {
        return null != instance ? instance : instance = new Singleton.StatsManager();
    }, StatsManager.toggle = function() {
        return this.get().toggle();
    }, StatsManager.setVisible = function() {
        return this.get().setVisible();
    }, StatsManager.update = function(renderer) {
        return this.get().update(renderer);
    }, StatsManager;
}();

var SoundManager;

SoundManager = function() {
    function SoundManager() {}
    var instance;
    return instance = null, Singleton.SoundManager = function() {
        function SoundManager() {}
        return SoundManager.prototype.items = {}, SoundManager.prototype.loadCount = 0, 
        SoundManager.prototype.load = function(key, url) {
            var howl;
            if (void 0 === this.items[key]) return this.items[key] = null, url instanceof Array || (url = [ url ]), 
            howl = new Howl({
                autoplay: !1,
                urls: url,
                onload: function() {
                    return window.SoundManager.get()._loaded(key, howl);
                }
            });
        }, SoundManager.prototype._loaded = function(key, howl) {
            return this.items[key] = howl, this.loadCount += 1;
        }, SoundManager.prototype.cmd = function(options) {
            if (null == options && (options = {}), null == options.type) throw new Error("options.type missing");
            if (null == options.key) throw new Error("options.key missing");
            if (!(options.key in this.items)) throw new Error("Sound with key: " + options.key + " not found!");
            switch (options.type) {
              case "play":
              case "pause":
              case "stop":
                this.items[options.key][options.type]();
                break;

              case "fadeIn":
              case "fadeOut":
                null == options.to && (options.to = 1), null == options.duration && (options.duration = 1e3), 
                this.items[options.key][options.type](options.to, options.duration);
                break;

              case "volume":
              case "volumeAll":
                null == options.volume && (options.volume = 1), "volume" === options.type ? this.items[options.key][options.type](options.volume) : this.volumeAll(options.volume);
                break;

              case "loop":
                null == options.loop && (options.loop = !1), this.items[options.key][options.type](options.loop);
                break;

              default:
                throw new Error("unknown options.type " + options.type);
            }
            return this.items[options.key];
        }, SoundManager.prototype.play = function(key) {
            return this.cmd({
                type: "play",
                key: key
            });
        }, SoundManager.prototype.pause = function(key) {
            return this.cmd({
                type: "pause",
                key: key
            });
        }, SoundManager.prototype.stop = function(key) {
            return this.cmd({
                type: "stop",
                key: key
            });
        }, SoundManager.prototype.fadeIn = function(key, to) {
            return this.cmd({
                type: "fadeIn",
                key: key,
                to: to,
                duration: duration
            });
        }, SoundManager.prototype.fadeOut = function(key, to) {
            return this.cmd({
                type: "fadeOut",
                key: key,
                to: to,
                duration: duration
            });
        }, SoundManager.prototype.volume = function(key, volume) {
            return this.cmd({
                type: "volume",
                key: key,
                volume: volume
            });
        }, SoundManager.prototype.looping = function(key, looping) {
            return this.cmd({
                type: "loop",
                key: key,
                loop: looping
            });
        }, SoundManager.prototype.hasFinishedLoading = function() {
            return this.loadCount === Object.keys(this.items).size();
        }, SoundManager.prototype.volumeAll = function(i) {
            var key;
            i < 0 && (i = 0), i > 1 && (i = 1);
            for (key in this.items) this.volume(key, i);
            return i;
        }, SoundManager.prototype.has = function(key) {
            return null != this.items[key];
        }, SoundManager;
    }(), SoundManager.get = function() {
        return null != instance ? instance : instance = new Singleton.SoundManager();
    }, SoundManager.has = function(key) {
        return this.get().has(key);
    }, SoundManager.play = function(key) {
        return this.get().play(key);
    }, SoundManager.pause = function(key) {
        return this.get().pause(key);
    }, SoundManager.stop = function(key) {
        return this.get().stop(key);
    }, SoundManager.fadeIn = function(key, to) {
        return this.get().fadeIn(key, to);
    }, SoundManager.fadeOut = function(key, to) {
        return this.get().fadeOut(key, to);
    }, SoundManager.volume = function(key, volume) {
        return this.get().volume(key, volume);
    }, SoundManager.looping = function(key, looping) {
        return this.get().looping(key, looping);
    }, SoundManager.volumeAll = function(i) {
        return this.get().volumeAll(i);
    }, SoundManager.load = function(key, url) {
        return this.get().load(key, url);
    }, SoundManager.cmd = function(options) {
        return this.get().cmd(options);
    }, SoundManager.hasFinishedLoading = function() {
        return this.get().hasFinishedLoading();
    }, SoundManager;
}();

var SaveObjectManager;

SaveObjectManager = function() {
    function SaveObjectManager() {}
    var instance;
    return instance = null, Singleton.SaveObjectManager = function() {
        function SaveObjectManager() {}
        return SaveObjectManager.prototype.items = {}, SaveObjectManager.prototype.loadCount = 0, 
        SaveObjectManager.prototype.load = function(key, url) {
            var request;
            if (void 0 === this.items[key]) return this.items[key] = null, request = new XMLHttpRequest(), 
            request.open("GET", url, !0), request.onload = function() {
                var data, som;
                if (request.status >= 200 && request.status < 400) {
                    try {
                        data = JSON.parse(request.responseText);
                    } catch (error) {
                        return void console.log("invalid json " + url);
                    }
                    som = window.SaveObjectManager.get(), som.items[key] = data, som._load();
                }
            }, request.onerror = function() {
                console.log("error loading " + url);
            }, request.send(), this;
        }, SaveObjectManager.prototype.hasFinishedLoading = function() {
            return this.loadCount === Object.keys(this.items).size();
        }, SaveObjectManager.prototype._load = function() {
            return window.SaveObjectManager.get().loadCount += 1;
        }, SaveObjectManager;
    }(), SaveObjectManager.get = function() {
        return null != instance ? instance : instance = new Singleton.SaveObjectManager();
    }, SaveObjectManager.hasFinishedLoading = function() {
        return this.get().hasFinishedLoading();
    }, SaveObjectManager.load = function() {
        return this.get().load(key, url);
    }, SaveObjectManager;
}();

var HighScoreManager;

HighScoreManager = function() {
    function HighScoreManager() {}
    var instance;
    return instance = null, Singleton.HighScoreManager = function() {
        function HighScoreManager() {}
        return HighScoreManager.prototype.apiKey = "guest", HighScoreManager.prototype.secret = "guest", 
        HighScoreManager.prototype.auth = function(apiKey, secret, tryRegister) {
            return null == tryRegister && (tryRegister = !1), tryRegister && jNorthPole.createUser(apiKey, secret, function(data) {
                return console.log("api key registered: " + apiKey);
            }), this._setTokens(apiKey, secret), this._ensureTokenPresence(), this;
        }, HighScoreManager.prototype._setTokens = function(apiKey, secret) {
            return this.apiKey = apiKey, this.secret = secret;
        }, HighScoreManager.prototype.addScore = function(name, score) {
            var json;
            if (this._ensureTokenPresence(), null == name) throw new Error("name required");
            if (!isNumeric(score)) throw new Error("score needs to be a number");
            return json = {
                api_key: this.apiKey,
                secret: this.secret,
                type: "highscore",
                name: name,
                score: score
            }, jNorthPole.createStorage(json, this.responseHandler, this.errorHandler);
        }, HighScoreManager.prototype.getScores = function(limit, order) {
            var json;
            return null == limit && (limit = 10), null == order && (order = "desc"), this._ensureTokenPresence(), 
            json = {
                api_key: this.apiKey,
                secret: this.secret,
                type: "highscore",
                __limit: limit,
                __sort: {
                    score: order
                }
            }, jNorthPole.getStorage(json, this.responseHandler, this.errorHandler);
        }, HighScoreManager.prototype.responseHandler = function(data) {
            return console.log(data);
        }, HighScoreManager.prototype.errorHandler = function(data, status) {
            return console.log(data);
        }, HighScoreManager.prototype._ensureTokenPresence = function() {
            if (null == this.apiKey) throw new Error("apiKey missing");
            if (null == this.secret) throw new Error("secret missing");
        }, HighScoreManager;
    }(), HighScoreManager.get = function() {
        return null != instance ? instance : instance = new Singleton.HighScoreManager();
    }, HighScoreManager.auth = function(apiKey, secret, tryRegister) {
        return this.get().auth(apiKey, secret, tryRegister);
    }, HighScoreManager.addScore = function(name, score) {
        return this.get().addScore(name, score);
    }, HighScoreManager.getScores = function(limit, order) {
        return this.get().getScores(limit, order);
    }, HighScoreManager;
}();

var Persist;

Persist = function() {
    function Persist() {
        this.storage = localStorage;
    }
    return Persist.PREFIX = "ce", Persist.DEFAULT_SUFFIX = "default", Persist.prototype.setJson = function(key, value, def) {
        return null == def && (def = void 0), value = JSON.stringify(value), null != def && (def = JSON.stringify(def)), 
        this.set(key, value, def);
    }, Persist.prototype.set = function(key, value, def) {
        if (null == def && (def = void 0), null == key) throw "key missing";
        if (this.storage[Persist.PREFIX + "." + key] = value, null != def) return this.default(key, def);
    }, Persist.prototype.defaultJson = function(key, value) {
        return value = JSON.stringify(value), this.default(key, value);
    }, Persist.prototype.default = function(key, value) {
        return this.set(key + "." + Persist.DEFAULT_SUFFIX, value);
    }, Persist.prototype.getJson = function(key) {
        var item;
        if (null != (item = this.get(key))) return JSON.parse(item);
    }, Persist.prototype.get = function(key) {
        var value;
        return value = this._get(key), null == value ? this._get(key + "." + Persist.DEFAULT_SUFFIX) : value;
    }, Persist.prototype._get = function(key) {
        var value;
        if (null == key) throw "key missing";
        return value = this.storage[Persist.PREFIX + "." + key], isNumeric(value) ? Number(value) : "true" === value || "false" !== value && ("undefined" !== value ? value : void 0);
    }, Persist.prototype.rm = function(key) {
        if (null == key) throw "key missing";
        return this.storage.removeItem(Persist.PREFIX + "." + key);
    }, Persist.prototype.clear = function(exceptions, withDefaults) {
        var results, storage;
        null == exceptions && (exceptions = []), null == withDefaults && (withDefaults = !1), 
        exceptions instanceof Array || (exceptions = [ exceptions ]), results = [];
        for (storage in this.storage) storage.endsWith("." + Persist.DEFAULT_SUFFIX) && !1 === withDefaults || (exceptions.includes(storage) ? results.push(void 0) : results.push(this.rm(storage)));
        return results;
    }, Persist.sessionStorage = function() {
        var persist;
        return persist = new Persist(), persist.storage = sessionStorage, persist;
    }, Persist.getJson = function(key) {
        return new Persist().getJson(key);
    }, Persist.get = function(key) {
        return new Persist().get(key);
    }, Persist.setJson = function(key, value, def) {
        return new Persist().setJson(key, value, def);
    }, Persist.set = function(key, value, def) {
        return new Persist().set(key, value, def);
    }, Persist.default = function(key, value) {
        return new Persist().default(key, value);
    }, Persist.defaultJson = function(key, value) {
        return new Persist().defaultJson(key, value);
    }, Persist.rm = function(key) {
        return new Persist().rm(key);
    }, Persist.clear = function(exceptions, withDefaults) {
        return new Persist().clear(exceptions, withDefaults);
    }, Persist;
}();

var Utils;

Utils = function() {
    function Utils() {}
    return Utils.JSON_URLS = [ ".json" ], Utils.IMG_URLS = [ ".png", ".jpg", ".jpeg" ], 
    Utils.SAVE_URLS = [ ".save.json" ], Utils.AUDIO_URLS = [ ".mp3", ".ogg", ".wav" ], 
    Utils.CAMERA_DEFAULT_VIEW_ANGLE = 45, Utils.CAMERA_DEFAULT_NEAR = 1, Utils.CAMERA_DEFAULT_FAR = 1e5, 
    Utils.CAMERA_DEFAULT_TYPE = "PerspectiveCamera", Utils.SKY_SPHERE_DEFAULT_RADIUS = 5e4, 
    Utils.SKY_SPHERE_DEFAULT_SEGMENTS = 64, Utils.PLANE_DEFAULT_COLOR = "#ff0000", Utils.PLANE_DEFAULT_WIDTH = 5, 
    Utils.PLANE_DEFAULT_HEIGHT = 5, Utils.PLANE_DEFAULT_W_SEGMENTS = 1, Utils.PLANE_DEFAULT_H_SEGMENTS = 1, 
    Utils.AMBIENT_LIGHT_DEFAULT_COLOR = "#404040", Utils.LIGHT_DEFAULT_COLOR = "#ffffff", 
    Utils.LIGHT_DEFAULT_POSITION_X = 0, Utils.LIGHT_DEFAULT_POSITION_Y = 100, Utils.LIGHT_DEFAULT_POSITION_Z = 60, 
    Utils.POINT_LIGHT_DEFAULT_COLOR = "#ffffff", Utils.POINT_LIGHT_DEFAULT_INTENSITY = 1, 
    Utils.POINT_LIGHT_DEFAULT_DISTANCE = 100, Utils.POINT_LIGHT_DEFAULT_DECAY = 1, Utils.MIRROR_DEFAULT_COLOR = "#777777", 
    Utils.MIRROR_DEFAULT_TEXTURE_WIDTH = 512, Utils.MIRROR_DEFAULT_TEXTURE_HEIGHT = 512, 
    Utils.MIRROR_DEFAULT_CLIP_BIAS = .003, Utils.WATER_DEFAULT_WATER_COLOR = "#001e0f", 
    Utils.WATER_DEFAULT_ALPHA = 1, Utils.CE_BUTTON_POSITIONS = [ "top-right", "bottom-right", "top-left", "bottom-left" ], 
    Utils.CE_BUTTON_TYPES = [ "fullscreen", "reinit" ], Utils.CE_UI_Z_INDEX = 1e3, Utils.ORIENTATIONS = [ "all", "landscape", "portrait" ], 
    Utils.FADE_COLOR = "black", Utils.FADE_DEFAULT_DURATION = 1e3, Utils.PHYSICS = {
        DISABLE_DEACTIVATION: 4
    }, Utils.toggleFullscreen = function() {
        document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ? document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen() : document.documentElement.requestFullscreen ? document.documentElement.requestFullscreen() : document.documentElement.msRequestFullscreen ? document.documentElement.msRequestFullscreen() : document.documentElement.mozRequestFullScreen ? document.documentElement.mozRequestFullScreen() : document.documentElement.webkitRequestFullscreen && document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }, Utils.guid = function() {
        var s4;
        return (s4 = function() {
            return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
        })() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
    }, Utils.setCursor = function(url) {
        return document.body.style.cursor = "url('" + url + "'), auto";
    }, Utils.rgbToHex = function(r, g, b) {
        if (r > 255 || g > 255 || b > 255) throw "Invalid color component";
        return (r << 16 | g << 8 | b).toString(16);
    }, Utils.degToRadians = function(angle) {
        return angle * Math.PI / 180;
    }, Utils.getKeyName = function(url, array) {
        return url.replaceAny(array, "").split("/").last();
    }, Utils.encrypt = function(json) {
        var s;
        return s = JSON.stringify(json), window.btoa(s);
    }, Utils.decrypt = function(s) {
        return JSON.parse(window.atob(s));
    }, Utils.saveFile = function(content, fileName, format) {
        var blob, json;
        return null == format && (format = "application/json"), Utils._ensureBlobPresence(), 
        json = JSON.stringify(content, null, 2), blob = new Blob([ json ], {
            type: format + ";charset=utf-8"
        }), saveAs(blob, fileName);
    }, Utils.saveScreenshot = function(engine, fileName) {
        var content;
        return null == fileName && (fileName = "screenshot.png"), Utils._ensureBlobPresence(), 
        content = engine.getScreenshot(), saveAs(Utils.base64ToBlob(content), fileName);
    }, Utils._ensureBlobPresence = function() {
        try {
            return !!new Blob();
        } catch (error) {
            throw error, "FileSaver not supported";
        }
    }, Utils.base64ToBlob = function(b64Data, contentType, sliceSize) {
        var byteArray, byteArrays, byteCharacters, byteNumbers, i, offset, slice;
        for (contentType = contentType || "", sliceSize = sliceSize || 512, byteCharacters = atob(b64Data), 
        byteArrays = [], offset = 0; offset < byteCharacters.length; ) {
            for (slice = byteCharacters.slice(offset, offset + sliceSize), byteNumbers = new Array(slice.length), 
            i = 0; i < slice.length; ) byteNumbers[i] = slice.charCodeAt(i), i++;
            byteArray = new Uint8Array(byteNumbers), byteArrays.push(byteArray), offset += sliceSize;
        }
        return new Blob(byteArrays, {
            type: contentType
        });
    }, Utils.addCEButton = function(options) {
        var img, posArray;
        if (null == options && (options = {}), null == options.size && (options.size = "32px"), 
        null == options.padding && (options.padding = "32px"), null == options.position && (options.position = "bottom-right"), 
        null == options.type && (options.type = "fullscreen"), options.size.endsWith("px") || (options.size = options.size + "px"), 
        options.padding.endsWith("px") || (options.padding = options.padding + "px"), !Utils.CE_BUTTON_TYPES.includes(options.type)) throw new Error("invalid type " + options.type);
        if (!document.querySelector(".ce-button-" + options.type)) {
            if (!Utils.CE_BUTTON_POSITIONS.includes(options.position)) throw new Error("invalid position " + options.position);
            return posArray = options.position.split("-"), img = document.createElement("img"), 
            img.style = "position: absolute; width: " + options.size + "; height: " + options.size + ";" + posArray[0] + ": " + options.padding + "; " + posArray[1] + ": " + options.padding, 
            img.setAttribute("class", "ce-button-" + options.type), "fullscreen" === options.type ? (img.setAttribute("onclick", "Utils.toggleFullscreen()"), 
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AYMDR07WbntUQAAAMZJREFUWMPtl7ENgzAQRR+IkhFYIdUVUTKP9wjswSCZIBHFVVmBEVKbNBTIMsFBcpLiXnlC9ke+7/suRGQinU5V23cfiEgLXFIXLPkxJqCK1J7AY0XcmLDmCAyRugcOQL0sFpEmvKvqOcffisgNOG0dQfnNI7cmNAEV0O2w2l564IphGEYwjsOMN6pqn2kcO6AJb8IwQA7zjZUDBxxtGJmALQE+434+ZsPpg1jeb1l0tppLjeWxd0EdRucFKWGiCa1mTfjXAl7JzisvsBIkfgAAAABJRU5ErkJggg==") : "reinit" === options.type && (img.setAttribute("onclick", 'Hodler.item("engine").initScene(SceneManager.currentScene())'), 
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfgBgwNMCmKKsb2AAACbklEQVRIx5XVz2tcVRQH8M971dZ01GppNWbhSHFjdJXTookiCOpGChKKVv8E68Yfiy6sol0J1l3ddCmIOxfBleBCyISqZ1BoxIUUuxCNJdVYiaEQdDF3zEzn1XG+m8u795zvvfec+77fSkHI3njEvCMeczQvGEI/YhiVnbR5C+7tL2Q1GhxP5WfX09wU73peeyT2e034MLY858tBktrbWv4eCV1pJLim7Xy8l2KAYFPb+ghFZ66JoAavxec7FHWyqe3X60/QbSJ4v4xPxHKfol/EM14djGwqIcQhF0yBM/l6IQjC18MlzAduQMBt1grFI86nmmSprP9UatFcQiRXzZaPjxN1iGfdA067v5SzuYSFIn90EtwXx0JFfOUwtnIq2OuSAx7KVf+J+FMLK7lQR8th8BalI5vj0nEazMettWfK1Llyx83tO43HuTI+WXsYXM7f+nf85tr4/Lzid/B4Xf6Db02KXuNnanfAyEscj3VwoC5vsZqYYBvsql0FBycmuAts1H4AcxMT9DIu1kUb9kd7kuxo299rR+3TMvfCRPv3o5cqIs3hr9w7wQk2TaGbsSvYcAw3z2z//MX/TH/D0+CVmdUK4hd3gwd9l+OSmdX7V9Zymppgsax2tWJcektf7RajJ5MpO86C3db/lYtmzFq3G3yQnezrbMiXLaOyx2qcuuH+p6zao0InTwyLqhTLFkrklnd8lJeG+v6iN93SF/18tG8u1aDzxVkvDWx4RddlHDRXno1y+BM73lQNm2fM+6R0pBlrFrMzbG2DistKTjuu0VV0Hc9pHUP22uTBUtzuqHDIPmy4KC3lH00G/w/Uq7TDOW+poQAAAABJRU5ErkJggg=="), 
            null != options.src && (img.src = options.src), document.body.appendChild(img);
        }
    }, Utils.isMobile = function() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }, Utils.orientation = function(orientation) {
        var a1, a2, baseStyle, div, existingElement, existingStyle, img, style;
        if (null == orientation && (orientation = "all"), existingElement = document.querySelector(".ce-turn-screen"), 
        null != existingElement && document.body.removeChild(existingElement), existingStyle = document.querySelector(".ce-turn-screen-style"), 
        null != existingStyle && document.head.removeChild(existingStyle), "all" !== orientation) {
            if (!Utils.ORIENTATIONS.includes(orientation)) throw new Error("invalid orientation type '" + orientation + "'");
            return div = document.createElement("div"), div.setAttribute("class", "ce-turn-screen"), 
            div.style = "position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #f0f0f0; z-index: " + Utils.CE_UI_Z_INDEX + ";", 
            img = document.createElement("img"), img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AYNDy012n9FrgAABkxJREFUeNrt3T1sG+cBgGGTRx3FH5GipADhjyGAg5EgaBa1BWog7dIgY5DFXQLEBRJ4yFI0S7aqyOAtS1B3bBEgWYIMLYJ0MZKxk7yoSzoYgmFRaAtRKgmSIU++6xKgi4eTJYo0+TzzR+l0pxffd+Tx7to1AAAAAAAAAOD/MnbB07Xb7d2HDx/uTvN37OzsJPb0bOzt7aX638/aVU9Xq9V+1263d+2J5SYQkSAQkSAQkSAQkSAQkSAQkSAQkSAQkbCocsv2BzcajReDIHg1CIJXgiBo53K57SAI6kEQbGaz2Vo2m13NZDLhOSK5Nu1P3NN+6svlX52w8IE0m80bKysrb4Rh+Nrq6urNlZWV5hRmkqlHghnk0rRarZ/m8/lbxWLxrTAM21e03BKJQOZ66fRCPp+/XSqV3s3n8zdmdE4iEoHM3RLq5UKh8MHa2trb2Ww2Pwcn7iIRyFyE8VKpVNotl8u3MpmMk1gE8sNSaqtYLH5UqVTey2QywTxt28nJye/NHgKZiXq9ngnD8M76+vrdXC63Pm/bJw6BzHI51a5UKn8qFos/n8ftE4dAZmZ7e/udWq32SRAEa1f1O5MkeZJ2+SYOgcxqSbVaKpXuVavVX1/2zz47OzudTCb7URTtR1G0H8fxQRzHnSRJ/pUkSffo6ChK84msOAQyqyVVo1qt/qVQKPz4Mn5eHMfj4XD4zXg8vh9F0f04jvePjo4udEmCOAQyqzh+tLGx8XUYhq0LLpOS4XD47Wg0+iyKoi87nc5/nXPwXAfSarVubm1tfR0EQfUCs8X3/X7/09Fo9PHh4eF3TshZiECuX7/+i83Nza+CICg/YxiTXq93bzQa3e10Ov+exjaKQyCzmjl+dpE4+v3+F4PB4MPDw8OH09pGcQhkZuccW1tbf3uWOKIo6pyent559OjRV9PcRnEIZFZxNDY2Np7pnKPX630+GAze73Q6p+Jg4QKp1+ur1Wr1r+d9typJkqjb7f7m4ODg3rS3URzMLJByufzHQqGwc57XnJ2d/ef4+PjNx48f/10cLGwg29vb71Qqldvnec1kMnnU7XZfPzw8/OdVbKM4mEkgzWazXavVPjnPa8bj8XfdbveXnU7nsUPGVbrS2/7U6/VMpVL583kuPPxh5hAHix9IGIZ3isXia+c55+h2u6+Lg4UPpNFobK2vr99NOz6O48nx8fGbV3XOATMNpFgsfnSebwKenJz89irerYKZB9JsNl+qVCrvpR3f6/U+Pzg4+IPDw1IEUiqVdtN+Qy+Kos5gMHjfoWEpAmk2my+Xy+Vbacefnp7emfblIzA3gRQKhQ/S3req3+9/Me0LD2FuAmk0Gi+sra29nWZsHMeTwWDwoUPC0gSSz+dvp70daK/XuzfN73PA3AVSKpXeTTl7fD8aje46HCxNIK1W6ydp77Le7/c/ndbXZGEuA8nn879KMy5JkmQ0Gn3sULBUgRSLxbfSjBsOh99O4+4jMLeBNJvNG2mf7DQajT5zGFiqQFZWVt5IeXI+jqLoS4eBpQokDMNUl7QPh8NvLvOOh/BcBLK6unozzbjxeHzfIWCpAmk0Gi+mfdRyFEUCYbkCCYLg1TTjzs7OTuM43ncIWLZAXkkzbjKZXPgRBPA8BpLq7d0oisweLF8guVxuO+US6x92P8s4g9TTjHvy5MmB3c8yBrKZZlySJB27n6ULJJvN1tKMi+PY1bssZSCrKWcQ3ztn+QLJZDJhmnFHR0cju595d+k3r37w4EFgt2IGAYGAQACBgEBAICAQEAgIBAQCAgGBAAIBgYBAQCAgEBAICAQEAgIBgQACAYHA5Ul947idnR0Pu5mR53Hf7+3tZcwgYIkFAgEEAgIBgYBAQCAgEHguXfoj2BblE1SebtmuqDCDgEBAICAQEAgIBAQCAgGBgEAAgYBAQCAgEBAICAQEAgIBgYBAAIGAQEAgIBAQCAgEBAICAYEAAgGBgEBAICAQmDc5u4BpWJRHtZlBQCAgEBAICAQEAgIBgYBAYAn5JJ2p2Nvby5hBwBILBAIIBAQCAgGBgEBAICAQEAgIBBAICAQEAgIBgYBAQCAgEBAICAQQCAgEBAICAYGAQEAgsFAu/e7ui/J8bDCDgEBAICAQEAgIBAQCAgGBAAAAAAAAAADAtf8BFNg15uCjV1oAAAAASUVORK5CYII=", 
            baseStyle = "position: absolute; margin: auto; top: 0; left: 0; right: 0; bottom: 0;", 
            "landscape" === orientation ? (img.style = baseStyle + "transform: rotate(90deg);", 
            a1 = "canvas#coffee-engine-dom", a2 = ".ce-turn-screen") : (img.style = baseStyle, 
            a1 = ".ce-turn-screen", a2 = "canvas#coffee-engine-dom"), style = document.createElement("style"), 
            style.setAttribute("class", "ce-turn-screen-style"), style.setAttribute("type", "text/css"), 
            style.setAttribute("media", "all"), style.innerHTML = "@media all and (orientation:portrait) { " + a1 + " { display: none; } } @media all and (orientation:landscape) { " + a2 + " { display: none; } }", 
            document.head.appendChild(style), div.appendChild(img), document.body.appendChild(div);
        }
    }, Utils.overrideConsole = function() {
        return window._log = console.log, window._warn = console.warn, window._info = console.info, 
        window._error = console.error, window._ceOutput = "coffee-engine console >", console.log = function(message) {
            var html;
            window._ceOutput += "\n" + message, html = document.querySelector(".ce-console-text"), 
            null != html && (html.innerHTML = window._ceOutput, html.scrollTop = html.scrollHeight), 
            window._log.apply(console, arguments);
        }, console.info = function(message) {
            var html;
            window._ceOutput += "\n" + message, html = document.querySelector(".ce-console-text"), 
            null != html && (html.innerHTML = window._ceOutput, html.scrollTop = html.scrollHeight), 
            window._info.apply(console, arguments);
        }, console.warn = function(message) {
            var html;
            window._ceOutput += "\n" + message, html = document.querySelector(".ce-console-text"), 
            null != html && (html.innerHTML = window._ceOutput, html.scrollTop = html.scrollHeight), 
            window._warn.apply(console, arguments);
        }, console.error = function(message) {
            var html;
            window._ceOutput += "\n" + message, html = document.querySelector(".ce-console-text"), 
            null != html && (html.innerHTML = window._ceOutput, html.scrollTop = html.scrollHeight), 
            window._error.apply(console, arguments);
        };
    }, Utils.console = function() {
        var div, divText, existingElement, existingStyle, style;
        return null == window._ceOutput && this.overrideConsole(), existingElement = document.querySelector(".ce-console"), 
        null != existingElement ? (document.body.removeChild(existingElement), existingStyle = document.head.querySelector(".ce-console-style"), 
        null != existingStyle && document.head.removeChild(existingStyle), !1) : (div = document.createElement("div"), 
        div.setAttribute("class", "ce-console"), divText = document.createElement("div"), 
        divText.setAttribute("class", "ce-console-text"), "undefined" != typeof _ceOutput && null !== _ceOutput && (divText.innerHTML = _ceOutput), 
        style = document.createElement("style"), style.setAttribute("class", "ce-console-style"), 
        style.setAttribute("type", "text/css"), style.setAttribute("media", "all"), style.innerHTML = ".ce-console { position: absolute; top: 0px; left: 0px; width: 100%; z-index: 3; background-color: gray; } .ce-console-text { height: 120px; padding: 5px; overflow-y: scroll; white-space: pre; color: black; }", 
        document.head.appendChild(style), div.appendChild(divText), document.body.appendChild(div), 
        !0);
    }, Utils.fade = function(options) {
        var animationEvent, div, existingElement, existingStyle, pointerEvents, style;
        return null == options && (options = {}), null == options.duration && (options.duration = Utils.FADE_DEFAULT_DURATION), 
        options.duration = options.duration / 1e3, null == options.type && (options.type = "in"), 
        "in" === options.type ? (options.opacityFrom = 0, options.opacityTo = 1) : (options.opacityFrom = 1, 
        options.opacityTo = 0), null == options.clickThrough && (options.clickThrough = !0), 
        existingElement = document.querySelector(".ce-fader"), null != existingElement && (document.body.removeChild(existingElement), 
        null != (existingStyle = document.head.querySelector(".ce-fader-style")) && document.head.removeChild(existingStyle)), 
        div = document.createElement("div"), div.setAttribute("class", "ce-fader"), options.clickThrough && (pointerEvents = "  pointer-events: none;"), 
        style = document.createElement("style"), style.setAttribute("class", "ce-fader-style"), 
        style.setAttribute("type", "text/css"), style.setAttribute("media", "all"), style.innerHTML = ".ce-fader { position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-color: " + Utils.FADE_COLOR + "; z-index: " + (Utils.CE_UI_Z_INDEX - 1) + "; " + pointerEvents + " -webkit-animation: fade-animation " + options.duration + "s; /* Safari, Chrome and Opera > 12.1 */ -moz-animation: fade-animation " + options.duration + "s; /* Firefox < 16 */ -ms-animation: fade-animation " + options.duration + "s; /* Internet Explorer */ -o-animation: fade-animation " + options.duration + "s; /* Opera < 12.1 */ animation: fade-animation " + options.duration + "s; } @keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } } /* Firefox < 16 */ @-moz-keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } } /* Safari, Chrome and Opera > 12.1 */ @-webkit-keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } } /* Internet Explorer */ @-ms-keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } } /* Opera < 12.1 */ @-o-keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } }", 
        document.head.appendChild(style), document.body.appendChild(div), 0 === options.opacityTo && (animationEvent = whichAnimationEvent()) && div.addEventListener(animationEvent, function() {
            document.body.removeChild(div), document.head.removeChild(style);
        }), !0;
    }, Utils;
}(), exports.Utils = Utils;

var VideoRecorderManager;

VideoRecorderManager = function() {
    function VideoRecorderManager() {}
    var instance;
    return instance = null, Singleton.VideoRecorderManager = function() {
        function VideoRecorderManager() {
            this.recording = !1;
        }
        return VideoRecorderManager.prototype.capture = function(domElement) {
            if (!1 !== this.recording) return this.recorder.capture(domElement);
        }, VideoRecorderManager.prototype.start = function() {
            return null == this.recorder && (this.recorder = new CCapture(Config.get().recorder)), 
            this.recorder.start(), this.recording = !0;
        }, VideoRecorderManager.prototype.stop = function() {
            return this.recorder.stop(), this.recording = !1;
        }, VideoRecorderManager.prototype.save = function() {
            return this.recorder.save();
        }, VideoRecorderManager;
    }(), VideoRecorderManager.get = function() {
        return null != instance ? instance : instance = new Singleton.VideoRecorderManager();
    }, VideoRecorderManager.start = function() {
        return this.get().start();
    }, VideoRecorderManager.stop = function() {
        return this.get().stop();
    }, VideoRecorderManager.save = function() {
        return this.get().save();
    }, VideoRecorderManager.capture = function(domElement) {
        return this.get().capture(domElement);
    }, VideoRecorderManager;
}();

var VirtualController;

VirtualController = function() {
    function VirtualController(options) {
        null == options && (options = {}), this.init(options);
    }
    return VirtualController.prototype.init = function(options) {
        return options = this._defaultOptions(options), this.joystick1 = new VirtualJoystick(options.joystick1), 
        this.joystick1.addEventListener("touchStartValidation", this._leftHalfTouch), this.joystick2 = new VirtualJoystick(options.joystick2), 
        this.joystick2.addEventListener("touchStartValidation", this._rightHalfTouch);
    }, VirtualController.prototype.isAvailable = function() {
        return VirtualJoystick.touchScreenAvailable();
    }, VirtualController.prototype._leftHalfTouch = function(event) {
        var touch;
        return touch = event.changedTouches[0], touch.pageX < window.innerWidth / 2;
    }, VirtualController.prototype._rightHalfTouch = function(event) {
        var touch;
        return touch = event.changedTouches[0], touch.pageX >= window.innerWidth / 2;
    }, VirtualController.prototype._defaultOptions = function(options) {
        var base, base1, base2, base3, base4, base5, base6;
        return null == options.joystick1 && (options.joystick1 = {}), null == (base = options.joystick1).strokeStyle && (base.strokeStyle = "cyan"), 
        null == (base1 = options.joystick1).limitStickTravel && (base1.limitStickTravel = !0), 
        null == (base2 = options.joystick1).mouseSupport && (base2.mouseSupport = !0), null == (base3 = options.joystick1).stickRadius && (base3.stickRadius = 60), 
        null == options.joystick2 && (options.joystick2 = {}), null == (base4 = options.joystick2).strokeStyle && (base4.strokeStyle = "orange"), 
        null == (base5 = options.joystick2).limitStickTravel && (base5.limitStickTravel = !0), 
        null == (base6 = options.joystick2).stickRadius && (base6.stickRadius = 0), options;
    }, VirtualController;
}();

var JsonModelManager;

JsonModelManager = function() {
    function JsonModelManager() {}
    var instance;
    return instance = null, Singleton.JsonModelManager = function() {
        function JsonModelManager() {}
        return JsonModelManager.prototype.baseUrl = "", JsonModelManager.prototype.loader = new THREE.JSONLoader(), 
        JsonModelManager.prototype.items = {}, JsonModelManager.prototype.loadCount = 0, 
        JsonModelManager.prototype.load = function(key, url, callback) {
            if (null == callback && (callback = function() {
                return {};
            }), void 0 === this.items[key]) return this.items[key] = null, this.loader.load("" + this.baseUrl + url, function(geometry, materials) {
                var i, jmm, len, mat, mesh;
                for (jmm = window.JsonModelManager.get(), mesh = new THREE.SkinnedMesh(geometry, materials), 
                i = 0, len = materials.length; i < len; i++) mat = materials[i], mat.skinning = !0;
                if (null != mesh.animations) throw "mesh already has animations. not overwriting default behaviour";
                return mesh = jmm.initAnimations(mesh), jmm.items[key] = mesh, jmm.loadCount += 1, 
                callback(mesh), this;
            });
        }, JsonModelManager.prototype.initAnimations = function(mesh) {
            var anim, animation, i, len, ref;
            if (null == mesh) throw new Error("missing param mesh");
            if (mesh.animations = [], mesh.animationsMixer = new THREE.AnimationMixer(mesh), 
            null != mesh.geometry.animations) for (ref = mesh.geometry.animations, i = 0, len = ref.length; i < len; i++) anim = ref[i], 
            animation = mesh.animationsMixer.clipAction(anim), animation.setEffectiveWeight(1), 
            mesh.animations.push(animation);
            return mesh;
        }, JsonModelManager.prototype.clone = function(key) {
            var mesh;
            if (null == this.items[key]) throw new Error("key '" + key + "' not found for JsonModelManager");
            return mesh = this._hack(this.items[key].clone()), this.initAnimations(mesh);
        }, JsonModelManager.prototype._hack = function(mesh) {
            var clone, i, len, mat, materials, ref;
            for (materials = [], ref = mesh.material, i = 0, len = ref.length; i < len; i++) mat = ref[i], 
            clone = mat.clone(), null != clone.map && (clone.map = clone.map.clone(), clone.map.needsUpdate = !0), 
            materials.push(clone);
            return mesh.material = materials, mesh;
        }, JsonModelManager.prototype.hasFinishedLoading = function() {
            return this.loadCount === Object.keys(this.items).size();
        }, JsonModelManager;
    }(), JsonModelManager.get = function() {
        return null != instance ? instance : instance = new Singleton.JsonModelManager();
    }, JsonModelManager.clone = function(key) {
        return this.get().clone(key);
    }, JsonModelManager.load = function(key, url, callback) {
        return this.get().load(key, url, callback);
    }, JsonModelManager.initAnimations = function(mesh) {
        return this.get().initAnimations(mesh);
    }, JsonModelManager;
}(), exports.JsonModelManager = JsonModelManager;

var TextureManager;

TextureManager = function() {
    function TextureManager() {}
    var instance;
    return instance = null, Singleton.TextureManager = function() {
        function TextureManager() {}
        return TextureManager.prototype.items = {}, TextureManager.prototype.loadCount = 0, 
        TextureManager.prototype.load = function(key, url, callback) {
            var loader;
            if (null == callback && (callback = function() {
                return {};
            }), void 0 === this.items[key]) return this.items[key] = null, loader = new THREE.TextureLoader(), 
            loader.load(url, function(image) {
                return setTimeout(function() {
                    return window.TextureManager.get()._load(image, key, callback);
                }, 100);
            }, void 0, function(err) {
                return console.log(err);
            }), this;
        }, TextureManager.prototype.hasFinishedLoading = function() {
            return this.loadCount === Object.keys(this.items).size();
        }, TextureManager.prototype._load = function(image, key, callback) {
            return window.TextureManager.get().items[key] = image, window.TextureManager.get().loadCount += 1, 
            callback(key);
        }, TextureManager.prototype.item = function(key) {
            if (null == this.items[key]) throw new Error(key + " not found in TextureManager");
            return this.items[key];
        }, TextureManager;
    }(), TextureManager.get = function() {
        return null != instance ? instance : instance = new Singleton.TextureManager();
    }, TextureManager.load = function(key, url, callback) {
        return this.get().load(key, url, callback);
    }, TextureManager.item = function(key) {
        return this.get().item(key);
    }, TextureManager.hasFinishedLoading = function() {
        return this.get().hasFinishedLoading();
    }, TextureManager;
}();

var MaterialManager;

MaterialManager = function() {
    function MaterialManager() {}
    var instance;
    return instance = null, Singleton.MaterialManager = function() {
        function MaterialManager() {}
        return MaterialManager.prototype.items = {}, MaterialManager.prototype.load = function(key, material) {
            return this.items[key] = material, this;
        }, MaterialManager.prototype.item = function(key) {
            if (null == this.items[key]) throw new Error(key + " not found in MaterialManager");
            return this.items[key];
        }, MaterialManager;
    }(), MaterialManager.get = function() {
        return null != instance ? instance : instance = new Singleton.MaterialManager();
    }, MaterialManager.load = function(key, material) {
        return this.get().load(key, material);
    }, MaterialManager.item = function(key) {
        return this.get().item(key);
    }, MaterialManager;
}();

var BaseScene;

BaseScene = function() {
    function BaseScene() {
        this.scene = new THREE.Scene(), this.jmm = JsonModelManager.get(), this.sm = SoundManager.get(), 
        this.config = Config.get(), this.som = SaveObjectManager.get(), this.tm = TextureManager.get(), 
        this.lastMousePosition = void 0, this.keyboard = new THREEx.KeyboardState(), this.loaded = !1, 
        this.uptime = 0;
    }
    return BaseScene.prototype.fullTick = function(tpf) {
        return this.uptime += tpf, this.scene.traverse(function(obj) {
            if (null != obj.animationsMixer) return obj.animationsMixer.update(tpf);
        }), this.tick(tpf);
    }, BaseScene.prototype.init = function(options) {
        throw "scene.init not implemented";
    }, BaseScene.prototype.uninit = function() {
        return this.clear();
    }, BaseScene.prototype.clear = function() {
        var child, children, i;
        for (children = this.scene.children, i = this.scene.children.length - 1; i >= 0; ) child = children[i], 
        child.clear(), this.scene.remove(child), i--;
    }, BaseScene.prototype.tick = function(tpf) {
        throw "scene.tick not implemented";
    }, BaseScene.prototype.doMouseEvent = function(event, raycaster) {
        throw "scene.doMouseEvent not implemented";
    }, BaseScene.prototype.doKeyboardEvent = function(event) {
        throw "scene.doKeyboardEvent not implemented";
    }, BaseScene.prototype.tweenLookAt = function(object, camera, duration, easing) {
        var endRotation, startRotation;
        return null == duration && (duration = 1e3), null == easing && (easing = TWEEN.Easing.Cubic.InOut), 
        startRotation = camera.rotation.clone(), camera.lookAt(object.position), endRotation = camera.rotation.clone(), 
        camera.rotation.set(startRotation.x, startRotation.y, startRotation.z), new TWEEN.Tween(startRotation).to(endRotation, duration).onUpdate(function() {
            camera.rotation.set(this.x, this.y, this.z);
        }).easing(easing).start();
    }, BaseScene.prototype.tweenMoveTo = function(object, camera, duration, easing) {
        var endPosition;
        return null == duration && (duration = 1e3), null == easing && (easing = TWEEN.Easing.Cubic.InOut), 
        camera.position.clone(), endPosition = object.position.clone(), new TWEEN.Tween(camera.position).to(endPosition, duration).onUpdate(function() {
            camera.position.set(this.x, this.y, this.z);
        }).easing(easing).start();
    }, BaseScene;
}();

var BaseModel;

BaseModel = function() {
    function BaseModel() {
        this.visible = !1, this.mesh = void 0;
    }
    return BaseModel.prototype.setScale = function(i) {
        return this.mesh.scale.set(i, i, i);
    }, BaseModel.prototype.setOpacity = function(opacity) {
        var j, len, mat, ref, results;
        if (Array.isArray(this.mesh.material)) {
            for (ref = this.mesh.material, results = [], j = 0, len = ref.length; j < len; j++) mat = ref[j], 
            mat.transparent = !0, results.push(mat.opacity = opacity);
            return results;
        }
        return this.mesh.material.opacity = opacity;
    }, BaseModel.prototype.getOpacity = function() {
        return this.mesh.material.opacity;
    }, BaseModel.prototype.setPosition = function(pos) {
        return this.mesh.position.set(pos.x, pos.y, pos.z);
    }, BaseModel.prototype.setVisible = function(value) {
        return this.mesh.traverse(function(object) {
            return object.visible = value;
        }), this.visible = value;
    }, BaseModel.prototype.isVisible = function() {
        return this.visible;
    }, BaseModel.prototype.attachToBone = function(boneName, mesh) {
        var added;
        if (added = !1, this.mesh instanceof THREE.SkinnedMesh) return this.mesh.traverse(function(object) {
            if (!added) return object instanceof THREE.Bone && object.name === boneName ? (added = !0, 
            object.add(mesh)) : void 0;
        });
    }, BaseModel.prototype.detachFromBone = function(boneName, mesh) {
        if (this.mesh instanceof THREE.SkinnedMesh) return this.mesh.traverse(function(object) {
            if (object instanceof THREE.Bone && object.name === boneName) return object.remove(mesh);
        });
    }, BaseModel.prototype.setSkin = function(key) {
        var tex;
        if (null == (tex = TextureManager.get().items[key])) throw new Error("texture not loaded");
        return this.mesh.material.materials[0].map = tex;
    }, BaseModel.prototype.toggleWireframe = function() {
        var j, k, len, len1, material, mesh, ref, ref1, results;
        if (null != this.mesh) {
            if (null != this.mesh.material) {
                if (this.mesh.material.wireframe = !this.mesh.material.wireframe, null != this.mesh.material.materials) for (ref = this.mesh.material.materials, 
                j = 0, len = ref.length; j < len; j++) material = ref[j], material.wireframe = !material.wireframe;
                return this.mesh.material.wireframe;
            }
            if (null != this.mesh.children) {
                for (ref1 = this.mesh.children, results = [], k = 0, len1 = ref1.length; k < len1; k++) mesh = ref1[k], 
                null != mesh.material && results.push(mesh.material.wireframe = !mesh.material.wireframe);
                return results;
            }
        }
    }, BaseModel.prototype.isHovered = function(raycaster) {
        return raycaster.intersectObject(this.mesh, !0).length > 0;
    }, BaseModel.prototype.animate = function(animationName, options) {
        var anim;
        return null == options && (options = {}), null == options.loop && (options.loop = !0), 
        null == options.reverse && (options.reverse = !1), null == options.timeScale && (options.timeScale = 1), 
        null == options.name && (options.name = animationName), options.reverse && (options.timeScale *= -1), 
        anim = this.animation(options.name), anim.setEffectiveTimeScale(options.timeScale), 
        options.loop ? (anim.clampWhenFinished = !1, anim.setLoop(THREE.LoopRepeat)) : options.reverse || (anim.clampWhenFinished = !0, 
        anim.setLoop(THREE.LoopOnce, 0)), this.stopAnimations(), anim.play(), options.reverse && !1 === options.loop && setTimeout(function() {
            return anim.stop();
        }, 1e3 * anim._clip.duration), anim;
    }, BaseModel.prototype.updateAnimations = function(tpf) {
        if (null != this.mesh.animationsMixer) return this.mesh.animationsMixer.update(tpf);
    }, BaseModel.prototype.stopAnimations = function() {
        var animation, j, len, ref, results;
        for (ref = this.mesh.animations, results = [], j = 0, len = ref.length; j < len; j++) animation = ref[j], 
        animation.isRunning() ? results.push(animation.stop()) : results.push(void 0);
        return results;
    }, BaseModel.prototype.isPlaying = function(animationName) {
        return this.animation(animationName).isRunning();
    }, BaseModel.prototype.animation = function(animationName) {
        var allAnimations, animation, animationIndex, j, len, ref;
        if (!(this.mesh instanceof THREE.SkinnedMesh)) throw "@mesh is not a THREE.SkinnedMesh";
        if (isNumeric(animationName)) {
            if ((animationIndex = parseInt(animationName)) >= this.mesh.animations.size()) throw "Animation index " + animationIndex + " out of bounds";
            return this.mesh.animations[animationIndex];
        }
        for (ref = this.mesh.animations, j = 0, len = ref.length; j < len; j++) if (animation = ref[j], 
        animation._clip.name === animationName) return animation;
        throw allAnimations = this.mesh.animations.map(function(a) {
            return a.data.name;
        }), animationName + " not found. Possible animations are: " + allAnimations;
    }, BaseModel.prototype.duration = function(animationName) {
        return 1e3 * this.animation(animationName)._clip.duration;
    }, BaseModel.prototype.moveToBody = function(transformAux) {
        var ms, p, q;
        if (ms = this.body.getMotionState()) return ms.getWorldTransform(transformAux), 
        p = transformAux.getOrigin(), q = transformAux.getRotation(), this.mesh.position.set(p.x(), p.y(), p.z()), 
        this.mesh.quaternion.set(q.x(), q.y(), q.z(), q.w());
    }, BaseModel;
}();

var BaseControls;

BaseControls = function() {
    function BaseControls(jsonModel, keyboard) {
        this.enabled = !0, this.jsonModel = jsonModel, this.keyboard = keyboard, this.lock = !1, 
        this.moving = !1;
    }
    return BaseControls.KEY_BINDINGS = {
        UP: "w",
        DOWN: [ "s" ],
        LEFT: "a",
        RIGHT: "d"
    }, BaseControls.prototype.toggleLock = function(target) {
        if (this.enabled) return this.lock = !this.lock, this.lock ? this.target = target : this.target = void 0;
    }, BaseControls.prototype.isPressed = function(bindings) {
        var binding, i, len;
        for (bindings instanceof Array || (bindings = [ bindings ]), i = 0, len = bindings.length; i < len; i++) if (binding = bindings[i], 
        this.keyboard.pressed(binding)) return !0;
        return !1;
    }, BaseControls.prototype.formatOutput = function() {
        return {
            moving: this.moving,
            lock: this.lock
        };
    }, BaseControls.prototype.withLock = function(tpf) {
        if (null != this.target) return this.jsonModel.model.lookAt(this.target.model.position), 
        this.isPressed(BaseControls.KEY_BINDINGS.UP) ? (this.jsonModel.model.translateZ(tpf), 
        this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.DOWN) ? (this.jsonModel.model.translateZ(-tpf), 
        this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.LEFT) ? (this.jsonModel.model.translateX(tpf), 
        this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.RIGHT) ? (this.jsonModel.model.translateX(-tpf), 
        this.moving = !0) : this.moving = !1, this.formatOutput();
    }, BaseControls.prototype.noLock = function(tpf) {
        return this.isPressed(BaseControls.KEY_BINDINGS.UP) ? (this.jsonModel.model.rotation.set(0, Math.PI, 0), 
        this.jsonModel.model.translateZ(tpf), this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.DOWN) ? (this.jsonModel.model.rotation.set(0, 0, 0), 
        this.jsonModel.model.translateZ(tpf), this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.LEFT) ? (this.jsonModel.model.rotation.set(0, -Math.PI / 2, 0), 
        this.jsonModel.model.translateZ(tpf), this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.RIGHT) ? (this.jsonModel.model.rotation.set(0, Math.PI / 2, 0), 
        this.jsonModel.model.translateZ(tpf), this.moving = !0) : this.moving = !1, this.formatOutput();
    }, BaseControls.prototype.tick = function(tpf) {
        var output;
        if (this.enabled) return output = this.lock ? this.withLock(tpf) : this.noLock(tpf), 
        this.jsonModel instanceof BaseModel && (this.moving ? this.jsonModel.isPlaying("walk") || (this.jsonModel.stopAnimations(), 
        this.jsonModel.animate("walk")) : this.jsonModel.isPlaying("idle") || (this.jsonModel.stopAnimations(), 
        this.jsonModel.animate("idle"))), output;
    }, BaseControls.prototype.doKeyboardEvent = function(event) {}, BaseControls.prototype.doMouseEvent = function(event, raycaster) {}, 
    BaseControls;
}();

var BaseParticle, BaseParticle2, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

BaseParticle = function(superClass) {
    function BaseParticle(texturePath) {
        var base, i, json, key, len, ref;
        if (json = {}, "string" == typeof texturePath) json = {
            group: {
                texture: THREE.ImageUtils.loadTexture(texturePath)
            }
        }; else {
            if (json = texturePath, null == json.group && (json.group = {}), null == (base = json.group).asset && (base.asset = {}), 
            null == json.group.asset.libPath) throw new Error("json.group.asset.libPath is required");
            key = Utils.getKeyName(json.group.asset.libPath, Utils.IMG_URLS), json.group.texture = TextureManager.get().items[key];
        }
        json = this.formatDefaults(json), this.particleGroup = new SPE.Group(json.group);
        for (key in json.emitter) if ("object" == typeof json.emitter[key]) {
            if (null == json.emitter[key]) continue;
            null != json.emitter[key].x && (json.emitter[key] = Helper.toVector3(json.emitter[key]));
        }
        for (ref = [ "colorStart", "colorMiddle", "colorEnd" ], i = 0, len = ref.length; i < len; i++) key = ref[i], 
        null != json.emitter[key] && (json.emitter[key] = new THREE.Color(json.emitter[key]));
        this.emitter = new SPE.Emitter(json.emitter), this.particleGroup.addEmitter(this.emitter), 
        this.mesh = this.particleGroup.mesh;
    }
    return extend(BaseParticle, superClass), BaseParticle.prototype.formatDefaults = function(json) {
        var attr, base, base1, base10, base11, base12, base13, base14, base15, base16, base17, base18, base19, base2, base20, base21, base22, base23, base24, base25, base26, base27, base28, base29, base3, base30, base31, base32, base33, base34, base35, base36, base37, base38, base39, base4, base40, base41, base42, base43, base44, base45, base46, base47, base48, base49, base5, base50, base51, base52, base53, base54, base55, base56, base57, base58, base6, base7, base8, base9, coord, i, j, len, len1, ref, ref1;
        for (null == json && (json = {}), null == json.group && (json.group = {}), null == (base = json.group).maxParticleCount && (base.maxParticleCount = 100), 
        null == (base1 = json.group).maxAge && (base1.maxAge = 3), null == (base2 = json.group).hasPerspective && (base2.hasPerspective = !0), 
        null == (base3 = json.group).colorize && (base3.colorize = !0), null == (base4 = json.group).blending && (base4.blending = 2), 
        null == (base5 = json.group).transparent && (base5.transparent = !0), null == (base6 = json.group).alphaTest && (base6.alphaTest = .5), 
        null == (base7 = json.group).depthWrite && (base7.depthWrite = !1), null == (base8 = json.group).depthTest && (base8.depthTest = !0), 
        null != json.group.fixedTimeStep && null == (base9 = json.group).fixedTimeStep && (base9.fixedTimeStep = .016), 
        null == (base10 = json.group).fog && (base10.fog = !0), null == json.emitter && (json.emitter = {}), 
        null == (base11 = json.emitter).type && (base11.type = "cube"), ref = [ "position", "positionSpread", "acceleration", "accelerationSpread", "velocity", "velocitySpread" ], 
        i = 0, len = ref.length; i < len; i++) for (attr = ref[i], null == (base12 = json.emitter)[attr] && (base12[attr] = {}), 
        ref1 = [ "x", "y", "z" ], j = 0, len1 = ref1.length; j < len1; j++) coord = ref1[j], 
        null == (base13 = json.emitter[attr])[coord] && (base13[coord] = 0);
        return null == (base14 = json.emitter).radius && (base14.radius = 10), null == (base15 = json.emitter).radiusScale && (base15.radiusScale = {}), 
        null == (base16 = json.emitter.radiusScale).x && (base16.x = 1), null == (base17 = json.emitter.radiusScale).y && (base17.y = 1), 
        null == (base18 = json.emitter.radiusScale).z && (base18.z = 1), null == (base19 = json.emitter).speed && (base19.speed = 0), 
        null == (base20 = json.emitter).speedSpread && (base20.speedSpread = 0), null == (base21 = json.emitter).sizeStart && (base21.sizeStart = 10), 
        null == (base22 = json.emitter).sizeStartSpread && (base22.sizeStartSpread = 0), 
        null == (base23 = json.emitter).sizeMiddle && (base23.sizeMiddle = 10), null == (base24 = json.emitter).sizeMiddleSpread && (base24.sizeMiddleSpread = 0), 
        null == (base25 = json.emitter).sizeEnd && (base25.sizeEnd = 10), null == (base26 = json.emitter).sizeEndSpread && (base26.sizeEndSpread = 0), 
        null == (base27 = json.emitter).angleStart && (base27.angleStart = 0), null == (base28 = json.emitter).angleStartSpread && (base28.angleStartSpread = 0), 
        null == (base29 = json.emitter).angleMiddle && (base29.angleMiddle = 0), null == (base30 = json.emitter).angleMiddleSpread && (base30.angleMiddleSpread = 0), 
        null == (base31 = json.emitter).angleEnd && (base31.angleEnd = 0), null == (base32 = json.emitter).angleEndSpread && (base32.angleEndSpread = 0), 
        null == (base33 = json.emitter).angleAlignVelocity && (base33.angleAlignVelocity = !1), 
        null == (base34 = json.emitter).colorStart && (base34.colorStart = "white"), null == (base35 = json.emitter).colorStartSpread && (base35.colorStartSpread = {}), 
        null == (base36 = json.emitter.colorStartSpread).x && (base36.x = 0), null == (base37 = json.emitter.colorStartSpread).y && (base37.y = 0), 
        null == (base38 = json.emitter.colorStartSpread).z && (base38.z = 0), null == (base39 = json.emitter).colorMiddle && (base39.colorMiddle = "white"), 
        null == (base40 = json.emitter).colorMiddleSpread && (base40.colorMiddleSpread = {}), 
        null == (base41 = json.emitter.colorMiddleSpread).x && (base41.x = 0), null == (base42 = json.emitter.colorMiddleSpread).y && (base42.y = 0), 
        null == (base43 = json.emitter.colorMiddleSpread).z && (base43.z = 0), null == (base44 = json.emitter).colorEnd && (base44.colorEnd = "blue"), 
        null == (base45 = json.emitter).colorEndSpread && (base45.colorEndSpread = {}), 
        null == (base46 = json.emitter.colorEndSpread).x && (base46.x = 0), null == (base47 = json.emitter.colorEndSpread).y && (base47.y = 0), 
        null == (base48 = json.emitter.colorEndSpread).z && (base48.z = 0), null == (base49 = json.emitter).opacityStart && (base49.opacityStart = 1), 
        null == (base50 = json.emitter).opacityStartSpread && (base50.opacityStartSpread = 0), 
        null == (base51 = json.emitter).opacityMiddle && (base51.opacityMiddle = .5), null == (base52 = json.emitter).opacityMiddleSpread && (base52.opacityMiddleSpread = 0), 
        null == (base53 = json.emitter).opacityEnd && (base53.opacityEnd = 0), null == (base54 = json.emitter).opacityEndSpread && (base54.opacityEndSpread = 0), 
        null == (base55 = json.emitter).particlesPerSecond && (base55.particlesPerSecond = 100), 
        null == (base56 = json.emitter).emitterDuration && (base56.emitterDuration = null), 
        null == (base57 = json.emitter).alive && (base57.alive = 1), null == (base58 = json.emitter).isStatic && (base58.isStatic = 0), 
        json;
    }, BaseParticle.prototype.tick = function(tpf) {
        return this.particleGroup.tick(tpf);
    }, BaseParticle.fromJson = function(assetJson) {
        var json;
        if ("particle" !== assetJson.type) throw new Error("not a particle");
        if (null == assetJson.key) throw new Error("key missing");
        return json = SaveObjectManager.get().items[assetJson.key], new BaseParticle(json);
    }, BaseParticle;
}(BaseModel), BaseParticle2 = function(superClass) {
    function BaseParticle2(input) {
        var emitJson, emitter, group, i, j, json, jsonInput, len, len1, ref;
        for (this.groups = [], this.mesh = new THREE.Object3D(), eval("var jsonInput = " + input), 
        void 0 !== jsonInput && null !== jsonInput || (jsonInput = []), i = 0, len = jsonInput.length; i < len; i++) {
            for (json = jsonInput[i], group = new SPE.Group(json), ref = json.emitters, j = 0, 
            len1 = ref.length; j < len1; j++) emitJson = ref[j], emitter = new SPE.Emitter(emitJson), 
            group.addEmitter(emitter);
            this.groups.push(group), this.mesh.add(group.mesh);
        }
    }
    return extend(BaseParticle2, superClass), BaseParticle2.prototype.tick = function(tpf) {
        var group, i, len, ref, results;
        for (ref = this.groups, results = [], i = 0, len = ref.length; i < len; i++) group = ref[i], 
        results.push(group.tick(tpf));
        return results;
    }, BaseParticle2.fromJson = function(assetJson) {
        var json;
        if ("particle" !== assetJson.type) throw new Error("not a particle");
        if (null == assetJson.key) throw new Error("key missing");
        return json = SaveObjectManager.get().items[assetJson.key], new BaseParticle2(json.particle);
    }, BaseParticle2;
}(BaseModel);

var Config;

Config = function() {
    function Config() {}
    var instance;
    return instance = null, Singleton.Config = function() {
        function Config() {}
        return Config.prototype.showStatsOnLoad = !1, Config.prototype.contextMenuDisabled = !0, 
        Config.prototype.antialias = !0, Config.prototype.anaglyph = !1, Config.prototype.stereoVR = !1, 
        Config.prototype.resize = !1, Config.prototype.width = 1280, Config.prototype.height = 1024, 
        Config.prototype.soundEnabled = !1, Config.prototype.debug = !1, Config.prototype.preventDefaultMouseEvents = !0, 
        Config.prototype.transparentBackground = !1, Config.prototype.logarithmicDepthBuffer = !0, 
        Config.prototype.recorder = {
            verbose: !1,
            display: !0,
            framerate: 60,
            quality: 100,
            format: "webm",
            frameLimit: 0,
            autoSaveTime: 0
        }, Config.prototype.sortObjects = !0, Config.prototype.fillWindow = function() {
            return this.resize = !0, this.width = window.innerWidth, this.height = window.innerHeight;
        }, Config.prototype.toggleAnaglyph = function() {
            return this.anaglyph = !this.anaglyph;
        }, Config.prototype.toggleStats = function() {
            return StatsManager.toggle();
        }, Config.prototype.toggleSound = function() {
            return this.soundEnabled = !this.soundEnabled;
        }, Config.prototype.toggleDebug = function() {
            return this.debug = !this.debug;
        }, Config.prototype.toggleFullscreen = function() {
            return Utils.toggleFullscreen();
        }, Config;
    }(), Config.get = function() {
        return null != instance ? instance : instance = new Singleton.Config();
    }, Config.fillWindow = function() {
        return this.get().fillWindow();
    }, Config.toggleAnaglyph = function() {
        return this.get().toggleAnaglyph();
    }, Config.toggleStats = function() {
        return this.get().toggleStats();
    }, Config.toggleSound = function() {
        return this.get().toggleSound();
    }, Config.toggleDebug = function() {
        return this.get().toggleDebug();
    }, Config.toggleFullscreen = function() {
        return this.get().toggleFullscreen();
    }, Config;
}(), exports.Config = Config;

var Helper, slice = [].slice;

Helper = function() {
    function Helper() {}
    return Helper.zero = new THREE.Vector3(0, 0, 0), Helper.one = new THREE.Vector3(1, 1, 1), 
    Helper.up = new THREE.Vector3(0, 1, 0), Helper.down = new THREE.Vector3(0, -1, 0), 
    Helper.toggleFullscreen = Utils.toggleFullscreen, Helper.addCEButton = Utils.addCEButton, 
    Helper.orientation = Utils.orientation, Helper.fade = Utils.fade, Helper.guid = Utils.guid, 
    Helper.setCursor = Utils.setCursor, Helper.rgbToHex = Utils.rgbToHex, Helper.defaultTweenDuration = 1e3, 
    Helper.delay = function() {
        var args, fn, time;
        return fn = arguments[0], time = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [], 
        setTimeout.apply(null, [ fn, time ].concat(slice.call(args)));
    }, Helper.interval = function() {
        var args, fn, time;
        return fn = arguments[0], time = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [], 
        setInterval.apply(null, [ fn, time ].concat(slice.call(args)));
    }, Helper.toVector3 = function(json) {
        return new THREE.Vector3(json.x, json.y, json.z);
    }, Helper.shallowClone = function(json) {
        return JSON.parse(JSON.stringify(json));
    }, Helper.random = function(min, max, mult) {
        return null == max && (max = min, min = 0), null != mult && (min *= mult, max *= mult), 
        Math.floor(Math.random() * (max - min + 1)) + min;
    }, Helper.distanceTo = function(v1, v2) {
        var dx, dy, dz;
        return dx = v1.x - v2.x, dy = v1.y - v2.y, dz = v1.z - v2.z, Math.sqrt(dx * dx + dy * dy + dz * dz);
    }, Helper.moveTowards = function(speed, tpf, src, dest) {
        var direction, distance, end, start;
        return start = {
            x: src.x,
            y: src.y,
            z: src.z
        }, end = {
            x: dest.x,
            y: dest.y,
            z: dest.z
        }, distance = Helper.distanceTo(start, end), direction = new THREE.Vector3(end.x - start.x, end.y - start.y, end.z - start.z).normalize(), 
        src.x += direction.x * speed * tpf, src.y += direction.y * speed * tpf, src.z += direction.z * speed * tpf, 
        Helper.distanceTo(start, src) >= distance && (src.x = end.x, src.y = end.y, src.z = end.z), 
        src;
    }, Helper.tendToZero = function(n, amount) {
        return 0 === n ? n : (n > 0 ? (n -= amount) < 0 && (n = 0) : (n += amount) > 0 && (n = 0), 
        n);
    }, Helper.tendTo = function(n, amount, target) {
        return n === target ? n : (n > target ? (n -= amount) < target && (n = target) : (n += amount) > target && (n = target), 
        n);
    }, Helper.addWithMinMax = function(n, amount, min, max) {
        return n += amount, n > max && (n = max), n < min && (n = min), n;
    }, Helper.screenshot = function(targetEngine) {
        var eng;
        if (null != targetEngine) eng = targetEngine; else {
            if ("undefined" == typeof engine || null === engine) throw "no engine found";
            eng = engine;
        }
        return eng.screenshot(), setTimeout(function() {
            return Utils.saveScreenshot(eng);
        }, 1e3);
    }, Helper.camera = function(options) {
        var config;
        return null == options && (options = {}), config = Config.get(), null == options.view_angle && (options.view_angle = Utils.CAMERA_DEFAULT_VIEW_ANGLE), 
        null == options.aspect && (options.aspect = config.width / config.height), null == options.near && (options.near = Utils.CAMERA_DEFAULT_NEAR), 
        null == options.far && (options.far = Utils.CAMERA_DEFAULT_FAR), options.type || (options.type = Utils.CAMERA_DEFAULT_TYPE), 
        new THREE[options.type](options.view_angle, options.aspect, options.near, options.far);
    }, Helper.light = function(options) {
        var base, base1, base2, light;
        return null == options && (options = {}), null == options.position && (options.position = {}), 
        null == (base = options.position).x && (base.x = Utils.LIGHT_DEFAULT_POSITION_X), 
        null == (base1 = options.position).y && (base1.y = Utils.LIGHT_DEFAULT_POSITION_Y), 
        null == (base2 = options.position).z && (base2.z = Utils.LIGHT_DEFAULT_POSITION_Z), 
        null == options.color && (options.color = Utils.LIGHT_DEFAULT_COLOR), light = new THREE.DirectionalLight(options.color), 
        light.position.set(options.position.x, options.position.y, options.position.z), 
        light.castShadow = !0, light.shadow.camera.left = -60, light.shadow.camera.top = -60, 
        light.shadow.camera.right = 60, light.shadow.camera.bottom = 60, light.shadow.camera.near = 1, 
        light.shadow.camera.far = 1e3, light.shadow.bias = -1e-4, light.shadow.mapSize.width = light.shadow.mapSize.height = 1024, 
        light.shadow.darkness = .7, light;
    }, Helper.directionalLight = function(options) {
        return null == options && (options = {}), this.light(options);
    }, Helper.ambientLight = function(options) {
        return null == options && (options = {}), null == options.color && (options.color = Utils.AMBIENT_LIGHT_DEFAULT_COLOR), 
        null == options.intensity && (options.intensity = Utils.POINT_LIGHT_DEFAULT_INTENSITY), 
        new THREE.AmbientLight(options.color, options.intensity);
    }, Helper.pointLight = function(options) {
        return null == options && (options = {}), null == options.color && (options.color = Utils.POINT_LIGHT_DEFAULT_COLOR), 
        null == options.intensity && (options.intensity = Utils.POINT_LIGHT_DEFAULT_INTENSITY), 
        null == options.distance && (options.distance = Utils.POINT_LIGHT_DEFAULT_DISTANCE), 
        null == options.decay && (options.decay = Utils.POINT_LIGHT_DEFAULT_DECAY), new THREE.PointLight(options.color, options.intensity, options.distance, options.decay);
    }, Helper.threePointLight = function() {
        return new THREEx.ThreePointsLighting();
    }, Helper.sunSetLight = function() {
        return new THREEx.SunSetLighting();
    }, Helper.hemiLight = function(options) {
        var base, base1, base2, base3, base4, base5, hemiLight;
        return null == options && (options = {}), null == options.skyColor && (options.skyColor = 16777215), 
        null == options.groundColor && (options.groundColor = 16777215), null == options.intensity && (options.intensity = .6), 
        null == options.skyColorHSL && (options.skyColorHSL = {}), null == (base = options.skyColorHSL).hue && (base.hue = .6), 
        null == (base1 = options.skyColorHSL).saturation && (base1.saturation = 1), null == (base2 = options.skyColorHSL).light && (base2.light = .6), 
        null == options.groundColorHSL && (options.groundColorHSL = {}), null == (base3 = options.groundColorHSL).hue && (base3.hue = .95), 
        null == (base4 = options.groundColorHSL).saturation && (base4.saturation = 1), null == (base5 = options.groundColorHSL).light && (base5.light = .75), 
        hemiLight = new THREE.HemisphereLight(options.skyColor, options.groundColor, options.intensity), 
        hemiLight.color.setHSL(options.skyColorHSL.hue, options.skyColorHSL.saturation, options.skyColorHSL.light), 
        hemiLight.groundColor.setHSL(options.groundColorHSL.hue, options.groundColorHSL.saturation, options.groundColorHSL.light), 
        hemiLight;
    }, Helper.cube = function(options) {
        var box, mat;
        return null == options && (options = {}), null == options.size && (options.size = 1), 
        null == options.material && (options.material = "MeshPhongMaterial"), null == options.color && (options.color = 16711680), 
        box = new THREE.BoxGeometry(options.size, options.size, options.size), mat = null != options.map ? new THREE.MeshBasicMaterial({
            map: TextureManager.get().items[options.map],
            transparent: !0,
            side: THREE.DoubleSide
        }) : null != options.color ? new THREE[options.material]({
            color: options.color
        }) : new THREE[options.material](), new THREE.Mesh(box, mat);
    }, Helper.model = function(options) {
        if (null == options && (options = {}), null == options.key) throw new Error("key missing for: " + JSON.stringify(options));
        return JsonModelManager.clone(options.key);
    }, Helper.terrain = function(options) {
        return null == options && (options = {}), Terrain.fromJson(options);
    }, Helper.particle = function(options) {
        return null == options && (options = {}), BaseParticle2.fromJson(options);
    }, Helper.mirror = function(engine, options) {
        return null == options && (options = {}), new Mirror(engine, options);
    }, Helper.water = function(engine, scene, options) {
        return null == options && (options = {}), new Water(engine, scene, options);
    }, Helper.graffiti = function(assetJson) {
        var json, material, plane;
        if ("graffiti" !== assetJson.type) throw new Error("not a graffiti");
        if (null == assetJson.key) throw new Error("key missing");
        return json = SaveObjectManager.get().items[assetJson.key], material = MaterialManager.get().items[assetJson.key], 
        null == material && (this.art = new ArtGenerator({
            width: json.width,
            height: json.height
        }), this.art.fromJson(json), material = this.materialFromCanvas(this.art.canvas)), 
        plane = this.plane(json.plane), plane.material = material, plane;
    }, Helper.plane = function(options) {
        var geometry, material;
        return null == options && (options = {}), null != options.size ? (options.width = options.size, 
        options.height = options.size) : (null == options.width && (options.width = Utils.PLANE_DEFAULT_WIDTH), 
        null == options.height && (options.height = Utils.PLANE_DEFAULT_HEIGHT)), null == options.wSegments && (options.wSegments = Utils.PLANE_DEFAULT_W_SEGMENTS), 
        null == options.hSegments && (options.hSegments = Utils.PLANE_DEFAULT_H_SEGMENTS), 
        null == options.color && (options.color = Utils.PLANE_DEFAULT_COLOR), null == options.class && (options.class = "PlaneBufferGeometry"), 
        material = null != options.map ? new THREE.MeshBasicMaterial({
            map: TextureManager.get().items[options.map],
            side: THREE.DoubleSide
        }) : null != options.material ? options.material : new THREE.MeshBasicMaterial({
            color: options.color,
            side: THREE.DoubleSide
        }), geometry = new THREE[options.class](options.width, options.height, options.wSegments, options.hSegments), 
        new THREE.Mesh(geometry, material);
    }, Helper.fancyShadows = function(renderer) {
        return renderer.shadowMap.enabled = !0, renderer.shadowMap.soft = !0, renderer.shadowMap.type = THREE.PCFShadowMap, 
        renderer.shadowMap.autoUpdate = !0;
    }, Helper.skySphere = function(options) {
        var geom, mat, name;
        if (null == options && (options = {}), null == options.textureUrl && null == options.map) throw "options.textureUrl or options.map not defined";
        return null == options.radius && (options.radius = Utils.SKY_SPHERE_DEFAULT_RADIUS), 
        null == options.segments && (options.segments = Utils.SKY_SPHERE_DEFAULT_SEGMENTS), 
        geom = new THREE.SphereGeometry(options.radius, options.segments, options.segments), 
        name = null != options.map ? options.map : Utils.getKeyName(options.textureUrl, Utils.IMG_URLS), 
        mat = new THREE.MeshBasicMaterial({
            map: TextureManager.get().items[name],
            side: THREE.BackSide
        }), new THREE.Mesh(geom, mat);
    }, Helper.skyBox = function(imgUrls, size) {
        var aCubeMap, aShader, aSkyBoxMaterial;
        return null == size && (size = 9e5), aCubeMap = THREE.ImageUtils.loadTextureCube(imgUrls), 
        aCubeMap.format = THREE.RGBFormat, aShader = THREE.ShaderLib.cube, aShader.uniforms.tCube.value = aCubeMap, 
        aSkyBoxMaterial = new THREE.ShaderMaterial({
            fragmentShader: aShader.fragmentShader,
            vertexShader: aShader.vertexShader,
            uniforms: aShader.uniforms,
            depthWrite: !1,
            side: THREE.BackSide
        }), new THREE.Mesh(new THREE.BoxGeometry(size, size, size), aSkyBoxMaterial);
    }, Helper.sampleShaderMaterial = function() {
        var shader;
        return shader = {
            uniforms: {
                time: {
                    type: "f",
                    value: 0
                },
                resolution: {
                    type: "v2",
                    value: new THREE.Vector2()
                }
            },
            fragment: [ "uniform float time;", "varying vec2 vUv;", "", "void main() {", "  vec2 position = -1.0 + 2.0 * vUv;", "", "  float red = abs(sin(position.x * position.y + time / 5.0));", "  float green = abs(sin(position.x * position.y + time / 4.0));", "  float blue = abs(sin(position.x * position.y + time / 3.0 ));", "  gl_FragColor = vec4(red, green, blue, 1.0);", "}" ].join("\n"),
            vertex: [ "varying vec2 vUv;", "", "void main() {", "  vUv = uv;", "  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n")
        }, new THREE.ShaderMaterial({
            uniforms: shader.uniforms,
            vertexShader: shader.vertex,
            fragmentShader: shader.fragment
        });
    }, Helper.sampleShader = function() {
        var itemMaterial, mesh;
        return itemMaterial = this.sampleShaderMaterial(), mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), itemMaterial), 
        mesh.shaderSrc = itemMaterial, mesh;
    }, Helper.orbitControls = function(engine) {
        if (!(engine instanceof Engine3D)) throw "not an instance of Engine3D";
        return new THREE.OrbitControls(engine.camera, engine.renderer.domElement);
    }, Helper.fog = function(options) {
        return null == options && (options = {}), null == options.color && (options.color = 0), 
        null == options.near && (options.near = 0), null == options.far && (options.far = 500), 
        new THREE.Fog(options.color, options.near, options.far);
    }, Helper.grid = function(options) {
        return null == options && (options = {}), null == options.size && (options.size = 10), 
        null == options.step && (options.step = 1), null == options.color && (options.color = 16777215), 
        null == options.colorCenterLine && (options.colorCenterLine = options.color), new THREE.GridHelper(options.size, options.step, options.colorCenterLine, options.color);
    }, Helper.materialFromCanvas = function(canvas) {
        var texture;
        return texture = new THREE.Texture(canvas), texture.needsUpdate = !0, texture.minFilter = THREE.LinearFilter, 
        new THREE.MeshBasicMaterial({
            map: texture,
            transparent: !0
        });
    }, Helper.intersectPlane = function() {
        return new THREE.Plane(new THREE.Vector3(0, 0, 1), -1);
    }, Helper.shake = function(target, options) {
        var i, j, k, originalPos, randX, randY, randZ, ref, tween, tweenArray;
        for (null == options && (options = {}), null == options.kind && (options.kind = "Cubic"), 
        null == options.direction && (options.direction = "In"), null == options.stepDuration && (options.stepDuration = 150), 
        originalPos = {
            x: target.position.x,
            y: target.position.y,
            z: target.position.z
        }, Helper.random(100) / 100, tweenArray = [], i = j = 0; j < 20; i = ++j) randX = Helper.random(100) / 100, 
        randY = Helper.random(100) / 100, randZ = Helper.random(100) / 100, Helper.random(100) < 50 && (randX *= -1), 
        Helper.random(100) < 50 && (randY *= -1), Helper.random(100) < 50 && (randZ *= -1), 
        tween = this.tween({
            target: {
                x: randX,
                y: randY,
                z: randZ
            },
            mesh: target,
            relative: !0,
            duration: options.stepDuration,
            kind: options.kind,
            direction: options.direction
        }), tweenArray.push(tween);
        for (i = k = 0, ref = tweenArray.size(); 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) null != tweenArray[i + 1] && tweenArray[i].chain(tweenArray[i + 1]);
        return tweenArray.last().onComplete(function(_this) {
            return function() {
                return _this.tween({
                    target: {
                        x: originalPos.x,
                        y: originalPos.y,
                        z: originalPos.z
                    },
                    mesh: target,
                    relative: !1,
                    duration: options.stepDuration,
                    kind: options.kind,
                    direction: options.direction
                }).start();
            };
        }(this)), tweenArray[0].start(), tweenArray;
    }, Helper.tween = function(options) {
        var base, base1, base2, base3, base4, base5, base6, base7, base8, e, j, k, l, len, len1, len2, ref, ref1, ref2, tween;
        if (null == options && (options = {}), null == options.target) throw new Error("options.target missing");
        if (null == options.mesh) throw new Error("options.mesh missing");
        if (null == options.relative && (options.relative = !1), null == options.duration && (options.duration = Helper.defaultTweenDuration), 
        null == options.kind && (options.kind = "Linear"), null == options.direction && (options.direction = "None"), 
        null == options.delay && (options.delay = 0), null == options.position && (options.position = options.mesh.position.clone()), 
        options.position.rX = options.mesh.rotation.x, options.position.rY = options.mesh.rotation.y, 
        options.position.rZ = options.mesh.rotation.z, options.position.sX = options.mesh.scale.x, 
        options.position.sY = options.mesh.scale.y, options.position.sZ = options.mesh.scale.z, 
        options.relative) {
            for (ref = [ "x", "y", "z" ], j = 0, len = ref.length; j < len; j++) e = ref[j], 
            null != options.target[e] ? options.target[e] += options.mesh.position[e] : options.target[e] = options.mesh.position[e];
            for (ref1 = [ "rX", "rY", "rZ" ], k = 0, len1 = ref1.length; k < len1; k++) e = ref1[k], 
            null != options.target[e] ? options.target[e] += options.mesh.rotation[e.toLowerCase()[1]] : options.target[e] = options.mesh.rotation[e.toLowerCase()[1]];
            for (ref2 = [ "sX", "sY", "sZ" ], l = 0, len2 = ref2.length; l < len2; l++) e = ref2[l], 
            null != options.target[e] ? options.target[e] += options.mesh.scale[e.toLowerCase()[1]] : options.target[e] = options.mesh.scale[e.toLowerCase()[1]];
        } else null == (base = options.target).x && (base.x = options.position.x), null == (base1 = options.target).y && (base1.y = options.position.y), 
        null == (base2 = options.target).z && (base2.z = options.position.z), null == (base3 = options.target).rX && (base3.rX = options.position.rX), 
        null == (base4 = options.target).rY && (base4.rY = options.position.rY), null == (base5 = options.target).rZ && (base5.rZ = options.position.rZ), 
        null == (base6 = options.target).sX && (base6.sX = options.position.sX), null == (base7 = options.target).sY && (base7.sY = options.position.sY), 
        null == (base8 = options.target).sZ && (base8.sZ = options.position.sZ);
        if (options.position === options.target) throw new Error("target same as position");
        return tween = new TWEEN.Tween(options.position).to(options.target, options.duration).easing(TWEEN.Easing[options.kind][options.direction]).onUpdate(function() {
            return options.mesh.position.set(this.x, this.y, this.z), options.mesh.rotation.set(this.rX, this.rY, this.rZ), 
            options.mesh.scale.set(this.sX, this.sY, this.sZ);
        }), 0 !== options.delay && tween.delay(options.delay), tween;
    }, Helper.tweenCustom = function(options) {
        if (null == options && (options = {}), null == options.src) throw new Error("options.src missing");
        if (null == options.dest) throw new Error("options.dest missing");
        if (null == options.onUpdate) throw new Error("options.onUpdate missing");
        return null == options.duration && (options.duration = Helper.defaultTweenDuration), 
        null == options.kind && (options.kind = "Linear"), null == options.direction && (options.direction = "None"), 
        null == options.onComplete && (options.onComplete = function() {
            return {};
        }), new TWEEN.Tween(options.src).to(options.dest, options.duration).easing(TWEEN.Easing[options.kind][options.direction]).onUpdate(options.onUpdate).onComplete(options.onComplete);
    }, Helper.vrPointer = function(camera, options) {
        var cube, scene, vector;
        return null == options && (options = {}), cube = this.cube({
            size: .5
        }), scene = SceneManager.currentScene(), scene.vrPointer = cube, vector = new THREE.Vector3(), 
        camera.getWorldDirection(vector), cube.translateZ(-1), scene.scene.add(cube);
    }, Helper.forest = function(options) {
        var attr, attrHash, base, base1, base10, base11, base12, base13, base14, base15, base16, base17, base2, base3, base4, base5, base6, base7, base8, base9, coords, item, j, k, l, len, len1, model, node, ref, ref1, ref2;
        for (null == options && (options = {}), null == options.items && (options.items = []), 
        null == options.positionMin && (options.positionMin = {}), null == (base = options.positionMin).x && (base.x = 0), 
        null == (base1 = options.positionMin).y && (base1.y = 0), null == (base2 = options.positionMin).z && (base2.z = 0), 
        null == options.positionMax && (options.positionMax = {}), null == (base3 = options.positionMax).x && (base3.x = 10), 
        null == (base4 = options.positionMax).y && (base4.y = 0), null == (base5 = options.positionMax).z && (base5.z = 10), 
        null == options.rotationMin && (options.rotationMin = {}), null == (base6 = options.rotationMin).x && (base6.x = 0), 
        null == (base7 = options.rotationMin).y && (base7.y = 0), null == (base8 = options.rotationMin).z && (base8.z = 0), 
        null == options.rotationMax && (options.rotationMax = {}), null == (base9 = options.rotationMax).x && (base9.x = 0), 
        null == (base10 = options.rotationMax).y && (base10.y = Math.PI), null == (base11 = options.rotationMax).z && (base11.z = 0), 
        null == options.scaleMin && (options.scaleMin = {}), null == (base12 = options.scaleMin).x && (base12.x = .5), 
        null == (base13 = options.scaleMin).y && (base13.y = .5), null == (base14 = options.scaleMin).z && (base14.z = .5), 
        null == options.scaleMax && (options.scaleMax = {}), null == (base15 = options.scaleMax).x && (base15.x = 1.5), 
        null == (base16 = options.scaleMax).y && (base16.y = 1.5), null == (base17 = options.scaleMax).z && (base17.z = 1.5), 
        node = new THREE.Object3D(), coords = function(item, options, attr, coord, which) {
            var s;
            return s = "" + attr + which, null != item[s] && null != item[s][coord] ? item[s][coord] : options[s][coord];
        }, new THREE.Geometry(), ref = options.items, j = 0, len = ref.length; j < len; j++) for (item = ref[j], 
        null == item.count && (item.count = 1), k = 0, ref1 = item.count; 0 <= ref1 ? k < ref1 : k > ref1; 0 <= ref1 ? ++k : --k) {
            for (model = JsonModelManager.clone(item.type), ref2 = [ "scale", "position", "rotation" ], 
            l = 0, len1 = ref2.length; l < len1; l++) attr = ref2[l], attrHash = {
                x: Helper.random(coords(item, options, attr, "x", "Min"), coords(item, options, attr, "x", "Max"), 1e3) / 1e3,
                y: Helper.random(coords(item, options, attr, "y", "Min"), coords(item, options, attr, "y", "Max"), 1e3) / 1e3,
                z: Helper.random(coords(item, options, attr, "z", "Min"), coords(item, options, attr, "z", "Max"), 1e3) / 1e3
            }, model[attr].set(attrHash.x, attrHash.y, attrHash.z);
            node.add(model);
        }
        return node;
    }, Helper.basicMaterial = function(key) {
        return new THREE.MeshBasicMaterial({
            map: TextureManager.get().items[key],
            transparent: !0
        });
    }, Helper.dissolveMaterial = function(texture) {
        return new THREE.ShaderMaterial({
            uniforms: {
                texture: {
                    type: "t",
                    value: texture
                },
                noise: {
                    type: "t",
                    value: texture
                },
                dissolve: {
                    type: "f",
                    value: 0
                }
            },
            morphTargets: !0,
            vertexShader: THREE.ShaderLib.dissolve.vertexShader,
            fragmentShader: THREE.ShaderLib.dissolve.fragmentShader,
            shading: THREE.SmoothShading
        });
    }, Helper.setDissolveMaterialColor = function(dm, r, g, b) {
        return null == dm && new Error("missing dm param"), r = parseFloat(r).toFixed(1), 
        g = parseFloat(g).toFixed(1), b = parseFloat(b).toFixed(1), dm.fragmentShader = dm.fragmentShader.replace("    color.r = 1.0; color.g = 0.5; color.b = 0.0;", "    color.r = " + r + "; color.g = " + g + "; color.b = " + b + ";"), 
        dm;
    }, Helper.networkReload = function() {
        var nm;
        return nm = NetworkManager.get(), nm._hasListener("reload") || nm.on("reload", function(data) {
            return location.reload();
        }), nm.emit({
            type: "reload"
        });
    }, Helper.desertScene = function(inputScene) {
        var d, dirLight, fragmentShader, ground, groundGeo, groundMat, hemiLight, scene, sky, skyGeo, skyMat, uniforms, vertexShader;
        return scene = inputScene instanceof BaseScene ? inputScene.scene : inputScene, 
        groundGeo = new THREE.PlaneBufferGeometry(1e4, 1e4), groundMat = new THREE.MeshPhongMaterial({
            color: 16777215,
            specular: 328965
        }), groundMat.color.setHSL(.095, 1, .75), ground = new THREE.Mesh(groundGeo, groundMat), 
        ground.rotation.x = -Math.PI / 2, scene.add(ground), ground.receiveShadow = !0, 
        scene.fog = new THREE.Fog(16777215, 1, 5e3), scene.fog.color.setHSL(.6, 0, 1), hemiLight = Helper.hemiLight(), 
        hemiLight.position.set(0, 500, 0), scene.add(hemiLight), dirLight = new THREE.DirectionalLight(16777215, 1), 
        dirLight.color.setHSL(.1, 1, .95), dirLight.position.set(-1, 1.75, 1), dirLight.position.multiplyScalar(50), 
        scene.add(dirLight), dirLight.castShadow = !0, dirLight.shadow.mapSize.width = 2048, 
        dirLight.shadow.mapSize.height = 2048, d = 50, dirLight.shadow.camera.left = -d, 
        dirLight.shadow.camera.right = d, dirLight.shadow.camera.top = d, dirLight.shadow.camera.bottom = -d, 
        dirLight.shadow.camera.far = 3500, dirLight.shadow.bias = -1e-4, vertexShader = THREE.ShaderLib.gradient.vertexShader, 
        fragmentShader = THREE.ShaderLib.gradient.fragmentShader, uniforms = {
            topColor: {
                value: new THREE.Color(30719)
            },
            bottomColor: {
                value: new THREE.Color(16777215)
            },
            offset: {
                value: 33
            },
            exponent: {
                value: .6
            }
        }, uniforms.topColor.value.copy(hemiLight.color), scene.fog.color.copy(uniforms.bottomColor.value), 
        skyGeo = new THREE.SphereGeometry(4e3, 32, 15), skyMat = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: uniforms,
            side: THREE.BackSide
        }), sky = new THREE.Mesh(skyGeo, skyMat), scene.add(sky), [ ground, hemiLight, dirLight, sky ];
    }, Helper.composer = function(scene, targetEngine) {
        var composer, effectBloom, effectCopy, effectFXAA, renderModel;
        return renderModel = new THREE.RenderPass(scene, targetEngine.camera), effectBloom = new THREE.BloomPass(1.3), 
        effectCopy = new THREE.ShaderPass(THREE.CopyShader), effectFXAA = new THREE.ShaderPass(THREE.FXAAShader), 
        effectFXAA.uniforms.resolution.value.set(1 / targetEngine.width, 1 / targetEngine.height), 
        effectCopy.renderToScreen = !0, composer = new THREE.EffectComposer(targetEngine.renderer), 
        composer.addPass(renderModel), composer.addPass(effectFXAA), composer.addPass(effectBloom), 
        composer.addPass(effectCopy), composer;
    }, Helper.filmComposer = function(scene, targetEngine) {
        var composer, effectCopy, filmPass, renderModel;
        return renderModel = new THREE.RenderPass(scene, targetEngine.camera), new THREE.BokehPass(scene, targetEngine.camera, {}), 
        filmPass = new THREE.FilmPass(), filmPass = new THREE.GlitchPass(), effectCopy = new THREE.ShaderPass(THREE.CopyShader), 
        effectCopy.renderToScreen = !0, composer = new THREE.EffectComposer(targetEngine.renderer), 
        composer.addPass(renderModel), composer.addPass(filmPass), composer.addPass(effectCopy), 
        composer;
    }, Helper.physicsWorld = function() {
        var broadphase, collisionConfiguration, dispatcher, physicsWorld, solver;
        return collisionConfiguration = new Ammo.btDefaultCollisionConfiguration(), dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration), 
        broadphase = new Ammo.btDbvtBroadphase(), solver = new Ammo.btSequentialImpulseConstraintSolver(), 
        physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration), 
        physicsWorld.setGravity(new Ammo.btVector3(0, -9.82, 0)), physicsWorld;
    }, Helper;
}(), THREE.ShaderLib.dissolve = {
    vertexShader: [ "varying vec2 vUv;", "uniform float morphTargetInfluences[ 8 ];", "void main() {", "  vUv = uv;", "  vec3 morphed = vec3( 0.0 );", "  morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];", "  morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];", "  morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];", "  morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];", "  morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];", "  morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];", "  morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];", "  morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];", "  morphed += position;", "  vec4 mvPosition;", "  mvPosition = modelViewMatrix * vec4( morphed, 1.0 );", "  gl_Position = projectionMatrix * mvPosition;", "  //vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "varying vec2 vUv;", "uniform sampler2D texture;", "uniform sampler2D noise;", "uniform float dissolve;", "void main()", "{", "  vec4 color = texture2D( texture, vUv );", "  float n = texture2D( noise, vUv ).x;", "  n = ( n - dissolve ) * 50.0;", "  if (n < 0.0) {", "    discard;", "  }", "  if (n < 1.0) {", "    color.r = 1.0; color.g = 0.5; color.b = 0.0;", "  }", "  gl_FragColor = color;", "}" ].join("\n")
}, THREE.ShaderLib.gradient = {
    vertexShader: [ "varying vec3 vWorldPosition;", "void main() {", "  vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "  vWorldPosition = worldPosition.xyz;", "  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "uniform vec3 topColor;", "uniform vec3 bottomColor;", "uniform float offset;", "uniform float exponent;", "varying vec3 vWorldPosition;", "void main() {", "  float h = normalize( vWorldPosition + offset ).y;", "  gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );", "}" ].join("\n")
}, THREE.ShaderLib.sample = {
    vertexShader: [ "" ].join("\n"),
    fragmentShader: [ "" ].join("\n")
};

var PoolManager;

PoolManager = function() {
    function PoolManager() {}
    var instance;
    return instance = null, Singleton.PoolManager = function() {
        function PoolManager() {}
        return PoolManager.prototype.validEvents = [ "spawn", "release" ], PoolManager.prototype.items = {}, 
        PoolManager.prototype.itemsInUse = {}, PoolManager.prototype.spawnEvents = {}, PoolManager.prototype.releaseEvents = {}, 
        PoolManager.prototype.spawn = function(type, options) {
            var item;
            return null == options && (options = {}), this._validation(type), item = this.items[type].isEmpty() ? new type() : this.items[type].shift(), 
            this.itemsInUse[type].push(item), null != this.spawnEvents[type] && this.spawnEvents[type](item, options), 
            item;
        }, PoolManager.prototype.spawnSpecific = function(item, options) {
            var type;
            if (null == options && (options = {}), type = item.constructor, this._validation(type), 
            !this.itemsInUse[type].includes(item)) {
                if (null === this.items[type].remove(item)) throw "item needs to be previously spawned by PoolManager";
                this.itemsInUse[type].push(item);
            }
            return null != this.spawnEvents[type] && this.spawnEvents[type](item, options), 
            item;
        }, PoolManager.prototype.release = function(item, options) {
            var type;
            if (null == options && (options = {}), "object" != typeof item || null == item.constructor) throw new Error("item " + item + " can not be released. wront type");
            if (type = this._validation(item.constructor), -1 === this.itemsInUse[type].indexOf(item) && -1 === this.items[type].indexOf(item)) throw new Error("item (" + type + ") was not spawned from the pool");
            -1 !== this.itemsInUse[type].indexOf(item) && this.itemsInUse[type].remove(item), 
            -1 === this.items[type].indexOf(item) && this.items[type].push(item), null != this.releaseEvents[type] && this.releaseEvents[type](item, options);
        }, PoolManager.prototype.on = function(which, type, func) {
            var base;
            if (!("function" == typeof (base = this.validEvents).includes ? base.includes(which) : void 0)) throw new Error(which + " invalid. Allowed: " + this.validEvents.join(", "));
            return this[which + "Events"][type] = func;
        }, PoolManager.prototype.onSpawn = function(type, func) {
            return this.on("spawn", type, func);
        }, PoolManager.prototype.onRelease = function(type, func) {
            return this.on("release", type, func);
        }, PoolManager.prototype._validation = function(type) {
            if (!(type.prototype instanceof BaseModel)) throw new Error("type " + type + " not instance of base model");
            return null == this.items[type] && (this.items[type] = []), null == this.itemsInUse[type] && (this.itemsInUse[type] = []), 
            type;
        }, PoolManager.prototype._count = function(items) {
            var count, key;
            count = 0;
            for (key in items) count += items[key].size();
            return count;
        }, PoolManager.prototype.toString = function() {
            var inPool, inUse;
            return inUse = this._count(this.itemsInUse), inPool = this._count(this.items), inUse + " items in use\n" + inPool + " items waiting in all pools\n" + (inUse + inPool) + " total items";
        }, PoolManager.prototype.releaseAll = function() {
            var i, item, j, key, len, len1, ref, toRelease;
            toRelease = [];
            for (key in this.itemsInUse) for (ref = this.itemsInUse[key], i = 0, len = ref.length; i < len; i++) item = ref[i], 
            toRelease.push(item);
            for (j = 0, len1 = toRelease.length; j < len1; j++) item = toRelease[j], this.release(item);
            return toRelease;
        }, PoolManager.prototype.getAll = function() {
            var allItems, i, item, itemSet, j, key, len, len1, ref, ref1;
            for (allItems = [], ref = [ this.items, this.itemsInUse ], i = 0, len = ref.length; i < len; i++) {
                itemSet = ref[i];
                for (key in itemSet) for (ref1 = itemSet[key], j = 0, len1 = ref1.length; j < len1; j++) item = ref1[j], 
                allItems.push(item);
            }
            return allItems;
        }, PoolManager;
    }(), PoolManager.get = function() {
        return null != instance ? instance : instance = new Singleton.PoolManager();
    }, PoolManager.spawn = function(type, options) {
        return null == options && (options = {}), this.get().spawn(type, options);
    }, PoolManager.release = function(item, options) {
        return null == options && (options = {}), this.get().release(item, options);
    }, PoolManager.on = function(which, type, func) {
        return this.get().on(which, type, func);
    }, PoolManager.onSpawn = function(type, func) {
        return this.get().on("spawn", type, func);
    }, PoolManager.onRelease = function(type, func) {
        return this.get().on("release", type, func);
    }, PoolManager.releaseAll = function() {
        return this.get().releaseAll();
    }, PoolManager.items = function(type) {
        var key, results;
        if (null != type) return this.get().items[type] || [];
        results = [];
        for (key in this.get().items) results = results.concat(this.get().items[key]);
        return results;
    }, PoolManager.itemsInUse = function(targetType) {
        var i, key, len, results, theType, type;
        if (results = [], null != targetType) for (type = [].concat(targetType), i = 0, 
        len = type.length; i < len; i++) theType = type[i], results = results.concat(this.get().itemsInUse[theType] || []); else for (key in this.get().itemsInUse) results = results.concat(this.get().itemsInUse[key]);
        return results;
    }, PoolManager;
}();

var PolyfillRenderer;

PolyfillRenderer = function() {
    function PolyfillRenderer() {
        this.domElement = PolyfillRenderer.makeDomElement();
    }
    return PolyfillRenderer.prototype.getPixelRatio = function() {
        return 1;
    }, PolyfillRenderer.prototype.setSize = function(width, height) {}, PolyfillRenderer.prototype.render = function(scene, camera) {}, 
    PolyfillRenderer.makeDomElement = function() {
        var element;
        return element = document.createElement("div"), element.innerHTML = "WebGL not supported", 
        element.style.display = "flex", element.style.position = "absolute", element.style.width = "100%", 
        element.style.height = "100%", element.style["align-items"] = "center", element.style["text-align"] = "center", 
        element.style["background-color"] = "black", element.style.color = "white", element.style["z-index"] = 10 * Utils.CE_UI_Z_INDEX, 
        element;
    }, PolyfillRenderer;
}();

var AfterEffects;

AfterEffects = function() {
    function AfterEffects(engine) {
        this.engine = engine, this.effects();
    }
    return AfterEffects.prototype.effects = function() {
        var effectBloom, effectCopy;
        return this.renderModel = new THREE.RenderPass(void 0, void 0), effectBloom = new THREE.BloomPass(1.25), 
        effectCopy = new THREE.ShaderPass(THREE.CopyShader), effectCopy.renderToScreen = !0, 
        this.composer = new THREE.EffectComposer(this.engine.renderer), this.composer.addPass(this.renderModel), 
        this.composer.addPass(effectBloom), this.composer.addPass(effectCopy);
    }, AfterEffects.prototype.enable = function(scene, camera) {
        return null != scene && (this.renderModel.scene = scene), null != camera && (this.renderModel.camera = camera), 
        this.engine.enableComposer(this.composer);
    }, AfterEffects.prototype.disable = function() {
        return this.engine.disableComposer(this.composer);
    }, AfterEffects;
}();

var ArtGenerator;

ArtGenerator = function() {
    function ArtGenerator(options) {
        this.options = options, this.tm = TextureManager.get(), this.canvas = document.createElement("canvas"), 
        this.canvas.width = options.width, this.canvas.height = options.height, this.ctx = this.canvas.getContext("2d");
    }
    return ArtGenerator.prototype.fromJson = function(json) {
        var i, item, len, ref, results;
        for (this.clear(), ref = json.items, results = [], i = 0, len = ref.length; i < len; i++) item = ref[i], 
        null != item.asset && null != item.asset.key && (item.key = item.asset.key), "image" === item.type && this.drawImage(item), 
        "text" === item.type && this.drawText(item), "bezier" === item.type ? results.push(this.drawBezier(item)) : results.push(void 0);
        return results;
    }, ArtGenerator.prototype.drawBezier = function(options) {
        return StackOverflow.drawBezier(options, this.ctx);
    }, ArtGenerator.prototype.drawText = function(options) {
        if (null == options && (options = {}), null == options.text) throw "options.text missing";
        return null == options.fillStyle && (options.fillStyle = "white"), null == options.fillLineWidth && (options.fillLineWidth = 1), 
        null == options.strokeLineWidth && (options.strokeLineWidth = 7), null == options.strokeStyle && (options.strokeStyle = void 0), 
        null == options.font && (options.font = "40px Helvetica"), null == options.x && (options.x = 0), 
        null == options.y && (options.y = 0), null == options.angle && (options.angle = 0), 
        this.ctx.save(), this.ctx.font = options.font, 0 !== options.angle && this.ctx.rotate(options.angle * Math.PI / 180), 
        null != options.strokeStyle && (this.ctx.miterLimit = 2, this.ctx.lineJoin = "circle", 
        this.ctx.strokeStyle = options.strokeStyle, this.ctx.lineWidth = options.strokeLineWidth, 
        this.ctx.strokeText(options.text, options.x, options.y)), this.ctx.lineWidth = options.fillLineWidth, 
        this.ctx.fillStyle = options.fillStyle, this.ctx.fillText(options.text, options.x, options.y), 
        this.ctx.restore();
    }, ArtGenerator.prototype.drawImage = function(options) {
        var image, x, y;
        if (null == options && (options = {}), null == options.key) throw "key not found";
        if (null == options.x && (options.x = 0), null == options.y && (options.y = 0), 
        null == options.angle && (options.angle = 0), x = options.x, y = options.y, image = this.tm.items[options.key].image, 
        0 !== options.angle && (this.ctx.save(), this.ctx.translate(options.x + image.width / 2, options.y + image.height / 2), 
        this.ctx.rotate(options.angle * Math.PI / 180), x = -image.width / 2, y = -image.height / 2), 
        this.ctx.drawImage(image, x, y), 0 !== options.angle) return this.ctx.restore();
    }, ArtGenerator.prototype.clear = function() {
        return this.ctx.clearRect(0, 0, this.options.width, this.options.height);
    }, ArtGenerator;
}();

var BaseText, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

BaseText = function(superClass) {
    function BaseText(options) {
        var geom, material;
        null == options && (options = {}), BaseText.__super__.constructor.call(this), this.canvasW = options.canvasW || 512, 
        this.canvasH = options.canvasH || 512, this.w = options.w || 4, this.h = options.h || 4, 
        this.margin = options.margin, this.lineHeight = options.lineHeight, this.align = options.align, 
        this.font = options.font, this.fillStyle = options.fillStyle, this.fillLineWidth = options.fillLineWidth, 
        this.strokeStyle = options.strokeStyle, this.strokeLineWidth = options.strokeLineWidth, 
        this.text = options.text, this.x = options.x, this.y = options.y, this.dynamicTexture = new THREEx.DynamicTexture(this.canvasW, this.canvasH), 
        this.setText(this.text), geom = new THREE.PlaneGeometry(this.w, this.h), material = new THREE.MeshBasicMaterial({
            map: this.dynamicTexture.texture,
            transparent: !0
        }), this.mesh = new THREE.Mesh(geom, material);
    }
    return extend(BaseText, superClass), BaseText.prototype.setText = function(text) {
        return "" !== text && null != text || (text = " "), this.text = text.toString(), 
        this.clear(), this.dynamicTexture.drawTextCooked({
            text: this.text,
            margin: this.margin,
            lineHeight: this.lineHeight,
            align: this.align,
            fillStyle: this.fillStyle,
            fillLineWidth: this.fillLineWidth,
            strokeStyle: this.strokeStyle,
            strokeLineWidth: this.strokeLineWidth,
            x: this.x,
            y: this.y,
            font: this.font
        });
    }, BaseText.prototype.clear = function() {
        return this.dynamicTexture.clear();
    }, BaseText.prototype.getTextWidth = function(s) {
        return this.dynamicTexture.context.measureText(s).width;
    }, BaseText;
}(BaseModel);

var Cinematic;

Cinematic = function() {
    function Cinematic(json, scene) {
        this.loaded = !1, null != scene && (this.scene = scene), this.cameras = [], this.items = [], 
        this.json = json, this._initUI(), this._loadFog(), this._loadMaterials(), this._loadCameras(), 
        this._loadItems(), this._loadSceneProperties(), this.loaded = !0;
    }
    return Cinematic.prototype._initUI = function() {
        var ceButtonType, i, len, ref;
        for (ref = Utils.CE_BUTTON_TYPES, i = 0, len = ref.length; i < len; i++) ceButtonType = ref[i], 
        null != this.json.ui && null != this.json.ui[ceButtonType + "Button"] && this.json.ui[ceButtonType + "Button"].enabled && (this.json.ui[ceButtonType + "Button"].type = ceButtonType, 
        Helper.addCEButton(this.json.ui[ceButtonType + "Button"]));
        return null != this.json.engine.orientation && Helper.orientation(this.json.engine.orientation), 
        Helper.fade({
            type: "out"
        });
    }, Cinematic.prototype._loadFog = function() {
        if (null != this.json.fog && this.json.fog.enabled) return this.scene.fog = Helper.fog(this.json.fog);
    }, Cinematic.prototype._loadMaterials = function() {
        var art, i, item, key, len, material, ref, results, so;
        for (ref = this.json.assets, results = [], i = 0, len = ref.length; i < len; i++) item = ref[i], 
        "graffiti" === item.type ? (key = Utils.getKeyName(item.destPath, Utils.SAVE_URLS), 
        so = SaveObjectManager.get().items[key], art = new ArtGenerator({
            width: so.width,
            height: so.height
        }), art.fromJson(so), material = Helper.materialFromCanvas(art.canvas), results.push(MaterialManager.load(key, material))) : results.push(void 0);
        return results;
    }, Cinematic.prototype._loadCameras = function() {
        var camera, i, item, len, ref, results, vector;
        for (ref = this.json.cameras, results = [], i = 0, len = ref.length; i < len; i++) item = ref[i], 
        camera = Helper.camera(item), this.setId(camera, item), this.setXYZProp("position", camera, item), 
        this.setXYZProp("rotation", camera, item), null != item.lookAt && (vector = this.getLookAtVector(item.lookAt), 
        camera.lookAt(vector)), results.push(this.cameras.push(camera));
        return results;
    }, Cinematic.prototype._loadItems = function() {
        var baseModel, i, item, len, obj, playlist, ref, results;
        for (ref = this.json.items, results = [], i = 0, len = ref.length; i < len; i++) switch (item = ref[i], 
        item.type) {
          case "playlist":
            playlist = new Playlist(item.items), this.setId(item, item), this.setId(playlist, item), 
            playlist.json = item, results.push(this.items.push(playlist));
            break;

          case "water":
            item[item.type] = item, baseModel = Helper[item.type](engine, this.scene, item), 
            obj = baseModel.mesh, results.push(this.cinemize(item, baseModel, obj));
            break;

          case "mirror":
            item[item.type] = item, baseModel = Helper[item.type](engine, item), obj = baseModel.mesh, 
            results.push(this.cinemize(item, baseModel, obj));
            break;

          case "terrain":
          case "particle":
            baseModel = Helper[item.type](item), obj = baseModel.mesh, results.push(this.cinemize(item, baseModel, obj));
            break;

          case "cube":
          case "plane":
          case "model":
          case "threePointLight":
          case "sunSetLight":
          case "ambientLight":
          case "light":
          case "pointLight":
          case "skySphere":
          case "graffiti":
          case "forest":
            obj = Helper[item.type](item), baseModel = new BaseModel(), baseModel.mesh = obj, 
            results.push(this.cinemize(item, baseModel, obj));
            break;

          default:
            results.push(console.log("unknown item type " + item.type));
        }
        return results;
    }, Cinematic.prototype._loadSceneProperties = function() {
        if (null != this.json.engine.camera) return engine.setCamera(this.cameras[this.json.engine.camera]);
    }, Cinematic.prototype.cinemize = function(item, baseModel, obj) {
        if (this.setId(baseModel, item), this.setId(obj, item), this.setName(obj, item), 
        this.setXYZProp("position", obj, item), this.setXYZProp("rotation", obj, item), 
        this.setXYZProp("scale", obj, item, 1), null != item.lookAt && engine.camera.lookAt(this.toVector3(item.lookAt)), 
        this.items.push(baseModel), this.scene) return this.scene.add(baseModel.mesh);
    }, Cinematic.prototype.addAll = function(scene) {
        var i, item, len, ref, results;
        for (ref = this.items, results = [], i = 0, len = ref.length; i < len; i++) item = ref[i], 
        item.mesh && results.push(scene.add(item.mesh));
        return results;
    }, Cinematic.prototype.find = function(id) {
        return this.items.where({
            ceId: id
        }).first() || this.cameras.where({
            ceId: id
        }).first();
    }, Cinematic.prototype.allMeshes = function() {
        var i, item, len, meshes, ref;
        for (meshes = [], ref = this.items, i = 0, len = ref.length; i < len; i++) item = ref[i], 
        null != item.mesh && meshes.push(item.mesh);
        return meshes;
    }, Cinematic.prototype.init = function(scene, options) {
        return null == options && (options = {}), this.addAll(scene);
    }, Cinematic.prototype.tick = function(tpf) {
        var action, i, item, j, len, len1, ref, ref1, script;
        if (!0 === this.loaded) {
            for (ref = this.items, i = 0, len = ref.length; i < len; i++) item = ref[i], item instanceof BaseParticle2 && item.tick(tpf), 
            item instanceof Mirror && item.tick(tpf), item instanceof Water && item.tick(tpf);
            if (!this.json.scripts.where({
                processing: !0
            }).any()) {
                if (null == (script = this.json.scripts.where({
                    processed: void 0
                }).first())) return "finished";
                for (script.processed = !0, script.processing = !0, ref1 = script.actions, j = 0, 
                len1 = ref1.length; j < len1; j++) action = ref1[j], this.processAction(action);
                return this.setNotProcessing(script);
            }
        }
    }, Cinematic.prototype.processAction = function(action) {
        var asset, i, isCamera, isSound, len, ref, target;
        if (null == action.delay && (action.delay = 0), null != action.target) {
            if (null == (target = this.items.where({
                ceId: action.target
            }).first()) && (target = {
                mesh: this.cameras.where({
                    ceId: action.target
                }).first()
            }, null != target.mesh && (isCamera = !0), null == target.mesh)) {
                for (ref = this.json.assets, i = 0, len = ref.length; i < len; i++) asset = ref[i], 
                "sound" === asset.type && Utils.getKeyName(asset.destPath, Utils.AUDIO_URLS) === action.target && (target = {
                    mesh: asset
                }, isSound = !0);
                if (null == target.mesh && !isCamera && !isSound) throw new Error("action.target " + action.target + " not found");
            }
            return setTimeout(function(_this) {
                return function() {
                    var vector;
                    return isSound ? (action.sound.key = action.target, SoundManager.get().cmd(action.sound)) : null != target.json && "playlist" === target.json.type ? target.cmd(action.sound) : (null != action.lookAt && (vector = _this.getLookAtVector(action.lookAt), 
                    target.mesh.lookAt(vector)), null != action.animate && !0 !== isCamera && (null != action.animate.stopOtherAnimations && target.stopAnimations(), 
                    target.animate(null, action.animate)), null != action.tween ? (action.tween.mesh = target.mesh, 
                    Helper.tween(action.tween).start()) : void 0);
                };
            }(this), action.delay);
        }
    }, Cinematic.prototype.setNotProcessing = function(script) {
        var duration;
        return duration = this.getScriptDuration(script), setTimeout(function(_this) {
            return function() {
                return script.processing = !1;
            };
        }(), duration);
    }, Cinematic.prototype.getScriptDuration = function(script) {
        var action, actionDuration, animateDuration, i, len, longestDuration, ref;
        for (longestDuration = 0, ref = script.actions, i = 0, len = ref.length; i < len; i++) action = ref[i], 
        null != action.animate && !0 !== action.animate.loop && (animateDuration = action.animate.waitScript || 0, 
        (animateDuration += action.delay || 0) > longestDuration && (longestDuration = animateDuration)), 
        null != action.tween && (actionDuration = action.tween.duration || Helper.defaultTweenDuration, 
        (actionDuration += action.delay || 0) > longestDuration && (longestDuration = actionDuration));
        return longestDuration;
    }, Cinematic.prototype.getLookAtVector = function(json) {
        var coord, i, len, ref, vector;
        for (vector = this.toVector3(json), ref = [ "x", "y", "z" ], i = 0, len = ref.length; i < len; i++) coord = ref[i], 
        vector[coord] += json["offset" + coord.toUpperCase()] || 0;
        return vector;
    }, Cinematic.prototype.toVector3 = function(hash) {
        return null == hash.x && (hash.x = 0), null == hash.y && (hash.y = 0), null == hash.z && (hash.z = 0), 
        new THREE.Vector3(hash.x, hash.y, hash.z);
    }, Cinematic.prototype.setId = function(object, json) {
        return object.ceId = json.id;
    }, Cinematic.prototype.setName = function(object, json) {
        return object.name = json.id;
    }, Cinematic.prototype.setXYZProp = function(prop, object, json, def) {
        var base, coordinate, i, len, newJs, ref;
        for (null == def && (def = 0), null == json[prop] && (json[prop] = {}), ref = [ "x", "y", "z" ], 
        i = 0, len = ref.length; i < len; i++) coordinate = ref[i], null == (base = json[prop])[coordinate] && (base[coordinate] = def), 
        "string" == typeof json[prop][coordinate] && json[prop][coordinate].contains("PI") && (newJs = json[prop][coordinate].replace("PI", "Math.PI"), 
        json[prop][coordinate] = eval(newJs));
        return object[prop].set(json[prop].x, json[prop].y, json[prop].z);
    }, Cinematic;
}();

var CinematicScene, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

CinematicScene = function(superClass) {
    function CinematicScene(json) {
        CinematicScene.__super__.constructor.call(this), this.cinematic = new Cinematic(json, this.scene);
    }
    return extend(CinematicScene, superClass), CinematicScene.fromJson = function(json) {
        return new CinematicScene(json);
    }, CinematicScene.fromSaveObjectKey = function(key) {
        var json;
        return json = SaveObjectManager.get().items[key], this.fromJson(json);
    }, CinematicScene.prototype.tick = function(tpf) {
        if ("finished" === this.cinematic.tick(tpf)) return this.afterCinematic(tpf);
    }, CinematicScene.prototype.afterCinematic = function(tpf) {}, CinematicScene.prototype.doMouseEvent = function(event, ray) {}, 
    CinematicScene.prototype.doKeyboardEvent = function(event) {}, CinematicScene.prototype.init = function(options) {
        return this.cinematic.init(this.scene, options);
    }, CinematicScene.getAssets = function(key) {
        return SaveObjectManager.get().items[key].assets;
    }, CinematicScene;
}(BaseScene);

var Bolt, BranchLightning, LightningBolt, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

Bolt = function(superClass) {
    function Bolt(src, dest, thickness, color, density, circumference) {
        var geometry, material, results;
        null == thickness && (thickness = 1), null == color && (color = 255), null == density && (density = 1), 
        null == circumference && (circumference = 1), Bolt.__super__.constructor.call(this), 
        this.src = src, this.dest = dest, this.color = color, this.thickness = thickness, 
        this.density = density, this.circumference = circumference, material = new THREE.LineBasicMaterial({
            transparent: !0,
            color: this.color,
            linewidth: this.thickness
        }), geometry = new THREE.Geometry(), this.mesh = new THREE.Line(geometry, material), 
        results = LightningBolt.createBolt(this.src, this.dest, this.thickness, this.density, this.circumference), 
        this.setSegments(results);
    }
    return extend(Bolt, superClass), Bolt.prototype.strike = function(src, dest) {
        return null == src && (src = this.src), null == dest && (dest = this.dest), this.src = src, 
        this.dest = dest, this.setSegments(LightningBolt.createBolt(src, dest, this.thickness, this.density, this.circumference));
    }, Bolt.prototype.setSegments = function(lines) {
        var geometry, k, len1, line, vertices;
        for (geometry = new THREE.Geometry(), vertices = [], k = 0, len1 = lines.length; k < len1; k++) line = lines[k], 
        -1 === vertices.indexOf(line.src) && vertices.push(line.src), -1 === vertices.indexOf(line.dest) && vertices.push(line.dest);
        return geometry.vertices = vertices, geometry.verticesNeedUpdate = !0, this.mesh.geometry = geometry;
    }, Bolt.prototype.getPointOnBolt = function(percentage) {
        var dest, pointIndex, rounded, src;
        return pointIndex = percentage * (this.mesh.geometry.vertices.size() - 1), rounded = Math.round(pointIndex), 
        parseInt(pointIndex) === rounded ? (0 === rounded && (rounded = 1), src = this.mesh.geometry.vertices[rounded - 1], 
        dest = this.mesh.geometry.vertices[rounded]) : (rounded === this.mesh.geometry.vertices.size() - 1 && (rounded = this.mesh.geometry.vertices.size() - 2), 
        src = this.mesh.geometry.vertices[rounded], dest = this.mesh.geometry.vertices[rounded + 1]), 
        this.getPointInBetweenByPerc(src, dest, .5);
    }, Bolt.prototype.getPointInBetweenByPerc = function(pointA, pointB, percentage) {
        var dir, len;
        return dir = pointB.clone().sub(pointA), len = dir.length(), dir = dir.normalize().multiplyScalar(len * percentage), 
        pointA.clone().add(dir);
    }, Bolt.createBolt = function(src, dest, thickness, density, circumference) {
        var displacement, displacementZ, envelope, i, jaggedness, k, l, len1, length, normal, point, pos, positions, prevDisplacement, prevDisplacementZ, prevPoint, ref, results, scale, sway, tangent, x, y, z;
        for (results = [], tangent = dest.clone().sub(src.clone()), normal = new THREE.Vector3(tangent.y, -tangent.x, tangent.z).normalize(), 
        length = Helper.distanceTo(src, dest), positions = [ 0 ], i = k = 0, ref = length / 4 * density; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) positions.push(Math.random());
        for (positions = positions.sort(), sway = 80, jaggedness = 1 / sway / circumference, 
        prevPoint = src.clone(), prevDisplacement = 0, prevDisplacementZ = 0, i = 0, l = 0, 
        len1 = positions.length; l < len1; l++) pos = positions[l], 0 !== i ? (scale = length * jaggedness * (pos - positions[i - 1]), 
        envelope = pos > .95 ? 20 * (1 - pos) : 1, displacement = Helper.random(-sway, sway) + Math.random(), 
        displacement -= (displacement - prevDisplacement) * (1 - scale), displacement *= envelope, 
        displacementZ = Helper.random(-sway, sway) + Math.random(), displacementZ -= (displacementZ - prevDisplacementZ) * (1 - scale), 
        displacementZ *= envelope, x = src.x + pos * tangent.x + displacement * normal.x, 
        y = src.y + pos * tangent.y + displacement * normal.y, z = src.z + pos * tangent.z + displacement * normal.z, 
        z = displacementZ, point = new THREE.Vector3(x, y, z), results.push({
            src: prevPoint,
            dest: point
        }), prevPoint = point, prevDisplacement = displacement, prevDisplacementZ = displacementZ, 
        i += 1) : i += 1;
        return results.push({
            src: prevPoint,
            dest: dest
        }), results;
    }, Bolt;
}(BaseModel), LightningBolt = function(superClass) {
    function LightningBolt(src, dest, thickness, color, density, circumference) {
        null == thickness && (thickness = 1), null == color && (color = 255), null == density && (density = 1), 
        LightningBolt.__super__.constructor.call(this, src, dest, thickness, color, density, circumference), 
        this.opacity = 0, this.bolts = [], this.numBranches = 0;
    }
    return extend(LightningBolt, superClass), LightningBolt.prototype.addBranch = function(thickness, color, density, circumference) {
        var newBolt;
        return this.numBranches += 1, newBolt = new LightningBolt(new THREE.Vector3(), new THREE.Vector3(), thickness, color, density, circumference), 
        this.bolts.push(newBolt), this.mesh.add(newBolt.mesh), newBolt;
    }, LightningBolt.prototype._getBranchPoints = function() {
        var branchPoints, k, ref;
        for (branchPoints = [], k = 0, ref = this.numBranches; 0 <= ref ? k < ref : k > ref; 0 <= ref ? ++k : --k) branchPoints.push(Math.random());
        return branchPoints.sort();
    }, LightningBolt.prototype._getTargetBranchPoint = function(bolt) {
        var branchPoints;
        return branchPoints = this._getBranchPoints(), branchPoints[this.bolts.indexOf(bolt)];
    }, LightningBolt.prototype.getChildBoltStart = function(bolt) {
        var targetBranchPoint;
        return targetBranchPoint = this._getTargetBranchPoint(bolt), this.getPointOnBolt(targetBranchPoint);
    }, LightningBolt.prototype.getChildBoltEnd = function(bolt) {
        var boltSrc, diff, targetBranchPoint, x, y, z;
        return targetBranchPoint = this._getTargetBranchPoint(bolt), boltSrc = this.getChildBoltStart(bolt), 
        diff = new THREE.Vector3(this.dest.x - this.src.x, this.dest.y - this.src.y, this.dest.z - this.src.z), 
        x = diff.x * (1 - targetBranchPoint) + boltSrc.x, y = diff.y * (1 - targetBranchPoint) + boltSrc.y, 
        z = diff.z * (1 - targetBranchPoint) + boltSrc.z, new THREE.Vector3(x, y, z);
    }, LightningBolt.prototype.strike = function(src, dest) {
        var bolt, boltEnd, boltSrc, k, len1, ref, results1;
        for (LightningBolt.__super__.strike.call(this, src, dest), ref = this.bolts, results1 = [], 
        k = 0, len1 = ref.length; k < len1; k++) bolt = ref[k], boltSrc = this.getChildBoltStart(bolt), 
        boltEnd = this.getChildBoltEnd(bolt), results1.push(bolt.strike(boltSrc, boltEnd));
        return results1;
    }, LightningBolt;
}(Bolt), BranchLightning = function(superClass) {
    function BranchLightning(src, dest, thickness, color, density, circumference, addBranches) {
        BranchLightning.__super__.constructor.call(this, src, dest, thickness, color, density, circumference), 
        null != addBranches ? addBranches(this) : this.addBranches(this), this.strike();
    }
    return extend(BranchLightning, superClass), BranchLightning.prototype.addBranches = function(parentBolt) {
        var j, k, newBolt, results1;
        for (results1 = [], k = 0; k < 4; ++k) newBolt = parentBolt.addBranch(parentBolt.thickness / 2, "yellow", parentBolt.density / 2, parentBolt.circumference), 
        results1.push(function() {
            var l, results2;
            for (results2 = [], j = l = 0; l < 2; j = ++l) results2.push(newBolt.addBranch(newBolt.thickness / 3, "orange", newBolt.density / 3, newBolt.circumference));
            return results2;
        }());
        return results1;
    }, BranchLightning;
}(LightningBolt);

var LoadingScene, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

LoadingScene = function(superClass) {
    function LoadingScene(urls, hasFinishedLoading) {
        if (null == hasFinishedLoading && (hasFinishedLoading = void 0), LoadingScene.__super__.constructor.call(this), 
        !(urls instanceof Array)) throw "urls needs to be an array";
        null != hasFinishedLoading && (this.hasFinishedLoading = hasFinishedLoading), this.preStart(), 
        this.loadAssets(urls);
    }
    return extend(LoadingScene, superClass), LoadingScene.LOADING_OPTIONS = {
        fillStyle: "white",
        font: "64px Arial",
        align: "center",
        text: "loading",
        model: Helper.cube({
            color: "white",
            size: .5
        }),
        camera: Helper.camera({
            aspect: window.innerWidth / window.innerHeight
        })
    }, LoadingScene.prototype.loadAssets = function(assets) {
        var asset, i, interval, len, url;
        for (i = 0, len = assets.length; i < len; i++) asset = assets[i], url = "string" == typeof asset ? asset : asset.destPath, 
        url.endsWithAny(Utils.SAVE_URLS) ? this._loadSaveObject(url) : url.endsWithAny(Utils.JSON_URLS) ? this._loadJsonModel(url) : url.endsWithAny(Utils.IMG_URLS) ? this._loadTexture(url) : url.endsWithAny(Utils.AUDIO_URLS) ? this._loadAudio(url) : console.log("WARNING: " + url + " is not a valid format");
        return interval = setInterval(function(_this) {
            return function() {
                if (console.ce("Loaded " + _this.getLoadedPercent() + "%"), _this.isLoadingDone()) return clearInterval(interval), 
                console.ce("Finished loading"), _this.hasFinishedLoading();
            };
        }(this), 100);
    }, LoadingScene.prototype.preStart = function() {
        var cam, engine;
        return engine = Hodler.item("engine"), engine.setClearColor(0), cam = LoadingScene.LOADING_OPTIONS.camera, 
        cam.position.set(0, 0, 10), cam.lookAt(Helper.zero), engine.setCamera(cam), this.scene.add(Helper.ambientLight()), 
        this.scene.add(Helper.ambientLight()), this.scene.add(Helper.light()), this.loadingAnimation = LoadingScene.LOADING_OPTIONS.model, 
        this.loadingAnimation.position.set(0, -.5, 0), this.scene.add(this.loadingAnimation), 
        this.text = new BaseText(LoadingScene.LOADING_OPTIONS), this.text.mesh.position.set(0, -3, 0), 
        this.scene.add(this.text.mesh);
    }, LoadingScene.prototype.isLoadingDone = function() {
        return this.jmm.hasFinishedLoading() && this.tm.hasFinishedLoading() && this.som.hasFinishedLoading() && this.sm.hasFinishedLoading();
    }, LoadingScene.prototype.getLoadedCount = function() {
        return this.jmm.loadCount + this.tm.loadCount + this.som.loadCount + this.sm.loadCount;
    }, LoadingScene.prototype.getAllAssetsCount = function() {
        var count, i, len, loader, ref;
        for (count = 0, ref = [ this.jmm, this.tm, this.som, this.sm ], i = 0, len = ref.length; i < len; i++) loader = ref[i], 
        count += Object.keys(loader.items).size();
        return count;
    }, LoadingScene.prototype.getLoadedPercent = function(decimals) {
        return null == decimals && (decimals = 2), Math.round(this.getLoadedCount() / this.getAllAssetsCount() * 100, decimals);
    }, LoadingScene.prototype._loadJsonModel = function(url) {
        var name;
        return name = Utils.getKeyName(url, Utils.JSON_URLS), console.ce("Loading model '" + name + "' from '" + url + "'"), 
        this.jmm.load(name, url);
    }, LoadingScene.prototype._loadTexture = function(url) {
        var name;
        return name = Utils.getKeyName(url, Utils.IMG_URLS), console.ce("Loading texture '" + name + "' from '" + url + "'"), 
        this.tm.load(name, url);
    }, LoadingScene.prototype._loadSaveObject = function(url) {
        var name;
        return name = Utils.getKeyName(url, Utils.SAVE_URLS), console.ce("Loading save object '" + name + "' from '" + url + "'"), 
        this.som.load(name, url);
    }, LoadingScene.prototype._loadAudio = function(url) {
        var name;
        return name = Utils.getKeyName(url, Utils.AUDIO_URLS), console.ce("Loading audio '" + name + "' from '" + url + "'"), 
        this.sm.load(name, url);
    }, LoadingScene.prototype.init = function() {
        return this.preStart();
    }, LoadingScene.prototype.tick = function(tpf) {
        if (null != this.loadingAnimation) return this.loadingAnimation.rotation.x += tpf, 
        this.loadingAnimation.rotation.y += tpf;
    }, LoadingScene.prototype.doMouseEvent = function(event, raycaster) {}, LoadingScene.prototype.doKeyboardEvent = function(event) {}, 
    LoadingScene.prototype.hasFinishedLoading = function() {
        if (null != this.hasFinishedLoading) return this.hasFinishedLoading();
        throw "not implemented";
    }, LoadingScene;
}(BaseScene);

var LookAtTimer;

LookAtTimer = function() {
    function LookAtTimer(from, mesh) {
        this.mesh = mesh, this.walker = new Walker(from), this.amount = 0, this.enabled = !0;
    }
    return LookAtTimer.prototype.tick = function(tpf) {
        var intersection;
        if (this.enabled) return intersection = this.walker.fromWorldDirection().intersects(this.mesh).first(), 
        null != intersection ? (this.amount += tpf, this.amount > 1 && (this.amount = 1)) : (this.amount -= tpf, 
        this.amount < 0 && (this.amount = 0)), this._transform(tpf);
    }, LookAtTimer.prototype.isSelected = function() {
        return 1 === this.amount;
    }, LookAtTimer.prototype._transform = function(tpf) {
        return this.mesh.scale.set(1 + this.amount, 1 + this.amount, 1 + this.amount);
    }, LookAtTimer;
}();

var Mirror, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

Mirror = function(superClass) {
    function Mirror(engine, options) {
        var base, base1, base2, base3, planeGeo;
        null == options && (options = {}), null == options.width && (options.width = Utils.PLANE_DEFAULT_WIDTH), 
        null == options.height && (options.height = Utils.PLANE_DEFAULT_HEIGHT), null == options.mirror && (options.mirror = {}), 
        null == (base = options.mirror).clipBias && (base.clipBias = Utils.MIRROR_DEFAULT_CLIP_BIAS), 
        null == (base1 = options.mirror).textureWidth && (base1.textureWidth = Utils.MIRROR_DEFAULT_TEXTURE_WIDTH), 
        null == (base2 = options.mirror).textureHeight && (base2.textureHeight = Utils.MIRROR_DEFAULT_TEXTURE_HEIGHT), 
        null == (base3 = options.mirror).color && (base3.color = Utils.MIRROR_DEFAULT_COLOR), 
        planeGeo = new THREE.PlaneBufferGeometry(options.width, options.height), this.mirror = new THREE.Mirror(engine.renderer, engine.camera, options.mirror), 
        this.mesh = new THREE.Mesh(planeGeo, this.mirror.material), this.mesh.add(this.mirror), 
        this.mesh.rotateX(-Math.PI / 2);
    }
    return extend(Mirror, superClass), Mirror.prototype.tick = function() {
        return this.mirror.render();
    }, Mirror;
}(BaseModel);

var BaseModifier, FadeInModifier, FadeModifier, NoticeMeModifier, ScaleModifier, ShakeModifier, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

BaseModifier = function() {
    function BaseModifier() {}
    return BaseModifier.prototype.start = function() {
        return this.tween.start();
    }, BaseModifier.prototype.stop = function() {
        return this.tween.stop();
    }, BaseModifier.prototype.delay = function(delay) {
        return null == delay && (delay = 0), this.tween.delay(delay), this;
    }, BaseModifier;
}(), FadeInModifier = function(superClass) {
    function FadeInModifier(model) {
        this.tween = new TWEEN.Tween({
            x: .5
        }).to({
            x: 1
        }, 700).easing(TWEEN.Easing.Exponential.Out), this.tween.onUpdate(function() {
            return model.setOpacity(this.x);
        });
    }
    return extend(FadeInModifier, superClass), FadeInModifier;
}(BaseModifier), FadeModifier = function(superClass) {
    function FadeModifier(model, srcX, destX, t) {
        this.tween = new TWEEN.Tween({
            x: srcX
        }).to({
            x: destX
        }, t).easing(TWEEN.Easing.Exponential.Out), this.tween.onUpdate(function() {
            return model.setOpacity(this.x);
        });
    }
    return extend(FadeModifier, superClass), FadeModifier;
}(BaseModifier), ShakeModifier = function(superClass) {
    function ShakeModifier(model, t) {
        var ease, originalRZ;
        ease = TWEEN.Easing.Linear.None, originalRZ = model.mesh.rotation.z, this.tween = new TWEEN.Tween({
            x: 0
        }).to({
            x: t
        }, t).easing(ease), this.tween.onUpdate(function() {
            if (model.mesh.rotation.z += Math.random() - .5, 1 === this.x) return model.mesh.rotation.z = originalRZ;
        });
    }
    return extend(ShakeModifier, superClass), ShakeModifier;
}(BaseModifier), ScaleModifier = function(superClass) {
    function ScaleModifier(model, srcX, destX, t) {
        var ease;
        ease = TWEEN.Easing.Linear.None, this.tween = new TWEEN.Tween({
            x: srcX
        }).to({
            x: destX
        }, t).easing(ease), this.tween.onUpdate(function() {
            return model.mesh.scale.set(this.x, this.x, this.x);
        });
    }
    return extend(ScaleModifier, superClass), ScaleModifier;
}(BaseModifier), NoticeMeModifier = function(superClass) {
    function NoticeMeModifier(model, srcX, destX, t) {
        this.scale1 = new ScaleModifier(model, srcX, destX, t / 2), this.scale2 = new ScaleModifier(model, destX, srcX, t / 2), 
        this.t = t;
    }
    return extend(NoticeMeModifier, superClass), NoticeMeModifier.prototype.start = function() {
        return this.scale1.start(), this.scale2.start();
    }, NoticeMeModifier.prototype.delay = function(delay) {
        return null == delay && (delay = 0), this.scale1.delay(delay), this.scale2.delay(delay + this.t / 2), 
        this;
    }, NoticeMeModifier;
}(BaseModifier);

var SpotLight, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

SpotLight = function(superClass) {
    function SpotLight(x, y, z, r1, r2, height) {
        var geometry;
        null == r1 && (r1 = .1), null == r2 && (r2 = 2.5), null == height && (height = 5), 
        geometry = new THREE.CylinderGeometry(r1, r2, height, 64, 40, !0), geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -geometry.parameters.height / 2, 0)), 
        geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2)), this.material = new THREEx.VolumetricSpotLightMaterial(), 
        this.mesh = new THREE.Mesh(geometry, this.material), this.mesh.position.set(x, y, z), 
        this.mesh.lookAt(new THREE.Vector3(0, 0, 0)), this.setColor("white"), this.material.uniforms.spotPosition.value = this.mesh.position, 
        this.spotLight = new THREE.SpotLight(), this.spotLight.position.copy(this.mesh.position), 
        this.spotLight.color = this.mesh.material.uniforms.lightColor.value, this.spotLight.exponent = 30, 
        this.spotLight.angle = Math.PI / 3, this.spotLight.intensity = 3, this.spotLight.castShadow = !0, 
        this.spotLight.shadow.camera.near = .01, this.spotLight.shadow.camera.far = 100, 
        this.spotLight.shadow.camera.fov = 45, this.spotLight.shadow.camera.left = -8, this.spotLight.shadow.camera.right = 8, 
        this.spotLight.shadow.camera.top = 8, this.spotLight.shadow.camera.bottom = -8, 
        this.spotLight.shadow.bias = .1, this.spotLight.shadow.darkness = .5, this.spotLight.shadow.mapSize.width = 1024, 
        this.spotLight.shadow.mapSize.height = 1024, this.direction = new THREE.Vector3(0, 0, 0), 
        this.lastDir = 0;
    }
    return extend(SpotLight, superClass), SpotLight.prototype.lookAt = function(node) {
        var target;
        return target = node.position, this.mesh.lookAt(target), this.spotLight.target.position.copy(target);
    }, SpotLight.prototype.addToScene = function(scene) {
        return scene.add(this.mesh), scene.add(this.spotLight), scene.add(this.spotLight.target);
    }, SpotLight.prototype.setColor = function(color) {
        return this.material.uniforms.lightColor.value.set(color);
    }, SpotLight;
}(BaseModel);

var Terrain, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

Terrain = function(superClass) {
    function Terrain(textureUrl, width, height, wSegments, hSegments) {
        var geom, json, key, mat;
        1 === arguments.length ? (json = textureUrl, key = Utils.getKeyName(json.texture.destPath, Utils.IMG_URLS), 
        mat = new THREE.MeshLambertMaterial({
            map: TextureManager.get().items[key]
        }), geom = new THREE.PlaneGeometry(json.width, json.height, json.wSegments, json.hSegments)) : (mat = new THREE.MeshLambertMaterial({
            map: THREE.ImageUtils.loadTexture(textureUrl)
        }), geom = new THREE.PlaneGeometry(width, height, wSegments, hSegments)), this.mesh = new THREE.Mesh(geom, mat), 
        this.mesh.rotation.x -= Math.PI / 2, this.raycaster = new THREE.Raycaster();
    }
    return extend(Terrain, superClass), Terrain.prototype.getHeightAt = function(position) {
        var intersects;
        return this.raycaster.set(new THREE.Vector3(position.x, 1e3, position.z), Helper.down), 
        intersects = this.raycaster.intersectObject(this.mesh), null != intersects[0] ? intersects[0].point.y : 0;
    }, Terrain.prototype.applyHeightmap = function(imageData) {
        var i, k, len, ref, results, vertice;
        for (i = 0, ref = this.mesh.geometry.vertices, results = [], k = 0, len = ref.length; k < len; k++) vertice = ref[k], 
        vertice.z = imageData[i], results.push(i++);
        return results;
    }, Terrain.heightmap = function(textureUrl, heightmapUrl, width, height, wSegments, hSegments, scale, scene) {
        return null == scale && (scale = 1), THREE.ImageUtils.loadTexture(heightmapUrl, THREE.UVMapping, function(_this) {
            return function(hm) {
                var terrain;
                return hm.heightData = Terrain.getHeightData(hm.image, scale), null == wSegments && (wSegments = hm.image.width - 1), 
                null == hSegments && (hSegments = hm.image.height - 1), terrain = new Terrain(textureUrl, width, height, wSegments, hSegments), 
                terrain.applyHeightmap(hm.heightData), null == scene && (scene = SceneManager.currentScene()), 
                scene.terrain = terrain, scene.scene.add(terrain.mesh);
            };
        }());
    }, Terrain.getHeightData = function(img, scale) {
        var all, canvas, context, data, i, imgd, j, pix, size;
        for (null == scale && (scale = 1), canvas = document.createElement("canvas"), canvas.width = img.width, 
        canvas.height = img.height, context = canvas.getContext("2d"), size = img.width * img.height, 
        data = new Float32Array(size), context.drawImage(img, 0, 0), i = 0; i < size; ) data[i] = 0, 
        i++;
        for (imgd = context.getImageData(0, 0, img.width, img.height), pix = imgd.data, 
        j = 0, i = 0; i < pix.length; ) all = pix[i] + pix[i + 1] + pix[i + 2], data[j++] = all / (12 * scale), 
        i += 4;
        return data;
    }, Terrain.fromJson = function(assetJson) {
        var hm, json, k, key, l, len, len1, ref, ref1, terrain;
        if ("terrain" !== assetJson.type) throw new Error("not a terrain");
        if (null == assetJson.key) throw new Error("key missing");
        for (json = SaveObjectManager.get().items[assetJson.key], ref = [ "width", "height", "scale", "texture", "heightmap" ], 
        k = 0, len = ref.length; k < len; k++) if (key = ref[k], null == json[key]) throw new Error(key + " missing for terrain");
        for (ref1 = [ "texture", "heightmap" ], l = 0, len1 = ref1.length; l < len1; l++) if (key = ref1[l], 
        null == json[key].destPath) throw new Error(key + ".destPath missing for terrain");
        return key = Utils.getKeyName(json.heightmap.destPath, Utils.IMG_URLS), hm = TextureManager.get().items[key], 
        hm.heightData = Terrain.getHeightData(hm.image, json.scale), null == json.wSegments && (json.wSegments = hm.image.width - 1), 
        null == json.hSegments && (json.hSegments = hm.image.height - 1), terrain = new Terrain(json), 
        terrain.applyHeightmap(hm.heightData), terrain;
    }, Terrain;
}(BaseModel);

var Tree, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

Tree = function(superClass) {
    function Tree(material, size, children) {
        var sizeModifier;
        null == size && (size = 1), null == children && (children = 5), this.mesh = new THREE.Object3D(), 
        null == material && (material = Helper.sampleShaderMaterial()), sizeModifier = .65, 
        this.branchPivots = [], this.mesh = this.createBranch(size, material, children, !1, sizeModifier);
    }
    return extend(Tree, superClass), Tree.prototype.createBranch = function(size, material, children, isChild, sizeModifier) {
        var branch, branchEnd, branchPivot, c, child, endSize, length;
        if (branchPivot = new THREE.Object3D(), branchEnd = new THREE.Object3D(), this.branchPivots.push(branchPivot), 
        length = Math.random() * size * 10 + 5 * size, endSize = 0 === children ? 0 : size * sizeModifier, 
        branch = new THREE.Mesh(new THREE.CylinderGeometry(endSize, size, length, 5, 1, !0), material), 
        branchPivot.add(branch), branch.add(branchEnd), branch.position.y = length / 2, 
        branchEnd.position.y = length / 2 - .4 * size, isChild ? (branchPivot.rotation.z += 1.5 * Math.random() - 1.05 * sizeModifier, 
        branchPivot.rotation.x += 1.5 * Math.random() - 1.05 * sizeModifier) : (branchPivot.rotation.z += .1 * Math.random() - .05, 
        branchPivot.rotation.x += .1 * Math.random() - .05), children > 0) for (c = 0; c < children; ) child = this.createBranch(size * sizeModifier, material, children - 1, !0, sizeModifier), 
        branchEnd.add(child), c++;
        return branchPivot;
    }, Tree.prototype.wind = function(wind) {
        var b, i, len, ref, results;
        for (ref = this.branchPivots, results = [], i = 0, len = ref.length; i < len; i++) b = ref[i], 
        results.push(b.rotation.z += 5e-4 * Math.cos(wind * Math.random()));
        return results;
    }, Tree;
}(BaseModel);

var VRControls, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

VRControls = function(superClass) {
    function VRControls(target) {
        var setOrientationControls;
        this.enabled = !0, this.supported = !1, this.controls = new THREE.DeviceOrientationControls(target, !0), 
        setOrientationControls = function(_this) {
            return function(e) {
                if (!e.alpha) return void (_this.enabled = !1);
                _this.supported = !0, _this.controls.connect(), _this.controls.update(), window.removeEventListener("deviceorientation", setOrientationControls, !0);
            };
        }(this), window.addEventListener("deviceorientation", setOrientationControls, !0);
    }
    return extend(VRControls, superClass), VRControls.prototype.tick = function(tpf) {
        if (this.enabled) return this.controls.update(tpf);
    }, VRControls.prototype.update = function(tpf) {
        return this.tick(tpf);
    }, VRControls.prototype.updateAlphaOffsetAngle = function(angle) {
        return this.controls.updateAlphaOffsetAngle(angle);
    }, VRControls.prototype.turn = function(angle) {
        return null == angle && (angle = 45), this.updateAlphaOffsetAngle(this.controls.alphaOffsetAngle + angle);
    }, VRControls.prototype.isSupported = function() {
        return this.areSupported();
    }, VRControls.prototype.areSupported = function() {
        return this.supported;
    }, VRControls;
}(BaseControls);

var Walker;

Walker = function() {
    function Walker(mesh, x, y, z) {
        null == x && (x = 0), null == y && (y = -1), null == z && (z = 0), this.mesh = mesh, 
        this.raycaster = new THREE.Raycaster(), this.direction = new THREE.Vector3(x, y, z);
    }
    return Walker.prototype.getContact = function(mesh) {
        var fromPosition, intersects;
        return null == mesh ? void console.log("walker.getContact needs a mesh") : (fromPosition = this.mesh.position.clone(), 
        this.raycaster.set(fromPosition, this.direction), intersects = this.raycaster.intersectObject(mesh), 
        intersects.size() > 0 ? intersects.first().point : null);
    }, Walker.prototype.intersects = function(meshes) {
        var fromPosition;
        return null == meshes ? void console.log("walker.intersects needs a mesh") : (meshes = [].concat(meshes), 
        fromPosition = this.mesh.position.clone(), this.raycaster.set(fromPosition, this.direction), 
        this.raycaster.intersectObjects(meshes));
    }, Walker.prototype.first = function(meshes) {
        return this.intersects(meshes).first();
    }, Walker.prototype.fromWorldDirection = function() {
        return this.mesh.getWorldDirection(this.direction), this;
    }, Walker;
}();

var Water, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

Water = function(superClass) {
    function Water(engine, scene, options) {
        var base, base1, base2, base3, base4, base5, base6, waterNormals;
        if (null == options && (options = {}), null == options.map) throw new Error("map missing. needs to be a TextureManager key");
        null == options.width && (options.width = Utils.PLANE_DEFAULT_WIDTH), null == options.height && (options.height = Utils.PLANE_DEFAULT_HEIGHT), 
        null == options.wSegments && (options.wSegments = Utils.PLANE_DEFAULT_W_SEGMENTS), 
        null == options.hSegments && (options.hSegments = Utils.PLANE_DEFAULT_H_SEGMENTS), 
        null == options.water && (options.water = {}), null == (base = options.water).textureWidth && (base.textureWidth = Utils.MIRROR_DEFAULT_TEXTURE_WIDTH / 2), 
        null == (base1 = options.water).textureHeight && (base1.textureHeight = Utils.MIRROR_DEFAULT_TEXTURE_HEIGHT / 2), 
        null == (base2 = options.water).alpha && (base2.alpha = Utils.WATER_DEFAULT_ALPHA), 
        null == (base3 = options.water).sunColor && (base3.sunColor = Utils.LIGHT_DEFAULT_COLOR), 
        null == (base4 = options.water).waterColor && (base4.waterColor = Utils.WATER_DEFAULT_WATER_COLOR), 
        null == (base5 = options.water).betaVersion && (base5.betaVersion = 0), null == (base6 = options.water).side && (base6.side = THREE.DoubleSide), 
        waterNormals = TextureManager.get().items[options.map], waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping, 
        options.water.waterNormals = waterNormals, this.water = new THREE.Water(engine.renderer, engine.camera, scene, options.water), 
        this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(options.width, options.height, options.wSegments, options.hSegments), this.water.material), 
        this.mesh.add(this.water), this.mesh.rotation.x = .5 * -Math.PI, this.speed = 1;
    }
    return extend(Water, superClass), Water.prototype.tick = function(tpf) {
        return this.water.material.uniforms.time.value += tpf * this.speed, this.water.render();
    }, Water;
}(BaseModel);

var Engine3D, bind = function(fn, me) {
    return function() {
        return fn.apply(me, arguments);
    };
};

Engine3D = function() {
    function Engine3D() {
        this.implode = bind(this.implode, this), this.start = bind(this.start, this), this.render = bind(this.render, this), 
        this.keyboardHandler = bind(this.keyboardHandler, this), this.mouseHandler = bind(this.mouseHandler, this);
        var camera, renderer;
        this.uptime = 0, this.time = void 0, this.config = Config.get(), this.webgl = Detector.webgl, 
        this.width = this.config.width, this.height = this.config.height, this.takeScreenshot = !1, 
        renderer = this.webgl ? THREE.WebGLRenderer : PolyfillRenderer, this.renderer = new renderer({
            antialias: this.config.antialias,
            alpha: this.config.transparentBackground,
            logarithmicDepthBuffer: this.config.logarithmicDepthBuffer
        }), this.renderer.sortObjects = this.config.sortObjects, this.renderer.setSize(this.width, this.height), 
        this.appendDom(), this.renderer.domElement.setAttribute("id", "coffee-engine-dom"), 
        camera = Helper.camera({
            aspect: this.width / this.height,
            near: Utils.CAMERA_DEFAULT_NEAR,
            far: Utils.CAMERA_DEFAULT_FAR
        }), this.setCamera(camera), this.camera.position.z = 10, this.anaglyphEffect = new THREE.AnaglyphEffect(this.renderer), 
        this.anaglyphEffect.setSize(this.width, this.height), this.stereoEffect = new THREE.StereoEffect(this.renderer), 
        this.stereoEffect.setSize(this.width, this.height), this.sceneManager = SceneManager.get(), 
        this.renderer.domElement.addEventListener("mouseup", this.mouseHandler, !1), this.renderer.domElement.addEventListener("mousedown", this.mouseHandler, !1), 
        this.renderer.domElement.addEventListener("mousemove", this.mouseHandler, !1), document.addEventListener("keydown", this.keyboardHandler, !1), 
        document.addEventListener("keyup", this.keyboardHandler, !1), this.renderer.domElement.addEventListener("touchstart", this.touchHandler, !1), 
        this.renderer.domElement.addEventListener("touchmove", this.touchHandler, !1), this.renderer.domElement.addEventListener("touchend", this.touchHandler, !1), 
        this.renderer.domElement.addEventListener("touchcancel", this.touchHandler, !1), 
        this.config.contextMenuDisabled && document.addEventListener("contextmenu", function(e) {
            return e.preventDefault();
        }, !1), this.config.showStatsOnLoad && StatsManager.toggle();
    }
    return Engine3D.loadingSceneAssets = [ "assets/scenes/start.save.json" ], Engine3D.prototype.setWidthHeight = function(width, height) {
        return this.width = width, this.height = height, this.config.width = width, this.config.height = height, 
        this.camera.aspect = this.width / this.height, this.camera.updateProjectionMatrix(), 
        this.renderer.setSize(this.width, this.height);
    }, Engine3D.prototype.touchHandler = function(event) {
        var first, simulatedEvent, touches, type;
        switch (touches = event.changedTouches, first = touches[0], type = "", event.type) {
          case "touchstart":
            type = "mousedown";
            break;

          case "touchmove":
            type = "mousemove";
            break;

          case "touchend":
            type = "mouseup";
            break;

          default:
            return;
        }
        simulatedEvent = document.createEvent("MouseEvent"), simulatedEvent.initMouseEvent(type, !0, !0, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, !1, !1, !1, !1, 0, null), 
        first.target.dispatchEvent(simulatedEvent), event.preventDefault();
    }, Engine3D.prototype.mouseHandler = function(event) {
        var raycaster;
        if (null != (raycaster = this._parseMouseEvent(event))) return this.sceneManager.currentScene().doMouseEvent(event, raycaster);
    }, Engine3D.prototype.keyboardHandler = function(event) {
        return this.sceneManager.currentScene().doKeyboardEvent(event);
    }, Engine3D.prototype.setCamera = function(camera) {
        if (this.camera = camera, this.config.resize) return this.winResize = new THREEx.WindowResize(this.renderer, this.camera);
    }, Engine3D.prototype.setClearColor = function(color, alpha) {
        return this.renderer.setClearColor(color, alpha);
    }, Engine3D.prototype.addScene = function(scene) {
        if (this.sceneManager.addScene(scene), null == this.sceneManager.currentSceneIndex) return this.sceneManager.setScene(scene);
    }, Engine3D.prototype.initScene = function(scene, options, fade) {
        return null == options && (options = {}), null == fade && (fade = !0), fade ? (Helper.fade({
            type: "in"
        }), setTimeout(function(_this) {
            return function() {
                return _this._doInitScene(scene, options), Helper.fade({
                    type: "out"
                });
            };
        }(this), Utils.FADE_DEFAULT_DURATION)) : this._doInitScene(scene, options);
    }, Engine3D.prototype._doInitScene = function(scene, options) {
        var currentScene;
        return currentScene = this.sceneManager.currentScene(), null != currentScene && currentScene.uninit(), 
        this.sceneManager.hasScene(scene) || this.sceneManager.addScene(scene), scene.init(options), 
        this.sceneManager.setScene(scene);
    }, Engine3D.prototype.removeScene = function(scene) {
        return this.sceneManager.removeScene(scene);
    }, Engine3D.prototype.render = function() {
        return console.warn("engine.render() is deprecated. Use engine.start() instead."), 
        this.start();
    }, Engine3D.prototype.start = function() {
        var now, tpf;
        if (!this.stop) return this.frameId = requestAnimationFrame(this.start), this.width = window.innerWidth, 
        this.height = window.innerHeight, now = new Date().getTime(), tpf = (now - (this.time || now)) / 1e3, 
        this.time = now, this.uptime += tpf, this.sceneManager.tick(tpf), StatsManager.update(this._getActiveRenderer()), 
        TWEEN.update(), null != this.composer ? (this.renderer.clear(), this.composer.render(tpf)) : this._getActiveRenderer().render(this.sceneManager.currentScene().scene, this.camera), 
        this._takeScreenshot(), VideoRecorderManager.capture(this.renderer.domElement);
    }, Engine3D.prototype.enableComposer = function(composer) {
        return this.renderer.autoClear = !1, this.composer = composer;
    }, Engine3D.prototype.disableComposer = function() {
        return this.renderer.autoClear = !0, this.composer = void 0;
    }, Engine3D.prototype._getActiveRenderer = function() {
        return this.config.anaglyph ? this.anaglyphEffect : this.config.stereoVR ? this.stereoEffect : this.renderer;
    }, Engine3D.prototype.screenshot = function() {
        return this.takeScreenshot = !0;
    }, Engine3D.prototype.getScreenshot = function(withMeta) {
        var data;
        if (null == withMeta && (withMeta = !1), null == this.screenshotData) throw "use engine.screenshot() first";
        return withMeta ? this.screenshotData : (data = this.screenshotData, data.split(",")[1]);
    }, Engine3D.prototype._takeScreenshot = function() {
        if (this.takeScreenshot) return this.takeScreenshot = !1, this.screenshotData = this._getActiveRenderer().domElement.toDataURL();
    }, Engine3D.prototype.pause = function() {
        return cancelAnimationFrame(this.frameId), this.frameId = void 0, this.stop = !0;
    }, Engine3D.prototype.resume = function() {
        return this.stop = !1, this.render();
    }, Engine3D.prototype.implode = function() {
        return this.stop = !0, this.removeDom();
    }, Engine3D.prototype.unproject = function(x, y) {
        var mouseX, mouseY, vector;
        return mouseX = x / this.width * 2 - 1, mouseY = -y / this.height * 2 + 1, vector = new THREE.Vector3(mouseX, mouseY, .5), 
        vector.unproject(this.camera), new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize());
    }, Engine3D.prototype.removeDom = function() {
        var e;
        if (null !== this.renderer.domElement.parentNode) try {
            return document.body.removeChild(this.renderer.domElement);
        } catch (error) {
            return e = error, console.log(e);
        }
    }, Engine3D.prototype.appendDom = function() {
        return document.body.appendChild(this.renderer.domElement);
    }, Engine3D.prototype._parseMouseEvent = function(event) {
        var mouseX, mouseY, vector;
        if (this.config.preventDefaultMouseEvents && event.preventDefault(), event.target === this.renderer.domElement) return mouseX = event.layerX / this.width * 2 - 1, 
        mouseY = -event.layerY / this.height * 2 + 1, vector = new THREE.Vector3(mouseX, mouseY, .5), 
        vector.unproject(this.camera), new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize());
    }, Engine3D.scenify = function(zeEngine, callback) {
        var loadingScene;
        return null == callback && (callback = function() {
            return {};
        }), loadingScene = new LoadingScene(Engine3D.loadingSceneAssets, function() {
            var assets;
            return loadingScene.hasFinishedLoading = function() {
                var scene;
                return scene = CinematicScene.fromSaveObjectKey("start"), zeEngine.addScene(scene), 
                zeEngine.sceneManager.setScene(scene), callback();
            }, assets = CinematicScene.getAssets("start"), loadingScene.loadAssets(assets);
        }), zeEngine.addScene(loadingScene), loadingScene;
    }, Engine3D.prototype.currentScene = function() {
        return this.sceneManager.currentScene();
    }, Engine3D;
}(), THREE.Object3D.prototype.clear = function() {
    var child, children, i;
    for (children = this.children, i = children.length - 1; i >= 0; ) child = children[i], 
    child.clear(), this.remove(child), i--;
};

var CyclicArray, Playlist, isNumeric, whichAnimationEvent;

Array.prototype.isEmpty = function() {
    return 0 === this.length;
}, Array.prototype.any = function() {
    return !this.isEmpty();
}, Array.prototype.clear = function() {
    var results;
    for (results = []; this.any(); ) results.push(this.pop());
    return results;
}, Array.prototype.last = function() {
    return this[this.length - 1];
}, Array.prototype.first = function() {
    return this[0];
}, Array.prototype.size = function() {
    return this.length;
}, Array.prototype.includes = function(e) {
    return -1 !== this.indexOf(e);
}, Array.prototype.shuffle = function() {
    var array, i, m, t;
    for (array = this, m = array.length, t = void 0, i = void 0; m; ) i = Math.floor(Math.random() * m--), 
    t = array[m], array[m] = array[i], array[i] = t;
    return array;
}, Array.prototype.equalsArray = function(a) {
    var eq, i, j, ref;
    for (eq = !0, i = j = 0, ref = a.size(); 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) if (a[i] !== this[i]) {
        eq = !1;
        break;
    }
    return eq;
}, Array.prototype.random = function() {
    return this.shuffle().first();
}, Array.prototype.diff = function(a) {
    return this.filter(function(i) {
        return a.indexOf(i) < 0;
    });
}, Array.prototype.remove = function(e) {
    var pos;
    return pos = this.indexOf(e), pos > -1 && this.splice(pos, 1), pos > -1 ? e : null;
}, Array.prototype.findById = function(id) {
    return this.filter(function(i) {
        return i.id === id;
    });
}, Array.prototype.sum = function() {
    var e, j, len, ref, sum;
    for (sum = 0, ref = this, j = 0, len = ref.length; j < len; j++) e = ref[j], sum += e;
    return sum;
}, Array.prototype.where = function(hash) {
    return this.filter(function(d) {
        var found, item, j, key, len, ok, ref;
        ok = !0;
        for (key in hash) if (found = !1, hash[key] instanceof Array) {
            for (ref = hash[key], j = 0, len = ref.length; j < len; j++) if (item = ref[j], 
            d[key] === item) {
                found = !0;
                break;
            }
            ok = ok && found;
        } else ok = ok && d[key] === hash[key];
        return ok;
    });
}, Array.prototype.insert = function(index, item) {
    this.splice(index, 0, item);
}, Array.prototype.toCyclicArray = function() {
    return new CyclicArray(this);
}, Array.prototype.shallowClone = function() {
    return JSON.parse(JSON.stringify(this));
}, String.prototype.size = function(s) {
    return this.length;
}, String.prototype.startsWith = function(s) {
    return 0 === this.indexOf(s);
}, String.prototype.startsWithAny = function(prefixes) {
    var j, len, prefix, startsWith;
    for (startsWith = !1, j = 0, len = prefixes.length; j < len; j++) prefix = prefixes[j], 
    this.startsWith(prefix) && (startsWith = !0);
    return startsWith;
}, String.prototype.endsWith = function(suffix) {
    return -1 !== this.indexOf(suffix, this.length - suffix.length);
}, String.prototype.endsWithAny = function(suffixes) {
    var endsWith, j, len, suffix;
    if (endsWith = !1, null == suffixes) return !1;
    for (j = 0, len = suffixes.length; j < len; j++) suffix = suffixes[j], this.endsWith(suffix) && (endsWith = !0);
    return endsWith;
}, String.prototype.replaceAny = function(sources, dest) {
    var j, len, source, tmp;
    for (tmp = this, j = 0, len = sources.length; j < len; j++) source = sources[j], 
    tmp = tmp.replace(source, dest);
    return tmp;
}, String.prototype.isEmpty = function() {
    return 0 === this.size();
}, String.prototype.contains = function(s) {
    return -1 !== this.indexOf(s);
}, String.prototype.containsAny = function(strings) {
    var containsAny, j, len, s;
    if (containsAny = !1, null == strings) return !1;
    for (j = 0, len = strings.length; j < len; j++) s = strings[j], this.contains(s) && (containsAny = !0);
    return containsAny;
}, String.prototype.isPresent = function() {
    return null != this && !this.isEmpty();
}, String.prototype.capitalizeFirstLetter = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
}, isNumeric = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}, Number.prototype.endsWith = function(s) {
    return this.toString().endsWith(s);
}, console.ce = function(message) {
    (void 0 === Config || null === Config || Config.get().debug) && console.log(message);
}, CyclicArray = function() {
    function CyclicArray(items) {
        null == items && (items = []), this.items = items, this.index = 0;
    }
    return CyclicArray.prototype.get = function() {
        return this.items[this.index];
    }, CyclicArray.prototype.next = function() {
        return this.index += 1, this.index > this.items.size() - 1 && (this.index = 0), 
        this.get();
    }, CyclicArray.prototype.prev = function() {
        return this.index -= 1, this.index < 0 && (this.index = this.items.size() - 1), 
        this.get();
    }, CyclicArray.prototype.size = function() {
        return this.items.size();
    }, CyclicArray;
}(), whichAnimationEvent = function() {
    var animations, el, t;
    el = document.createElement("fakeelement"), animations = {
        animation: "animationend",
        OAnimation: "oAnimationEnd",
        MozAnimation: "animationend",
        WebkitAnimation: "webkitAnimationEnd"
    };
    for (t in animations) if (void 0 !== el.style[t]) return animations[t];
}, Playlist = function() {
    function Playlist(keys) {
        var j, key, len;
        if (!(keys instanceof Array)) throw new Error("keys needs to be an array");
        for (j = 0, len = keys.length; j < len; j++) if (key = keys[j], !SoundManager.has(key)) throw new Error("key '" + key + "' not loaded in SoundManager");
        this.items = new CyclicArray(keys);
    }
    return Playlist.prototype.cmd = function(options) {
        var audio, item, j, len, ref;
        if (options.key = this.items.get(), "volumeAll" === options.type) for (options.type = "volume", 
        ref = this.items.items, j = 0, len = ref.length; j < len; j++) item = ref[j], options.key = item, 
        SoundManager.cmd(options); else audio = SoundManager.cmd(options);
        return [ "play", "fadeIn" ].includes(options.type) ? (audio._onend = [], audio.on("end", function(_this) {
            return function(data) {
                return _this.items.next(), _this.cmd(options);
            };
        }(this))) : [ "volume", "volumeAll" ].includes(options.type) ? void 0 : audio._onend = [];
    }, Playlist.prototype.getPlayingKey = function() {
        return this.items.get();
    }, Playlist.prototype.getPlayingAudio = function() {
        return SoundManager.get().items[this.getPlayingKey()];
    }, Playlist;
}();

var Hodler;

Hodler = function() {
    function Hodler() {}
    var instance;
    return instance = null, Singleton.Hodler = function() {
        function Hodler() {}
        return Hodler.prototype.items = {}, Hodler.prototype.add = function(key, item) {
            return this.items[key] = item, this.item(key);
        }, Hodler.prototype.item = function(key) {
            return this.items[key];
        }, Hodler;
    }(), Hodler.get = function() {
        return null != instance ? instance : instance = new Singleton.Hodler();
    }, Hodler.add = function(key, item) {
        return this.get().add(key, item);
    }, Hodler.item = function(key) {
        return this.get().item(key);
    }, Hodler;
}(), function() {
    var cache = {}, ctx = null, usingWebAudio = !0, noAudio = !1;
    try {
        "undefined" != typeof AudioContext ? ctx = new AudioContext() : "undefined" != typeof webkitAudioContext ? ctx = new webkitAudioContext() : usingWebAudio = !1;
    } catch (e) {
        usingWebAudio = !1;
    }
    if (!usingWebAudio) if ("undefined" != typeof Audio) try {
        new Audio();
    } catch (e) {
        noAudio = !0;
    } else noAudio = !0;
    if (usingWebAudio) {
        var masterGain = void 0 === ctx.createGain ? ctx.createGainNode() : ctx.createGain();
        masterGain.gain.value = 1, masterGain.connect(ctx.destination);
    }
    var HowlerGlobal = function(codecs) {
        this._volume = 1, this._muted = !1, this.usingWebAudio = usingWebAudio, this.ctx = ctx, 
        this.noAudio = noAudio, this._howls = [], this._codecs = codecs, this.iOSAutoEnable = !0;
    };
    HowlerGlobal.prototype = {
        volume: function(vol) {
            var self = this;
            if ((vol = parseFloat(vol)) >= 0 && vol <= 1) {
                self._volume = vol, usingWebAudio && (masterGain.gain.value = vol);
                for (var key in self._howls) if (self._howls.hasOwnProperty(key) && !1 === self._howls[key]._webAudio) for (var i = 0; i < self._howls[key]._audioNode.length; i++) self._howls[key]._audioNode[i].volume = self._howls[key]._volume * self._volume;
                return self;
            }
            return usingWebAudio ? masterGain.gain.value : self._volume;
        },
        mute: function() {
            return this._setMuted(!0), this;
        },
        unmute: function() {
            return this._setMuted(!1), this;
        },
        _setMuted: function(muted) {
            var self = this;
            self._muted = muted, usingWebAudio && (masterGain.gain.value = muted ? 0 : self._volume);
            for (var key in self._howls) if (self._howls.hasOwnProperty(key) && !1 === self._howls[key]._webAudio) for (var i = 0; i < self._howls[key]._audioNode.length; i++) self._howls[key]._audioNode[i].muted = muted;
        },
        codecs: function(ext) {
            return this._codecs[ext];
        },
        _enableiOSAudio: function() {
            var self = this;
            if (!ctx || !self._iOSEnabled && /iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                self._iOSEnabled = !1;
                var unlock = function() {
                    var buffer = ctx.createBuffer(1, 1, 22050), source = ctx.createBufferSource();
                    source.buffer = buffer, source.connect(ctx.destination), void 0 === source.start ? source.noteOn(0) : source.start(0), 
                    setTimeout(function() {
                        source.playbackState !== source.PLAYING_STATE && source.playbackState !== source.FINISHED_STATE || (self._iOSEnabled = !0, 
                        self.iOSAutoEnable = !1, window.removeEventListener("touchend", unlock, !1));
                    }, 0);
                };
                return window.addEventListener("touchend", unlock, !1), self;
            }
        }
    };
    var audioTest = null, codecs = {};
    noAudio || (audioTest = new Audio(), codecs = {
        mp3: !!audioTest.canPlayType("audio/mpeg;").replace(/^no$/, ""),
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
        aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
        m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
        mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
    });
    var Howler = new HowlerGlobal(codecs), Howl = function(o) {
        var self = this;
        self._autoplay = o.autoplay || !1, self._buffer = o.buffer || !1, self._duration = o.duration || 0, 
        self._format = o.format || null, self._loop = o.loop || !1, self._loaded = !1, self._sprite = o.sprite || {}, 
        self._src = o.src || "", self._pos3d = o.pos3d || [ 0, 0, -.5 ], self._volume = void 0 !== o.volume ? o.volume : 1, 
        self._urls = o.urls || [], self._rate = o.rate || 1, self._model = o.model || null, 
        self._onload = [ o.onload || function() {} ], self._onloaderror = [ o.onloaderror || function() {} ], 
        self._onend = [ o.onend || function() {} ], self._onpause = [ o.onpause || function() {} ], 
        self._onplay = [ o.onplay || function() {} ], self._onendTimer = [], self._webAudio = usingWebAudio && !self._buffer, 
        self._audioNode = [], self._webAudio && self._setupAudioNode(), void 0 !== ctx && ctx && Howler.iOSAutoEnable && Howler._enableiOSAudio(), 
        Howler._howls.push(self), self.load();
    };
    if (Howl.prototype = {
        load: function() {
            var self = this, url = null;
            if (noAudio) return void self.on("loaderror", new Error("No audio support."));
            for (var i = 0; i < self._urls.length; i++) {
                var ext, urlItem;
                if (self._format) ext = self._format; else {
                    if (urlItem = self._urls[i], ext = /^data:audio\/([^;,]+);/i.exec(urlItem), ext || (ext = /\.([^.]+)$/.exec(urlItem.split("?", 1)[0])), 
                    !ext) return void self.on("loaderror", new Error("Could not extract format from passed URLs, please add format parameter."));
                    ext = ext[1].toLowerCase();
                }
                if (codecs[ext]) {
                    url = self._urls[i];
                    break;
                }
            }
            if (!url) return void self.on("loaderror", new Error("No codec support for selected audio sources."));
            if (self._src = url, self._webAudio) loadBuffer(self, url); else {
                var newNode = new Audio();
                newNode.addEventListener("error", function() {
                    newNode.error && 4 === newNode.error.code && (HowlerGlobal.noAudio = !0), self.on("loaderror", {
                        type: newNode.error ? newNode.error.code : 0
                    });
                }, !1), self._audioNode.push(newNode), newNode.src = url, newNode._pos = 0, newNode.preload = "auto", 
                newNode.volume = Howler._muted ? 0 : self._volume * Howler.volume();
                var listener = function() {
                    self._duration = Math.ceil(10 * newNode.duration) / 10, 0 === Object.getOwnPropertyNames(self._sprite).length && (self._sprite = {
                        _default: [ 0, 1e3 * self._duration ]
                    }), self._loaded || (self._loaded = !0, self.on("load")), self._autoplay && self.play(), 
                    newNode.removeEventListener("canplaythrough", listener, !1);
                };
                newNode.addEventListener("canplaythrough", listener, !1), newNode.load();
            }
            return self;
        },
        urls: function(urls) {
            var self = this;
            return urls ? (self.stop(), self._urls = "string" == typeof urls ? [ urls ] : urls, 
            self._loaded = !1, self.load(), self) : self._urls;
        },
        play: function(sprite, callback) {
            var self = this;
            return "function" == typeof sprite && (callback = sprite), sprite && "function" != typeof sprite || (sprite = "_default"), 
            self._loaded ? self._sprite[sprite] ? (self._inactiveNode(function(node) {
                node._sprite = sprite;
                var pos = node._pos > 0 ? node._pos : self._sprite[sprite][0] / 1e3, duration = 0;
                self._webAudio ? (duration = self._sprite[sprite][1] / 1e3 - node._pos, node._pos > 0 && (pos = self._sprite[sprite][0] / 1e3 + pos)) : duration = self._sprite[sprite][1] / 1e3 - (pos - self._sprite[sprite][0] / 1e3);
                var timerId, loop = !(!self._loop && !self._sprite[sprite][2]), soundId = "string" == typeof callback ? callback : Math.round(Date.now() * Math.random()) + "";
                if (function() {
                    var data = {
                        id: soundId,
                        sprite: sprite,
                        loop: loop
                    };
                    timerId = setTimeout(function() {
                        !self._webAudio && loop && self.stop(data.id).play(sprite, data.id), self._webAudio && !loop && (self._nodeById(data.id).paused = !0, 
                        self._nodeById(data.id)._pos = 0, self._clearEndTimer(data.id)), self._webAudio || loop || self.stop(data.id), 
                        self.on("end", soundId);
                    }, duration / self._rate * 1e3), self._onendTimer.push({
                        timer: timerId,
                        id: data.id
                    });
                }(), self._webAudio) {
                    var loopStart = self._sprite[sprite][0] / 1e3, loopEnd = self._sprite[sprite][1] / 1e3;
                    node.id = soundId, node.paused = !1, refreshBuffer(self, [ loop, loopStart, loopEnd ], soundId), 
                    self._playStart = ctx.currentTime, node.gain.value = self._volume, void 0 === node.bufferSource.start ? loop ? node.bufferSource.noteGrainOn(0, pos, 86400) : node.bufferSource.noteGrainOn(0, pos, duration) : loop ? node.bufferSource.start(0, pos, 86400) : node.bufferSource.start(0, pos, duration);
                } else {
                    if (4 !== node.readyState && (node.readyState || !navigator.isCocoonJS)) return self._clearEndTimer(soundId), 
                    function() {
                        var sound = self, playSprite = sprite, fn = callback, newNode = node, listener = function() {
                            sound.play(playSprite, fn), newNode.removeEventListener("canplaythrough", listener, !1);
                        };
                        newNode.addEventListener("canplaythrough", listener, !1);
                    }(), self;
                    node.readyState = 4, node.id = soundId, node.currentTime = pos, node.muted = Howler._muted || node.muted, 
                    node.volume = self._volume * Howler.volume(), setTimeout(function() {
                        node.play();
                    }, 0);
                }
                return self.on("play"), "function" == typeof callback && callback(soundId), self;
            }), self) : ("function" == typeof callback && callback(), self) : (self.on("load", function() {
                self.play(sprite, callback);
            }), self);
        },
        pause: function(id) {
            var self = this;
            if (!self._loaded) return self.on("play", function() {
                self.pause(id);
            }), self;
            self._clearEndTimer(id);
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            if (activeNode) if (activeNode._pos = self.pos(null, id), self._webAudio) {
                if (!activeNode.bufferSource || activeNode.paused) return self;
                activeNode.paused = !0, void 0 === activeNode.bufferSource.stop ? activeNode.bufferSource.noteOff(0) : activeNode.bufferSource.stop(0);
            } else activeNode.pause();
            return self.on("pause"), self;
        },
        stop: function(id) {
            var self = this;
            if (!self._loaded) return self.on("play", function() {
                self.stop(id);
            }), self;
            self._clearEndTimer(id);
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            if (activeNode) if (activeNode._pos = 0, self._webAudio) {
                if (!activeNode.bufferSource || activeNode.paused) return self;
                activeNode.paused = !0, void 0 === activeNode.bufferSource.stop ? activeNode.bufferSource.noteOff(0) : activeNode.bufferSource.stop(0);
            } else isNaN(activeNode.duration) || (activeNode.pause(), activeNode.currentTime = 0);
            return self;
        },
        mute: function(id) {
            var self = this;
            if (!self._loaded) return self.on("play", function() {
                self.mute(id);
            }), self;
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            return activeNode && (self._webAudio ? activeNode.gain.value = 0 : activeNode.muted = !0), 
            self;
        },
        unmute: function(id) {
            var self = this;
            if (!self._loaded) return self.on("play", function() {
                self.unmute(id);
            }), self;
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            return activeNode && (self._webAudio ? activeNode.gain.value = self._volume : activeNode.muted = !1), 
            self;
        },
        volume: function(vol, id) {
            var self = this;
            if ((vol = parseFloat(vol)) >= 0 && vol <= 1) {
                if (self._volume = vol, !self._loaded) return self.on("play", function() {
                    self.volume(vol, id);
                }), self;
                var activeNode = id ? self._nodeById(id) : self._activeNode();
                return activeNode && (self._webAudio ? activeNode.gain.value = vol : activeNode.volume = vol * Howler.volume()), 
                self;
            }
            return self._volume;
        },
        loop: function(loop) {
            var self = this;
            return "boolean" == typeof loop ? (self._loop = loop, self) : self._loop;
        },
        sprite: function(sprite) {
            var self = this;
            return "object" == typeof sprite ? (self._sprite = sprite, self) : self._sprite;
        },
        pos: function(pos, id) {
            var self = this;
            if (!self._loaded) return self.on("load", function() {
                self.pos(pos);
            }), "number" == typeof pos ? self : self._pos || 0;
            pos = parseFloat(pos);
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            if (activeNode) return pos >= 0 ? (self.pause(id), activeNode._pos = pos, self.play(activeNode._sprite, id), 
            self) : self._webAudio ? activeNode._pos + (ctx.currentTime - self._playStart) : activeNode.currentTime;
            if (pos >= 0) return self;
            for (var i = 0; i < self._audioNode.length; i++) if (self._audioNode[i].paused && 4 === self._audioNode[i].readyState) return self._webAudio ? self._audioNode[i]._pos : self._audioNode[i].currentTime;
        },
        pos3d: function(x, y, z, id) {
            var self = this;
            if (y = void 0 !== y && y ? y : 0, z = void 0 !== z && z ? z : -.5, !self._loaded) return self.on("play", function() {
                self.pos3d(x, y, z, id);
            }), self;
            if (!(x >= 0 || x < 0)) return self._pos3d;
            if (self._webAudio) {
                var activeNode = id ? self._nodeById(id) : self._activeNode();
                activeNode && (self._pos3d = [ x, y, z ], activeNode.panner.setPosition(x, y, z), 
                activeNode.panner.panningModel = self._model || "HRTF");
            }
            return self;
        },
        fade: function(from, to, len, callback, id) {
            var self = this, diff = Math.abs(from - to), dir = from > to ? "down" : "up", steps = diff / .01, stepTime = len / steps;
            if (!self._loaded) return self.on("load", function() {
                self.fade(from, to, len, callback, id);
            }), self;
            self.volume(from, id);
            for (var i = 1; i <= steps; i++) !function() {
                var change = self._volume + ("up" === dir ? .01 : -.01) * i, vol = Math.round(1e3 * change) / 1e3, toVol = to;
                setTimeout(function() {
                    self.volume(vol, id), vol === toVol && callback && callback();
                }, stepTime * i);
            }();
        },
        fadeIn: function(to, len, callback) {
            return this.volume(0).play().fade(0, to, len, callback);
        },
        fadeOut: function(to, len, callback, id) {
            var self = this;
            return self.fade(self._volume, to, len, function() {
                callback && callback(), self.pause(id), self.on("end");
            }, id);
        },
        _nodeById: function(id) {
            for (var self = this, node = self._audioNode[0], i = 0; i < self._audioNode.length; i++) if (self._audioNode[i].id === id) {
                node = self._audioNode[i];
                break;
            }
            return node;
        },
        _activeNode: function() {
            for (var self = this, node = null, i = 0; i < self._audioNode.length; i++) if (!self._audioNode[i].paused) {
                node = self._audioNode[i];
                break;
            }
            return self._drainPool(), node;
        },
        _inactiveNode: function(callback) {
            for (var self = this, node = null, i = 0; i < self._audioNode.length; i++) if (self._audioNode[i].paused && 4 === self._audioNode[i].readyState) {
                callback(self._audioNode[i]), node = !0;
                break;
            }
            if (self._drainPool(), !node) {
                var newNode;
                if (self._webAudio) newNode = self._setupAudioNode(), callback(newNode); else {
                    self.load(), newNode = self._audioNode[self._audioNode.length - 1];
                    var listenerEvent = navigator.isCocoonJS ? "canplaythrough" : "loadedmetadata", listener = function() {
                        newNode.removeEventListener(listenerEvent, listener, !1), callback(newNode);
                    };
                    newNode.addEventListener(listenerEvent, listener, !1);
                }
            }
        },
        _drainPool: function() {
            var i, self = this, inactive = 0;
            for (i = 0; i < self._audioNode.length; i++) self._audioNode[i].paused && inactive++;
            for (i = self._audioNode.length - 1; i >= 0 && !(inactive <= 5); i--) self._audioNode[i].paused && (self._webAudio && self._audioNode[i].disconnect(0), 
            inactive--, self._audioNode.splice(i, 1));
        },
        _clearEndTimer: function(soundId) {
            for (var self = this, index = -1, i = 0; i < self._onendTimer.length; i++) if (self._onendTimer[i].id === soundId) {
                index = i;
                break;
            }
            var timer = self._onendTimer[index];
            timer && (clearTimeout(timer.timer), self._onendTimer.splice(index, 1));
        },
        _setupAudioNode: function() {
            var self = this, node = self._audioNode, index = self._audioNode.length;
            return node[index] = void 0 === ctx.createGain ? ctx.createGainNode() : ctx.createGain(), 
            node[index].gain.value = self._volume, node[index].paused = !0, node[index]._pos = 0, 
            node[index].readyState = 4, node[index].connect(masterGain), node[index].panner = ctx.createPanner(), 
            node[index].panner.panningModel = self._model || "equalpower", node[index].panner.setPosition(self._pos3d[0], self._pos3d[1], self._pos3d[2]), 
            node[index].panner.connect(node[index]), node[index];
        },
        on: function(event, fn) {
            var self = this, events = self["_on" + event];
            if ("function" == typeof fn) events.push(fn); else for (var i = 0; i < events.length; i++) fn ? events[i].call(self, fn) : events[i].call(self);
            return self;
        },
        off: function(event, fn) {
            var self = this, events = self["_on" + event];
            if (fn) {
                for (var i = 0; i < events.length; i++) if (fn === events[i]) {
                    events.splice(i, 1);
                    break;
                }
            } else self["_on" + event] = [];
            return self;
        },
        unload: function() {
            for (var self = this, nodes = self._audioNode, i = 0; i < self._audioNode.length; i++) nodes[i].paused || (self.stop(nodes[i].id), 
            self.on("end", nodes[i].id)), self._webAudio ? nodes[i].disconnect(0) : nodes[i].src = "";
            for (i = 0; i < self._onendTimer.length; i++) clearTimeout(self._onendTimer[i].timer);
            var index = Howler._howls.indexOf(self);
            null !== index && index >= 0 && Howler._howls.splice(index, 1), delete cache[self._src], 
            self = null;
        }
    }, usingWebAudio) var loadBuffer = function(obj, url) {
        if (url in cache) return obj._duration = cache[url].duration, void loadSound(obj);
        if (/^data:[^;]+;base64,/.test(url)) {
            for (var data = atob(url.split(",")[1]), dataView = new Uint8Array(data.length), i = 0; i < data.length; ++i) dataView[i] = data.charCodeAt(i);
            decodeAudioData(dataView.buffer, obj, url);
        } else {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, !0), xhr.responseType = "arraybuffer", xhr.onload = function() {
                decodeAudioData(xhr.response, obj, url);
            }, xhr.onerror = function() {
                obj._webAudio && (obj._buffer = !0, obj._webAudio = !1, obj._audioNode = [], delete obj._gainNode, 
                delete cache[url], obj.load());
            };
            try {
                xhr.send();
            } catch (e) {
                xhr.onerror();
            }
        }
    }, decodeAudioData = function(arraybuffer, obj, url) {
        ctx.decodeAudioData(arraybuffer, function(buffer) {
            buffer && (cache[url] = buffer, loadSound(obj, buffer));
        }, function(err) {
            obj.on("loaderror", err);
        });
    }, loadSound = function(obj, buffer) {
        obj._duration = buffer ? buffer.duration : obj._duration, 0 === Object.getOwnPropertyNames(obj._sprite).length && (obj._sprite = {
            _default: [ 0, 1e3 * obj._duration ]
        }), obj._loaded || (obj._loaded = !0, obj.on("load")), obj._autoplay && obj.play();
    }, refreshBuffer = function(obj, loop, id) {
        var node = obj._nodeById(id);
        node.bufferSource = ctx.createBufferSource(), node.bufferSource.buffer = cache[obj._src], 
        node.bufferSource.connect(node.panner), node.bufferSource.loop = loop[0], loop[0] && (node.bufferSource.loopStart = loop[1], 
        node.bufferSource.loopEnd = loop[1] + loop[2]), node.bufferSource.playbackRate.value = obj._rate;
    };
    "function" == typeof define && define.amd && define(function() {
        return {
            Howler: Howler,
            Howl: Howl
        };
    }), void 0 !== exports && (exports.Howler = Howler, exports.Howl = Howl), "undefined" != typeof window && (window.Howler = Howler, 
    window.Howl = Howl);
}(), function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.io = factory() : root.io = factory();
}(this, function() {
    return function(modules) {
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: !1
            };
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        var installedModules = {};
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        function lookup(uri, opts) {
            "object" === (void 0 === uri ? "undefined" : _typeof(uri)) && (opts = uri, uri = void 0), 
            opts = opts || {};
            var io, parsed = url(uri), source = parsed.source, id = parsed.id, path = parsed.path, sameNamespace = cache[id] && path in cache[id].nsps, newConnection = opts.forceNew || opts["force new connection"] || !1 === opts.multiplex || sameNamespace;
            return newConnection ? (debug("ignoring socket cache for %s", source), io = Manager(source, opts)) : (cache[id] || (debug("new io instance for %s", source), 
            cache[id] = Manager(source, opts)), io = cache[id]), parsed.query && !opts.query ? opts.query = parsed.query : opts && "object" === _typeof(opts.query) && (opts.query = encodeQueryString(opts.query)), 
            io.socket(parsed.path, opts);
        }
        function encodeQueryString(obj) {
            var str = [];
            for (var p in obj) obj.hasOwnProperty(p) && str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
            return str.join("&");
        }
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, url = __webpack_require__(1), parser = __webpack_require__(7), Manager = __webpack_require__(17), debug = __webpack_require__(3)("socket.io-client");
        module.exports = exports = lookup;
        var cache = exports.managers = {};
        exports.protocol = parser.protocol, exports.connect = lookup, exports.Manager = __webpack_require__(17), 
        exports.Socket = __webpack_require__(44);
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            function url(uri, loc) {
                var obj = uri;
                loc = loc || global.location, null == uri && (uri = loc.protocol + "//" + loc.host), 
                "string" == typeof uri && ("/" === uri.charAt(0) && (uri = "/" === uri.charAt(1) ? loc.protocol + uri : loc.host + uri), 
                /^(https?|wss?):\/\//.test(uri) || (debug("protocol-less url %s", uri), uri = void 0 !== loc ? loc.protocol + "//" + uri : "https://" + uri), 
                debug("parse %s", uri), obj = parseuri(uri)), obj.port || (/^(http|ws)$/.test(obj.protocol) ? obj.port = "80" : /^(http|ws)s$/.test(obj.protocol) && (obj.port = "443")), 
                obj.path = obj.path || "/";
                var ipv6 = -1 !== obj.host.indexOf(":"), host = ipv6 ? "[" + obj.host + "]" : obj.host;
                return obj.id = obj.protocol + "://" + host + ":" + obj.port, obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port), 
                obj;
            }
            var parseuri = __webpack_require__(2), debug = __webpack_require__(3)("socket.io-client:url");
            module.exports = url;
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports) {
        var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [ "source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor" ];
        module.exports = function(str) {
            var src = str, b = str.indexOf("["), e = str.indexOf("]");
            -1 != b && -1 != e && (str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length));
            for (var m = re.exec(str || ""), uri = {}, i = 14; i--; ) uri[parts[i]] = m[i] || "";
            return -1 != b && -1 != e && (uri.source = src, uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":"), 
            uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), 
            uri.ipv6uri = !0), uri;
        };
    }, function(module, exports, __webpack_require__) {
        (function(process) {
            function useColors() {
                return "undefined" != typeof document && "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
            }
            function formatArgs() {
                var args = arguments, useColors = this.useColors;
                if (args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff), 
                !useColors) return args;
                var c = "color: " + this.color;
                args = [ args[0], c, "color: inherit" ].concat(Array.prototype.slice.call(args, 1));
                var index = 0, lastC = 0;
                return args[0].replace(/%[a-z%]/g, function(match) {
                    "%%" !== match && (index++, "%c" === match && (lastC = index));
                }), args.splice(lastC, 0, c), args;
            }
            function log() {
                return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
            }
            function save(namespaces) {
                try {
                    null == namespaces ? exports.storage.removeItem("debug") : exports.storage.debug = namespaces;
                } catch (e) {}
            }
            function load() {
                try {
                    return exports.storage.debug;
                } catch (e) {}
                if (void 0 !== process && "env" in process) return process.env.DEBUG;
            }
            exports = module.exports = __webpack_require__(5), exports.log = log, exports.formatArgs = formatArgs, 
            exports.save = save, exports.load = load, exports.useColors = useColors, exports.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : function() {
                try {
                    return window.localStorage;
                } catch (e) {}
            }(), exports.colors = [ "lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson" ], 
            exports.formatters.j = function(v) {
                try {
                    return JSON.stringify(v);
                } catch (err) {
                    return "[UnexpectedJSONParseError]: " + err.message;
                }
            }, exports.enable(load());
        }).call(exports, __webpack_require__(4));
    }, function(module, exports) {
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
            clearTimeout(marker);
            try {
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, runClearTimeout(timeout);
            }
        }
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
        process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, function(module, exports, __webpack_require__) {
        function selectColor() {
            return exports.colors[prevColor++ % exports.colors.length];
        }
        function debug(namespace) {
            function disabled() {}
            function enabled() {
                var self = enabled, curr = +new Date(), ms = curr - (prevTime || curr);
                self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, null == self.useColors && (self.useColors = exports.useColors()), 
                null == self.color && self.useColors && (self.color = selectColor());
                for (var args = new Array(arguments.length), i = 0; i < args.length; i++) args[i] = arguments[i];
                args[0] = exports.coerce(args[0]), "string" != typeof args[0] && (args = [ "%o" ].concat(args));
                var index = 0;
                args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
                    if ("%%" === match) return match;
                    index++;
                    var formatter = exports.formatters[format];
                    if ("function" == typeof formatter) {
                        var val = args[index];
                        match = formatter.call(self, val), args.splice(index, 1), index--;
                    }
                    return match;
                }), args = exports.formatArgs.apply(self, args), (enabled.log || exports.log || console.log.bind(console)).apply(self, args);
            }
            disabled.enabled = !1, enabled.enabled = !0;
            var fn = exports.enabled(namespace) ? enabled : disabled;
            return fn.namespace = namespace, fn;
        }
        function enable(namespaces) {
            exports.save(namespaces);
            for (var split = (namespaces || "").split(/[\s,]+/), len = split.length, i = 0; i < len; i++) split[i] && (namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, "\\$&").replace(/\*/g, ".*?"), 
            "-" === namespaces[0] ? exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$")) : exports.names.push(new RegExp("^" + namespaces + "$")));
        }
        function disable() {
            exports.enable("");
        }
        function enabled(name) {
            var i, len;
            for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return !1;
            for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return !0;
            return !1;
        }
        function coerce(val) {
            return val instanceof Error ? val.stack || val.message : val;
        }
        exports = module.exports = debug.debug = debug, exports.coerce = coerce, exports.disable = disable, 
        exports.enable = enable, exports.enabled = enabled, exports.humanize = __webpack_require__(6), 
        exports.names = [], exports.skips = [], exports.formatters = {};
        var prevTime, prevColor = 0;
    }, function(module, exports) {
        function parse(str) {
            if (str = String(str), !(str.length > 1e4)) {
                var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
                if (match) {
                    var n = parseFloat(match[1]);
                    switch ((match[2] || "ms").toLowerCase()) {
                      case "years":
                      case "year":
                      case "yrs":
                      case "yr":
                      case "y":
                        return n * y;

                      case "days":
                      case "day":
                      case "d":
                        return n * d;

                      case "hours":
                      case "hour":
                      case "hrs":
                      case "hr":
                      case "h":
                        return n * h;

                      case "minutes":
                      case "minute":
                      case "mins":
                      case "min":
                      case "m":
                        return n * m;

                      case "seconds":
                      case "second":
                      case "secs":
                      case "sec":
                      case "s":
                        return n * s;

                      case "milliseconds":
                      case "millisecond":
                      case "msecs":
                      case "msec":
                      case "ms":
                        return n;

                      default:
                        return;
                    }
                }
            }
        }
        function fmtShort(ms) {
            return ms >= d ? Math.round(ms / d) + "d" : ms >= h ? Math.round(ms / h) + "h" : ms >= m ? Math.round(ms / m) + "m" : ms >= s ? Math.round(ms / s) + "s" : ms + "ms";
        }
        function fmtLong(ms) {
            return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
        }
        function plural(ms, n, name) {
            if (!(ms < n)) return ms < 1.5 * n ? Math.floor(ms / n) + " " + name : Math.ceil(ms / n) + " " + name + "s";
        }
        var s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h, y = 365.25 * d;
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if ("string" === type && val.length > 0) return parse(val);
            if ("number" === type && !1 === isNaN(val)) return options.long ? fmtLong(val) : fmtShort(val);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
    }, function(module, exports, __webpack_require__) {
        function Encoder() {}
        function encodeAsString(obj) {
            var str = "", nsp = !1;
            return str += obj.type, exports.BINARY_EVENT != obj.type && exports.BINARY_ACK != obj.type || (str += obj.attachments, 
            str += "-"), obj.nsp && "/" != obj.nsp && (nsp = !0, str += obj.nsp), null != obj.id && (nsp && (str += ",", 
            nsp = !1), str += obj.id), null != obj.data && (nsp && (str += ","), str += json.stringify(obj.data)), 
            debug("encoded %j as %s", obj, str), str;
        }
        function encodeAsBinary(obj, callback) {
            function writeEncoding(bloblessData) {
                var deconstruction = binary.deconstructPacket(bloblessData), pack = encodeAsString(deconstruction.packet), buffers = deconstruction.buffers;
                buffers.unshift(pack), callback(buffers);
            }
            binary.removeBlobs(obj, writeEncoding);
        }
        function Decoder() {
            this.reconstructor = null;
        }
        function decodeString(str) {
            var p = {}, i = 0;
            if (p.type = Number(str.charAt(0)), null == exports.types[p.type]) return error();
            if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
                for (var buf = ""; "-" != str.charAt(++i) && (buf += str.charAt(i), i != str.length); ) ;
                if (buf != Number(buf) || "-" != str.charAt(i)) throw new Error("Illegal attachments");
                p.attachments = Number(buf);
            }
            if ("/" == str.charAt(i + 1)) for (p.nsp = ""; ++i; ) {
                var c = str.charAt(i);
                if ("," == c) break;
                if (p.nsp += c, i == str.length) break;
            } else p.nsp = "/";
            var next = str.charAt(i + 1);
            if ("" !== next && Number(next) == next) {
                for (p.id = ""; ++i; ) {
                    var c = str.charAt(i);
                    if (null == c || Number(c) != c) {
                        --i;
                        break;
                    }
                    if (p.id += str.charAt(i), i == str.length) break;
                }
                p.id = Number(p.id);
            }
            return str.charAt(++i) && (p = tryParse(p, str.substr(i))), debug("decoded %s as %j", str, p), 
            p;
        }
        function tryParse(p, str) {
            try {
                p.data = json.parse(str);
            } catch (e) {
                return error();
            }
            return p;
        }
        function BinaryReconstructor(packet) {
            this.reconPack = packet, this.buffers = [];
        }
        function error(data) {
            return {
                type: exports.ERROR,
                data: "parser error"
            };
        }
        var debug = __webpack_require__(8)("socket.io-parser"), json = __webpack_require__(11), Emitter = __webpack_require__(13), binary = __webpack_require__(14), isBuf = __webpack_require__(16);
        exports.protocol = 4, exports.types = [ "CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK" ], 
        exports.CONNECT = 0, exports.DISCONNECT = 1, exports.EVENT = 2, exports.ACK = 3, 
        exports.ERROR = 4, exports.BINARY_EVENT = 5, exports.BINARY_ACK = 6, exports.Encoder = Encoder, 
        exports.Decoder = Decoder, Encoder.prototype.encode = function(obj, callback) {
            if (debug("encoding packet %j", obj), exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) encodeAsBinary(obj, callback); else {
                callback([ encodeAsString(obj) ]);
            }
        }, Emitter(Decoder.prototype), Decoder.prototype.add = function(obj) {
            var packet;
            if ("string" == typeof obj) packet = decodeString(obj), exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type ? (this.reconstructor = new BinaryReconstructor(packet), 
            0 === this.reconstructor.reconPack.attachments && this.emit("decoded", packet)) : this.emit("decoded", packet); else {
                if (!isBuf(obj) && !obj.base64) throw new Error("Unknown type: " + obj);
                if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
                (packet = this.reconstructor.takeBinaryData(obj)) && (this.reconstructor = null, 
                this.emit("decoded", packet));
            }
        }, Decoder.prototype.destroy = function() {
            this.reconstructor && this.reconstructor.finishedReconstruction();
        }, BinaryReconstructor.prototype.takeBinaryData = function(binData) {
            if (this.buffers.push(binData), this.buffers.length == this.reconPack.attachments) {
                var packet = binary.reconstructPacket(this.reconPack, this.buffers);
                return this.finishedReconstruction(), packet;
            }
            return null;
        }, BinaryReconstructor.prototype.finishedReconstruction = function() {
            this.reconPack = null, this.buffers = [];
        };
    }, function(module, exports, __webpack_require__) {
        function useColors() {
            return "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
        }
        function formatArgs() {
            var args = arguments, useColors = this.useColors;
            if (args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff), 
            !useColors) return args;
            var c = "color: " + this.color;
            args = [ args[0], c, "color: inherit" ].concat(Array.prototype.slice.call(args, 1));
            var index = 0, lastC = 0;
            return args[0].replace(/%[a-z%]/g, function(match) {
                "%%" !== match && (index++, "%c" === match && (lastC = index));
            }), args.splice(lastC, 0, c), args;
        }
        function log() {
            return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }
        function save(namespaces) {
            try {
                null == namespaces ? exports.storage.removeItem("debug") : exports.storage.debug = namespaces;
            } catch (e) {}
        }
        function load() {
            var r;
            try {
                r = exports.storage.debug;
            } catch (e) {}
            return r;
        }
        exports = module.exports = __webpack_require__(9), exports.log = log, exports.formatArgs = formatArgs, 
        exports.save = save, exports.load = load, exports.useColors = useColors, exports.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : function() {
            try {
                return window.localStorage;
            } catch (e) {}
        }(), exports.colors = [ "lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson" ], 
        exports.formatters.j = function(v) {
            return JSON.stringify(v);
        }, exports.enable(load());
    }, function(module, exports, __webpack_require__) {
        function selectColor() {
            return exports.colors[prevColor++ % exports.colors.length];
        }
        function debug(namespace) {
            function disabled() {}
            function enabled() {
                var self = enabled, curr = +new Date(), ms = curr - (prevTime || curr);
                self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, null == self.useColors && (self.useColors = exports.useColors()), 
                null == self.color && self.useColors && (self.color = selectColor());
                var args = Array.prototype.slice.call(arguments);
                args[0] = exports.coerce(args[0]), "string" != typeof args[0] && (args = [ "%o" ].concat(args));
                var index = 0;
                args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
                    if ("%%" === match) return match;
                    index++;
                    var formatter = exports.formatters[format];
                    if ("function" == typeof formatter) {
                        var val = args[index];
                        match = formatter.call(self, val), args.splice(index, 1), index--;
                    }
                    return match;
                }), "function" == typeof exports.formatArgs && (args = exports.formatArgs.apply(self, args)), 
                (enabled.log || exports.log || console.log.bind(console)).apply(self, args);
            }
            disabled.enabled = !1, enabled.enabled = !0;
            var fn = exports.enabled(namespace) ? enabled : disabled;
            return fn.namespace = namespace, fn;
        }
        function enable(namespaces) {
            exports.save(namespaces);
            for (var split = (namespaces || "").split(/[\s,]+/), len = split.length, i = 0; i < len; i++) split[i] && (namespaces = split[i].replace(/\*/g, ".*?"), 
            "-" === namespaces[0] ? exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$")) : exports.names.push(new RegExp("^" + namespaces + "$")));
        }
        function disable() {
            exports.enable("");
        }
        function enabled(name) {
            var i, len;
            for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return !1;
            for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return !0;
            return !1;
        }
        function coerce(val) {
            return val instanceof Error ? val.stack || val.message : val;
        }
        exports = module.exports = debug, exports.coerce = coerce, exports.disable = disable, 
        exports.enable = enable, exports.enabled = enabled, exports.humanize = __webpack_require__(10), 
        exports.names = [], exports.skips = [], exports.formatters = {};
        var prevTime, prevColor = 0;
    }, function(module, exports) {
        function parse(str) {
            if (str = "" + str, !(str.length > 1e4)) {
                var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
                if (match) {
                    var n = parseFloat(match[1]);
                    switch ((match[2] || "ms").toLowerCase()) {
                      case "years":
                      case "year":
                      case "yrs":
                      case "yr":
                      case "y":
                        return n * y;

                      case "days":
                      case "day":
                      case "d":
                        return n * d;

                      case "hours":
                      case "hour":
                      case "hrs":
                      case "hr":
                      case "h":
                        return n * h;

                      case "minutes":
                      case "minute":
                      case "mins":
                      case "min":
                      case "m":
                        return n * m;

                      case "seconds":
                      case "second":
                      case "secs":
                      case "sec":
                      case "s":
                        return n * s;

                      case "milliseconds":
                      case "millisecond":
                      case "msecs":
                      case "msec":
                      case "ms":
                        return n;
                    }
                }
            }
        }
        function short(ms) {
            return ms >= d ? Math.round(ms / d) + "d" : ms >= h ? Math.round(ms / h) + "h" : ms >= m ? Math.round(ms / m) + "m" : ms >= s ? Math.round(ms / s) + "s" : ms + "ms";
        }
        function long(ms) {
            return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
        }
        function plural(ms, n, name) {
            if (!(ms < n)) return ms < 1.5 * n ? Math.floor(ms / n) + " " + name : Math.ceil(ms / n) + " " + name + "s";
        }
        var s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h, y = 365.25 * d;
        module.exports = function(val, options) {
            return options = options || {}, "string" == typeof val ? parse(val) : options.long ? long(val) : short(val);
        };
    }, function(module, exports, __webpack_require__) {
        (function(module, global) {
            var define = !1;
            (function() {
                function runInContext(context, exports) {
                    function has(name) {
                        if (has[name] !== undef) return has[name];
                        var isSupported;
                        if ("bug-string-char-index" == name) isSupported = "a" != "a"[0]; else if ("json" == name) isSupported = has("json-stringify") && has("json-parse"); else {
                            var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
                            if ("json-stringify" == name) {
                                var stringify = exports.stringify, stringifySupported = "function" == typeof stringify && isExtended;
                                if (stringifySupported) {
                                    (value = function() {
                                        return 1;
                                    }).toJSON = value;
                                    try {
                                        stringifySupported = "0" === stringify(0) && "0" === stringify(new Number()) && '""' == stringify(new String()) && stringify(getClass) === undef && stringify(undef) === undef && stringify() === undef && "1" === stringify(value) && "[1]" == stringify([ value ]) && "[null]" == stringify([ undef ]) && "null" == stringify(null) && "[null,null,null]" == stringify([ undef, getClass, null ]) && stringify({
                                            a: [ value, !0, !1, null, "\0\b\n\f\r\t" ]
                                        }) == serialized && "1" === stringify(null, value) && "[\n 1,\n 2\n]" == stringify([ 1, 2 ], null, 1) && '"-271821-04-20T00:00:00.000Z"' == stringify(new Date(-864e13)) && '"+275760-09-13T00:00:00.000Z"' == stringify(new Date(864e13)) && '"-000001-01-01T00:00:00.000Z"' == stringify(new Date(-621987552e5)) && '"1969-12-31T23:59:59.999Z"' == stringify(new Date(-1));
                                    } catch (exception) {
                                        stringifySupported = !1;
                                    }
                                }
                                isSupported = stringifySupported;
                            }
                            if ("json-parse" == name) {
                                var parse = exports.parse;
                                if ("function" == typeof parse) try {
                                    if (0 === parse("0") && !parse(!1)) {
                                        value = parse(serialized);
                                        var parseSupported = 5 == value.a.length && 1 === value.a[0];
                                        if (parseSupported) {
                                            try {
                                                parseSupported = !parse('"\t"');
                                            } catch (exception) {}
                                            if (parseSupported) try {
                                                parseSupported = 1 !== parse("01");
                                            } catch (exception) {}
                                            if (parseSupported) try {
                                                parseSupported = 1 !== parse("1.");
                                            } catch (exception) {}
                                        }
                                    }
                                } catch (exception) {
                                    parseSupported = !1;
                                }
                                isSupported = parseSupported;
                            }
                        }
                        return has[name] = !!isSupported;
                    }
                    context || (context = root.Object()), exports || (exports = root.Object());
                    var Number = context.Number || root.Number, String = context.String || root.String, Object = context.Object || root.Object, Date = context.Date || root.Date, SyntaxError = context.SyntaxError || root.SyntaxError, TypeError = context.TypeError || root.TypeError, Math = context.Math || root.Math, nativeJSON = context.JSON || root.JSON;
                    "object" == typeof nativeJSON && nativeJSON && (exports.stringify = nativeJSON.stringify, 
                    exports.parse = nativeJSON.parse);
                    var isProperty, forEach, undef, objectProto = Object.prototype, getClass = objectProto.toString, isExtended = new Date(-0xc782b5b800cec);
                    try {
                        isExtended = -109252 == isExtended.getUTCFullYear() && 0 === isExtended.getUTCMonth() && 1 === isExtended.getUTCDate() && 10 == isExtended.getUTCHours() && 37 == isExtended.getUTCMinutes() && 6 == isExtended.getUTCSeconds() && 708 == isExtended.getUTCMilliseconds();
                    } catch (exception) {}
                    if (!has("json")) {
                        var charIndexBuggy = has("bug-string-char-index");
                        if (!isExtended) var floor = Math.floor, Months = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ], getDay = function(year, month) {
                            return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                        };
                        if ((isProperty = objectProto.hasOwnProperty) || (isProperty = function(property) {
                            var constructor, members = {};
                            return (members.__proto__ = null, members.__proto__ = {
                                toString: 1
                            }, members).toString != getClass ? isProperty = function(property) {
                                var original = this.__proto__, result = property in (this.__proto__ = null, this);
                                return this.__proto__ = original, result;
                            } : (constructor = members.constructor, isProperty = function(property) {
                                var parent = (this.constructor || constructor).prototype;
                                return property in this && !(property in parent && this[property] === parent[property]);
                            }), members = null, isProperty.call(this, property);
                        }), forEach = function(object, callback) {
                            var Properties, members, property, size = 0;
                            (Properties = function() {
                                this.valueOf = 0;
                            }).prototype.valueOf = 0, members = new Properties();
                            for (property in members) isProperty.call(members, property) && size++;
                            return Properties = members = null, size ? forEach = 2 == size ? function(object, callback) {
                                var property, members = {}, isFunction = "[object Function]" == getClass.call(object);
                                for (property in object) isFunction && "prototype" == property || isProperty.call(members, property) || !(members[property] = 1) || !isProperty.call(object, property) || callback(property);
                            } : function(object, callback) {
                                var property, isConstructor, isFunction = "[object Function]" == getClass.call(object);
                                for (property in object) isFunction && "prototype" == property || !isProperty.call(object, property) || (isConstructor = "constructor" === property) || callback(property);
                                (isConstructor || isProperty.call(object, property = "constructor")) && callback(property);
                            } : (members = [ "valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor" ], 
                            forEach = function(object, callback) {
                                var property, length, isFunction = "[object Function]" == getClass.call(object), hasProperty = !isFunction && "function" != typeof object.constructor && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
                                for (property in object) isFunction && "prototype" == property || !hasProperty.call(object, property) || callback(property);
                                for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) ;
                            }), forEach(object, callback);
                        }, !has("json-stringify")) {
                            var Escapes = {
                                92: "\\\\",
                                34: '\\"',
                                8: "\\b",
                                12: "\\f",
                                10: "\\n",
                                13: "\\r",
                                9: "\\t"
                            }, toPaddedString = function(width, value) {
                                return ("000000" + (value || 0)).slice(-width);
                            }, quote = function(value) {
                                for (var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10, symbols = useCharIndex && (charIndexBuggy ? value.split("") : value); index < length; index++) {
                                    var charCode = value.charCodeAt(index);
                                    switch (charCode) {
                                      case 8:
                                      case 9:
                                      case 10:
                                      case 12:
                                      case 13:
                                      case 34:
                                      case 92:
                                        result += Escapes[charCode];
                                        break;

                                      default:
                                        if (charCode < 32) {
                                            result += "\\u00" + toPaddedString(2, charCode.toString(16));
                                            break;
                                        }
                                        result += useCharIndex ? symbols[index] : value.charAt(index);
                                    }
                                }
                                return result + '"';
                            }, serialize = function(property, object, callback, properties, whitespace, indentation, stack) {
                                var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
                                try {
                                    value = object[property];
                                } catch (exception) {}
                                if ("object" == typeof value && value) if ("[object Date]" != (className = getClass.call(value)) || isProperty.call(value, "toJSON")) "function" == typeof value.toJSON && ("[object Number]" != className && "[object String]" != className && "[object Array]" != className || isProperty.call(value, "toJSON")) && (value = value.toJSON(property)); else if (value > -1 / 0 && value < 1 / 0) {
                                    if (getDay) {
                                        for (date = floor(value / 864e5), year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) ;
                                        for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) ;
                                        date = 1 + date - getDay(year, month), time = (value % 864e5 + 864e5) % 864e5, hours = floor(time / 36e5) % 24, 
                                        minutes = floor(time / 6e4) % 60, seconds = floor(time / 1e3) % 60, milliseconds = time % 1e3;
                                    } else year = value.getUTCFullYear(), month = value.getUTCMonth(), date = value.getUTCDate(), 
                                    hours = value.getUTCHours(), minutes = value.getUTCMinutes(), seconds = value.getUTCSeconds(), 
                                    milliseconds = value.getUTCMilliseconds();
                                    value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + "." + toPaddedString(3, milliseconds) + "Z";
                                } else value = null;
                                if (callback && (value = callback.call(object, property, value)), null === value) return "null";
                                if ("[object Boolean]" == (className = getClass.call(value))) return "" + value;
                                if ("[object Number]" == className) return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
                                if ("[object String]" == className) return quote("" + value);
                                if ("object" == typeof value) {
                                    for (length = stack.length; length--; ) if (stack[length] === value) throw TypeError();
                                    if (stack.push(value), results = [], prefix = indentation, indentation += whitespace, 
                                    "[object Array]" == className) {
                                        for (index = 0, length = value.length; index < length; index++) element = serialize(index, value, callback, properties, whitespace, indentation, stack), 
                                        results.push(element === undef ? "null" : element);
                                        result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
                                    } else forEach(properties || value, function(property) {
                                        var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                                        element !== undef && results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                                    }), result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
                                    return stack.pop(), result;
                                }
                            };
                            exports.stringify = function(source, filter, width) {
                                var whitespace, callback, properties, className;
                                if (objectTypes[typeof filter] && filter) if ("[object Function]" == (className = getClass.call(filter))) callback = filter; else if ("[object Array]" == className) {
                                    properties = {};
                                    for (var value, index = 0, length = filter.length; index < length; value = filter[index++], 
                                    ("[object String]" == (className = getClass.call(value)) || "[object Number]" == className) && (properties[value] = 1)) ;
                                }
                                if (width) if ("[object Number]" == (className = getClass.call(width))) {
                                    if ((width -= width % 1) > 0) for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") ;
                                } else "[object String]" == className && (whitespace = width.length <= 10 ? width : width.slice(0, 10));
                                return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
                            };
                        }
                        if (!has("json-parse")) {
                            var Index, Source, fromCharCode = String.fromCharCode, Unescapes = {
                                92: "\\",
                                34: '"',
                                47: "/",
                                98: "\b",
                                116: "\t",
                                110: "\n",
                                102: "\f",
                                114: "\r"
                            }, abort = function() {
                                throw Index = Source = null, SyntaxError();
                            }, lex = function() {
                                for (var value, begin, position, isSigned, charCode, source = Source, length = source.length; Index < length; ) switch (charCode = source.charCodeAt(Index)) {
                                  case 9:
                                  case 10:
                                  case 13:
                                  case 32:
                                    Index++;
                                    break;

                                  case 123:
                                  case 125:
                                  case 91:
                                  case 93:
                                  case 58:
                                  case 44:
                                    return value = charIndexBuggy ? source.charAt(Index) : source[Index], Index++, value;

                                  case 34:
                                    for (value = "@", Index++; Index < length; ) if ((charCode = source.charCodeAt(Index)) < 32) abort(); else if (92 == charCode) switch (charCode = source.charCodeAt(++Index)) {
                                      case 92:
                                      case 34:
                                      case 47:
                                      case 98:
                                      case 116:
                                      case 110:
                                      case 102:
                                      case 114:
                                        value += Unescapes[charCode], Index++;
                                        break;

                                      case 117:
                                        for (begin = ++Index, position = Index + 4; Index < position; Index++) (charCode = source.charCodeAt(Index)) >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70 || abort();
                                        value += fromCharCode("0x" + source.slice(begin, Index));
                                        break;

                                      default:
                                        abort();
                                    } else {
                                        if (34 == charCode) break;
                                        for (charCode = source.charCodeAt(Index), begin = Index; charCode >= 32 && 92 != charCode && 34 != charCode; ) charCode = source.charCodeAt(++Index);
                                        value += source.slice(begin, Index);
                                    }
                                    if (34 == source.charCodeAt(Index)) return Index++, value;
                                    abort();

                                  default:
                                    if (begin = Index, 45 == charCode && (isSigned = !0, charCode = source.charCodeAt(++Index)), 
                                    charCode >= 48 && charCode <= 57) {
                                        for (48 == charCode && (charCode = source.charCodeAt(Index + 1)) >= 48 && charCode <= 57 && abort(), 
                                        isSigned = !1; Index < length && (charCode = source.charCodeAt(Index)) >= 48 && charCode <= 57; Index++) ;
                                        if (46 == source.charCodeAt(Index)) {
                                            for (position = ++Index; position < length && (charCode = source.charCodeAt(position)) >= 48 && charCode <= 57; position++) ;
                                            position == Index && abort(), Index = position;
                                        }
                                        if (101 == (charCode = source.charCodeAt(Index)) || 69 == charCode) {
                                            for (charCode = source.charCodeAt(++Index), 43 != charCode && 45 != charCode || Index++, 
                                            position = Index; position < length && (charCode = source.charCodeAt(position)) >= 48 && charCode <= 57; position++) ;
                                            position == Index && abort(), Index = position;
                                        }
                                        return +source.slice(begin, Index);
                                    }
                                    if (isSigned && abort(), "true" == source.slice(Index, Index + 4)) return Index += 4, 
                                    !0;
                                    if ("false" == source.slice(Index, Index + 5)) return Index += 5, !1;
                                    if ("null" == source.slice(Index, Index + 4)) return Index += 4, null;
                                    abort();
                                }
                                return "$";
                            }, get = function(value) {
                                var results, hasMembers;
                                if ("$" == value && abort(), "string" == typeof value) {
                                    if ("@" == (charIndexBuggy ? value.charAt(0) : value[0])) return value.slice(1);
                                    if ("[" == value) {
                                        for (results = []; "]" != (value = lex()); hasMembers || (hasMembers = !0)) hasMembers && ("," == value ? "]" == (value = lex()) && abort() : abort()), 
                                        "," == value && abort(), results.push(get(value));
                                        return results;
                                    }
                                    if ("{" == value) {
                                        for (results = {}; "}" != (value = lex()); hasMembers || (hasMembers = !0)) hasMembers && ("," == value ? "}" == (value = lex()) && abort() : abort()), 
                                        "," != value && "string" == typeof value && "@" == (charIndexBuggy ? value.charAt(0) : value[0]) && ":" == lex() || abort(), 
                                        results[value.slice(1)] = get(lex());
                                        return results;
                                    }
                                    abort();
                                }
                                return value;
                            }, update = function(source, property, callback) {
                                var element = walk(source, property, callback);
                                element === undef ? delete source[property] : source[property] = element;
                            }, walk = function(source, property, callback) {
                                var length, value = source[property];
                                if ("object" == typeof value && value) if ("[object Array]" == getClass.call(value)) for (length = value.length; length--; ) update(value, length, callback); else forEach(value, function(property) {
                                    update(value, property, callback);
                                });
                                return callback.call(source, property, value);
                            };
                            exports.parse = function(source, callback) {
                                var result, value;
                                return Index = 0, Source = "" + source, result = get(lex()), "$" != lex() && abort(), 
                                Index = Source = null, callback && "[object Function]" == getClass.call(callback) ? walk((value = {}, 
                                value[""] = result, value), "", callback) : result;
                            };
                        }
                    }
                    return exports.runInContext = runInContext, exports;
                }
                var isLoader = "function" == typeof define && define.amd, objectTypes = {
                    function: !0,
                    object: !0
                }, freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports, root = objectTypes[typeof window] && window || this, freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && "object" == typeof global && global;
                if (!freeGlobal || freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal && freeGlobal.self !== freeGlobal || (root = freeGlobal), 
                freeExports && !isLoader) runInContext(root, freeExports); else {
                    var nativeJSON = root.JSON, previousJSON = root.JSON3, isRestored = !1, JSON3 = runInContext(root, root.JSON3 = {
                        noConflict: function() {
                            return isRestored || (isRestored = !0, root.JSON = nativeJSON, root.JSON3 = previousJSON, 
                            nativeJSON = previousJSON = null), JSON3;
                        }
                    });
                    root.JSON = {
                        parse: JSON3.parse,
                        stringify: JSON3.stringify
                    };
                }
                isLoader && define(function() {
                    return JSON3;
                });
            }).call(this);
        }).call(exports, __webpack_require__(12)(module), function() {
            return this;
        }());
    }, function(module, exports) {
        module.exports = function(module) {
            return module.webpackPolyfill || (module.deprecate = function() {}, module.paths = [], 
            module.children = [], module.webpackPolyfill = 1), module;
        };
    }, function(module, exports) {
        function Emitter(obj) {
            if (obj) return mixin(obj);
        }
        function mixin(obj) {
            for (var key in Emitter.prototype) obj[key] = Emitter.prototype[key];
            return obj;
        }
        module.exports = Emitter, Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
            return this._callbacks = this._callbacks || {}, (this._callbacks[event] = this._callbacks[event] || []).push(fn), 
            this;
        }, Emitter.prototype.once = function(event, fn) {
            function on() {
                self.off(event, on), fn.apply(this, arguments);
            }
            var self = this;
            return this._callbacks = this._callbacks || {}, on.fn = fn, this.on(event, on), 
            this;
        }, Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
            if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, 
            this;
            var callbacks = this._callbacks[event];
            if (!callbacks) return this;
            if (1 == arguments.length) return delete this._callbacks[event], this;
            for (var cb, i = 0; i < callbacks.length; i++) if ((cb = callbacks[i]) === fn || cb.fn === fn) {
                callbacks.splice(i, 1);
                break;
            }
            return this;
        }, Emitter.prototype.emit = function(event) {
            this._callbacks = this._callbacks || {};
            var args = [].slice.call(arguments, 1), callbacks = this._callbacks[event];
            if (callbacks) {
                callbacks = callbacks.slice(0);
                for (var i = 0, len = callbacks.length; i < len; ++i) callbacks[i].apply(this, args);
            }
            return this;
        }, Emitter.prototype.listeners = function(event) {
            return this._callbacks = this._callbacks || {}, this._callbacks[event] || [];
        }, Emitter.prototype.hasListeners = function(event) {
            return !!this.listeners(event).length;
        };
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            var isArray = __webpack_require__(15), isBuf = __webpack_require__(16);
            exports.deconstructPacket = function(packet) {
                function _deconstructPacket(data) {
                    if (!data) return data;
                    if (isBuf(data)) {
                        var placeholder = {
                            _placeholder: !0,
                            num: buffers.length
                        };
                        return buffers.push(data), placeholder;
                    }
                    if (isArray(data)) {
                        for (var newData = new Array(data.length), i = 0; i < data.length; i++) newData[i] = _deconstructPacket(data[i]);
                        return newData;
                    }
                    if ("object" == typeof data && !(data instanceof Date)) {
                        var newData = {};
                        for (var key in data) newData[key] = _deconstructPacket(data[key]);
                        return newData;
                    }
                    return data;
                }
                var buffers = [], packetData = packet.data, pack = packet;
                return pack.data = _deconstructPacket(packetData), pack.attachments = buffers.length, 
                {
                    packet: pack,
                    buffers: buffers
                };
            }, exports.reconstructPacket = function(packet, buffers) {
                function _reconstructPacket(data) {
                    if (data && data._placeholder) {
                        return buffers[data.num];
                    }
                    if (isArray(data)) {
                        for (var i = 0; i < data.length; i++) data[i] = _reconstructPacket(data[i]);
                        return data;
                    }
                    if (data && "object" == typeof data) {
                        for (var key in data) data[key] = _reconstructPacket(data[key]);
                        return data;
                    }
                    return data;
                }
                return packet.data = _reconstructPacket(packet.data), packet.attachments = void 0, 
                packet;
            }, exports.removeBlobs = function(data, callback) {
                function _removeBlobs(obj, curKey, containingObject) {
                    if (!obj) return obj;
                    if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
                        pendingBlobs++;
                        var fileReader = new FileReader();
                        fileReader.onload = function() {
                            containingObject ? containingObject[curKey] = this.result : bloblessData = this.result, 
                            --pendingBlobs || callback(bloblessData);
                        }, fileReader.readAsArrayBuffer(obj);
                    } else if (isArray(obj)) for (var i = 0; i < obj.length; i++) _removeBlobs(obj[i], i, obj); else if (obj && "object" == typeof obj && !isBuf(obj)) for (var key in obj) _removeBlobs(obj[key], key, obj);
                }
                var pendingBlobs = 0, bloblessData = data;
                _removeBlobs(bloblessData), pendingBlobs || callback(bloblessData);
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports) {
        module.exports = Array.isArray || function(arr) {
            return "[object Array]" == Object.prototype.toString.call(arr);
        };
    }, function(module, exports) {
        (function(global) {
            function isBuf(obj) {
                return global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;
            }
            module.exports = isBuf;
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports, __webpack_require__) {
        function Manager(uri, opts) {
            if (!(this instanceof Manager)) return new Manager(uri, opts);
            uri && "object" === (void 0 === uri ? "undefined" : _typeof(uri)) && (opts = uri, 
            uri = void 0), opts = opts || {}, opts.path = opts.path || "/socket.io", this.nsps = {}, 
            this.subs = [], this.opts = opts, this.reconnection(!1 !== opts.reconnection), this.reconnectionAttempts(opts.reconnectionAttempts || 1 / 0), 
            this.reconnectionDelay(opts.reconnectionDelay || 1e3), this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3), 
            this.randomizationFactor(opts.randomizationFactor || .5), this.backoff = new Backoff({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor()
            }), this.timeout(null == opts.timeout ? 2e4 : opts.timeout), this.readyState = "closed", 
            this.uri = uri, this.connecting = [], this.lastPing = null, this.encoding = !1, 
            this.packetBuffer = [], this.encoder = new parser.Encoder(), this.decoder = new parser.Decoder(), 
            this.autoConnect = !1 !== opts.autoConnect, this.autoConnect && this.open();
        }
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, eio = __webpack_require__(18), Socket = __webpack_require__(44), Emitter = __webpack_require__(35), parser = __webpack_require__(7), on = __webpack_require__(46), bind = __webpack_require__(47), debug = __webpack_require__(3)("socket.io-client:manager"), indexOf = __webpack_require__(42), Backoff = __webpack_require__(48), has = Object.prototype.hasOwnProperty;
        module.exports = Manager, Manager.prototype.emitAll = function() {
            this.emit.apply(this, arguments);
            for (var nsp in this.nsps) has.call(this.nsps, nsp) && this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
        }, Manager.prototype.updateSocketIds = function() {
            for (var nsp in this.nsps) has.call(this.nsps, nsp) && (this.nsps[nsp].id = this.engine.id);
        }, Emitter(Manager.prototype), Manager.prototype.reconnection = function(v) {
            return arguments.length ? (this._reconnection = !!v, this) : this._reconnection;
        }, Manager.prototype.reconnectionAttempts = function(v) {
            return arguments.length ? (this._reconnectionAttempts = v, this) : this._reconnectionAttempts;
        }, Manager.prototype.reconnectionDelay = function(v) {
            return arguments.length ? (this._reconnectionDelay = v, this.backoff && this.backoff.setMin(v), 
            this) : this._reconnectionDelay;
        }, Manager.prototype.randomizationFactor = function(v) {
            return arguments.length ? (this._randomizationFactor = v, this.backoff && this.backoff.setJitter(v), 
            this) : this._randomizationFactor;
        }, Manager.prototype.reconnectionDelayMax = function(v) {
            return arguments.length ? (this._reconnectionDelayMax = v, this.backoff && this.backoff.setMax(v), 
            this) : this._reconnectionDelayMax;
        }, Manager.prototype.timeout = function(v) {
            return arguments.length ? (this._timeout = v, this) : this._timeout;
        }, Manager.prototype.maybeReconnectOnOpen = function() {
            !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();
        }, Manager.prototype.open = Manager.prototype.connect = function(fn, opts) {
            if (debug("readyState %s", this.readyState), ~this.readyState.indexOf("open")) return this;
            debug("opening %s", this.uri), this.engine = eio(this.uri, this.opts);
            var socket = this.engine, self = this;
            this.readyState = "opening", this.skipReconnect = !1;
            var openSub = on(socket, "open", function() {
                self.onopen(), fn && fn();
            }), errorSub = on(socket, "error", function(data) {
                if (debug("connect_error"), self.cleanup(), self.readyState = "closed", self.emitAll("connect_error", data), 
                fn) {
                    var err = new Error("Connection error");
                    err.data = data, fn(err);
                } else self.maybeReconnectOnOpen();
            });
            if (!1 !== this._timeout) {
                var timeout = this._timeout;
                debug("connect attempt will timeout after %d", timeout);
                var timer = setTimeout(function() {
                    debug("connect attempt timed out after %d", timeout), openSub.destroy(), socket.close(), 
                    socket.emit("error", "timeout"), self.emitAll("connect_timeout", timeout);
                }, timeout);
                this.subs.push({
                    destroy: function() {
                        clearTimeout(timer);
                    }
                });
            }
            return this.subs.push(openSub), this.subs.push(errorSub), this;
        }, Manager.prototype.onopen = function() {
            debug("open"), this.cleanup(), this.readyState = "open", this.emit("open");
            var socket = this.engine;
            this.subs.push(on(socket, "data", bind(this, "ondata"))), this.subs.push(on(socket, "ping", bind(this, "onping"))), 
            this.subs.push(on(socket, "pong", bind(this, "onpong"))), this.subs.push(on(socket, "error", bind(this, "onerror"))), 
            this.subs.push(on(socket, "close", bind(this, "onclose"))), this.subs.push(on(this.decoder, "decoded", bind(this, "ondecoded")));
        }, Manager.prototype.onping = function() {
            this.lastPing = new Date(), this.emitAll("ping");
        }, Manager.prototype.onpong = function() {
            this.emitAll("pong", new Date() - this.lastPing);
        }, Manager.prototype.ondata = function(data) {
            this.decoder.add(data);
        }, Manager.prototype.ondecoded = function(packet) {
            this.emit("packet", packet);
        }, Manager.prototype.onerror = function(err) {
            debug("error", err), this.emitAll("error", err);
        }, Manager.prototype.socket = function(nsp, opts) {
            function onConnecting() {
                ~indexOf(self.connecting, socket) || self.connecting.push(socket);
            }
            var socket = this.nsps[nsp];
            if (!socket) {
                socket = new Socket(this, nsp, opts), this.nsps[nsp] = socket;
                var self = this;
                socket.on("connecting", onConnecting), socket.on("connect", function() {
                    socket.id = self.engine.id;
                }), this.autoConnect && onConnecting();
            }
            return socket;
        }, Manager.prototype.destroy = function(socket) {
            var index = indexOf(this.connecting, socket);
            ~index && this.connecting.splice(index, 1), this.connecting.length || this.close();
        }, Manager.prototype.packet = function(packet) {
            debug("writing packet %j", packet);
            var self = this;
            packet.query && 0 === packet.type && (packet.nsp += "?" + packet.query), self.encoding ? self.packetBuffer.push(packet) : (self.encoding = !0, 
            this.encoder.encode(packet, function(encodedPackets) {
                for (var i = 0; i < encodedPackets.length; i++) self.engine.write(encodedPackets[i], packet.options);
                self.encoding = !1, self.processPacketQueue();
            }));
        }, Manager.prototype.processPacketQueue = function() {
            if (this.packetBuffer.length > 0 && !this.encoding) {
                var pack = this.packetBuffer.shift();
                this.packet(pack);
            }
        }, Manager.prototype.cleanup = function() {
            debug("cleanup");
            for (var subsLength = this.subs.length, i = 0; i < subsLength; i++) {
                this.subs.shift().destroy();
            }
            this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy();
        }, Manager.prototype.close = Manager.prototype.disconnect = function() {
            debug("disconnect"), this.skipReconnect = !0, this.reconnecting = !1, "opening" === this.readyState && this.cleanup(), 
            this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close();
        }, Manager.prototype.onclose = function(reason) {
            debug("onclose"), this.cleanup(), this.backoff.reset(), this.readyState = "closed", 
            this.emit("close", reason), this._reconnection && !this.skipReconnect && this.reconnect();
        }, Manager.prototype.reconnect = function() {
            if (this.reconnecting || this.skipReconnect) return this;
            var self = this;
            if (this.backoff.attempts >= this._reconnectionAttempts) debug("reconnect failed"), 
            this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1; else {
                var delay = this.backoff.duration();
                debug("will wait %dms before reconnect attempt", delay), this.reconnecting = !0;
                var timer = setTimeout(function() {
                    self.skipReconnect || (debug("attempting reconnect"), self.emitAll("reconnect_attempt", self.backoff.attempts), 
                    self.emitAll("reconnecting", self.backoff.attempts), self.skipReconnect || self.open(function(err) {
                        err ? (debug("reconnect attempt error"), self.reconnecting = !1, self.reconnect(), 
                        self.emitAll("reconnect_error", err.data)) : (debug("reconnect success"), self.onreconnect());
                    }));
                }, delay);
                this.subs.push({
                    destroy: function() {
                        clearTimeout(timer);
                    }
                });
            }
        }, Manager.prototype.onreconnect = function() {
            var attempt = this.backoff.attempts;
            this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", attempt);
        };
    }, function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(19);
    }, function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(20), module.exports.parser = __webpack_require__(27);
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            function Socket(uri, opts) {
                if (!(this instanceof Socket)) return new Socket(uri, opts);
                opts = opts || {}, uri && "object" == typeof uri && (opts = uri, uri = null), uri ? (uri = parseuri(uri), 
                opts.hostname = uri.host, opts.secure = "https" === uri.protocol || "wss" === uri.protocol, 
                opts.port = uri.port, uri.query && (opts.query = uri.query)) : opts.host && (opts.hostname = parseuri(opts.host).host), 
                this.secure = null != opts.secure ? opts.secure : global.location && "https:" === location.protocol, 
                opts.hostname && !opts.port && (opts.port = this.secure ? "443" : "80"), this.agent = opts.agent || !1, 
                this.hostname = opts.hostname || (global.location ? location.hostname : "localhost"), 
                this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80), 
                this.query = opts.query || {}, "string" == typeof this.query && (this.query = parseqs.decode(this.query)), 
                this.upgrade = !1 !== opts.upgrade, this.path = (opts.path || "/engine.io").replace(/\/$/, "") + "/", 
                this.forceJSONP = !!opts.forceJSONP, this.jsonp = !1 !== opts.jsonp, this.forceBase64 = !!opts.forceBase64, 
                this.enablesXDR = !!opts.enablesXDR, this.timestampParam = opts.timestampParam || "t", 
                this.timestampRequests = opts.timestampRequests, this.transports = opts.transports || [ "polling", "websocket" ], 
                this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = opts.policyPort || 843, 
                this.rememberUpgrade = opts.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades, 
                this.perMessageDeflate = !1 !== opts.perMessageDeflate && (opts.perMessageDeflate || {}), 
                !0 === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), 
                this.pfx = opts.pfx || null, this.key = opts.key || null, this.passphrase = opts.passphrase || null, 
                this.cert = opts.cert || null, this.ca = opts.ca || null, this.ciphers = opts.ciphers || null, 
                this.rejectUnauthorized = void 0 === opts.rejectUnauthorized ? null : opts.rejectUnauthorized, 
                this.forceNode = !!opts.forceNode;
                var freeGlobal = "object" == typeof global && global;
                freeGlobal.global === freeGlobal && (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0 && (this.extraHeaders = opts.extraHeaders), 
                opts.localAddress && (this.localAddress = opts.localAddress)), this.id = null, this.upgrades = null, 
                this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, 
                this.pingTimeoutTimer = null, this.open();
            }
            function clone(obj) {
                var o = {};
                for (var i in obj) obj.hasOwnProperty(i) && (o[i] = obj[i]);
                return o;
            }
            var transports = __webpack_require__(21), Emitter = __webpack_require__(35), debug = __webpack_require__(3)("engine.io-client:socket"), index = __webpack_require__(42), parser = __webpack_require__(27), parseuri = __webpack_require__(2), parsejson = __webpack_require__(43), parseqs = __webpack_require__(36);
            module.exports = Socket, Socket.priorWebsocketSuccess = !1, Emitter(Socket.prototype), 
            Socket.protocol = parser.protocol, Socket.Socket = Socket, Socket.Transport = __webpack_require__(26), 
            Socket.transports = __webpack_require__(21), Socket.parser = __webpack_require__(27), 
            Socket.prototype.createTransport = function(name) {
                debug('creating transport "%s"', name);
                var query = clone(this.query);
                return query.EIO = parser.protocol, query.transport = name, this.id && (query.sid = this.id), 
                new transports[name]({
                    agent: this.agent,
                    hostname: this.hostname,
                    port: this.port,
                    secure: this.secure,
                    path: this.path,
                    query: query,
                    forceJSONP: this.forceJSONP,
                    jsonp: this.jsonp,
                    forceBase64: this.forceBase64,
                    enablesXDR: this.enablesXDR,
                    timestampRequests: this.timestampRequests,
                    timestampParam: this.timestampParam,
                    policyPort: this.policyPort,
                    socket: this,
                    pfx: this.pfx,
                    key: this.key,
                    passphrase: this.passphrase,
                    cert: this.cert,
                    ca: this.ca,
                    ciphers: this.ciphers,
                    rejectUnauthorized: this.rejectUnauthorized,
                    perMessageDeflate: this.perMessageDeflate,
                    extraHeaders: this.extraHeaders,
                    forceNode: this.forceNode,
                    localAddress: this.localAddress
                });
            }, Socket.prototype.open = function() {
                var transport;
                if (this.rememberUpgrade && Socket.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket")) transport = "websocket"; else {
                    if (0 === this.transports.length) {
                        var self = this;
                        return void setTimeout(function() {
                            self.emit("error", "No transports available");
                        }, 0);
                    }
                    transport = this.transports[0];
                }
                this.readyState = "opening";
                try {
                    transport = this.createTransport(transport);
                } catch (e) {
                    return this.transports.shift(), void this.open();
                }
                transport.open(), this.setTransport(transport);
            }, Socket.prototype.setTransport = function(transport) {
                debug("setting transport %s", transport.name);
                var self = this;
                this.transport && (debug("clearing existing transport %s", this.transport.name), 
                this.transport.removeAllListeners()), this.transport = transport, transport.on("drain", function() {
                    self.onDrain();
                }).on("packet", function(packet) {
                    self.onPacket(packet);
                }).on("error", function(e) {
                    self.onError(e);
                }).on("close", function() {
                    self.onClose("transport close");
                });
            }, Socket.prototype.probe = function(name) {
                function onTransportOpen() {
                    if (self.onlyBinaryUpgrades) {
                        var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
                        failed = failed || upgradeLosesBinary;
                    }
                    failed || (debug('probe transport "%s" opened', name), transport.send([ {
                        type: "ping",
                        data: "probe"
                    } ]), transport.once("packet", function(msg) {
                        if (!failed) if ("pong" === msg.type && "probe" === msg.data) {
                            if (debug('probe transport "%s" pong', name), self.upgrading = !0, self.emit("upgrading", transport), 
                            !transport) return;
                            Socket.priorWebsocketSuccess = "websocket" === transport.name, debug('pausing current transport "%s"', self.transport.name), 
                            self.transport.pause(function() {
                                failed || "closed" !== self.readyState && (debug("changing transport and sending upgrade packet"), 
                                cleanup(), self.setTransport(transport), transport.send([ {
                                    type: "upgrade"
                                } ]), self.emit("upgrade", transport), transport = null, self.upgrading = !1, self.flush());
                            });
                        } else {
                            debug('probe transport "%s" failed', name);
                            var err = new Error("probe error");
                            err.transport = transport.name, self.emit("upgradeError", err);
                        }
                    }));
                }
                function freezeTransport() {
                    failed || (failed = !0, cleanup(), transport.close(), transport = null);
                }
                function onerror(err) {
                    var error = new Error("probe error: " + err);
                    error.transport = transport.name, freezeTransport(), debug('probe transport "%s" failed because of error: %s', name, err), 
                    self.emit("upgradeError", error);
                }
                function onTransportClose() {
                    onerror("transport closed");
                }
                function onclose() {
                    onerror("socket closed");
                }
                function onupgrade(to) {
                    transport && to.name !== transport.name && (debug('"%s" works - aborting "%s"', to.name, transport.name), 
                    freezeTransport());
                }
                function cleanup() {
                    transport.removeListener("open", onTransportOpen), transport.removeListener("error", onerror), 
                    transport.removeListener("close", onTransportClose), self.removeListener("close", onclose), 
                    self.removeListener("upgrading", onupgrade);
                }
                debug('probing transport "%s"', name);
                var transport = this.createTransport(name, {
                    probe: 1
                }), failed = !1, self = this;
                Socket.priorWebsocketSuccess = !1, transport.once("open", onTransportOpen), transport.once("error", onerror), 
                transport.once("close", onTransportClose), this.once("close", onclose), this.once("upgrading", onupgrade), 
                transport.open();
            }, Socket.prototype.onOpen = function() {
                if (debug("socket open"), this.readyState = "open", Socket.priorWebsocketSuccess = "websocket" === this.transport.name, 
                this.emit("open"), this.flush(), "open" === this.readyState && this.upgrade && this.transport.pause) {
                    debug("starting upgrade probes");
                    for (var i = 0, l = this.upgrades.length; i < l; i++) this.probe(this.upgrades[i]);
                }
            }, Socket.prototype.onPacket = function(packet) {
                if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (debug('socket receive: type "%s", data "%s"', packet.type, packet.data), 
                this.emit("packet", packet), this.emit("heartbeat"), packet.type) {
                  case "open":
                    this.onHandshake(parsejson(packet.data));
                    break;

                  case "pong":
                    this.setPing(), this.emit("pong");
                    break;

                  case "error":
                    var err = new Error("server error");
                    err.code = packet.data, this.onError(err);
                    break;

                  case "message":
                    this.emit("data", packet.data), this.emit("message", packet.data);
                } else debug('packet received with socket readyState "%s"', this.readyState);
            }, Socket.prototype.onHandshake = function(data) {
                this.emit("handshake", data), this.id = data.sid, this.transport.query.sid = data.sid, 
                this.upgrades = this.filterUpgrades(data.upgrades), this.pingInterval = data.pingInterval, 
                this.pingTimeout = data.pingTimeout, this.onOpen(), "closed" !== this.readyState && (this.setPing(), 
                this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat));
            }, Socket.prototype.onHeartbeat = function(timeout) {
                clearTimeout(this.pingTimeoutTimer);
                var self = this;
                self.pingTimeoutTimer = setTimeout(function() {
                    "closed" !== self.readyState && self.onClose("ping timeout");
                }, timeout || self.pingInterval + self.pingTimeout);
            }, Socket.prototype.setPing = function() {
                var self = this;
                clearTimeout(self.pingIntervalTimer), self.pingIntervalTimer = setTimeout(function() {
                    debug("writing ping packet - expecting pong within %sms", self.pingTimeout), self.ping(), 
                    self.onHeartbeat(self.pingTimeout);
                }, self.pingInterval);
            }, Socket.prototype.ping = function() {
                var self = this;
                this.sendPacket("ping", function() {
                    self.emit("ping");
                });
            }, Socket.prototype.onDrain = function() {
                this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush();
            }, Socket.prototype.flush = function() {
                "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (debug("flushing %d packets in socket", this.writeBuffer.length), 
                this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, 
                this.emit("flush"));
            }, Socket.prototype.write = Socket.prototype.send = function(msg, options, fn) {
                return this.sendPacket("message", msg, options, fn), this;
            }, Socket.prototype.sendPacket = function(type, data, options, fn) {
                if ("function" == typeof data && (fn = data, data = void 0), "function" == typeof options && (fn = options, 
                options = null), "closing" !== this.readyState && "closed" !== this.readyState) {
                    options = options || {}, options.compress = !1 !== options.compress;
                    var packet = {
                        type: type,
                        data: data,
                        options: options
                    };
                    this.emit("packetCreate", packet), this.writeBuffer.push(packet), fn && this.once("flush", fn), 
                    this.flush();
                }
            }, Socket.prototype.close = function() {
                function close() {
                    self.onClose("forced close"), debug("socket closing - telling transport to close"), 
                    self.transport.close();
                }
                function cleanupAndClose() {
                    self.removeListener("upgrade", cleanupAndClose), self.removeListener("upgradeError", cleanupAndClose), 
                    close();
                }
                function waitForUpgrade() {
                    self.once("upgrade", cleanupAndClose), self.once("upgradeError", cleanupAndClose);
                }
                if ("opening" === this.readyState || "open" === this.readyState) {
                    this.readyState = "closing";
                    var self = this;
                    this.writeBuffer.length ? this.once("drain", function() {
                        this.upgrading ? waitForUpgrade() : close();
                    }) : this.upgrading ? waitForUpgrade() : close();
                }
                return this;
            }, Socket.prototype.onError = function(err) {
                debug("socket error %j", err), Socket.priorWebsocketSuccess = !1, this.emit("error", err), 
                this.onClose("transport error", err);
            }, Socket.prototype.onClose = function(reason, desc) {
                if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
                    debug('socket close with reason: "%s"', reason);
                    var self = this;
                    clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), 
                    this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", 
                    this.id = null, this.emit("close", reason, desc), self.writeBuffer = [], self.prevBufferLen = 0;
                }
            }, Socket.prototype.filterUpgrades = function(upgrades) {
                for (var filteredUpgrades = [], i = 0, j = upgrades.length; i < j; i++) ~index(this.transports, upgrades[i]) && filteredUpgrades.push(upgrades[i]);
                return filteredUpgrades;
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            function polling(opts) {
                var xd = !1, xs = !1, jsonp = !1 !== opts.jsonp;
                if (global.location) {
                    var isSSL = "https:" === location.protocol, port = location.port;
                    port || (port = isSSL ? 443 : 80), xd = opts.hostname !== location.hostname || port !== opts.port, 
                    xs = opts.secure !== isSSL;
                }
                if (opts.xdomain = xd, opts.xscheme = xs, "open" in new XMLHttpRequest(opts) && !opts.forceJSONP) return new XHR(opts);
                if (!jsonp) throw new Error("JSONP disabled");
                return new JSONP(opts);
            }
            var XMLHttpRequest = __webpack_require__(22), XHR = __webpack_require__(24), JSONP = __webpack_require__(39), websocket = __webpack_require__(40);
            exports.polling = polling, exports.websocket = websocket;
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            var hasCORS = __webpack_require__(23);
            module.exports = function(opts) {
                var xdomain = opts.xdomain, xscheme = opts.xscheme, enablesXDR = opts.enablesXDR;
                try {
                    if ("undefined" != typeof XMLHttpRequest && (!xdomain || hasCORS)) return new XMLHttpRequest();
                } catch (e) {}
                try {
                    if ("undefined" != typeof XDomainRequest && !xscheme && enablesXDR) return new XDomainRequest();
                } catch (e) {}
                if (!xdomain) try {
                    return new (global[[ "Active" ].concat("Object").join("X")])("Microsoft.XMLHTTP");
                } catch (e) {}
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports) {
        try {
            module.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
        } catch (err) {
            module.exports = !1;
        }
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            function empty() {}
            function XHR(opts) {
                if (Polling.call(this, opts), this.requestTimeout = opts.requestTimeout, global.location) {
                    var isSSL = "https:" === location.protocol, port = location.port;
                    port || (port = isSSL ? 443 : 80), this.xd = opts.hostname !== global.location.hostname || port !== opts.port, 
                    this.xs = opts.secure !== isSSL;
                } else this.extraHeaders = opts.extraHeaders;
            }
            function Request(opts) {
                this.method = opts.method || "GET", this.uri = opts.uri, this.xd = !!opts.xd, this.xs = !!opts.xs, 
                this.async = !1 !== opts.async, this.data = void 0 !== opts.data ? opts.data : null, 
                this.agent = opts.agent, this.isBinary = opts.isBinary, this.supportsBinary = opts.supportsBinary, 
                this.enablesXDR = opts.enablesXDR, this.requestTimeout = opts.requestTimeout, this.pfx = opts.pfx, 
                this.key = opts.key, this.passphrase = opts.passphrase, this.cert = opts.cert, this.ca = opts.ca, 
                this.ciphers = opts.ciphers, this.rejectUnauthorized = opts.rejectUnauthorized, 
                this.extraHeaders = opts.extraHeaders, this.create();
            }
            function unloadHandler() {
                for (var i in Request.requests) Request.requests.hasOwnProperty(i) && Request.requests[i].abort();
            }
            var XMLHttpRequest = __webpack_require__(22), Polling = __webpack_require__(25), Emitter = __webpack_require__(35), inherit = __webpack_require__(37), debug = __webpack_require__(3)("engine.io-client:polling-xhr");
            module.exports = XHR, module.exports.Request = Request, inherit(XHR, Polling), XHR.prototype.supportsBinary = !0, 
            XHR.prototype.request = function(opts) {
                return opts = opts || {}, opts.uri = this.uri(), opts.xd = this.xd, opts.xs = this.xs, 
                opts.agent = this.agent || !1, opts.supportsBinary = this.supportsBinary, opts.enablesXDR = this.enablesXDR, 
                opts.pfx = this.pfx, opts.key = this.key, opts.passphrase = this.passphrase, opts.cert = this.cert, 
                opts.ca = this.ca, opts.ciphers = this.ciphers, opts.rejectUnauthorized = this.rejectUnauthorized, 
                opts.requestTimeout = this.requestTimeout, opts.extraHeaders = this.extraHeaders, 
                new Request(opts);
            }, XHR.prototype.doWrite = function(data, fn) {
                var isBinary = "string" != typeof data && void 0 !== data, req = this.request({
                    method: "POST",
                    data: data,
                    isBinary: isBinary
                }), self = this;
                req.on("success", fn), req.on("error", function(err) {
                    self.onError("xhr post error", err);
                }), this.sendXhr = req;
            }, XHR.prototype.doPoll = function() {
                debug("xhr poll");
                var req = this.request(), self = this;
                req.on("data", function(data) {
                    self.onData(data);
                }), req.on("error", function(err) {
                    self.onError("xhr poll error", err);
                }), this.pollXhr = req;
            }, Emitter(Request.prototype), Request.prototype.create = function() {
                var opts = {
                    agent: this.agent,
                    xdomain: this.xd,
                    xscheme: this.xs,
                    enablesXDR: this.enablesXDR
                };
                opts.pfx = this.pfx, opts.key = this.key, opts.passphrase = this.passphrase, opts.cert = this.cert, 
                opts.ca = this.ca, opts.ciphers = this.ciphers, opts.rejectUnauthorized = this.rejectUnauthorized;
                var xhr = this.xhr = new XMLHttpRequest(opts), self = this;
                try {
                    debug("xhr open %s: %s", this.method, this.uri), xhr.open(this.method, this.uri, this.async);
                    try {
                        if (this.extraHeaders) {
                            xhr.setDisableHeaderCheck(!0);
                            for (var i in this.extraHeaders) this.extraHeaders.hasOwnProperty(i) && xhr.setRequestHeader(i, this.extraHeaders[i]);
                        }
                    } catch (e) {}
                    if (this.supportsBinary && (xhr.responseType = "arraybuffer"), "POST" === this.method) try {
                        this.isBinary ? xhr.setRequestHeader("Content-type", "application/octet-stream") : xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                    } catch (e) {}
                    try {
                        xhr.setRequestHeader("Accept", "*/*");
                    } catch (e) {}
                    "withCredentials" in xhr && (xhr.withCredentials = !0), this.requestTimeout && (xhr.timeout = this.requestTimeout), 
                    this.hasXDR() ? (xhr.onload = function() {
                        self.onLoad();
                    }, xhr.onerror = function() {
                        self.onError(xhr.responseText);
                    }) : xhr.onreadystatechange = function() {
                        4 === xhr.readyState && (200 === xhr.status || 1223 === xhr.status ? self.onLoad() : setTimeout(function() {
                            self.onError(xhr.status);
                        }, 0));
                    }, debug("xhr data %s", this.data), xhr.send(this.data);
                } catch (e) {
                    return void setTimeout(function() {
                        self.onError(e);
                    }, 0);
                }
                global.document && (this.index = Request.requestsCount++, Request.requests[this.index] = this);
            }, Request.prototype.onSuccess = function() {
                this.emit("success"), this.cleanup();
            }, Request.prototype.onData = function(data) {
                this.emit("data", data), this.onSuccess();
            }, Request.prototype.onError = function(err) {
                this.emit("error", err), this.cleanup(!0);
            }, Request.prototype.cleanup = function(fromError) {
                if (void 0 !== this.xhr && null !== this.xhr) {
                    if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = empty : this.xhr.onreadystatechange = empty, 
                    fromError) try {
                        this.xhr.abort();
                    } catch (e) {}
                    global.document && delete Request.requests[this.index], this.xhr = null;
                }
            }, Request.prototype.onLoad = function() {
                var data;
                try {
                    var contentType;
                    try {
                        contentType = this.xhr.getResponseHeader("Content-Type").split(";")[0];
                    } catch (e) {}
                    if ("application/octet-stream" === contentType) data = this.xhr.response || this.xhr.responseText; else if (this.supportsBinary) try {
                        data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
                    } catch (e) {
                        for (var ui8Arr = new Uint8Array(this.xhr.response), dataArray = [], idx = 0, length = ui8Arr.length; idx < length; idx++) dataArray.push(ui8Arr[idx]);
                        data = String.fromCharCode.apply(null, dataArray);
                    } else data = this.xhr.responseText;
                } catch (e) {
                    this.onError(e);
                }
                null != data && this.onData(data);
            }, Request.prototype.hasXDR = function() {
                return void 0 !== global.XDomainRequest && !this.xs && this.enablesXDR;
            }, Request.prototype.abort = function() {
                this.cleanup();
            }, Request.requestsCount = 0, Request.requests = {}, global.document && (global.attachEvent ? global.attachEvent("onunload", unloadHandler) : global.addEventListener && global.addEventListener("beforeunload", unloadHandler, !1));
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports, __webpack_require__) {
        function Polling(opts) {
            var forceBase64 = opts && opts.forceBase64;
            hasXHR2 && !forceBase64 || (this.supportsBinary = !1), Transport.call(this, opts);
        }
        var Transport = __webpack_require__(26), parseqs = __webpack_require__(36), parser = __webpack_require__(27), inherit = __webpack_require__(37), yeast = __webpack_require__(38), debug = __webpack_require__(3)("engine.io-client:polling");
        module.exports = Polling;
        var hasXHR2 = function() {
            return null != new (__webpack_require__(22))({
                xdomain: !1
            }).responseType;
        }();
        inherit(Polling, Transport), Polling.prototype.name = "polling", Polling.prototype.doOpen = function() {
            this.poll();
        }, Polling.prototype.pause = function(onPause) {
            function pause() {
                debug("paused"), self.readyState = "paused", onPause();
            }
            var self = this;
            if (this.readyState = "pausing", this.polling || !this.writable) {
                var total = 0;
                this.polling && (debug("we are currently polling - waiting to pause"), total++, 
                this.once("pollComplete", function() {
                    debug("pre-pause polling complete"), --total || pause();
                })), this.writable || (debug("we are currently writing - waiting to pause"), total++, 
                this.once("drain", function() {
                    debug("pre-pause writing complete"), --total || pause();
                }));
            } else pause();
        }, Polling.prototype.poll = function() {
            debug("polling"), this.polling = !0, this.doPoll(), this.emit("poll");
        }, Polling.prototype.onData = function(data) {
            var self = this;
            debug("polling got data %s", data);
            var callback = function(packet, index, total) {
                if ("opening" === self.readyState && self.onOpen(), "close" === packet.type) return self.onClose(), 
                !1;
                self.onPacket(packet);
            };
            parser.decodePayload(data, this.socket.binaryType, callback), "closed" !== this.readyState && (this.polling = !1, 
            this.emit("pollComplete"), "open" === this.readyState ? this.poll() : debug('ignoring poll - transport state "%s"', this.readyState));
        }, Polling.prototype.doClose = function() {
            function close() {
                debug("writing close packet"), self.write([ {
                    type: "close"
                } ]);
            }
            var self = this;
            "open" === this.readyState ? (debug("transport open - closing"), close()) : (debug("transport not open - deferring close"), 
            this.once("open", close));
        }, Polling.prototype.write = function(packets) {
            var self = this;
            this.writable = !1;
            var callbackfn = function() {
                self.writable = !0, self.emit("drain");
            };
            parser.encodePayload(packets, this.supportsBinary, function(data) {
                self.doWrite(data, callbackfn);
            });
        }, Polling.prototype.uri = function() {
            var query = this.query || {}, schema = this.secure ? "https" : "http", port = "";
            return !1 !== this.timestampRequests && (query[this.timestampParam] = yeast()), 
            this.supportsBinary || query.sid || (query.b64 = 1), query = parseqs.encode(query), 
            this.port && ("https" === schema && 443 !== Number(this.port) || "http" === schema && 80 !== Number(this.port)) && (port = ":" + this.port), 
            query.length && (query = "?" + query), schema + "://" + (-1 !== this.hostname.indexOf(":") ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
        };
    }, function(module, exports, __webpack_require__) {
        function Transport(opts) {
            this.path = opts.path, this.hostname = opts.hostname, this.port = opts.port, this.secure = opts.secure, 
            this.query = opts.query, this.timestampParam = opts.timestampParam, this.timestampRequests = opts.timestampRequests, 
            this.readyState = "", this.agent = opts.agent || !1, this.socket = opts.socket, 
            this.enablesXDR = opts.enablesXDR, this.pfx = opts.pfx, this.key = opts.key, this.passphrase = opts.passphrase, 
            this.cert = opts.cert, this.ca = opts.ca, this.ciphers = opts.ciphers, this.rejectUnauthorized = opts.rejectUnauthorized, 
            this.forceNode = opts.forceNode, this.extraHeaders = opts.extraHeaders, this.localAddress = opts.localAddress;
        }
        var parser = __webpack_require__(27), Emitter = __webpack_require__(35);
        module.exports = Transport, Emitter(Transport.prototype), Transport.prototype.onError = function(msg, desc) {
            var err = new Error(msg);
            return err.type = "TransportError", err.description = desc, this.emit("error", err), 
            this;
        }, Transport.prototype.open = function() {
            return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", 
            this.doOpen()), this;
        }, Transport.prototype.close = function() {
            return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), 
            this.onClose()), this;
        }, Transport.prototype.send = function(packets) {
            if ("open" !== this.readyState) throw new Error("Transport not open");
            this.write(packets);
        }, Transport.prototype.onOpen = function() {
            this.readyState = "open", this.writable = !0, this.emit("open");
        }, Transport.prototype.onData = function(data) {
            var packet = parser.decodePacket(data, this.socket.binaryType);
            this.onPacket(packet);
        }, Transport.prototype.onPacket = function(packet) {
            this.emit("packet", packet);
        }, Transport.prototype.onClose = function() {
            this.readyState = "closed", this.emit("close");
        };
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            function encodeBase64Object(packet, callback) {
                return callback("b" + exports.packets[packet.type] + packet.data.data);
            }
            function encodeArrayBuffer(packet, supportsBinary, callback) {
                if (!supportsBinary) return exports.encodeBase64Packet(packet, callback);
                var data = packet.data, contentArray = new Uint8Array(data), resultBuffer = new Uint8Array(1 + data.byteLength);
                resultBuffer[0] = packets[packet.type];
                for (var i = 0; i < contentArray.length; i++) resultBuffer[i + 1] = contentArray[i];
                return callback(resultBuffer.buffer);
            }
            function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
                if (!supportsBinary) return exports.encodeBase64Packet(packet, callback);
                var fr = new FileReader();
                return fr.onload = function() {
                    packet.data = fr.result, exports.encodePacket(packet, supportsBinary, !0, callback);
                }, fr.readAsArrayBuffer(packet.data);
            }
            function encodeBlob(packet, supportsBinary, callback) {
                if (!supportsBinary) return exports.encodeBase64Packet(packet, callback);
                if (dontSendBlobs) return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
                var length = new Uint8Array(1);
                return length[0] = packets[packet.type], callback(new Blob([ length.buffer, packet.data ]));
            }
            function tryDecode(data) {
                try {
                    data = utf8.decode(data);
                } catch (e) {
                    return !1;
                }
                return data;
            }
            function map(ary, each, done) {
                for (var result = new Array(ary.length), next = after(ary.length, done), i = 0; i < ary.length; i++) !function(i, el, cb) {
                    each(el, function(error, msg) {
                        result[i] = msg, cb(error, result);
                    });
                }(i, ary[i], next);
            }
            var base64encoder, keys = __webpack_require__(28), hasBinary = __webpack_require__(29), sliceBuffer = __webpack_require__(30), after = __webpack_require__(31), utf8 = __webpack_require__(32);
            global && global.ArrayBuffer && (base64encoder = __webpack_require__(33));
            var isAndroid = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent), isPhantomJS = "undefined" != typeof navigator && /PhantomJS/i.test(navigator.userAgent), dontSendBlobs = isAndroid || isPhantomJS;
            exports.protocol = 3;
            var packets = exports.packets = {
                open: 0,
                close: 1,
                ping: 2,
                pong: 3,
                message: 4,
                upgrade: 5,
                noop: 6
            }, packetslist = keys(packets), err = {
                type: "error",
                data: "parser error"
            }, Blob = __webpack_require__(34);
            exports.encodePacket = function(packet, supportsBinary, utf8encode, callback) {
                "function" == typeof supportsBinary && (callback = supportsBinary, supportsBinary = !1), 
                "function" == typeof utf8encode && (callback = utf8encode, utf8encode = null);
                var data = void 0 === packet.data ? void 0 : packet.data.buffer || packet.data;
                if (global.ArrayBuffer && data instanceof ArrayBuffer) return encodeArrayBuffer(packet, supportsBinary, callback);
                if (Blob && data instanceof global.Blob) return encodeBlob(packet, supportsBinary, callback);
                if (data && data.base64) return encodeBase64Object(packet, callback);
                var encoded = packets[packet.type];
                return void 0 !== packet.data && (encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data)), 
                callback("" + encoded);
            }, exports.encodeBase64Packet = function(packet, callback) {
                var message = "b" + exports.packets[packet.type];
                if (Blob && packet.data instanceof global.Blob) {
                    var fr = new FileReader();
                    return fr.onload = function() {
                        var b64 = fr.result.split(",")[1];
                        callback(message + b64);
                    }, fr.readAsDataURL(packet.data);
                }
                var b64data;
                try {
                    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
                } catch (e) {
                    for (var typed = new Uint8Array(packet.data), basic = new Array(typed.length), i = 0; i < typed.length; i++) basic[i] = typed[i];
                    b64data = String.fromCharCode.apply(null, basic);
                }
                return message += global.btoa(b64data), callback(message);
            }, exports.decodePacket = function(data, binaryType, utf8decode) {
                if (void 0 === data) return err;
                if ("string" == typeof data) {
                    if ("b" == data.charAt(0)) return exports.decodeBase64Packet(data.substr(1), binaryType);
                    if (utf8decode && !1 === (data = tryDecode(data))) return err;
                    var type = data.charAt(0);
                    return Number(type) == type && packetslist[type] ? data.length > 1 ? {
                        type: packetslist[type],
                        data: data.substring(1)
                    } : {
                        type: packetslist[type]
                    } : err;
                }
                var asArray = new Uint8Array(data), type = asArray[0], rest = sliceBuffer(data, 1);
                return Blob && "blob" === binaryType && (rest = new Blob([ rest ])), {
                    type: packetslist[type],
                    data: rest
                };
            }, exports.decodeBase64Packet = function(msg, binaryType) {
                var type = packetslist[msg.charAt(0)];
                if (!base64encoder) return {
                    type: type,
                    data: {
                        base64: !0,
                        data: msg.substr(1)
                    }
                };
                var data = base64encoder.decode(msg.substr(1));
                return "blob" === binaryType && Blob && (data = new Blob([ data ])), {
                    type: type,
                    data: data
                };
            }, exports.encodePayload = function(packets, supportsBinary, callback) {
                function setLengthHeader(message) {
                    return message.length + ":" + message;
                }
                function encodeOne(packet, doneCallback) {
                    exports.encodePacket(packet, !!isBinary && supportsBinary, !0, function(message) {
                        doneCallback(null, setLengthHeader(message));
                    });
                }
                "function" == typeof supportsBinary && (callback = supportsBinary, supportsBinary = null);
                var isBinary = hasBinary(packets);
                return supportsBinary && isBinary ? Blob && !dontSendBlobs ? exports.encodePayloadAsBlob(packets, callback) : exports.encodePayloadAsArrayBuffer(packets, callback) : packets.length ? void map(packets, encodeOne, function(err, results) {
                    return callback(results.join(""));
                }) : callback("0:");
            }, exports.decodePayload = function(data, binaryType, callback) {
                if ("string" != typeof data) return exports.decodePayloadAsBinary(data, binaryType, callback);
                "function" == typeof binaryType && (callback = binaryType, binaryType = null);
                var packet;
                if ("" == data) return callback(err, 0, 1);
                for (var n, msg, length = "", i = 0, l = data.length; i < l; i++) {
                    var chr = data.charAt(i);
                    if (":" != chr) length += chr; else {
                        if ("" == length || length != (n = Number(length))) return callback(err, 0, 1);
                        if (msg = data.substr(i + 1, n), length != msg.length) return callback(err, 0, 1);
                        if (msg.length) {
                            if (packet = exports.decodePacket(msg, binaryType, !0), err.type == packet.type && err.data == packet.data) return callback(err, 0, 1);
                            if (!1 === callback(packet, i + n, l)) return;
                        }
                        i += n, length = "";
                    }
                }
                return "" != length ? callback(err, 0, 1) : void 0;
            }, exports.encodePayloadAsArrayBuffer = function(packets, callback) {
                function encodeOne(packet, doneCallback) {
                    exports.encodePacket(packet, !0, !0, function(data) {
                        return doneCallback(null, data);
                    });
                }
                if (!packets.length) return callback(new ArrayBuffer(0));
                map(packets, encodeOne, function(err, encodedPackets) {
                    var totalLength = encodedPackets.reduce(function(acc, p) {
                        var len;
                        return len = "string" == typeof p ? p.length : p.byteLength, acc + len.toString().length + len + 2;
                    }, 0), resultArray = new Uint8Array(totalLength), bufferIndex = 0;
                    return encodedPackets.forEach(function(p) {
                        var isString = "string" == typeof p, ab = p;
                        if (isString) {
                            for (var view = new Uint8Array(p.length), i = 0; i < p.length; i++) view[i] = p.charCodeAt(i);
                            ab = view.buffer;
                        }
                        resultArray[bufferIndex++] = isString ? 0 : 1;
                        for (var lenStr = ab.byteLength.toString(), i = 0; i < lenStr.length; i++) resultArray[bufferIndex++] = parseInt(lenStr[i]);
                        resultArray[bufferIndex++] = 255;
                        for (var view = new Uint8Array(ab), i = 0; i < view.length; i++) resultArray[bufferIndex++] = view[i];
                    }), callback(resultArray.buffer);
                });
            }, exports.encodePayloadAsBlob = function(packets, callback) {
                function encodeOne(packet, doneCallback) {
                    exports.encodePacket(packet, !0, !0, function(encoded) {
                        var binaryIdentifier = new Uint8Array(1);
                        if (binaryIdentifier[0] = 1, "string" == typeof encoded) {
                            for (var view = new Uint8Array(encoded.length), i = 0; i < encoded.length; i++) view[i] = encoded.charCodeAt(i);
                            encoded = view.buffer, binaryIdentifier[0] = 0;
                        }
                        for (var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size, lenStr = len.toString(), lengthAry = new Uint8Array(lenStr.length + 1), i = 0; i < lenStr.length; i++) lengthAry[i] = parseInt(lenStr[i]);
                        if (lengthAry[lenStr.length] = 255, Blob) {
                            var blob = new Blob([ binaryIdentifier.buffer, lengthAry.buffer, encoded ]);
                            doneCallback(null, blob);
                        }
                    });
                }
                map(packets, encodeOne, function(err, results) {
                    return callback(new Blob(results));
                });
            }, exports.decodePayloadAsBinary = function(data, binaryType, callback) {
                "function" == typeof binaryType && (callback = binaryType, binaryType = null);
                for (var bufferTail = data, buffers = [], numberTooLong = !1; bufferTail.byteLength > 0; ) {
                    for (var tailArray = new Uint8Array(bufferTail), isString = 0 === tailArray[0], msgLength = "", i = 1; 255 != tailArray[i]; i++) {
                        if (msgLength.length > 310) {
                            numberTooLong = !0;
                            break;
                        }
                        msgLength += tailArray[i];
                    }
                    if (numberTooLong) return callback(err, 0, 1);
                    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length), msgLength = parseInt(msgLength);
                    var msg = sliceBuffer(bufferTail, 0, msgLength);
                    if (isString) try {
                        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
                    } catch (e) {
                        var typed = new Uint8Array(msg);
                        msg = "";
                        for (var i = 0; i < typed.length; i++) msg += String.fromCharCode(typed[i]);
                    }
                    buffers.push(msg), bufferTail = sliceBuffer(bufferTail, msgLength);
                }
                var total = buffers.length;
                buffers.forEach(function(buffer, i) {
                    callback(exports.decodePacket(buffer, binaryType, !0), i, total);
                });
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports) {
        module.exports = Object.keys || function(obj) {
            var arr = [], has = Object.prototype.hasOwnProperty;
            for (var i in obj) has.call(obj, i) && arr.push(i);
            return arr;
        };
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            function hasBinary(data) {
                function _hasBinary(obj) {
                    if (!obj) return !1;
                    if (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) return !0;
                    if (isArray(obj)) {
                        for (var i = 0; i < obj.length; i++) if (_hasBinary(obj[i])) return !0;
                    } else if (obj && "object" == typeof obj) {
                        obj.toJSON && "function" == typeof obj.toJSON && (obj = obj.toJSON());
                        for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) return !0;
                    }
                    return !1;
                }
                return _hasBinary(data);
            }
            var isArray = __webpack_require__(15);
            module.exports = hasBinary;
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports) {
        module.exports = function(arraybuffer, start, end) {
            var bytes = arraybuffer.byteLength;
            if (start = start || 0, end = end || bytes, arraybuffer.slice) return arraybuffer.slice(start, end);
            if (start < 0 && (start += bytes), end < 0 && (end += bytes), end > bytes && (end = bytes), 
            start >= bytes || start >= end || 0 === bytes) return new ArrayBuffer(0);
            for (var abv = new Uint8Array(arraybuffer), result = new Uint8Array(end - start), i = start, ii = 0; i < end; i++, 
            ii++) result[ii] = abv[i];
            return result.buffer;
        };
    }, function(module, exports) {
        function after(count, callback, err_cb) {
            function proxy(err, result) {
                if (proxy.count <= 0) throw new Error("after called too many times");
                --proxy.count, err ? (bail = !0, callback(err), callback = err_cb) : 0 !== proxy.count || bail || callback(null, result);
            }
            var bail = !1;
            return err_cb = err_cb || noop, proxy.count = count, 0 === count ? callback() : proxy;
        }
        function noop() {}
        module.exports = after;
    }, function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        (function(module, global) {
            !function(root) {
                function ucs2decode(string) {
                    for (var value, extra, output = [], counter = 0, length = string.length; counter < length; ) value = string.charCodeAt(counter++), 
                    value >= 55296 && value <= 56319 && counter < length ? (extra = string.charCodeAt(counter++), 
                    56320 == (64512 & extra) ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value), 
                    counter--)) : output.push(value);
                    return output;
                }
                function ucs2encode(array) {
                    for (var value, length = array.length, index = -1, output = ""; ++index < length; ) value = array[index], 
                    value > 65535 && (value -= 65536, output += stringFromCharCode(value >>> 10 & 1023 | 55296), 
                    value = 56320 | 1023 & value), output += stringFromCharCode(value);
                    return output;
                }
                function createByte(codePoint, shift) {
                    return stringFromCharCode(codePoint >> shift & 63 | 128);
                }
                function encodeCodePoint(codePoint) {
                    if (0 == (4294967168 & codePoint)) return stringFromCharCode(codePoint);
                    var symbol = "";
                    return 0 == (4294965248 & codePoint) ? symbol = stringFromCharCode(codePoint >> 6 & 31 | 192) : 0 == (4294901760 & codePoint) ? (symbol = stringFromCharCode(codePoint >> 12 & 15 | 224), 
                    symbol += createByte(codePoint, 6)) : 0 == (4292870144 & codePoint) && (symbol = stringFromCharCode(codePoint >> 18 & 7 | 240), 
                    symbol += createByte(codePoint, 12), symbol += createByte(codePoint, 6)), symbol += stringFromCharCode(63 & codePoint | 128);
                }
                function wtf8encode(string) {
                    for (var codePoint, codePoints = ucs2decode(string), length = codePoints.length, index = -1, byteString = ""; ++index < length; ) codePoint = codePoints[index], 
                    byteString += encodeCodePoint(codePoint);
                    return byteString;
                }
                function readContinuationByte() {
                    if (byteIndex >= byteCount) throw Error("Invalid byte index");
                    var continuationByte = 255 & byteArray[byteIndex];
                    if (byteIndex++, 128 == (192 & continuationByte)) return 63 & continuationByte;
                    throw Error("Invalid continuation byte");
                }
                function decodeSymbol() {
                    var byte1, byte2, byte3, byte4, codePoint;
                    if (byteIndex > byteCount) throw Error("Invalid byte index");
                    if (byteIndex == byteCount) return !1;
                    if (byte1 = 255 & byteArray[byteIndex], byteIndex++, 0 == (128 & byte1)) return byte1;
                    if (192 == (224 & byte1)) {
                        var byte2 = readContinuationByte();
                        if ((codePoint = (31 & byte1) << 6 | byte2) >= 128) return codePoint;
                        throw Error("Invalid continuation byte");
                    }
                    if (224 == (240 & byte1)) {
                        if (byte2 = readContinuationByte(), byte3 = readContinuationByte(), (codePoint = (15 & byte1) << 12 | byte2 << 6 | byte3) >= 2048) return codePoint;
                        throw Error("Invalid continuation byte");
                    }
                    if (240 == (248 & byte1) && (byte2 = readContinuationByte(), byte3 = readContinuationByte(), 
                    byte4 = readContinuationByte(), (codePoint = (15 & byte1) << 18 | byte2 << 12 | byte3 << 6 | byte4) >= 65536 && codePoint <= 1114111)) return codePoint;
                    throw Error("Invalid WTF-8 detected");
                }
                function wtf8decode(byteString) {
                    byteArray = ucs2decode(byteString), byteCount = byteArray.length, byteIndex = 0;
                    for (var tmp, codePoints = []; !1 !== (tmp = decodeSymbol()); ) codePoints.push(tmp);
                    return ucs2encode(codePoints);
                }
                var freeExports = "object" == typeof exports && exports, freeGlobal = ("object" == typeof module && module && module.exports, 
                "object" == typeof global && global);
                var byteArray, byteCount, byteIndex, stringFromCharCode = String.fromCharCode, wtf8 = {
                    version: "1.0.0",
                    encode: wtf8encode,
                    decode: wtf8decode
                };
                void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return wtf8;
                }.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
            }();
        }).call(exports, __webpack_require__(12)(module), function() {
            return this;
        }());
    }, function(module, exports) {
        !function() {
            for (var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup = new Uint8Array(256), i = 0; i < chars.length; i++) lookup[chars.charCodeAt(i)] = i;
            exports.encode = function(arraybuffer) {
                var i, bytes = new Uint8Array(arraybuffer), len = bytes.length, base64 = "";
                for (i = 0; i < len; i += 3) base64 += chars[bytes[i] >> 2], base64 += chars[(3 & bytes[i]) << 4 | bytes[i + 1] >> 4], 
                base64 += chars[(15 & bytes[i + 1]) << 2 | bytes[i + 2] >> 6], base64 += chars[63 & bytes[i + 2]];
                return len % 3 == 2 ? base64 = base64.substring(0, base64.length - 1) + "=" : len % 3 == 1 && (base64 = base64.substring(0, base64.length - 2) + "=="), 
                base64;
            }, exports.decode = function(base64) {
                var i, encoded1, encoded2, encoded3, encoded4, bufferLength = .75 * base64.length, len = base64.length, p = 0;
                "=" === base64[base64.length - 1] && (bufferLength--, "=" === base64[base64.length - 2] && bufferLength--);
                var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
                for (i = 0; i < len; i += 4) encoded1 = lookup[base64.charCodeAt(i)], encoded2 = lookup[base64.charCodeAt(i + 1)], 
                encoded3 = lookup[base64.charCodeAt(i + 2)], encoded4 = lookup[base64.charCodeAt(i + 3)], 
                bytes[p++] = encoded1 << 2 | encoded2 >> 4, bytes[p++] = (15 & encoded2) << 4 | encoded3 >> 2, 
                bytes[p++] = (3 & encoded3) << 6 | 63 & encoded4;
                return arraybuffer;
            };
        }();
    }, function(module, exports) {
        (function(global) {
            function mapArrayBufferViews(ary) {
                for (var i = 0; i < ary.length; i++) {
                    var chunk = ary[i];
                    if (chunk.buffer instanceof ArrayBuffer) {
                        var buf = chunk.buffer;
                        if (chunk.byteLength !== buf.byteLength) {
                            var copy = new Uint8Array(chunk.byteLength);
                            copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength)), buf = copy.buffer;
                        }
                        ary[i] = buf;
                    }
                }
            }
            function BlobBuilderConstructor(ary, options) {
                options = options || {};
                var bb = new BlobBuilder();
                mapArrayBufferViews(ary);
                for (var i = 0; i < ary.length; i++) bb.append(ary[i]);
                return options.type ? bb.getBlob(options.type) : bb.getBlob();
            }
            function BlobConstructor(ary, options) {
                return mapArrayBufferViews(ary), new Blob(ary, options || {});
            }
            var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder, blobSupported = function() {
                try {
                    return 2 === new Blob([ "hi" ]).size;
                } catch (e) {
                    return !1;
                }
            }(), blobSupportsArrayBufferView = blobSupported && function() {
                try {
                    return 2 === new Blob([ new Uint8Array([ 1, 2 ]) ]).size;
                } catch (e) {
                    return !1;
                }
            }(), blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
            module.exports = function() {
                return blobSupported ? blobSupportsArrayBufferView ? global.Blob : BlobConstructor : blobBuilderSupported ? BlobBuilderConstructor : void 0;
            }();
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports, __webpack_require__) {
        function Emitter(obj) {
            if (obj) return mixin(obj);
        }
        function mixin(obj) {
            for (var key in Emitter.prototype) obj[key] = Emitter.prototype[key];
            return obj;
        }
        module.exports = Emitter, Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn), 
            this;
        }, Emitter.prototype.once = function(event, fn) {
            function on() {
                this.off(event, on), fn.apply(this, arguments);
            }
            return on.fn = fn, this.on(event, on), this;
        }, Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
            if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, 
            this;
            var callbacks = this._callbacks["$" + event];
            if (!callbacks) return this;
            if (1 == arguments.length) return delete this._callbacks["$" + event], this;
            for (var cb, i = 0; i < callbacks.length; i++) if ((cb = callbacks[i]) === fn || cb.fn === fn) {
                callbacks.splice(i, 1);
                break;
            }
            return this;
        }, Emitter.prototype.emit = function(event) {
            this._callbacks = this._callbacks || {};
            var args = [].slice.call(arguments, 1), callbacks = this._callbacks["$" + event];
            if (callbacks) {
                callbacks = callbacks.slice(0);
                for (var i = 0, len = callbacks.length; i < len; ++i) callbacks[i].apply(this, args);
            }
            return this;
        }, Emitter.prototype.listeners = function(event) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + event] || [];
        }, Emitter.prototype.hasListeners = function(event) {
            return !!this.listeners(event).length;
        };
    }, function(module, exports) {
        exports.encode = function(obj) {
            var str = "";
            for (var i in obj) obj.hasOwnProperty(i) && (str.length && (str += "&"), str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]));
            return str;
        }, exports.decode = function(qs) {
            for (var qry = {}, pairs = qs.split("&"), i = 0, l = pairs.length; i < l; i++) {
                var pair = pairs[i].split("=");
                qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
            }
            return qry;
        };
    }, function(module, exports) {
        module.exports = function(a, b) {
            var fn = function() {};
            fn.prototype = b.prototype, a.prototype = new fn(), a.prototype.constructor = a;
        };
    }, function(module, exports) {
        function encode(num) {
            var encoded = "";
            do {
                encoded = alphabet[num % length] + encoded, num = Math.floor(num / length);
            } while (num > 0);
            return encoded;
        }
        function decode(str) {
            var decoded = 0;
            for (i = 0; i < str.length; i++) decoded = decoded * length + map[str.charAt(i)];
            return decoded;
        }
        function yeast() {
            var now = encode(+new Date());
            return now !== prev ? (seed = 0, prev = now) : now + "." + encode(seed++);
        }
        for (var prev, alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {}, seed = 0, i = 0; i < length; i++) map[alphabet[i]] = i;
        yeast.encode = encode, yeast.decode = decode, module.exports = yeast;
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            function empty() {}
            function JSONPPolling(opts) {
                Polling.call(this, opts), this.query = this.query || {}, callbacks || (global.___eio || (global.___eio = []), 
                callbacks = global.___eio), this.index = callbacks.length;
                var self = this;
                callbacks.push(function(msg) {
                    self.onData(msg);
                }), this.query.j = this.index, global.document && global.addEventListener && global.addEventListener("beforeunload", function() {
                    self.script && (self.script.onerror = empty);
                }, !1);
            }
            var Polling = __webpack_require__(25), inherit = __webpack_require__(37);
            module.exports = JSONPPolling;
            var callbacks, rNewline = /\n/g, rEscapedNewline = /\\n/g;
            inherit(JSONPPolling, Polling), JSONPPolling.prototype.supportsBinary = !1, JSONPPolling.prototype.doClose = function() {
                this.script && (this.script.parentNode.removeChild(this.script), this.script = null), 
                this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), 
                Polling.prototype.doClose.call(this);
            }, JSONPPolling.prototype.doPoll = function() {
                var self = this, script = document.createElement("script");
                this.script && (this.script.parentNode.removeChild(this.script), this.script = null), 
                script.async = !0, script.src = this.uri(), script.onerror = function(e) {
                    self.onError("jsonp poll error", e);
                };
                var insertAt = document.getElementsByTagName("script")[0];
                insertAt ? insertAt.parentNode.insertBefore(script, insertAt) : (document.head || document.body).appendChild(script), 
                this.script = script, "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent) && setTimeout(function() {
                    var iframe = document.createElement("iframe");
                    document.body.appendChild(iframe), document.body.removeChild(iframe);
                }, 100);
            }, JSONPPolling.prototype.doWrite = function(data, fn) {
                function complete() {
                    initIframe(), fn();
                }
                function initIframe() {
                    if (self.iframe) try {
                        self.form.removeChild(self.iframe);
                    } catch (e) {
                        self.onError("jsonp polling iframe removal error", e);
                    }
                    try {
                        var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
                        iframe = document.createElement(html);
                    } catch (e) {
                        iframe = document.createElement("iframe"), iframe.name = self.iframeId, iframe.src = "javascript:0";
                    }
                    iframe.id = self.iframeId, self.form.appendChild(iframe), self.iframe = iframe;
                }
                var self = this;
                if (!this.form) {
                    var iframe, form = document.createElement("form"), area = document.createElement("textarea"), id = this.iframeId = "eio_iframe_" + this.index;
                    form.className = "socketio", form.style.position = "absolute", form.style.top = "-1000px", 
                    form.style.left = "-1000px", form.target = id, form.method = "POST", form.setAttribute("accept-charset", "utf-8"), 
                    area.name = "d", form.appendChild(area), document.body.appendChild(form), this.form = form, 
                    this.area = area;
                }
                this.form.action = this.uri(), initIframe(), data = data.replace(rEscapedNewline, "\\\n"), 
                this.area.value = data.replace(rNewline, "\\n");
                try {
                    this.form.submit();
                } catch (e) {}
                this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
                    "complete" === self.iframe.readyState && complete();
                } : this.iframe.onload = complete;
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports, __webpack_require__) {
        (function(global) {
            function WS(opts) {
                opts && opts.forceBase64 && (this.supportsBinary = !1), this.perMessageDeflate = opts.perMessageDeflate, 
                this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode, this.usingBrowserWebSocket || (WebSocket = NodeWebSocket), 
                Transport.call(this, opts);
            }
            var NodeWebSocket, Transport = __webpack_require__(26), parser = __webpack_require__(27), parseqs = __webpack_require__(36), inherit = __webpack_require__(37), yeast = __webpack_require__(38), debug = __webpack_require__(3)("engine.io-client:websocket"), BrowserWebSocket = global.WebSocket || global.MozWebSocket;
            if ("undefined" == typeof window) try {
                NodeWebSocket = __webpack_require__(41);
            } catch (e) {}
            var WebSocket = BrowserWebSocket;
            WebSocket || "undefined" != typeof window || (WebSocket = NodeWebSocket), module.exports = WS, 
            inherit(WS, Transport), WS.prototype.name = "websocket", WS.prototype.supportsBinary = !0, 
            WS.prototype.doOpen = function() {
                if (this.check()) {
                    var uri = this.uri(), opts = {
                        agent: this.agent,
                        perMessageDeflate: this.perMessageDeflate
                    };
                    opts.pfx = this.pfx, opts.key = this.key, opts.passphrase = this.passphrase, opts.cert = this.cert, 
                    opts.ca = this.ca, opts.ciphers = this.ciphers, opts.rejectUnauthorized = this.rejectUnauthorized, 
                    this.extraHeaders && (opts.headers = this.extraHeaders), this.localAddress && (opts.localAddress = this.localAddress);
                    try {
                        this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, void 0, opts);
                    } catch (err) {
                        return this.emit("error", err);
                    }
                    void 0 === this.ws.binaryType && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, 
                    this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners();
                }
            }, WS.prototype.addEventListeners = function() {
                var self = this;
                this.ws.onopen = function() {
                    self.onOpen();
                }, this.ws.onclose = function() {
                    self.onClose();
                }, this.ws.onmessage = function(ev) {
                    self.onData(ev.data);
                }, this.ws.onerror = function(e) {
                    self.onError("websocket error", e);
                };
            }, WS.prototype.write = function(packets) {
                function done() {
                    self.emit("flush"), setTimeout(function() {
                        self.writable = !0, self.emit("drain");
                    }, 0);
                }
                var self = this;
                this.writable = !1;
                for (var total = packets.length, i = 0, l = total; i < l; i++) !function(packet) {
                    parser.encodePacket(packet, self.supportsBinary, function(data) {
                        if (!self.usingBrowserWebSocket) {
                            var opts = {};
                            if (packet.options && (opts.compress = packet.options.compress), self.perMessageDeflate) {
                                ("string" == typeof data ? global.Buffer.byteLength(data) : data.length) < self.perMessageDeflate.threshold && (opts.compress = !1);
                            }
                        }
                        try {
                            self.usingBrowserWebSocket ? self.ws.send(data) : self.ws.send(data, opts);
                        } catch (e) {
                            debug("websocket closed before onclose event");
                        }
                        --total || done();
                    });
                }(packets[i]);
            }, WS.prototype.onClose = function() {
                Transport.prototype.onClose.call(this);
            }, WS.prototype.doClose = function() {
                void 0 !== this.ws && this.ws.close();
            }, WS.prototype.uri = function() {
                var query = this.query || {}, schema = this.secure ? "wss" : "ws", port = "";
                return this.port && ("wss" === schema && 443 !== Number(this.port) || "ws" === schema && 80 !== Number(this.port)) && (port = ":" + this.port), 
                this.timestampRequests && (query[this.timestampParam] = yeast()), this.supportsBinary || (query.b64 = 1), 
                query = parseqs.encode(query), query.length && (query = "?" + query), schema + "://" + (-1 !== this.hostname.indexOf(":") ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
            }, WS.prototype.check = function() {
                return !(!WebSocket || "__initialize" in WebSocket && this.name === WS.prototype.name);
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports) {}, function(module, exports) {
        var indexOf = [].indexOf;
        module.exports = function(arr, obj) {
            if (indexOf) return arr.indexOf(obj);
            for (var i = 0; i < arr.length; ++i) if (arr[i] === obj) return i;
            return -1;
        };
    }, function(module, exports) {
        (function(global) {
            var rvalidchars = /^[\],:{}\s]*$/, rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g, rtrimLeft = /^\s+/, rtrimRight = /\s+$/;
            module.exports = function(data) {
                return "string" == typeof data && data ? (data = data.replace(rtrimLeft, "").replace(rtrimRight, ""), 
                global.JSON && JSON.parse ? JSON.parse(data) : rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, "")) ? new Function("return " + data)() : void 0) : null;
            };
        }).call(exports, function() {
            return this;
        }());
    }, function(module, exports, __webpack_require__) {
        function Socket(io, nsp, opts) {
            this.io = io, this.nsp = nsp, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], 
            this.sendBuffer = [], this.connected = !1, this.disconnected = !0, opts && opts.query && (this.query = opts.query), 
            this.io.autoConnect && this.open();
        }
        var parser = __webpack_require__(7), Emitter = __webpack_require__(35), toArray = __webpack_require__(45), on = __webpack_require__(46), bind = __webpack_require__(47), debug = __webpack_require__(3)("socket.io-client:socket"), hasBin = __webpack_require__(29);
        module.exports = Socket;
        var events = {
            connect: 1,
            connect_error: 1,
            connect_timeout: 1,
            connecting: 1,
            disconnect: 1,
            error: 1,
            reconnect: 1,
            reconnect_attempt: 1,
            reconnect_failed: 1,
            reconnect_error: 1,
            reconnecting: 1,
            ping: 1,
            pong: 1
        }, emit = Emitter.prototype.emit;
        Emitter(Socket.prototype), Socket.prototype.subEvents = function() {
            if (!this.subs) {
                var io = this.io;
                this.subs = [ on(io, "open", bind(this, "onopen")), on(io, "packet", bind(this, "onpacket")), on(io, "close", bind(this, "onclose")) ];
            }
        }, Socket.prototype.open = Socket.prototype.connect = function() {
            return this.connected ? this : (this.subEvents(), this.io.open(), "open" === this.io.readyState && this.onopen(), 
            this.emit("connecting"), this);
        }, Socket.prototype.send = function() {
            var args = toArray(arguments);
            return args.unshift("message"), this.emit.apply(this, args), this;
        }, Socket.prototype.emit = function(ev) {
            if (events.hasOwnProperty(ev)) return emit.apply(this, arguments), this;
            var args = toArray(arguments), parserType = parser.EVENT;
            hasBin(args) && (parserType = parser.BINARY_EVENT);
            var packet = {
                type: parserType,
                data: args
            };
            return packet.options = {}, packet.options.compress = !this.flags || !1 !== this.flags.compress, 
            "function" == typeof args[args.length - 1] && (debug("emitting packet with ack id %d", this.ids), 
            this.acks[this.ids] = args.pop(), packet.id = this.ids++), this.connected ? this.packet(packet) : this.sendBuffer.push(packet), 
            delete this.flags, this;
        }, Socket.prototype.packet = function(packet) {
            packet.nsp = this.nsp, this.io.packet(packet);
        }, Socket.prototype.onopen = function() {
            debug("transport is open - connecting"), "/" !== this.nsp && (this.query ? this.packet({
                type: parser.CONNECT,
                query: this.query
            }) : this.packet({
                type: parser.CONNECT
            }));
        }, Socket.prototype.onclose = function(reason) {
            debug("close (%s)", reason), this.connected = !1, this.disconnected = !0, delete this.id, 
            this.emit("disconnect", reason);
        }, Socket.prototype.onpacket = function(packet) {
            if (packet.nsp === this.nsp) switch (packet.type) {
              case parser.CONNECT:
                this.onconnect();
                break;

              case parser.EVENT:
              case parser.BINARY_EVENT:
                this.onevent(packet);
                break;

              case parser.ACK:
              case parser.BINARY_ACK:
                this.onack(packet);
                break;

              case parser.DISCONNECT:
                this.ondisconnect();
                break;

              case parser.ERROR:
                this.emit("error", packet.data);
            }
        }, Socket.prototype.onevent = function(packet) {
            var args = packet.data || [];
            debug("emitting event %j", args), null != packet.id && (debug("attaching ack callback to event"), 
            args.push(this.ack(packet.id))), this.connected ? emit.apply(this, args) : this.receiveBuffer.push(args);
        }, Socket.prototype.ack = function(id) {
            var self = this, sent = !1;
            return function() {
                if (!sent) {
                    sent = !0;
                    var args = toArray(arguments);
                    debug("sending ack %j", args);
                    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
                    self.packet({
                        type: type,
                        id: id,
                        data: args
                    });
                }
            };
        }, Socket.prototype.onack = function(packet) {
            var ack = this.acks[packet.id];
            "function" == typeof ack ? (debug("calling ack %s with %j", packet.id, packet.data), 
            ack.apply(this, packet.data), delete this.acks[packet.id]) : debug("bad ack %s", packet.id);
        }, Socket.prototype.onconnect = function() {
            this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered();
        }, Socket.prototype.emitBuffered = function() {
            var i;
            for (i = 0; i < this.receiveBuffer.length; i++) emit.apply(this, this.receiveBuffer[i]);
            for (this.receiveBuffer = [], i = 0; i < this.sendBuffer.length; i++) this.packet(this.sendBuffer[i]);
            this.sendBuffer = [];
        }, Socket.prototype.ondisconnect = function() {
            debug("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect");
        }, Socket.prototype.destroy = function() {
            if (this.subs) {
                for (var i = 0; i < this.subs.length; i++) this.subs[i].destroy();
                this.subs = null;
            }
            this.io.destroy(this);
        }, Socket.prototype.close = Socket.prototype.disconnect = function() {
            return this.connected && (debug("performing disconnect (%s)", this.nsp), this.packet({
                type: parser.DISCONNECT
            })), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
        }, Socket.prototype.compress = function(compress) {
            return this.flags = this.flags || {}, this.flags.compress = compress, this;
        };
    }, function(module, exports) {
        function toArray(list, index) {
            var array = [];
            index = index || 0;
            for (var i = index || 0; i < list.length; i++) array[i - index] = list[i];
            return array;
        }
        module.exports = toArray;
    }, function(module, exports) {
        function on(obj, ev, fn) {
            return obj.on(ev, fn), {
                destroy: function() {
                    obj.removeListener(ev, fn);
                }
            };
        }
        module.exports = on;
    }, function(module, exports) {
        var slice = [].slice;
        module.exports = function(obj, fn) {
            if ("string" == typeof fn && (fn = obj[fn]), "function" != typeof fn) throw new Error("bind() requires a function");
            var args = slice.call(arguments, 2);
            return function() {
                return fn.apply(obj, args.concat(slice.call(arguments)));
            };
        };
    }, function(module, exports) {
        function Backoff(opts) {
            opts = opts || {}, this.ms = opts.min || 100, this.max = opts.max || 1e4, this.factor = opts.factor || 2, 
            this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0, this.attempts = 0;
        }
        module.exports = Backoff, Backoff.prototype.duration = function() {
            var ms = this.ms * Math.pow(this.factor, this.attempts++);
            if (this.jitter) {
                var rand = Math.random(), deviation = Math.floor(rand * this.jitter * ms);
                ms = 0 == (1 & Math.floor(10 * rand)) ? ms - deviation : ms + deviation;
            }
            return 0 | Math.min(ms, this.max);
        }, Backoff.prototype.reset = function() {
            this.attempts = 0;
        }, Backoff.prototype.setMin = function(min) {
            this.ms = min;
        }, Backoff.prototype.setMax = function(max) {
            this.max = max;
        }, Backoff.prototype.setJitter = function(jitter) {
            this.jitter = jitter;
        };
    } ]);
});

var StackOverflow, bezier, bezier1, bezier2, bezierT;

StackOverflow = StackOverflow || {}, StackOverflow.drawBezier = function(options, ctx) {
    var a, b, c, cDist, curveSample, i, j, k, len, letterPadding, p, ref, ribbon, ribbonSpecs, textCurve, totalLength, totalPadding, w, ww, x1, x2, z;
    if (null == options && (options = {}), options = Helper.shallowClone(options), null != options.curve && null == options.points && (options.points = options.curve.split(",")), 
    null == options.text && (options.text = "Text"), null == options.letterPadding && (options.letterPadding = .25), 
    null == options.fillStyle && (options.fillStyle = "white"), null == options.fillLineWidth && (options.fillLineWidth = 1), 
    null == options.strokeLineWidth && (options.strokeLineWidth = 10), null == options.strokeStyle && (options.strokeStyle = void 0), 
    null == options.font && (options.font = "40px Helvetica"), null == options.points && (options.points = []), 
    null == options.drawText && (options.drawText = !0), null == options.drawCurve && (options.drawCurve = !1), 
    null == options.maxChar && (options.maxChar = 50), null == options.x && (options.x = 0), 
    null == options.y && (options.y = 0), 8 !== options.points.length) throw "needs 8 points";
    for (options.points = options.points.map(function(item) {
        return parseFloat(item);
    }), i = 0, ref = options.points, k = 0, len = ref.length; k < len; k++) ref[k], 
    options.points[i] += i % 2 == 0 ? options.x : options.y, i += 1;
    if (ribbonSpecs = {
        maxChar: options.maxChar,
        startX: options.points[0],
        startY: options.points[1],
        control1X: options.points[2],
        control1Y: options.points[3],
        control2X: options.points[4],
        control2Y: options.points[5],
        endX: options.points[6],
        endY: options.points[7]
    }, options.drawCurve && (ctx.save(), ctx.beginPath(), ctx.moveTo(ribbonSpecs.startX, ribbonSpecs.startY), 
    ctx.bezierCurveTo(ribbonSpecs.control1X, ribbonSpecs.control1Y, ribbonSpecs.control2X, ribbonSpecs.control2Y, ribbonSpecs.endX, ribbonSpecs.endY), 
    ctx.stroke(), ctx.restore()), options.drawText) {
        for (textCurve = [], ribbon = options.text.substring(0, ribbonSpecs.maxChar), curveSample = 1e3, 
        0, i = 0, i = 0; i < curveSample; ) a = new bezier2(i / curveSample, ribbonSpecs.startX, ribbonSpecs.startY, ribbonSpecs.control1X, ribbonSpecs.control1Y, ribbonSpecs.control2X, ribbonSpecs.control2Y, ribbonSpecs.endX, ribbonSpecs.endY), 
        b = new bezier2((i + 1) / curveSample, ribbonSpecs.startX, ribbonSpecs.startY, ribbonSpecs.control1X, ribbonSpecs.control1Y, ribbonSpecs.control2X, ribbonSpecs.control2Y, ribbonSpecs.endX, ribbonSpecs.endY), 
        c = new bezier(a, b), textCurve.push({
            bezier: a,
            curve: c.curve
        }), i++;
        for (letterPadding = ctx.measureText(" ").width * options.letterPadding, w = ribbon.length, 
        ww = Math.round(ctx.measureText(ribbon).width), totalPadding = (w - 1) * letterPadding, 
        totalLength = ww + totalPadding, p = 0, cDist = textCurve[curveSample - 1].curve.cDist, 
        z = cDist / 2 - totalLength / 2, i = 0; i < curveSample; ) {
            if (textCurve[i].curve.cDist >= z) {
                p = i;
                break;
            }
            i++;
        }
        for (i = 0; i < w; ) {
            for (ctx.save(), ctx.translate(textCurve[p].bezier.point.x, textCurve[p].bezier.point.y), 
            ctx.rotate(textCurve[p].curve.rad), ctx.font = options.font, null != options.strokeStyle && (ctx.strokeStyle = options.strokeStyle, 
            ctx.lineWidth = options.strokeLineWidth, ctx.strokeText(ribbon[i], 0, 0)), ctx.fillStyle = options.fillStyle, 
            ctx.lineWidth = options.fillLineWidth, ctx.fillText(ribbon[i], 0, 0), ctx.restore(), 
            x1 = ctx.measureText(ribbon[i]).width + letterPadding, x2 = 0, j = p; j < curveSample; ) {
                if ((x2 += textCurve[j].curve.dist) >= x1) {
                    p = j;
                    break;
                }
                j++;
            }
            i++;
        }
    }
}, bezier = function(b1, b2) {
    var xDist;
    this.rad = Math.atan(b1.point.mY / b1.point.mX), this.b2 = b2, this.b1 = b1, b2.x, 
    b1.x, b2.x, b1.x, b2.x, b1.x, this.dist = Math.sqrt((b2.x - b1.x) * (b2.x - b1.x) + (b2.y - b1.y) * (b2.y - b1.y)), 
    xDist += this.dist, this.curve = {
        rad: this.rad,
        dist: this.dist,
        cDist: xDist
    };
}, bezierT = function(t, startX, startY, control1X, control1Y, control2X, control2Y, endX, endY) {
    this.mx = 3 * (1 - t) * (1 - t) * (control1X - startX) + 6 * (1 - t) * t * (control2X - control1X) + 3 * t * t * (endX - control2X), 
    this.my = 3 * (1 - t) * (1 - t) * (control1Y - startY) + 6 * (1 - t) * t * (control2Y - control1Y) + 3 * t * t * (endY - control2Y);
}, bezier2 = function(t, startX, startY, control1X, control1Y, control2X, control2Y, endX, endY) {
    this.Bezier1 = new bezier1(t, startX, startY, control1X, control1Y, control2X, control2Y), 
    this.Bezier2 = new bezier1(t, control1X, control1Y, control2X, control2Y, endX, endY), 
    this.x = (1 - t) * this.Bezier1.x + t * this.Bezier2.x, this.y = (1 - t) * this.Bezier1.y + t * this.Bezier2.y, 
    this.slope = new bezierT(t, startX, startY, control1X, control1Y, control2X, control2Y, endX, endY), 
    this.point = {
        t: t,
        x: this.x,
        y: this.y,
        mX: this.slope.mx,
        mY: this.slope.my
    };
}, bezier1 = function(t, startX, startY, control1X, control1Y, control2X, control2Y) {
    this.x = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * control1X + t * t * control2X, 
    this.y = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * control1Y + t * t * control2Y;
}, window.jNorthPole = {
    BASE_URL: "https://json.northpole.ro/",
    help: "NorthPole JS wrapper example usage:\n\nresponseHandler = function (data) {\n  console.log(data);\n};\n\njNorthPole.getStorage(json, responseHandler);\n\nsocket = jNorthPole.getNewRealtimeSocket(responseHandler)\njNorthPole.subscribe(socket, 'foo')\njNorthPole.publish(socket, 'foo', { message: 'hello' })",
    genericRequest: function(jsonObj, method, endPoint, responseHandler, errorHandler) {
        var r;
        if (null == errorHandler && (errorHandler = responseHandler), null == responseHandler) throw "responseHandler function missing";
        r = new XMLHttpRequest(), r.open(method, "" + this.BASE_URL + endPoint + ".json", !0), 
        r.onreadystatechange = function() {
            4 === r.readyState && (200 === r.status ? responseHandler(JSON.parse(r.responseText), r.status) : errorHandler(JSON.parse(r.responseText), r.status));
        }, r.send(JSON.stringify(jsonObj));
    },
    createUser: function(api_key, secret, success, failure) {
        var jsonObj;
        jsonObj = {
            api_key: api_key,
            secret: secret
        }, this.genericRequest(jsonObj, "POST", "user", success, failure);
    },
    getUser: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "SEARCH", "user", responseHandler, errorHandler);
    },
    createStorage: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "POST", "storage", responseHandler, errorHandler);
    },
    getStorage: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "SEARCH", "storage", responseHandler, errorHandler);
    },
    putStorage: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "PUT", "storage", responseHandler, errorHandler);
    },
    deleteStorage: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "DELETE", "storage", responseHandler, errorHandler);
    },
    getNewRealtimeSocket: function(responseHandler, errorHandler) {
        var socket, socketUrl;
        return null == errorHandler && (errorHandler = responseHandler), socketUrl = this.BASE_URL.replace("http", "ws"), 
        socket = new WebSocket(socketUrl + "realtime"), socket.onmessage = responseHandler, 
        socket.onclose = errorHandler, socket;
    },
    subscribe: function(socket, channel_name) {
        return socket.send(JSON.stringify({
            type: "subscribe",
            channel_name: channel_name
        }));
    },
    unsubscribe: function(socket, channel_name) {
        return socket.send(JSON.stringify({
            type: "unsubscribe",
            channel_name: channel_name
        }));
    },
    publish: function(socket, channel_name, json) {
        return socket.send(JSON.stringify({
            type: "publish",
            channel_name: channel_name,
            content: json
        }));
    }
};

var GameInstance, Utils, e, bind = function(fn, me) {
    return function() {
        return fn.apply(me, arguments);
    };
};

try {
    Utils = require("../shared/Utils.coffee").Utils;
} catch (error) {
    e = error, console.ce(e);
}

GameInstance = function() {
    function GameInstance(config) {
        null == config && (config = {}), this.tick = bind(this.tick, this), null == config.ticksPerSecond && (config.ticksPerSecond = 10), 
        null == config.autoStart && (config.autoStart = !0), this.players = {}, this.sockets = {}, 
        this.inputs = [], this.id = config.id || Utils.guid(), this.config = config, this.config.autoStart && this.setTickInterval(this.config.ticksPerSecond);
    }
    return GameInstance.prototype.tick = function() {
        throw "tick needs to be implemented";
    }, GameInstance.prototype.setTickInterval = function(tps) {
        return null == tps && (tps = 10), this.config.ticksPerSecond = tps, null != this.tickInterval && clearInterval(this.tickInterval), 
        this.tickInterval = setInterval(this.tick, 1e3 / this.config.ticksPerSecond);
    }, GameInstance.prototype.startTicking = function() {
        return this.setTickInterval(this.config.ticksPerSecond);
    }, GameInstance.prototype.stopTicking = function() {
        if (null != this.tickInterval) return clearInterval(this.tickInterval);
    }, GameInstance;
}(), exports.GameInstance = GameInstance;
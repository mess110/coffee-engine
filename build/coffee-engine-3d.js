var Stats = function() {
    var startTime = Date.now(), prevTime = startTime, ms = 0, msMin = 1 / 0, msMax = 0, fps = 0, fpsMin = 1 / 0, fpsMax = 0, frames = 0, mode = 0, container = document.createElement("div");
    container.id = "stats", container.addEventListener("mousedown", function(event) {
        event.preventDefault(), setMode(++mode % 2);
    }, !1), container.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var fpsDiv = document.createElement("div");
    fpsDiv.id = "fps", fpsDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002", 
    container.appendChild(fpsDiv);
    var fpsText = document.createElement("div");
    fpsText.id = "fpsText", fpsText.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    fpsText.innerHTML = "FPS", fpsDiv.appendChild(fpsText);
    var fpsGraph = document.createElement("div");
    for (fpsGraph.id = "fpsGraph", fpsGraph.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff", 
    fpsDiv.appendChild(fpsGraph); fpsGraph.children.length < 74; ) {
        var bar = document.createElement("span");
        bar.style.cssText = "width:1px;height:30px;float:left;background-color:#113", fpsGraph.appendChild(bar);
    }
    var msDiv = document.createElement("div");
    msDiv.id = "ms", msDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none", 
    container.appendChild(msDiv);
    var msText = document.createElement("div");
    msText.id = "msText", msText.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    msText.innerHTML = "MS", msDiv.appendChild(msText);
    var msGraph = document.createElement("div");
    for (msGraph.id = "msGraph", msGraph.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0", 
    msDiv.appendChild(msGraph); msGraph.children.length < 74; ) {
        var bar = document.createElement("span");
        bar.style.cssText = "width:1px;height:30px;float:left;background-color:#131", msGraph.appendChild(bar);
    }
    var setMode = function(value) {
        switch (mode = value) {
          case 0:
            fpsDiv.style.display = "block", msDiv.style.display = "none";
            break;

          case 1:
            fpsDiv.style.display = "none", msDiv.style.display = "block";
        }
    }, updateGraph = function(dom, value) {
        var child = dom.appendChild(dom.firstChild);
        child.style.height = value + "px";
    };
    return {
        REVISION: 11,
        domElement: container,
        setMode: setMode,
        begin: function() {
            startTime = Date.now();
        },
        end: function() {
            var time = Date.now();
            return ms = time - startTime, msMin = Math.min(msMin, ms), msMax = Math.max(msMax, ms), 
            msText.textContent = ms + " MS (" + msMin + "-" + msMax + ")", updateGraph(msGraph, Math.min(30, 30 - ms / 200 * 30)), 
            frames++, time > prevTime + 1e3 && (fps = Math.round(1e3 * frames / (time - prevTime)), 
            fpsMin = Math.min(fpsMin, fps), fpsMax = Math.max(fpsMax, fps), fpsText.textContent = fps + " FPS (" + fpsMin + "-" + fpsMax + ")", 
            updateGraph(fpsGraph, Math.min(30, 30 - fps / 100 * 30)), prevTime = time, frames = 0), 
            time;
        },
        update: function() {
            startTime = this.end();
        }
    };
};

void 0 === Date.now && (Date.now = function() {
    return new Date().valueOf();
});

var TWEEN = TWEEN || function() {
    var _tweens = [];
    return {
        REVISION: "14",
        getAll: function() {
            return _tweens;
        },
        removeAll: function() {
            _tweens = [];
        },
        add: function(tween) {
            _tweens.push(tween);
        },
        remove: function(tween) {
            var i = _tweens.indexOf(tween);
            -1 !== i && _tweens.splice(i, 1);
        },
        update: function(time) {
            if (0 === _tweens.length) return !1;
            var i = 0;
            for (time = void 0 !== time ? time : "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); i < _tweens.length; ) _tweens[i].update(time) ? i++ : _tweens.splice(i, 1);
            return !0;
        }
    };
}();

TWEEN.Tween = function(object) {
    var _object = object, _valuesStart = {}, _valuesEnd = {}, _valuesStartRepeat = {}, _duration = 1e3, _repeat = 0, _yoyo = !1, _isPlaying = !1, _reversed = !1, _delayTime = 0, _startTime = null, _easingFunction = TWEEN.Easing.Linear.None, _interpolationFunction = TWEEN.Interpolation.Linear, _chainedTweens = [], _onStartCallback = null, _onStartCallbackFired = !1, _onUpdateCallback = null, _onCompleteCallback = null, _onStopCallback = null;
    for (var field in object) _valuesStart[field] = parseFloat(object[field], 10);
    this.to = function(properties, duration) {
        return void 0 !== duration && (_duration = duration), _valuesEnd = properties, this;
    }, this.start = function(time) {
        TWEEN.add(this), _isPlaying = !0, _onStartCallbackFired = !1, _startTime = void 0 !== time ? time : "undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(), 
        _startTime += _delayTime;
        for (var property in _valuesEnd) {
            if (_valuesEnd[property] instanceof Array) {
                if (0 === _valuesEnd[property].length) continue;
                _valuesEnd[property] = [ _object[property] ].concat(_valuesEnd[property]);
            }
            _valuesStart[property] = _object[property], _valuesStart[property] instanceof Array == !1 && (_valuesStart[property] *= 1), 
            _valuesStartRepeat[property] = _valuesStart[property] || 0;
        }
        return this;
    }, this.stop = function() {
        return _isPlaying ? (TWEEN.remove(this), _isPlaying = !1, null !== _onStopCallback && _onStopCallback.call(_object), 
        this.stopChainedTweens(), this) : this;
    }, this.stopChainedTweens = function() {
        for (var i = 0, numChainedTweens = _chainedTweens.length; numChainedTweens > i; i++) _chainedTweens[i].stop();
    }, this.delay = function(amount) {
        return _delayTime = amount, this;
    }, this.repeat = function(times) {
        return _repeat = times, this;
    }, this.yoyo = function(yoyo) {
        return _yoyo = yoyo, this;
    }, this.easing = function(easing) {
        return _easingFunction = easing, this;
    }, this.interpolation = function(interpolation) {
        return _interpolationFunction = interpolation, this;
    }, this.chain = function() {
        return _chainedTweens = arguments, this;
    }, this.onStart = function(callback) {
        return _onStartCallback = callback, this;
    }, this.onUpdate = function(callback) {
        return _onUpdateCallback = callback, this;
    }, this.onComplete = function(callback) {
        return _onCompleteCallback = callback, this;
    }, this.onStop = function(callback) {
        return _onStopCallback = callback, this;
    }, this.update = function(time) {
        var property;
        if (_startTime > time) return !0;
        _onStartCallbackFired === !1 && (null !== _onStartCallback && _onStartCallback.call(_object), 
        _onStartCallbackFired = !0);
        var elapsed = (time - _startTime) / _duration;
        elapsed = elapsed > 1 ? 1 : elapsed;
        var value = _easingFunction(elapsed);
        for (property in _valuesEnd) {
            var start = _valuesStart[property] || 0, end = _valuesEnd[property];
            end instanceof Array ? _object[property] = _interpolationFunction(end, value) : ("string" == typeof end && (end = start + parseFloat(end, 10)), 
            "number" == typeof end && (_object[property] = start + (end - start) * value));
        }
        if (null !== _onUpdateCallback && _onUpdateCallback.call(_object, value), 1 == elapsed) {
            if (_repeat > 0) {
                isFinite(_repeat) && _repeat--;
                for (property in _valuesStartRepeat) {
                    if ("string" == typeof _valuesEnd[property] && (_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10)), 
                    _yoyo) {
                        var tmp = _valuesStartRepeat[property];
                        _valuesStartRepeat[property] = _valuesEnd[property], _valuesEnd[property] = tmp;
                    }
                    _valuesStart[property] = _valuesStartRepeat[property];
                }
                return _yoyo && (_reversed = !_reversed), _startTime = time + _delayTime, !0;
            }
            null !== _onCompleteCallback && _onCompleteCallback.call(_object);
            for (var i = 0, numChainedTweens = _chainedTweens.length; numChainedTweens > i; i++) _chainedTweens[i].start(time);
            return !1;
        }
        return !0;
    };
}, TWEEN.Easing = {
    Linear: {
        None: function(k) {
            return k;
        }
    },
    Quadratic: {
        In: function(k) {
            return k * k;
        },
        Out: function(k) {
            return k * (2 - k);
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1);
        }
    },
    Cubic: {
        In: function(k) {
            return k * k * k;
        },
        Out: function(k) {
            return --k * k * k + 1;
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2);
        }
    },
    Quartic: {
        In: function(k) {
            return k * k * k * k;
        },
        Out: function(k) {
            return 1 - --k * k * k * k;
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2);
        }
    },
    Quintic: {
        In: function(k) {
            return k * k * k * k * k;
        },
        Out: function(k) {
            return --k * k * k * k * k + 1;
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2);
        }
    },
    Sinusoidal: {
        In: function(k) {
            return 1 - Math.cos(k * Math.PI / 2);
        },
        Out: function(k) {
            return Math.sin(k * Math.PI / 2);
        },
        InOut: function(k) {
            return .5 * (1 - Math.cos(Math.PI * k));
        }
    },
    Exponential: {
        In: function(k) {
            return 0 === k ? 0 : Math.pow(1024, k - 1);
        },
        Out: function(k) {
            return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
        },
        InOut: function(k) {
            return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        }
    },
    Circular: {
        In: function(k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        Out: function(k) {
            return Math.sqrt(1 - --k * k);
        },
        InOut: function(k) {
            return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        }
    },
    Elastic: {
        In: function(k) {
            var s, a = .1, p = .4;
            return 0 === k ? 0 : 1 === k ? 1 : (!a || 1 > a ? (a = 1, s = p / 4) : s = p * Math.asin(1 / a) / (2 * Math.PI), 
            -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p)));
        },
        Out: function(k) {
            var s, a = .1, p = .4;
            return 0 === k ? 0 : 1 === k ? 1 : (!a || 1 > a ? (a = 1, s = p / 4) : s = p * Math.asin(1 / a) / (2 * Math.PI), 
            a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
        },
        InOut: function(k) {
            var s, a = .1, p = .4;
            return 0 === k ? 0 : 1 === k ? 1 : (!a || 1 > a ? (a = 1, s = p / 4) : s = p * Math.asin(1 / a) / (2 * Math.PI), 
            (k *= 2) < 1 ? -.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p)) : a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1);
        }
    },
    Back: {
        In: function(k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        },
        Out: function(k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        },
        InOut: function(k) {
            var s = 2.5949095;
            return (k *= 2) < 1 ? .5 * (k * k * ((s + 1) * k - s)) : .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        }
    },
    Bounce: {
        In: function(k) {
            return 1 - TWEEN.Easing.Bounce.Out(1 - k);
        },
        Out: function(k) {
            return 1 / 2.75 > k ? 7.5625 * k * k : 2 / 2.75 > k ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : 2.5 / 2.75 > k ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
        },
        InOut: function(k) {
            return .5 > k ? .5 * TWEEN.Easing.Bounce.In(2 * k) : .5 * TWEEN.Easing.Bounce.Out(2 * k - 1) + .5;
        }
    }
}, TWEEN.Interpolation = {
    Linear: function(v, k) {
        var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.Linear;
        return 0 > k ? fn(v[0], v[1], f) : k > 1 ? fn(v[m], v[m - 1], m - f) : fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function(v, k) {
        var i, b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein;
        for (i = 0; n >= i; i++) b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        return b;
    },
    CatmullRom: function(v, k) {
        var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.CatmullRom;
        return v[0] === v[m] ? (0 > k && (i = Math.floor(f = m * (1 + k))), fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i)) : 0 > k ? v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]) : k > 1 ? v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]) : fn(v[i ? i - 1 : 0], v[i], v[i + 1 > m ? m : i + 1], v[i + 2 > m ? m : i + 2], f - i);
    },
    Utils: {
        Linear: function(p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function(n, i) {
            var fc = TWEEN.Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: function() {
            var a = [ 1 ];
            return function(n) {
                var i, s = 1;
                if (a[n]) return a[n];
                for (i = n; i > 1; i--) s *= i;
                return a[n] = s;
            };
        }(),
        CatmullRom: function(p0, p1, p2, p3, t) {
            var v0 = .5 * (p2 - p0), v1 = .5 * (p3 - p1), t2 = t * t, t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
    }
}, function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? factory(exports) : "function" == typeof define && define.amd ? define([ "exports" ], factory) : factory(global.THREE = global.THREE || {});
}(this, function(exports) {
    "use strict";
    function EventDispatcher() {}
    function Vector2(x, y) {
        this.x = x || 0, this.y = y || 0;
    }
    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        Object.defineProperty(this, "id", {
            value: TextureIdCount()
        }), this.uuid = _Math.generateUUID(), this.name = "", this.sourceFile = "", this.image = void 0 !== image ? image : Texture.DEFAULT_IMAGE, 
        this.mipmaps = [], this.mapping = void 0 !== mapping ? mapping : Texture.DEFAULT_MAPPING, 
        this.wrapS = void 0 !== wrapS ? wrapS : ClampToEdgeWrapping, this.wrapT = void 0 !== wrapT ? wrapT : ClampToEdgeWrapping, 
        this.magFilter = void 0 !== magFilter ? magFilter : LinearFilter, this.minFilter = void 0 !== minFilter ? minFilter : LinearMipMapLinearFilter, 
        this.anisotropy = void 0 !== anisotropy ? anisotropy : 1, this.format = void 0 !== format ? format : RGBAFormat, 
        this.type = void 0 !== type ? type : UnsignedByteType, this.offset = new Vector2(0, 0), 
        this.repeat = new Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, 
        this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== encoding ? encoding : LinearEncoding, 
        this.version = 0, this.onUpdate = null;
    }
    function TextureIdCount() {
        return count++;
    }
    function Vector4(x, y, z, w) {
        this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = void 0 !== w ? w : 1;
    }
    function WebGLRenderTarget(width, height, options) {
        this.uuid = _Math.generateUUID(), this.width = width, this.height = height, this.scissor = new Vector4(0, 0, width, height), 
        this.scissorTest = !1, this.viewport = new Vector4(0, 0, width, height), options = options || {}, 
        void 0 === options.minFilter && (options.minFilter = LinearFilter), this.texture = new Texture(void 0, void 0, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding), 
        this.depthBuffer = void 0 !== options.depthBuffer ? options.depthBuffer : !0, this.stencilBuffer = void 0 !== options.stencilBuffer ? options.stencilBuffer : !0, 
        this.depthTexture = void 0 !== options.depthTexture ? options.depthTexture : null;
    }
    function WebGLRenderTargetCube(width, height, options) {
        WebGLRenderTarget.call(this, width, height, options), this.activeCubeFace = 0, this.activeMipMapLevel = 0;
    }
    function Quaternion(x, y, z, w) {
        this._x = x || 0, this._y = y || 0, this._z = z || 0, this._w = void 0 !== w ? w : 1;
    }
    function Vector3(x, y, z) {
        this.x = x || 0, this.y = y || 0, this.z = z || 0;
    }
    function Matrix4() {
        this.elements = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]), 
        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = void 0 !== images ? images : [], mapping = void 0 !== mapping ? mapping : CubeReflectionMapping, 
        Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding), 
        this.flipY = !1;
    }
    function UniformContainer() {
        this.seq = [], this.map = {};
    }
    function flatten(array, nBlocks, blockSize) {
        var firstElem = array[0];
        if (0 >= firstElem || firstElem > 0) return array;
        var n = nBlocks * blockSize, r = arrayCacheF32[n];
        if (void 0 === r && (r = new Float32Array(n), arrayCacheF32[n] = r), 0 !== nBlocks) {
            firstElem.toArray(r, 0);
            for (var i = 1, offset = 0; i !== nBlocks; ++i) offset += blockSize, array[i].toArray(r, offset);
        }
        return r;
    }
    function allocTexUnits(renderer, n) {
        var r = arrayCacheI32[n];
        void 0 === r && (r = new Int32Array(n), arrayCacheI32[n] = r);
        for (var i = 0; i !== n; ++i) r[i] = renderer.allocTextureUnit();
        return r;
    }
    function setValue1f(gl, v) {
        gl.uniform1f(this.addr, v);
    }
    function setValue1i(gl, v) {
        gl.uniform1i(this.addr, v);
    }
    function setValue2fv(gl, v) {
        void 0 === v.x ? gl.uniform2fv(this.addr, v) : gl.uniform2f(this.addr, v.x, v.y);
    }
    function setValue3fv(gl, v) {
        void 0 !== v.x ? gl.uniform3f(this.addr, v.x, v.y, v.z) : void 0 !== v.r ? gl.uniform3f(this.addr, v.r, v.g, v.b) : gl.uniform3fv(this.addr, v);
    }
    function setValue4fv(gl, v) {
        void 0 === v.x ? gl.uniform4fv(this.addr, v) : gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
    }
    function setValue2fm(gl, v) {
        gl.uniformMatrix2fv(this.addr, !1, v.elements || v);
    }
    function setValue3fm(gl, v) {
        gl.uniformMatrix3fv(this.addr, !1, v.elements || v);
    }
    function setValue4fm(gl, v) {
        gl.uniformMatrix4fv(this.addr, !1, v.elements || v);
    }
    function setValueT1(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit), renderer.setTexture2D(v || emptyTexture, unit);
    }
    function setValueT6(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit), renderer.setTextureCube(v || emptyCubeTexture, unit);
    }
    function setValue2iv(gl, v) {
        gl.uniform2iv(this.addr, v);
    }
    function setValue3iv(gl, v) {
        gl.uniform3iv(this.addr, v);
    }
    function setValue4iv(gl, v) {
        gl.uniform4iv(this.addr, v);
    }
    function getSingularSetter(type) {
        switch (type) {
          case 5126:
            return setValue1f;

          case 35664:
            return setValue2fv;

          case 35665:
            return setValue3fv;

          case 35666:
            return setValue4fv;

          case 35674:
            return setValue2fm;

          case 35675:
            return setValue3fm;

          case 35676:
            return setValue4fm;

          case 35678:
            return setValueT1;

          case 35680:
            return setValueT6;

          case 5124:
          case 35670:
            return setValue1i;

          case 35667:
          case 35671:
            return setValue2iv;

          case 35668:
          case 35672:
            return setValue3iv;

          case 35669:
          case 35673:
            return setValue4iv;
        }
    }
    function setValue1fv(gl, v) {
        gl.uniform1fv(this.addr, v);
    }
    function setValue1iv(gl, v) {
        gl.uniform1iv(this.addr, v);
    }
    function setValueV2a(gl, v) {
        gl.uniform2fv(this.addr, flatten(v, this.size, 2));
    }
    function setValueV3a(gl, v) {
        gl.uniform3fv(this.addr, flatten(v, this.size, 3));
    }
    function setValueV4a(gl, v) {
        gl.uniform4fv(this.addr, flatten(v, this.size, 4));
    }
    function setValueM2a(gl, v) {
        gl.uniformMatrix2fv(this.addr, !1, flatten(v, this.size, 4));
    }
    function setValueM3a(gl, v) {
        gl.uniformMatrix3fv(this.addr, !1, flatten(v, this.size, 9));
    }
    function setValueM4a(gl, v) {
        gl.uniformMatrix4fv(this.addr, !1, flatten(v, this.size, 16));
    }
    function setValueT1a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) renderer.setTexture2D(v[i] || emptyTexture, units[i]);
    }
    function setValueT6a(gl, v, renderer) {
        var n = v.length, units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
    function getPureArraySetter(type) {
        switch (type) {
          case 5126:
            return setValue1fv;

          case 35664:
            return setValueV2a;

          case 35665:
            return setValueV3a;

          case 35666:
            return setValueV4a;

          case 35674:
            return setValueM2a;

          case 35675:
            return setValueM3a;

          case 35676:
            return setValueM4a;

          case 35678:
            return setValueT1a;

          case 35680:
            return setValueT6a;

          case 5124:
          case 35670:
            return setValue1iv;

          case 35667:
          case 35671:
            return setValue2iv;

          case 35668:
          case 35672:
            return setValue3iv;

          case 35669:
          case 35673:
            return setValue4iv;
        }
    }
    function SingleUniform(id, activeInfo, addr) {
        this.id = id, this.addr = addr, this.setValue = getSingularSetter(activeInfo.type);
    }
    function PureArrayUniform(id, activeInfo, addr) {
        this.id = id, this.addr = addr, this.size = activeInfo.size, this.setValue = getPureArraySetter(activeInfo.type);
    }
    function StructuredUniform(id) {
        this.id = id, UniformContainer.call(this);
    }
    function addUniform(container, uniformObject) {
        container.seq.push(uniformObject), container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform(activeInfo, addr, container) {
        var path = activeInfo.name, pathLength = path.length;
        for (RePathPart.lastIndex = 0; ;) {
            var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = "]" === match[2], subscript = match[3];
            if (idIsIndex && (id = 0 | id), void 0 === subscript || "[" === subscript && matchEnd + 2 === pathLength) {
                addUniform(container, void 0 === subscript ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                break;
            }
            var map = container.map, next = map[id];
            void 0 === next && (next = new StructuredUniform(id), addUniform(container, next)), 
            container = next;
        }
    }
    function WebGLUniforms(gl, program, renderer) {
        UniformContainer.call(this), this.renderer = renderer;
        for (var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS), i = 0; i !== n; ++i) {
            var info = gl.getActiveUniform(program, i), path = info.name, addr = gl.getUniformLocation(program, path);
            parseUniform(info, addr, this);
        }
    }
    function Color(r, g, b) {
        return void 0 === g && void 0 === b ? this.set(r) : this.setRGB(r, g, b);
    }
    function Box2(min, max) {
        this.min = void 0 !== min ? min : new Vector2(+(1 / 0), +(1 / 0)), this.max = void 0 !== max ? max : new Vector2(-(1 / 0), -(1 / 0));
    }
    function LensFlarePlugin(renderer, flares) {
        function init() {
            var vertices = new Float32Array([ -1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1 ]), faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
            vertexBuffer = gl.createBuffer(), elementBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), 
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer), 
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW), tempTexture = gl.createTexture(), 
            occlusionTexture = gl.createTexture(), state.bindTexture(gl.TEXTURE_2D, tempTexture), 
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST), 
            state.bindTexture(gl.TEXTURE_2D, occlusionTexture), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST), 
            shader = {
                vertexShader: [ "uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}" ].join("\n"),
                fragmentShader: [ "uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}" ].join("\n")
            }, program = createProgram(shader), attributes = {
                vertex: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            }, uniforms = {
                renderType: gl.getUniformLocation(program, "renderType"),
                map: gl.getUniformLocation(program, "map"),
                occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
                opacity: gl.getUniformLocation(program, "opacity"),
                color: gl.getUniformLocation(program, "color"),
                scale: gl.getUniformLocation(program, "scale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                screenPosition: gl.getUniformLocation(program, "screenPosition")
            };
        }
        function createProgram(shader) {
            var program = gl.createProgram(), fragmentShader = gl.createShader(gl.FRAGMENT_SHADER), vertexShader = gl.createShader(gl.VERTEX_SHADER), prefix = "precision " + renderer.getPrecision() + " float;\n";
            return gl.shaderSource(fragmentShader, prefix + shader.fragmentShader), gl.shaderSource(vertexShader, prefix + shader.vertexShader), 
            gl.compileShader(fragmentShader), gl.compileShader(vertexShader), gl.attachShader(program, fragmentShader), 
            gl.attachShader(program, vertexShader), gl.linkProgram(program), program;
        }
        var vertexBuffer, elementBuffer, shader, program, attributes, uniforms, tempTexture, occlusionTexture, gl = renderer.context, state = renderer.state;
        this.render = function(scene, camera, viewport) {
            if (0 !== flares.length) {
                var tempPosition = new Vector3(), invAspect = viewport.w / viewport.z, halfViewportWidth = .5 * viewport.z, halfViewportHeight = .5 * viewport.w, size = 16 / viewport.w, scale = new Vector2(size * invAspect, size), screenPosition = new Vector3(1, 1, 0), screenPositionPixels = new Vector2(1, 1), validArea = new Box2();
                validArea.min.set(viewport.x, viewport.y), validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)), 
                void 0 === program && init(), gl.useProgram(program), state.initAttributes(), state.enableAttribute(attributes.vertex), 
                state.enableAttribute(attributes.uv), state.disableUnusedAttributes(), gl.uniform1i(uniforms.occlusionMap, 0), 
                gl.uniform1i(uniforms.map, 1), gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, !1, 16, 0), 
                gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, !1, 16, 8), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer), 
                state.disable(gl.CULL_FACE), state.setDepthWrite(!1);
                for (var i = 0, l = flares.length; l > i; i++) {
                    size = 16 / viewport.w, scale.set(size * invAspect, size);
                    var flare = flares[i];
                    if (tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]), 
                    tempPosition.applyMatrix4(camera.matrixWorldInverse), tempPosition.applyProjection(camera.projectionMatrix), 
                    screenPosition.copy(tempPosition), screenPositionPixels.x = viewport.x + screenPosition.x * halfViewportWidth + halfViewportWidth - 8, 
                    screenPositionPixels.y = viewport.y + screenPosition.y * halfViewportHeight + halfViewportHeight - 8, 
                    validArea.containsPoint(screenPositionPixels) === !0) {
                        state.activeTexture(gl.TEXTURE0), state.bindTexture(gl.TEXTURE_2D, null), state.activeTexture(gl.TEXTURE1), 
                        state.bindTexture(gl.TEXTURE_2D, tempTexture), gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0), 
                        gl.uniform1i(uniforms.renderType, 0), gl.uniform2f(uniforms.scale, scale.x, scale.y), 
                        gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z), 
                        state.disable(gl.BLEND), state.enable(gl.DEPTH_TEST), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0), 
                        state.activeTexture(gl.TEXTURE0), state.bindTexture(gl.TEXTURE_2D, occlusionTexture), 
                        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0), 
                        gl.uniform1i(uniforms.renderType, 1), state.disable(gl.DEPTH_TEST), state.activeTexture(gl.TEXTURE1), 
                        state.bindTexture(gl.TEXTURE_2D, tempTexture), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0), 
                        flare.positionScreen.copy(screenPosition), flare.customUpdateCallback ? flare.customUpdateCallback(flare) : flare.updateLensFlares(), 
                        gl.uniform1i(uniforms.renderType, 2), state.enable(gl.BLEND);
                        for (var j = 0, jl = flare.lensFlares.length; jl > j; j++) {
                            var sprite = flare.lensFlares[j];
                            sprite.opacity > .001 && sprite.scale > .001 && (screenPosition.x = sprite.x, screenPosition.y = sprite.y, 
                            screenPosition.z = sprite.z, size = sprite.size * sprite.scale / viewport.w, scale.x = size * invAspect, 
                            scale.y = size, gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z), 
                            gl.uniform2f(uniforms.scale, scale.x, scale.y), gl.uniform1f(uniforms.rotation, sprite.rotation), 
                            gl.uniform1f(uniforms.opacity, sprite.opacity), gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b), 
                            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst), 
                            renderer.setTexture2D(sprite.texture, 1), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
                        }
                    }
                }
                state.enable(gl.CULL_FACE), state.enable(gl.DEPTH_TEST), state.setDepthWrite(!0), 
                renderer.resetGLState();
            }
        };
    }
    function SpritePlugin(renderer, sprites) {
        function init() {
            var vertices = new Float32Array([ -.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1 ]), faces = new Uint16Array([ 0, 1, 2, 0, 2, 3 ]);
            vertexBuffer = gl.createBuffer(), elementBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), 
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer), 
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW), program = createProgram(), 
            attributes = {
                position: gl.getAttribLocation(program, "position"),
                uv: gl.getAttribLocation(program, "uv")
            }, uniforms = {
                uvOffset: gl.getUniformLocation(program, "uvOffset"),
                uvScale: gl.getUniformLocation(program, "uvScale"),
                rotation: gl.getUniformLocation(program, "rotation"),
                scale: gl.getUniformLocation(program, "scale"),
                color: gl.getUniformLocation(program, "color"),
                map: gl.getUniformLocation(program, "map"),
                opacity: gl.getUniformLocation(program, "opacity"),
                modelViewMatrix: gl.getUniformLocation(program, "modelViewMatrix"),
                projectionMatrix: gl.getUniformLocation(program, "projectionMatrix"),
                fogType: gl.getUniformLocation(program, "fogType"),
                fogDensity: gl.getUniformLocation(program, "fogDensity"),
                fogNear: gl.getUniformLocation(program, "fogNear"),
                fogFar: gl.getUniformLocation(program, "fogFar"),
                fogColor: gl.getUniformLocation(program, "fogColor"),
                alphaTest: gl.getUniformLocation(program, "alphaTest")
            };
            var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            canvas.width = 8, canvas.height = 8;
            var context = canvas.getContext("2d");
            context.fillStyle = "white", context.fillRect(0, 0, 8, 8), texture = new Texture(canvas), 
            texture.needsUpdate = !0;
        }
        function createProgram() {
            var program = gl.createProgram(), vertexShader = gl.createShader(gl.VERTEX_SHADER), fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            return gl.shaderSource(vertexShader, [ "precision " + renderer.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}" ].join("\n")), 
            gl.shaderSource(fragmentShader, [ "precision " + renderer.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}" ].join("\n")), 
            gl.compileShader(vertexShader), gl.compileShader(fragmentShader), gl.attachShader(program, vertexShader), 
            gl.attachShader(program, fragmentShader), gl.linkProgram(program), program;
        }
        function painterSortStable(a, b) {
            return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id;
        }
        var vertexBuffer, elementBuffer, program, attributes, uniforms, texture, gl = renderer.context, state = renderer.state, spritePosition = new Vector3(), spriteRotation = new Quaternion(), spriteScale = new Vector3();
        this.render = function(scene, camera) {
            if (0 !== sprites.length) {
                void 0 === program && init(), gl.useProgram(program), state.initAttributes(), state.enableAttribute(attributes.position), 
                state.enableAttribute(attributes.uv), state.disableUnusedAttributes(), state.disable(gl.CULL_FACE), 
                state.enable(gl.BLEND), gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer), gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, !1, 16, 0), 
                gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, !1, 16, 8), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer), 
                gl.uniformMatrix4fv(uniforms.projectionMatrix, !1, camera.projectionMatrix.elements), 
                state.activeTexture(gl.TEXTURE0), gl.uniform1i(uniforms.map, 0);
                var oldFogType = 0, sceneFogType = 0, fog = scene.fog;
                fog ? (gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b), fog && fog.isFog ? (gl.uniform1f(uniforms.fogNear, fog.near), 
                gl.uniform1f(uniforms.fogFar, fog.far), gl.uniform1i(uniforms.fogType, 1), oldFogType = 1, 
                sceneFogType = 1) : fog && fog.isFogExp2 && (gl.uniform1f(uniforms.fogDensity, fog.density), 
                gl.uniform1i(uniforms.fogType, 2), oldFogType = 2, sceneFogType = 2)) : (gl.uniform1i(uniforms.fogType, 0), 
                oldFogType = 0, sceneFogType = 0);
                for (var i = 0, l = sprites.length; l > i; i++) {
                    var sprite = sprites[i];
                    sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld), 
                    sprite.z = -sprite.modelViewMatrix.elements[14];
                }
                sprites.sort(painterSortStable);
                for (var scale = [], i = 0, l = sprites.length; l > i; i++) {
                    var sprite = sprites[i], material = sprite.material;
                    if (material.visible !== !1) {
                        gl.uniform1f(uniforms.alphaTest, material.alphaTest), gl.uniformMatrix4fv(uniforms.modelViewMatrix, !1, sprite.modelViewMatrix.elements), 
                        sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale), scale[0] = spriteScale.x, 
                        scale[1] = spriteScale.y;
                        var fogType = 0;
                        scene.fog && material.fog && (fogType = sceneFogType), oldFogType !== fogType && (gl.uniform1i(uniforms.fogType, fogType), 
                        oldFogType = fogType), null !== material.map ? (gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y), 
                        gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y)) : (gl.uniform2f(uniforms.uvOffset, 0, 0), 
                        gl.uniform2f(uniforms.uvScale, 1, 1)), gl.uniform1f(uniforms.opacity, material.opacity), 
                        gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b), 
                        gl.uniform1f(uniforms.rotation, material.rotation), gl.uniform2fv(uniforms.scale, scale), 
                        state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst), 
                        state.setDepthTest(material.depthTest), state.setDepthWrite(material.depthWrite), 
                        material.map ? renderer.setTexture2D(material.map, 0) : renderer.setTexture2D(texture, 0), 
                        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    }
                }
                state.enable(gl.CULL_FACE), renderer.resetGLState();
            }
        };
    }
    function Material() {
        Object.defineProperty(this, "id", {
            value: MaterialIdCount()
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, 
        this.lights = !0, this.blending = NormalBlending, this.side = FrontSide, this.shading = SmoothShading, 
        this.vertexColors = NoColors, this.opacity = 1, this.transparent = !1, this.blendSrc = SrcAlphaFactor, 
        this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, 
        this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = LessEqualDepth, 
        this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, 
        this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, 
        this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.premultipliedAlpha = !1, 
        this.overdraw = 0, this.visible = !0, this._needsUpdate = !0;
    }
    function MaterialIdCount() {
        return count$1++;
    }
    function ShaderMaterial(parameters) {
        Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, 
        this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", 
        this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", 
        this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, 
        this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, 
        this.morphNormals = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [ 1, 1, 1 ],
            uv: [ 0, 0 ],
            uv2: [ 0, 0 ]
        }, this.index0AttributeName = void 0, void 0 !== parameters && (void 0 !== parameters.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), 
        this.setValues(parameters));
    }
    function MeshDepthMaterial(parameters) {
        Material.call(this), this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, 
        this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, 
        this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, 
        this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, 
        this.setValues(parameters);
    }
    function Box3(min, max) {
        this.min = void 0 !== min ? min : new Vector3(+(1 / 0), +(1 / 0), +(1 / 0)), this.max = void 0 !== max ? max : new Vector3(-(1 / 0), -(1 / 0), -(1 / 0));
    }
    function Sphere(center, radius) {
        this.center = void 0 !== center ? center : new Vector3(), this.radius = void 0 !== radius ? radius : 0;
    }
    function Matrix3() {
        this.elements = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    function Plane(normal, constant) {
        this.normal = void 0 !== normal ? normal : new Vector3(1, 0, 0), this.constant = void 0 !== constant ? constant : 0;
    }
    function Frustum(p0, p1, p2, p3, p4, p5) {
        this.planes = [ void 0 !== p0 ? p0 : new Plane(), void 0 !== p1 ? p1 : new Plane(), void 0 !== p2 ? p2 : new Plane(), void 0 !== p3 ? p3 : new Plane(), void 0 !== p4 ? p4 : new Plane(), void 0 !== p5 ? p5 : new Plane() ];
    }
    function WebGLShadowMap(_renderer, _lights, _objects, capabilities) {
        function getDepthMaterial(object, material, isPointLight, lightPositionWorld) {
            var geometry = object.geometry, result = null, materialVariants = _depthMaterials, customMaterial = object.customDepthMaterial;
            if (isPointLight && (materialVariants = _distanceMaterials, customMaterial = object.customDistanceMaterial), 
            customMaterial) result = customMaterial; else {
                var useMorphing = !1;
                material.morphTargets && (geometry && geometry.isBufferGeometry ? useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0 : geometry && geometry.isGeometry && (useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0));
                var useSkinning = object.isSkinnedMesh && material.skinning, variantIndex = 0;
                useMorphing && (variantIndex |= _MorphingFlag), useSkinning && (variantIndex |= _SkinningFlag), 
                result = materialVariants[variantIndex];
            }
            if (_renderer.localClippingEnabled && material.clipShadows === !0 && 0 !== material.clippingPlanes.length) {
                var keyA = result.uuid, keyB = material.uuid, materialsForVariant = _materialCache[keyA];
                void 0 === materialsForVariant && (materialsForVariant = {}, _materialCache[keyA] = materialsForVariant);
                var cachedMaterial = materialsForVariant[keyB];
                void 0 === cachedMaterial && (cachedMaterial = result.clone(), materialsForVariant[keyB] = cachedMaterial), 
                result = cachedMaterial;
            }
            result.visible = material.visible, result.wireframe = material.wireframe;
            var side = material.side;
            return scope.renderSingleSided && side == DoubleSide && (side = FrontSide), scope.renderReverseSided && (side === FrontSide ? side = BackSide : side === BackSide && (side = FrontSide)), 
            result.side = side, result.clipShadows = material.clipShadows, result.clippingPlanes = material.clippingPlanes, 
            result.wireframeLinewidth = material.wireframeLinewidth, result.linewidth = material.linewidth, 
            isPointLight && void 0 !== result.uniforms.lightPos && result.uniforms.lightPos.value.copy(lightPositionWorld), 
            result;
        }
        function projectObject(object, camera, shadowCamera) {
            if (object.visible !== !1) {
                var visible = 0 !== (object.layers.mask & camera.layers.mask);
                if (visible && (object.isMesh || object.isLine || object.isPoints) && object.castShadow && (object.frustumCulled === !1 || _frustum.intersectsObject(object) === !0)) {
                    var material = object.material;
                    material.visible === !0 && (object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld), 
                    _renderList.push(object));
                }
                for (var children = object.children, i = 0, l = children.length; l > i; i++) projectObject(children[i], camera, shadowCamera);
            }
        }
        var _gl = _renderer.context, _state = _renderer.state, _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _lightShadows = _lights.shadows, _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(capabilities.maxTextureSize, capabilities.maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _renderList = [], _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {}, cubeDirections = [ new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0) ], cubeUps = [ new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1) ], cube2DViewPorts = [ new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4() ], depthMaterialTemplate = new MeshDepthMaterial();
        depthMaterialTemplate.depthPacking = RGBADepthPacking, depthMaterialTemplate.clipping = !0;
        for (var distanceShader = ShaderLib.distanceRGBA, distanceUniforms = UniformsUtils.clone(distanceShader.uniforms), i = 0; i !== _NumberOfMaterialVariants; ++i) {
            var useMorphing = 0 !== (i & _MorphingFlag), useSkinning = 0 !== (i & _SkinningFlag), depthMaterial = depthMaterialTemplate.clone();
            depthMaterial.morphTargets = useMorphing, depthMaterial.skinning = useSkinning, 
            _depthMaterials[i] = depthMaterial;
            var distanceMaterial = new ShaderMaterial({
                defines: {
                    USE_SHADOWMAP: ""
                },
                uniforms: distanceUniforms,
                vertexShader: distanceShader.vertexShader,
                fragmentShader: distanceShader.fragmentShader,
                morphTargets: useMorphing,
                skinning: useSkinning,
                clipping: !0
            });
            _distanceMaterials[i] = distanceMaterial;
        }
        var scope = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap, 
        this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function(scene, camera) {
            if (scope.enabled !== !1 && (scope.autoUpdate !== !1 || scope.needsUpdate !== !1) && 0 !== _lightShadows.length) {
                _state.clearColor(1, 1, 1, 1), _state.disable(_gl.BLEND), _state.setDepthTest(!0), 
                _state.setScissorTest(!1);
                for (var faceCount, isPointLight, i = 0, il = _lightShadows.length; il > i; i++) {
                    var light = _lightShadows[i], shadow = light.shadow;
                    if (void 0 !== shadow) {
                        var shadowCamera = shadow.camera;
                        if (_shadowMapSize.copy(shadow.mapSize), _shadowMapSize.min(_maxShadowMapSize), 
                        light && light.isPointLight) {
                            faceCount = 6, isPointLight = !0;
                            var vpWidth = _shadowMapSize.x, vpHeight = _shadowMapSize.y;
                            cube2DViewPorts[0].set(2 * vpWidth, vpHeight, vpWidth, vpHeight), cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight), 
                            cube2DViewPorts[2].set(3 * vpWidth, vpHeight, vpWidth, vpHeight), cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight), 
                            cube2DViewPorts[4].set(3 * vpWidth, 0, vpWidth, vpHeight), cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight), 
                            _shadowMapSize.x *= 4, _shadowMapSize.y *= 2;
                        } else faceCount = 1, isPointLight = !1;
                        if (null === shadow.map) {
                            var pars = {
                                minFilter: NearestFilter,
                                magFilter: NearestFilter,
                                format: RGBAFormat
                            };
                            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars), shadowCamera.updateProjectionMatrix();
                        }
                        shadow && shadow.isSpotLightShadow && shadow.update(light);
                        var shadowMap = shadow.map, shadowMatrix = shadow.matrix;
                        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld), shadowCamera.position.copy(_lightPositionWorld), 
                        _renderer.setRenderTarget(shadowMap), _renderer.clear();
                        for (var face = 0; faceCount > face; face++) {
                            if (isPointLight) {
                                _lookTarget.copy(shadowCamera.position), _lookTarget.add(cubeDirections[face]), 
                                shadowCamera.up.copy(cubeUps[face]), shadowCamera.lookAt(_lookTarget);
                                var vpDimensions = cube2DViewPorts[face];
                                _state.viewport(vpDimensions);
                            } else _lookTarget.setFromMatrixPosition(light.target.matrixWorld), shadowCamera.lookAt(_lookTarget);
                            shadowCamera.updateMatrixWorld(), shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld), 
                            shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), shadowMatrix.multiply(shadowCamera.projectionMatrix), 
                            shadowMatrix.multiply(shadowCamera.matrixWorldInverse), _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse), 
                            _frustum.setFromMatrix(_projScreenMatrix), _renderList.length = 0, projectObject(scene, camera, shadowCamera);
                            for (var j = 0, jl = _renderList.length; jl > j; j++) {
                                var object = _renderList[j], geometry = _objects.update(object), material = object.material;
                                if (material && material.isMultiMaterial) for (var groups = geometry.groups, materials = material.materials, k = 0, kl = groups.length; kl > k; k++) {
                                    var group = groups[k], groupMaterial = materials[group.materialIndex];
                                    if (groupMaterial.visible === !0) {
                                        var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld);
                                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                                    }
                                } else {
                                    var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld);
                                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                                }
                            }
                        }
                    } else console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
                }
                var clearColor = _renderer.getClearColor(), clearAlpha = _renderer.getClearAlpha();
                _renderer.setClearColor(clearColor, clearAlpha), scope.needsUpdate = !1;
            }
        };
    }
    function Ray(origin, direction) {
        this.origin = void 0 !== origin ? origin : new Vector3(), this.direction = void 0 !== direction ? direction : new Vector3();
    }
    function Euler(x, y, z, order) {
        this._x = x || 0, this._y = y || 0, this._z = z || 0, this._order = order || Euler.DefaultOrder;
    }
    function Layers() {
        this.mask = 1;
    }
    function Object3D() {
        function onRotationChange() {
            quaternion.setFromEuler(rotation, !1);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, void 0, !1);
        }
        Object.defineProperty(this, "id", {
            value: Object3DIdCount()
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, 
        this.children = [], this.up = Object3D.DefaultUp.clone();
        var position = new Vector3(), rotation = new Euler(), quaternion = new Quaternion(), scale = new Vector3(1, 1, 1);
        rotation.onChange(onRotationChange), quaternion.onChange(onQuaternionChange), Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: position
            },
            rotation: {
                enumerable: !0,
                value: rotation
            },
            quaternion: {
                enumerable: !0,
                value: quaternion
            },
            scale: {
                enumerable: !0,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        }), this.matrix = new Matrix4(), this.matrixWorld = new Matrix4(), this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, 
        this.matrixWorldNeedsUpdate = !1, this.layers = new Layers(), this.visible = !0, 
        this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, 
        this.userData = {}, this.onBeforeRender = function() {}, this.onAfterRender = function() {};
    }
    function Object3DIdCount() {
        return count$2++;
    }
    function Line3(start, end) {
        this.start = void 0 !== start ? start : new Vector3(), this.end = void 0 !== end ? end : new Vector3();
    }
    function Triangle(a, b, c) {
        this.a = void 0 !== a ? a : new Vector3(), this.b = void 0 !== b ? b : new Vector3(), 
        this.c = void 0 !== c ? c : new Vector3();
    }
    function Face3(a, b, c, normal, color, materialIndex) {
        this.a = a, this.b = b, this.c = c, this.normal = normal && normal.isVector3 ? normal : new Vector3(), 
        this.vertexNormals = Array.isArray(normal) ? normal : [], this.color = color && color.isColor ? color : new Color(), 
        this.vertexColors = Array.isArray(color) ? color : [], this.materialIndex = void 0 !== materialIndex ? materialIndex : 0;
    }
    function MeshBasicMaterial(parameters) {
        Material.call(this), this.type = "MeshBasicMaterial", this.color = new Color(16777215), 
        this.map = null, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, 
        this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, 
        this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", 
        this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, 
        this.setValues(parameters);
    }
    function BufferAttribute(array, itemSize, normalized) {
        if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.uuid = _Math.generateUUID(), this.array = array, this.itemSize = itemSize, 
        this.count = void 0 !== array ? array.length / itemSize : 0, this.normalized = normalized === !0, 
        this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0;
    }
    function Int8Attribute(array, itemSize) {
        return new BufferAttribute(new Int8Array(array), itemSize);
    }
    function Uint8Attribute(array, itemSize) {
        return new BufferAttribute(new Uint8Array(array), itemSize);
    }
    function Uint8ClampedAttribute(array, itemSize) {
        return new BufferAttribute(new Uint8ClampedArray(array), itemSize);
    }
    function Int16Attribute(array, itemSize) {
        return new BufferAttribute(new Int16Array(array), itemSize);
    }
    function Uint16Attribute(array, itemSize) {
        return new BufferAttribute(new Uint16Array(array), itemSize);
    }
    function Int32Attribute(array, itemSize) {
        return new BufferAttribute(new Int32Array(array), itemSize);
    }
    function Uint32Attribute(array, itemSize) {
        return new BufferAttribute(new Uint32Array(array), itemSize);
    }
    function Float32Attribute(array, itemSize) {
        return new BufferAttribute(new Float32Array(array), itemSize);
    }
    function Float64Attribute(array, itemSize) {
        return new BufferAttribute(new Float64Array(array), itemSize);
    }
    function DynamicBufferAttribute(array, itemSize) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), 
        new BufferAttribute(array, itemSize).setDynamic(!0);
    }
    function Geometry() {
        Object.defineProperty(this, "id", {
            value: GeometryIdCount()
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], 
        this.colors = [], this.faces = [], this.faceVertexUvs = [ [] ], this.morphTargets = [], 
        this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], 
        this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, 
        this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, 
        this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1;
    }
    function GeometryIdCount() {
        return count$3++;
    }
    function DirectGeometry() {
        Object.defineProperty(this, "id", {
            value: GeometryIdCount()
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "DirectGeometry", 
        this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], 
        this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], 
        this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, 
        this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, 
        this.groupsNeedUpdate = !1;
    }
    function BufferGeometry() {
        Object.defineProperty(this, "id", {
            value: GeometryIdCount()
        }), this.uuid = _Math.generateUUID(), this.name = "", this.type = "BufferGeometry", 
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], 
        this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        };
    }
    function Mesh(geometry, material) {
        Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== geometry ? geometry : new BufferGeometry(), 
        this.material = void 0 !== material ? material : new MeshBasicMaterial({
            color: 16777215 * Math.random()
        }), this.drawMode = TrianglesDrawMode, this.updateMorphTargets();
    }
    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        function calculateVertexCount(w, h, d) {
            var vertices = 0;
            return vertices += (w + 1) * (h + 1) * 2, vertices += (w + 1) * (d + 1) * 2, vertices += (d + 1) * (h + 1) * 2;
        }
        function calculateIndexCount(w, h, d) {
            var index = 0;
            return index += w * h * 2, index += w * d * 2, index += d * h * 2, 6 * index;
        }
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            for (var segmentWidth = width / gridX, segmentHeight = height / gridY, widthHalf = width / 2, heightHalf = height / 2, depthHalf = depth / 2, gridX1 = gridX + 1, gridY1 = gridY + 1, vertexCounter = 0, groupCount = 0, vector = new Vector3(), iy = 0; gridY1 > iy; iy++) for (var y = iy * segmentHeight - heightHalf, ix = 0; gridX1 > ix; ix++) {
                var x = ix * segmentWidth - widthHalf;
                vector[u] = x * udir, vector[v] = y * vdir, vector[w] = depthHalf, vertices[vertexBufferOffset] = vector.x, 
                vertices[vertexBufferOffset + 1] = vector.y, vertices[vertexBufferOffset + 2] = vector.z, 
                vector[u] = 0, vector[v] = 0, vector[w] = depth > 0 ? 1 : -1, normals[vertexBufferOffset] = vector.x, 
                normals[vertexBufferOffset + 1] = vector.y, normals[vertexBufferOffset + 2] = vector.z, 
                uvs[uvBufferOffset] = ix / gridX, uvs[uvBufferOffset + 1] = 1 - iy / gridY, vertexBufferOffset += 3, 
                uvBufferOffset += 2, vertexCounter += 1;
            }
            for (iy = 0; gridY > iy; iy++) for (ix = 0; gridX > ix; ix++) {
                var a = numberOfVertices + ix + gridX1 * iy, b = numberOfVertices + ix + gridX1 * (iy + 1), c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1), d = numberOfVertices + (ix + 1) + gridX1 * iy;
                indices[indexBufferOffset] = a, indices[indexBufferOffset + 1] = b, indices[indexBufferOffset + 2] = d, 
                indices[indexBufferOffset + 3] = b, indices[indexBufferOffset + 4] = c, indices[indexBufferOffset + 5] = d, 
                indexBufferOffset += 6, groupCount += 6;
            }
            scope.addGroup(groupStart, groupCount, materialIndex), groupStart += groupCount, 
            numberOfVertices += vertexCounter;
        }
        BufferGeometry.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        var scope = this;
        widthSegments = Math.floor(widthSegments) || 1, heightSegments = Math.floor(heightSegments) || 1, 
        depthSegments = Math.floor(depthSegments) || 1;
        var vertexCount = calculateVertexCount(widthSegments, heightSegments, depthSegments), indexCount = calculateIndexCount(widthSegments, heightSegments, depthSegments), indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), vertices = new Float32Array(3 * vertexCount), normals = new Float32Array(3 * vertexCount), uvs = new Float32Array(2 * vertexCount), vertexBufferOffset = 0, uvBufferOffset = 0, indexBufferOffset = 0, numberOfVertices = 0, groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0), 
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1), 
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2), 
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3), 
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4), 
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5), 
        this.setIndex(new BufferAttribute(indices, 1)), this.addAttribute("position", new BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new BufferAttribute(normals, 3)), this.addAttribute("uv", new BufferAttribute(uvs, 2));
    }
    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
        BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        for (var width_half = width / 2, height_half = height / 2, gridX = Math.floor(widthSegments) || 1, gridY = Math.floor(heightSegments) || 1, gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, vertices = new Float32Array(gridX1 * gridY1 * 3), normals = new Float32Array(gridX1 * gridY1 * 3), uvs = new Float32Array(gridX1 * gridY1 * 2), offset = 0, offset2 = 0, iy = 0; gridY1 > iy; iy++) for (var y = iy * segment_height - height_half, ix = 0; gridX1 > ix; ix++) {
            var x = ix * segment_width - width_half;
            vertices[offset] = x, vertices[offset + 1] = -y, normals[offset + 2] = 1, uvs[offset2] = ix / gridX, 
            uvs[offset2 + 1] = 1 - iy / gridY, offset += 3, offset2 += 2;
        }
        offset = 0;
        for (var indices = new (vertices.length / 3 > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6), iy = 0; gridY > iy; iy++) for (var ix = 0; gridX > ix; ix++) {
            var a = ix + gridX1 * iy, b = ix + gridX1 * (iy + 1), c = ix + 1 + gridX1 * (iy + 1), d = ix + 1 + gridX1 * iy;
            indices[offset] = a, indices[offset + 1] = b, indices[offset + 2] = d, indices[offset + 3] = b, 
            indices[offset + 4] = c, indices[offset + 5] = d, offset += 6;
        }
        this.setIndex(new BufferAttribute(indices, 1)), this.addAttribute("position", new BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new BufferAttribute(normals, 3)), this.addAttribute("uv", new BufferAttribute(uvs, 2));
    }
    function Camera() {
        Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new Matrix4(), 
        this.projectionMatrix = new Matrix4();
    }
    function PerspectiveCamera(fov, aspect, near, far) {
        Camera.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== fov ? fov : 50, 
        this.zoom = 1, this.near = void 0 !== near ? near : .1, this.far = void 0 !== far ? far : 2e3, 
        this.focus = 10, this.aspect = void 0 !== aspect ? aspect : 1, this.view = null, 
        this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    function OrthographicCamera(left, right, top, bottom, near, far) {
        Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, 
        this.left = left, this.right = right, this.top = top, this.bottom = bottom, this.near = void 0 !== near ? near : .1, 
        this.far = void 0 !== far ? far : 2e3, this.updateProjectionMatrix();
    }
    function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
        function setMode(value) {
            mode = value;
        }
        function setIndex(index) {
            index.array instanceof Uint32Array && extensions.get("OES_element_index_uint") ? (type = gl.UNSIGNED_INT, 
            size = 4) : (type = gl.UNSIGNED_SHORT, size = 2);
        }
        function render(start, count) {
            gl.drawElements(mode, count, type, start * size), infoRender.calls++, infoRender.vertices += count, 
            mode === gl.TRIANGLES && (infoRender.faces += count / 3);
        }
        function renderInstances(geometry, start, count) {
            var extension = extensions.get("ANGLE_instanced_arrays");
            return null === extension ? void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (extension.drawElementsInstancedANGLE(mode, count, type, start * size, geometry.maxInstancedCount), 
            infoRender.calls++, infoRender.vertices += count * geometry.maxInstancedCount, void (mode === gl.TRIANGLES && (infoRender.faces += geometry.maxInstancedCount * count / 3)));
        }
        var mode, type, size;
        return {
            setMode: setMode,
            setIndex: setIndex,
            render: render,
            renderInstances: renderInstances
        };
    }
    function WebGLBufferRenderer(gl, extensions, infoRender) {
        function setMode(value) {
            mode = value;
        }
        function render(start, count) {
            gl.drawArrays(mode, start, count), infoRender.calls++, infoRender.vertices += count, 
            mode === gl.TRIANGLES && (infoRender.faces += count / 3);
        }
        function renderInstances(geometry) {
            var extension = extensions.get("ANGLE_instanced_arrays");
            if (null === extension) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            var position = geometry.attributes.position, count = 0;
            position && position.isInterleavedBufferAttribute ? (count = position.data.count, 
            extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount)) : (count = position.count, 
            extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount)), 
            infoRender.calls++, infoRender.vertices += count * geometry.maxInstancedCount, mode === gl.TRIANGLES && (infoRender.faces += geometry.maxInstancedCount * count / 3);
        }
        var mode;
        return {
            setMode: setMode,
            render: render,
            renderInstances: renderInstances
        };
    }
    function WebGLLights() {
        var lights = {};
        return {
            get: function(light) {
                if (void 0 !== lights[light.id]) return lights[light.id];
                var uniforms;
                switch (light.type) {
                  case "DirectionalLight":
                    uniforms = {
                        direction: new Vector3(),
                        color: new Color(),
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "SpotLight":
                    uniforms = {
                        position: new Vector3(),
                        direction: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "PointLight":
                    uniforms = {
                        position: new Vector3(),
                        color: new Color(),
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector2()
                    };
                    break;

                  case "HemisphereLight":
                    uniforms = {
                        direction: new Vector3(),
                        skyColor: new Color(),
                        groundColor: new Color()
                    };
                }
                return lights[light.id] = uniforms, uniforms;
            }
        };
    }
    function addLineNumbers(string) {
        for (var lines = string.split("\n"), i = 0; i < lines.length; i++) lines[i] = i + 1 + ": " + lines[i];
        return lines.join("\n");
    }
    function WebGLShader(gl, type, string) {
        var shader = gl.createShader(type);
        return gl.shaderSource(shader, string), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), 
        "" !== gl.getShaderInfoLog(shader) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === gl.VERTEX_SHADER ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string)), 
        shader;
    }
    function getEncodingComponents(encoding) {
        switch (encoding) {
          case LinearEncoding:
            return [ "Linear", "( value )" ];

          case sRGBEncoding:
            return [ "sRGB", "( value )" ];

          case RGBEEncoding:
            return [ "RGBE", "( value )" ];

          case RGBM7Encoding:
            return [ "RGBM", "( value, 7.0 )" ];

          case RGBM16Encoding:
            return [ "RGBM", "( value, 16.0 )" ];

          case RGBDEncoding:
            return [ "RGBD", "( value, 256.0 )" ];

          case GammaEncoding:
            return [ "Gamma", "( value, float( GAMMA_FACTOR ) )" ];

          default:
            throw new Error("unsupported encoding: " + encoding);
        }
    }
    function getTexelDecodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
    }
    function getTexelEncodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
    }
    function getToneMappingFunction(functionName, toneMapping) {
        var toneMappingName;
        switch (toneMapping) {
          case LinearToneMapping:
            toneMappingName = "Linear";
            break;

          case ReinhardToneMapping:
            toneMappingName = "Reinhard";
            break;

          case Uncharted2ToneMapping:
            toneMappingName = "Uncharted2";
            break;

          case CineonToneMapping:
            toneMappingName = "OptimizedCineon";
            break;

          default:
            throw new Error("unsupported toneMapping: " + toneMapping);
        }
        return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
    }
    function generateExtensions(extensions, parameters, rendererExtensions) {
        extensions = extensions || {};
        var chunks = [ extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : "" ];
        return chunks.filter(filterEmptyLine).join("\n");
    }
    function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
            var value = defines[name];
            value !== !1 && chunks.push("#define " + name + " " + value);
        }
        return chunks.join("\n");
    }
    function fetchAttributeLocations(gl, program, identifiers) {
        for (var attributes = {}, n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES), i = 0; n > i; i++) {
            var info = gl.getActiveAttrib(program, i), name = info.name;
            attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
    }
    function filterEmptyLine(string) {
        return "" !== string;
    }
    function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
    }
    function parseIncludes(string) {
        function replace(match, include) {
            var replace = ShaderChunk[include];
            if (void 0 === replace) throw new Error("Can not resolve #include <" + include + ">");
            return parseIncludes(replace);
        }
        var pattern = /#include +<([\w\d.]+)>/g;
        return string.replace(pattern, replace);
    }
    function unrollLoops(string) {
        function replace(match, start, end, snippet) {
            for (var unroll = "", i = parseInt(start); i < parseInt(end); i++) unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
            return unroll;
        }
        var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        return string.replace(pattern, replace);
    }
    function WebGLProgram(renderer, code, material, parameters) {
        var gl = renderer.context, extensions = material.extensions, defines = material.defines, vertexShader = material.__webglShader.vertexShader, fragmentShader = material.__webglShader.fragmentShader, shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
        parameters.shadowMapType === PCFShadowMap ? shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF" : parameters.shadowMapType === PCFSoftShadowMap && (shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT");
        var envMapTypeDefine = "ENVMAP_TYPE_CUBE", envMapModeDefine = "ENVMAP_MODE_REFLECTION", envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        if (parameters.envMap) {
            switch (material.envMap.mapping) {
              case CubeReflectionMapping:
              case CubeRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE";
                break;

              case CubeUVReflectionMapping:
              case CubeUVRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
                break;

              case EquirectangularReflectionMapping:
              case EquirectangularRefractionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
                break;

              case SphericalReflectionMapping:
                envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
            }
            switch (material.envMap.mapping) {
              case CubeRefractionMapping:
              case EquirectangularRefractionMapping:
                envMapModeDefine = "ENVMAP_MODE_REFRACTION";
            }
            switch (material.combine) {
              case MultiplyOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
                break;

              case MixOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
                break;

              case AddOperation:
                envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
            }
        }
        var prefixVertex, prefixFragment, gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1, customExtensions = generateExtensions(extensions, parameters, renderer.extensions), customDefines = generateDefines(defines), program = gl.createProgram();
        material.isRawShaderMaterial ? (prefixVertex = [ customDefines, "\n" ].filter(filterEmptyLine).join("\n"), 
        prefixFragment = [ customExtensions, customDefines, "\n" ].filter(filterEmptyLine).join("\n")) : (prefixVertex = [ "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + material.__webglShader.name, customDefines, parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n" ].filter(filterEmptyLine).join("\n"), 
        prefixFragment = [ customExtensions, "precision " + parameters.precision + " float;", "precision " + parameters.precision + " int;", "#define SHADER_NAME " + material.__webglShader.name, customDefines, parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest : "", "#define GAMMA_FACTOR " + gammaFactorDefine, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + parameters.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (parameters.numClippingPlanes - parameters.numClipIntersection), parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && renderer.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", parameters.envMap && renderer.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", parameters.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "", parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk.encodings_pars_fragment : "", parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "", parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "", parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "", parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "", parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "", "\n" ].filter(filterEmptyLine).join("\n")), 
        vertexShader = parseIncludes(vertexShader, parameters), vertexShader = replaceLightNums(vertexShader, parameters), 
        fragmentShader = parseIncludes(fragmentShader, parameters), fragmentShader = replaceLightNums(fragmentShader, parameters), 
        material.isShaderMaterial || (vertexShader = unrollLoops(vertexShader), fragmentShader = unrollLoops(fragmentShader));
        var vertexGlsl = prefixVertex + vertexShader, fragmentGlsl = prefixFragment + fragmentShader, glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl), glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader), gl.attachShader(program, glFragmentShader), 
        void 0 !== material.index0AttributeName ? gl.bindAttribLocation(program, 0, material.index0AttributeName) : parameters.morphTargets === !0 && gl.bindAttribLocation(program, 0, "position"), 
        gl.linkProgram(program);
        var programLog = gl.getProgramInfoLog(program), vertexLog = gl.getShaderInfoLog(glVertexShader), fragmentLog = gl.getShaderInfoLog(glFragmentShader), runnable = !0, haveDiagnostics = !0;
        gl.getProgramParameter(program, gl.LINK_STATUS) === !1 ? (runnable = !1, console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog)) : "" !== programLog ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog) : "" !== vertexLog && "" !== fragmentLog || (haveDiagnostics = !1), 
        haveDiagnostics && (this.diagnostics = {
            runnable: runnable,
            material: material,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        }), gl.deleteShader(glVertexShader), gl.deleteShader(glFragmentShader);
        var cachedUniforms;
        this.getUniforms = function() {
            return void 0 === cachedUniforms && (cachedUniforms = new WebGLUniforms(gl, program, renderer)), 
            cachedUniforms;
        };
        var cachedAttributes;
        return this.getAttributes = function() {
            return void 0 === cachedAttributes && (cachedAttributes = fetchAttributeLocations(gl, program)), 
            cachedAttributes;
        }, this.destroy = function() {
            gl.deleteProgram(program), this.program = void 0;
        }, Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms();
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), 
                    this.getAttributes();
                }
            }
        }), this.id = programIdCount++, this.code = code, this.usedTimes = 1, this.program = program, 
        this.vertexShader = glVertexShader, this.fragmentShader = glFragmentShader, this;
    }
    function WebGLPrograms(renderer, capabilities) {
        function allocateBones(object) {
            if (capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture) return 1024;
            var nVertexUniforms = capabilities.maxVertexUniforms, nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4), maxBones = nVertexMatrices;
            return void 0 !== object && object && object.isSkinnedMesh && (maxBones = Math.min(object.skeleton.bones.length, maxBones), 
            maxBones < object.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + object.skeleton.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)")), 
            maxBones;
        }
        function getTextureEncodingFromMap(map, gammaOverrideLinear) {
            var encoding;
            return map ? map && map.isTexture ? encoding = map.encoding : map && map.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), 
            encoding = map.texture.encoding) : encoding = LinearEncoding, encoding === LinearEncoding && gammaOverrideLinear && (encoding = GammaEncoding), 
            encoding;
        }
        var programs = [], shaderIDs = {
            MeshDepthMaterial: "depth",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points"
        }, parameterNames = [ "precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking" ];
        this.getParameters = function(material, lights, fog, nClipPlanes, nClipIntersection, object) {
            var shaderID = shaderIDs[material.type], maxBones = allocateBones(object), precision = renderer.getPrecision();
            null !== material.precision && (precision = capabilities.getMaxPrecision(material.precision), 
            precision !== material.precision && console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead."));
            var currentRenderTarget = renderer.getCurrentRenderTarget(), parameters = {
                shaderID: shaderID,
                precision: precision,
                supportsVertexTextures: capabilities.vertexTextures,
                outputEncoding: getTextureEncodingFromMap(currentRenderTarget ? currentRenderTarget.texture : null, renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                combine: material.combine,
                vertexColors: material.vertexColors,
                fog: !!fog,
                useFog: material.fog,
                fogExp: fog && fog.isFogExp2,
                flatShading: material.shading === FlatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                skinning: material.skinning,
                maxBones: maxBones,
                useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numHemiLights: lights.hemi.length,
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
                shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: renderer.toneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                depthPacking: void 0 !== material.depthPacking ? material.depthPacking : !1
            };
            return parameters;
        }, this.getProgramCode = function(material, parameters) {
            var array = [];
            if (parameters.shaderID ? array.push(parameters.shaderID) : (array.push(material.fragmentShader), 
            array.push(material.vertexShader)), void 0 !== material.defines) for (var name in material.defines) array.push(name), 
            array.push(material.defines[name]);
            for (var i = 0; i < parameterNames.length; i++) array.push(parameters[parameterNames[i]]);
            return array.join();
        }, this.acquireProgram = function(material, parameters, code) {
            for (var program, p = 0, pl = programs.length; pl > p; p++) {
                var programInfo = programs[p];
                if (programInfo.code === code) {
                    program = programInfo, ++program.usedTimes;
                    break;
                }
            }
            return void 0 === program && (program = new WebGLProgram(renderer, code, material, parameters), 
            programs.push(program)), program;
        }, this.releaseProgram = function(program) {
            if (0 === --program.usedTimes) {
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1], programs.pop(), program.destroy();
            }
        }, this.programs = programs;
    }
    function WebGLGeometries(gl, properties, info) {
        function onGeometryDispose(event) {
            var geometry = event.target, buffergeometry = geometries[geometry.id];
            null !== buffergeometry.index && deleteAttribute(buffergeometry.index), deleteAttributes(buffergeometry.attributes), 
            geometry.removeEventListener("dispose", onGeometryDispose), delete geometries[geometry.id];
            var property = properties.get(geometry);
            property.wireframe && deleteAttribute(property.wireframe), properties["delete"](geometry);
            var bufferproperty = properties.get(buffergeometry);
            bufferproperty.wireframe && deleteAttribute(bufferproperty.wireframe), properties["delete"](buffergeometry), 
            info.memory.geometries--;
        }
        function getAttributeBuffer(attribute) {
            return attribute.isInterleavedBufferAttribute ? properties.get(attribute.data).__webglBuffer : properties.get(attribute).__webglBuffer;
        }
        function deleteAttribute(attribute) {
            var buffer = getAttributeBuffer(attribute);
            void 0 !== buffer && (gl.deleteBuffer(buffer), removeAttributeBuffer(attribute));
        }
        function deleteAttributes(attributes) {
            for (var name in attributes) deleteAttribute(attributes[name]);
        }
        function removeAttributeBuffer(attribute) {
            attribute.isInterleavedBufferAttribute ? properties["delete"](attribute.data) : properties["delete"](attribute);
        }
        var geometries = {};
        return {
            get: function(object) {
                var geometry = object.geometry;
                if (void 0 !== geometries[geometry.id]) return geometries[geometry.id];
                geometry.addEventListener("dispose", onGeometryDispose);
                var buffergeometry;
                return geometry.isBufferGeometry ? buffergeometry = geometry : geometry.isGeometry && (void 0 === geometry._bufferGeometry && (geometry._bufferGeometry = new BufferGeometry().setFromObject(object)), 
                buffergeometry = geometry._bufferGeometry), geometries[geometry.id] = buffergeometry, 
                info.memory.geometries++, buffergeometry;
            }
        };
    }
    function WebGLObjects(gl, properties, info) {
        function update(object) {
            var geometry = geometries.get(object);
            object.geometry.isGeometry && geometry.updateFromObject(object);
            var index = geometry.index, attributes = geometry.attributes;
            null !== index && updateAttribute(index, gl.ELEMENT_ARRAY_BUFFER);
            for (var name in attributes) updateAttribute(attributes[name], gl.ARRAY_BUFFER);
            var morphAttributes = geometry.morphAttributes;
            for (var name in morphAttributes) for (var array = morphAttributes[name], i = 0, l = array.length; l > i; i++) updateAttribute(array[i], gl.ARRAY_BUFFER);
            return geometry;
        }
        function updateAttribute(attribute, bufferType) {
            var data = attribute.isInterleavedBufferAttribute ? attribute.data : attribute, attributeProperties = properties.get(data);
            void 0 === attributeProperties.__webglBuffer ? createBuffer(attributeProperties, data, bufferType) : attributeProperties.version !== data.version && updateBuffer(attributeProperties, data, bufferType);
        }
        function createBuffer(attributeProperties, data, bufferType) {
            attributeProperties.__webglBuffer = gl.createBuffer(), gl.bindBuffer(bufferType, attributeProperties.__webglBuffer);
            var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
            gl.bufferData(bufferType, data.array, usage), attributeProperties.version = data.version;
        }
        function updateBuffer(attributeProperties, data, bufferType) {
            gl.bindBuffer(bufferType, attributeProperties.__webglBuffer), data.dynamic === !1 ? gl.bufferData(bufferType, data.array, gl.STATIC_DRAW) : -1 === data.updateRange.count ? gl.bufferSubData(bufferType, 0, data.array) : 0 === data.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (gl.bufferSubData(bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT, data.array.subarray(data.updateRange.offset, data.updateRange.offset + data.updateRange.count)), 
            data.updateRange.count = 0), attributeProperties.version = data.version;
        }
        function getAttributeBuffer(attribute) {
            return attribute.isInterleavedBufferAttribute ? properties.get(attribute.data).__webglBuffer : properties.get(attribute).__webglBuffer;
        }
        function getWireframeAttribute(geometry) {
            var property = properties.get(geometry);
            if (void 0 !== property.wireframe) return property.wireframe;
            var indices = [], index = geometry.index, attributes = geometry.attributes, position = attributes.position;
            if (null !== index) for (var array = index.array, i = 0, l = array.length; l > i; i += 3) {
                var a = array[i + 0], b = array[i + 1], c = array[i + 2];
                indices.push(a, b, b, c, c, a);
            } else for (var array = attributes.position.array, i = 0, l = array.length / 3 - 1; l > i; i += 3) {
                var a = i + 0, b = i + 1, c = i + 2;
                indices.push(a, b, b, c, c, a);
            }
            var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array, attribute = new BufferAttribute(new TypeArray(indices), 1);
            return updateAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER), property.wireframe = attribute, 
            attribute;
        }
        var geometries = new WebGLGeometries(gl, properties, info);
        return {
            getAttributeBuffer: getAttributeBuffer,
            getWireframeAttribute: getWireframeAttribute,
            update: update
        };
    }
    function WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, info) {
        function clampToMaxSize(image, maxSize) {
            if (image.width > maxSize || image.height > maxSize) {
                var scale = maxSize / Math.max(image.width, image.height), canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = Math.floor(image.width * scale), canvas.height = Math.floor(image.height * scale);
                var context = canvas.getContext("2d");
                return context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height), 
                console.warn("THREE.WebGLRenderer: image is too big (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image), 
                canvas;
            }
            return image;
        }
        function isPowerOfTwo(image) {
            return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
        }
        function makePowerOfTwo(image) {
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
                var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = _Math.nearestPowerOfTwo(image.width), canvas.height = _Math.nearestPowerOfTwo(image.height);
                var context = canvas.getContext("2d");
                return context.drawImage(image, 0, 0, canvas.width, canvas.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + image.width + "x" + image.height + "). Resized to " + canvas.width + "x" + canvas.height, image), 
                canvas;
            }
            return image;
        }
        function textureNeedsPowerOfTwo(texture) {
            return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ? !0 : texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function filterFallback(f) {
            return f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ? _gl.NEAREST : _gl.LINEAR;
        }
        function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener("dispose", onTextureDispose), deallocateTexture(texture), 
            _infoMemory.textures--;
        }
        function onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener("dispose", onRenderTargetDispose), deallocateRenderTarget(renderTarget), 
            _infoMemory.textures--;
        }
        function deallocateTexture(texture) {
            var textureProperties = properties.get(texture);
            if (texture.image && textureProperties.__image__webglTextureCube) _gl.deleteTexture(textureProperties.__image__webglTextureCube); else {
                if (void 0 === textureProperties.__webglInit) return;
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            properties["delete"](texture);
        }
        function deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget), textureProperties = properties.get(renderTarget.texture);
            if (renderTarget) {
                if (void 0 !== textureProperties.__webglTexture && _gl.deleteTexture(textureProperties.__webglTexture), 
                renderTarget.depthTexture && renderTarget.depthTexture.dispose(), renderTarget && renderTarget.isWebGLRenderTargetCube) for (var i = 0; 6 > i; i++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]), 
                renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]); else _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer), 
                renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
                properties["delete"](renderTarget.texture), properties["delete"](renderTarget);
            }
        }
        function setTexture2D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (void 0 === image) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", texture); else {
                    if (image.complete !== !1) return void uploadTexture(textureProperties, texture, slot);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", texture);
                }
            }
            state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
            var textureProperties = properties.get(texture);
            if (6 === texture.image.length) if (texture.version > 0 && textureProperties.__version !== texture.version) {
                textureProperties.__image__webglTextureCube || (texture.addEventListener("dispose", onTextureDispose), 
                textureProperties.__image__webglTextureCube = _gl.createTexture(), _infoMemory.textures++), 
                state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube), 
                _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                for (var isCompressed = texture && texture.isCompressedTexture, isDataTexture = texture.image[0] && texture.image[0].isDataTexture, cubeImage = [], i = 0; 6 > i; i++) isCompressed || isDataTexture ? cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i] : cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                var image = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                for (var i = 0; 6 > i; i++) if (isCompressed) for (var mipmap, mipmaps = cubeImage[i].mipmaps, j = 0, jl = mipmaps.length; jl > j; j++) mipmap = mipmaps[j], 
                texture.format !== RGBAFormat && texture.format !== RGBFormat ? state.getCompressedTextureFormats().indexOf(glFormat) > -1 ? state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data); else isDataTexture ? state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                texture.generateMipmaps && isPowerOfTwoImage && _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP), 
                textureProperties.__version = texture.version, texture.onUpdate && texture.onUpdate(texture);
            } else state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
        }
        function setTextureCubeDynamic(texture, slot) {
            state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
        }
        function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
            var extension;
            if (isPowerOfTwoImage ? (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS)), 
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT)), 
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter)), 
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter))) : (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE), 
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE), texture.wrapS === ClampToEdgeWrapping && texture.wrapT === ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", texture), 
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter)), 
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter)), 
            texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", texture)), 
            extension = extensions.get("EXT_texture_filter_anisotropic")) {
                if (texture.type === FloatType && null === extensions.get("OES_texture_float_linear")) return;
                if (texture.type === HalfFloatType && null === extensions.get("OES_texture_half_float_linear")) return;
                (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) && (_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy())), 
                properties.get(texture).__currentAnisotropy = texture.anisotropy);
            }
        }
        function uploadTexture(textureProperties, texture, slot) {
            void 0 === textureProperties.__webglInit && (textureProperties.__webglInit = !0, 
            texture.addEventListener("dispose", onTextureDispose), textureProperties.__webglTexture = _gl.createTexture(), 
            _infoMemory.textures++), state.activeTexture(_gl.TEXTURE0 + slot), state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture), 
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha), 
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
            textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === !1 && (image = makePowerOfTwo(image));
            var isPowerOfTwoImage = isPowerOfTwo(image), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
            setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
            var mipmap, mipmaps = texture.mipmaps;
            if (texture && texture.isDepthTexture) {
                var internalFormat = _gl.DEPTH_COMPONENT;
                if (texture.type === FloatType) {
                    if (!_isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    internalFormat = _gl.DEPTH_COMPONENT32F;
                } else _isWebGL2 && (internalFormat = _gl.DEPTH_COMPONENT16);
                texture.format === DepthStencilFormat && (internalFormat = _gl.DEPTH_STENCIL), state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
            } else if (texture && texture.isDataTexture) if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; il > i; i++) mipmap = mipmaps[i], state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                texture.generateMipmaps = !1;
            } else state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data); else if (texture && texture.isCompressedTexture) for (var i = 0, il = mipmaps.length; il > i; i++) mipmap = mipmaps[i], 
            texture.format !== RGBAFormat && texture.format !== RGBFormat ? state.getCompressedTextureFormats().indexOf(glFormat) > -1 ? state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data); else if (mipmaps.length > 0 && isPowerOfTwoImage) {
                for (var i = 0, il = mipmaps.length; il > i; i++) mipmap = mipmaps[i], state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                texture.generateMipmaps = !1;
            } else state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
            texture.generateMipmaps && isPowerOfTwoImage && _gl.generateMipmap(_gl.TEXTURE_2D), 
            textureProperties.__version = texture.version, texture.onUpdate && texture.onUpdate(texture);
        }
        function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = paramThreeToGL(renderTarget.texture.format), glType = paramThreeToGL(renderTarget.texture.type);
            state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null), 
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0), 
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderBufferStorage(renderbuffer, renderTarget) {
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer), renderTarget.depthBuffer && !renderTarget.stencilBuffer ? (_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height), 
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)) : renderTarget.depthBuffer && renderTarget.stencilBuffer ? (_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height), 
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)) : _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height), 
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }
        function setupDepthTexture(framebuffer, renderTarget) {
            var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
            if (isCube) throw new Error("Depth Texture with cube render targets is not supported!");
            if (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), !renderTarget.depthTexture || !renderTarget.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            properties.get(renderTarget.depthTexture).__webglTexture && renderTarget.depthTexture.image.width === renderTarget.width && renderTarget.depthTexture.image.height === renderTarget.height || (renderTarget.depthTexture.image.width = renderTarget.width, 
            renderTarget.depthTexture.image.height = renderTarget.height, renderTarget.depthTexture.needsUpdate = !0), 
            setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0); else {
                if (renderTarget.depthTexture.format !== DepthStencilFormat) throw new Error("Unknown depthTexture format");
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            }
        }
        function setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget), isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
            if (renderTarget.depthTexture) {
                if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            } else if (isCube) {
                renderTargetProperties.__webglDepthbuffer = [];
                for (var i = 0; 6 > i; i++) _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]), 
                renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
            } else _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer), 
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget), textureProperties = properties.get(renderTarget.texture);
            renderTarget.addEventListener("dispose", onRenderTargetDispose), textureProperties.__webglTexture = _gl.createTexture(), 
            _infoMemory.textures++;
            var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube, isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; 6 > i; i++) renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
            } else renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isCube) {
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                for (var i = 0; 6 > i; i++) setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                renderTarget.texture.generateMipmaps && isTargetPowerOfTwo && _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP), 
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
            } else state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo), 
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D), 
            renderTarget.texture.generateMipmaps && isTargetPowerOfTwo && _gl.generateMipmap(_gl.TEXTURE_2D), 
            state.bindTexture(_gl.TEXTURE_2D, null);
            renderTarget.depthBuffer && setupDepthRenderbuffer(renderTarget);
        }
        function updateRenderTargetMipmap(renderTarget) {
            var texture = renderTarget.texture;
            if (texture.generateMipmaps && isPowerOfTwo(renderTarget) && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                var target = renderTarget && renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D, webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture), _gl.generateMipmap(target), state.bindTexture(target, null);
            }
        }
        var _infoMemory = info.memory, _isWebGL2 = "undefined" != typeof WebGL2RenderingContext && _gl instanceof WebGL2RenderingContext;
        this.setTexture2D = setTexture2D, this.setTextureCube = setTextureCube, this.setTextureCubeDynamic = setTextureCubeDynamic, 
        this.setupRenderTarget = setupRenderTarget, this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    }
    function WebGLProperties() {
        var properties = {};
        return {
            get: function(object) {
                var uuid = object.uuid, map = properties[uuid];
                return void 0 === map && (map = {}, properties[uuid] = map), map;
            },
            "delete": function(object) {
                delete properties[object.uuid];
            },
            clear: function() {
                properties = {};
            }
        };
    }
    function WebGLState(gl, extensions, paramThreeToGL) {
        function ColorBuffer() {
            var locked = !1, color = new Vector4(), currentColorMask = null, currentColorClear = new Vector4();
            return {
                setMask: function(colorMask) {
                    currentColorMask === colorMask || locked || (gl.colorMask(colorMask, colorMask, colorMask, colorMask), 
                    currentColorMask = colorMask);
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(r, g, b, a) {
                    color.set(r, g, b, a), currentColorClear.equals(color) === !1 && (gl.clearColor(r, g, b, a), 
                    currentColorClear.copy(color));
                },
                reset: function() {
                    locked = !1, currentColorMask = null, currentColorClear.set(0, 0, 0, 1);
                }
            };
        }
        function DepthBuffer() {
            var locked = !1, currentDepthMask = null, currentDepthFunc = null, currentDepthClear = null;
            return {
                setTest: function(depthTest) {
                    depthTest ? enable(gl.DEPTH_TEST) : disable(gl.DEPTH_TEST);
                },
                setMask: function(depthMask) {
                    currentDepthMask === depthMask || locked || (gl.depthMask(depthMask), currentDepthMask = depthMask);
                },
                setFunc: function(depthFunc) {
                    if (currentDepthFunc !== depthFunc) {
                        if (depthFunc) switch (depthFunc) {
                          case NeverDepth:
                            gl.depthFunc(gl.NEVER);
                            break;

                          case AlwaysDepth:
                            gl.depthFunc(gl.ALWAYS);
                            break;

                          case LessDepth:
                            gl.depthFunc(gl.LESS);
                            break;

                          case LessEqualDepth:
                            gl.depthFunc(gl.LEQUAL);
                            break;

                          case EqualDepth:
                            gl.depthFunc(gl.EQUAL);
                            break;

                          case GreaterEqualDepth:
                            gl.depthFunc(gl.GEQUAL);
                            break;

                          case GreaterDepth:
                            gl.depthFunc(gl.GREATER);
                            break;

                          case NotEqualDepth:
                            gl.depthFunc(gl.NOTEQUAL);
                            break;

                          default:
                            gl.depthFunc(gl.LEQUAL);
                        } else gl.depthFunc(gl.LEQUAL);
                        currentDepthFunc = depthFunc;
                    }
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(depth) {
                    currentDepthClear !== depth && (gl.clearDepth(depth), currentDepthClear = depth);
                },
                reset: function() {
                    locked = !1, currentDepthMask = null, currentDepthFunc = null, currentDepthClear = null;
                }
            };
        }
        function StencilBuffer() {
            var locked = !1, currentStencilMask = null, currentStencilFunc = null, currentStencilRef = null, currentStencilFuncMask = null, currentStencilFail = null, currentStencilZFail = null, currentStencilZPass = null, currentStencilClear = null;
            return {
                setTest: function(stencilTest) {
                    stencilTest ? enable(gl.STENCIL_TEST) : disable(gl.STENCIL_TEST);
                },
                setMask: function(stencilMask) {
                    currentStencilMask === stencilMask || locked || (gl.stencilMask(stencilMask), currentStencilMask = stencilMask);
                },
                setFunc: function(stencilFunc, stencilRef, stencilMask) {
                    currentStencilFunc === stencilFunc && currentStencilRef === stencilRef && currentStencilFuncMask === stencilMask || (gl.stencilFunc(stencilFunc, stencilRef, stencilMask), 
                    currentStencilFunc = stencilFunc, currentStencilRef = stencilRef, currentStencilFuncMask = stencilMask);
                },
                setOp: function(stencilFail, stencilZFail, stencilZPass) {
                    currentStencilFail === stencilFail && currentStencilZFail === stencilZFail && currentStencilZPass === stencilZPass || (gl.stencilOp(stencilFail, stencilZFail, stencilZPass), 
                    currentStencilFail = stencilFail, currentStencilZFail = stencilZFail, currentStencilZPass = stencilZPass);
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(stencil) {
                    currentStencilClear !== stencil && (gl.clearStencil(stencil), currentStencilClear = stencil);
                },
                reset: function() {
                    locked = !1, currentStencilMask = null, currentStencilFunc = null, currentStencilRef = null, 
                    currentStencilFuncMask = null, currentStencilFail = null, currentStencilZFail = null, 
                    currentStencilZPass = null, currentStencilClear = null;
                }
            };
        }
        function createTexture(type, target, count) {
            var data = new Uint8Array(4), texture = gl.createTexture();
            gl.bindTexture(type, texture), gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST), 
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            for (var i = 0; count > i; i++) gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            return texture;
        }
        function init() {
            clearColor(0, 0, 0, 1), clearDepth(1), clearStencil(0), enable(gl.DEPTH_TEST), setDepthFunc(LessEqualDepth), 
            setFlipSided(!1), setCullFace(CullFaceBack), enable(gl.CULL_FACE), enable(gl.BLEND), 
            setBlending(NormalBlending);
        }
        function initAttributes() {
            for (var i = 0, l = newAttributes.length; l > i; i++) newAttributes[i] = 0;
        }
        function enableAttribute(attribute) {
            if (newAttributes[attribute] = 1, 0 === enabledAttributes[attribute] && (gl.enableVertexAttribArray(attribute), 
            enabledAttributes[attribute] = 1), 0 !== attributeDivisors[attribute]) {
                var extension = extensions.get("ANGLE_instanced_arrays");
                extension.vertexAttribDivisorANGLE(attribute, 0), attributeDivisors[attribute] = 0;
            }
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute, extension) {
            newAttributes[attribute] = 1, 0 === enabledAttributes[attribute] && (gl.enableVertexAttribArray(attribute), 
            enabledAttributes[attribute] = 1), attributeDivisors[attribute] !== meshPerAttribute && (extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute), 
            attributeDivisors[attribute] = meshPerAttribute);
        }
        function disableUnusedAttributes() {
            for (var i = 0, l = enabledAttributes.length; i !== l; ++i) enabledAttributes[i] !== newAttributes[i] && (gl.disableVertexAttribArray(i), 
            enabledAttributes[i] = 0);
        }
        function enable(id) {
            capabilities[id] !== !0 && (gl.enable(id), capabilities[id] = !0);
        }
        function disable(id) {
            capabilities[id] !== !1 && (gl.disable(id), capabilities[id] = !1);
        }
        function getCompressedTextureFormats() {
            if (null === compressedTextureFormats && (compressedTextureFormats = [], extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1"))) for (var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS), i = 0; i < formats.length; i++) compressedTextureFormats.push(formats[i]);
            return compressedTextureFormats;
        }
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            blending !== NoBlending ? enable(gl.BLEND) : disable(gl.BLEND), blending === currentBlending && premultipliedAlpha === currentPremultipledAlpha || (blending === AdditiveBlending ? premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), 
            gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE)) : (gl.blendEquation(gl.FUNC_ADD), 
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE)) : blending === SubtractiveBlending ? premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), 
            gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA)) : (gl.blendEquation(gl.FUNC_ADD), 
            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR)) : blending === MultiplyBlending ? premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), 
            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA)) : (gl.blendEquation(gl.FUNC_ADD), 
            gl.blendFunc(gl.ZERO, gl.SRC_COLOR)) : premultipliedAlpha ? (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), 
            gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)) : (gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), 
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)), 
            currentBlending = blending, currentPremultipledAlpha = premultipliedAlpha), blending === CustomBlending ? (blendEquationAlpha = blendEquationAlpha || blendEquation, 
            blendSrcAlpha = blendSrcAlpha || blendSrc, blendDstAlpha = blendDstAlpha || blendDst, 
            blendEquation === currentBlendEquation && blendEquationAlpha === currentBlendEquationAlpha || (gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha)), 
            currentBlendEquation = blendEquation, currentBlendEquationAlpha = blendEquationAlpha), 
            blendSrc === currentBlendSrc && blendDst === currentBlendDst && blendSrcAlpha === currentBlendSrcAlpha && blendDstAlpha === currentBlendDstAlpha || (gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha)), 
            currentBlendSrc = blendSrc, currentBlendDst = blendDst, currentBlendSrcAlpha = blendSrcAlpha, 
            currentBlendDstAlpha = blendDstAlpha)) : (currentBlendEquation = null, currentBlendSrc = null, 
            currentBlendDst = null, currentBlendEquationAlpha = null, currentBlendSrcAlpha = null, 
            currentBlendDstAlpha = null);
        }
        function setColorWrite(colorWrite) {
            colorBuffer.setMask(colorWrite);
        }
        function setDepthTest(depthTest) {
            depthBuffer.setTest(depthTest);
        }
        function setDepthWrite(depthWrite) {
            depthBuffer.setMask(depthWrite);
        }
        function setDepthFunc(depthFunc) {
            depthBuffer.setFunc(depthFunc);
        }
        function setStencilTest(stencilTest) {
            stencilBuffer.setTest(stencilTest);
        }
        function setStencilWrite(stencilWrite) {
            stencilBuffer.setMask(stencilWrite);
        }
        function setStencilFunc(stencilFunc, stencilRef, stencilMask) {
            stencilBuffer.setFunc(stencilFunc, stencilRef, stencilMask);
        }
        function setStencilOp(stencilFail, stencilZFail, stencilZPass) {
            stencilBuffer.setOp(stencilFail, stencilZFail, stencilZPass);
        }
        function setFlipSided(flipSided) {
            currentFlipSided !== flipSided && (flipSided ? gl.frontFace(gl.CW) : gl.frontFace(gl.CCW), 
            currentFlipSided = flipSided);
        }
        function setCullFace(cullFace) {
            cullFace !== CullFaceNone ? (enable(gl.CULL_FACE), cullFace !== currentCullFace && (cullFace === CullFaceBack ? gl.cullFace(gl.BACK) : cullFace === CullFaceFront ? gl.cullFace(gl.FRONT) : gl.cullFace(gl.FRONT_AND_BACK))) : disable(gl.CULL_FACE), 
            currentCullFace = cullFace;
        }
        function setLineWidth(width) {
            width !== currentLineWidth && (gl.lineWidth(width), currentLineWidth = width);
        }
        function setPolygonOffset(polygonOffset, factor, units) {
            polygonOffset ? (enable(gl.POLYGON_OFFSET_FILL), currentPolygonOffsetFactor === factor && currentPolygonOffsetUnits === units || (gl.polygonOffset(factor, units), 
            currentPolygonOffsetFactor = factor, currentPolygonOffsetUnits = units)) : disable(gl.POLYGON_OFFSET_FILL);
        }
        function getScissorTest() {
            return currentScissorTest;
        }
        function setScissorTest(scissorTest) {
            currentScissorTest = scissorTest, scissorTest ? enable(gl.SCISSOR_TEST) : disable(gl.SCISSOR_TEST);
        }
        function activeTexture(webglSlot) {
            void 0 === webglSlot && (webglSlot = gl.TEXTURE0 + maxTextures - 1), currentTextureSlot !== webglSlot && (gl.activeTexture(webglSlot), 
            currentTextureSlot = webglSlot);
        }
        function bindTexture(webglType, webglTexture) {
            null === currentTextureSlot && activeTexture();
            var boundTexture = currentBoundTextures[currentTextureSlot];
            void 0 === boundTexture && (boundTexture = {
                type: void 0,
                texture: void 0
            }, currentBoundTextures[currentTextureSlot] = boundTexture), boundTexture.type === webglType && boundTexture.texture === webglTexture || (gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]), 
            boundTexture.type = webglType, boundTexture.texture = webglTexture);
        }
        function compressedTexImage2D() {
            try {
                gl.compressedTexImage2D.apply(gl, arguments);
            } catch (error) {
                console.error(error);
            }
        }
        function texImage2D() {
            try {
                gl.texImage2D.apply(gl, arguments);
            } catch (error) {
                console.error(error);
            }
        }
        function clearColor(r, g, b, a) {
            colorBuffer.setClear(r, g, b, a);
        }
        function clearDepth(depth) {
            depthBuffer.setClear(depth);
        }
        function clearStencil(stencil) {
            stencilBuffer.setClear(stencil);
        }
        function scissor(scissor) {
            currentScissor.equals(scissor) === !1 && (gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w), 
            currentScissor.copy(scissor));
        }
        function viewport(viewport) {
            currentViewport.equals(viewport) === !1 && (gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w), 
            currentViewport.copy(viewport));
        }
        function reset() {
            for (var i = 0; i < enabledAttributes.length; i++) 1 === enabledAttributes[i] && (gl.disableVertexAttribArray(i), 
            enabledAttributes[i] = 0);
            capabilities = {}, compressedTextureFormats = null, currentTextureSlot = null, currentBoundTextures = {}, 
            currentBlending = null, currentFlipSided = null, currentCullFace = null, colorBuffer.reset(), 
            depthBuffer.reset(), stencilBuffer.reset();
        }
        var colorBuffer = new ColorBuffer(), depthBuffer = new DepthBuffer(), stencilBuffer = new StencilBuffer(), maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), newAttributes = new Uint8Array(maxVertexAttributes), enabledAttributes = new Uint8Array(maxVertexAttributes), attributeDivisors = new Uint8Array(maxVertexAttributes), capabilities = {}, compressedTextureFormats = null, currentBlending = null, currentBlendEquation = null, currentBlendSrc = null, currentBlendDst = null, currentBlendEquationAlpha = null, currentBlendSrcAlpha = null, currentBlendDstAlpha = null, currentPremultipledAlpha = !1, currentFlipSided = null, currentCullFace = null, currentLineWidth = null, currentPolygonOffsetFactor = null, currentPolygonOffsetUnits = null, currentScissorTest = null, maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), currentTextureSlot = null, currentBoundTextures = {}, currentScissor = new Vector4(), currentViewport = new Vector4(), emptyTextures = {};
        return emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1), 
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6), 
        {
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            init: init,
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            enableAttributeAndDivisor: enableAttributeAndDivisor,
            disableUnusedAttributes: disableUnusedAttributes,
            enable: enable,
            disable: disable,
            getCompressedTextureFormats: getCompressedTextureFormats,
            setBlending: setBlending,
            setColorWrite: setColorWrite,
            setDepthTest: setDepthTest,
            setDepthWrite: setDepthWrite,
            setDepthFunc: setDepthFunc,
            setStencilTest: setStencilTest,
            setStencilWrite: setStencilWrite,
            setStencilFunc: setStencilFunc,
            setStencilOp: setStencilOp,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            getScissorTest: getScissorTest,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            clearColor: clearColor,
            clearDepth: clearDepth,
            clearStencil: clearStencil,
            scissor: scissor,
            viewport: viewport,
            reset: reset
        };
    }
    function WebGLCapabilities(gl, extensions, parameters) {
        function getMaxAnisotropy() {
            if (void 0 !== maxAnisotropy) return maxAnisotropy;
            var extension = extensions.get("EXT_texture_filter_anisotropic");
            return maxAnisotropy = null !== extension ? gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        }
        function getMaxPrecision(precision) {
            if ("highp" === precision) {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) return "highp";
                precision = "mediump";
            }
            return "mediump" === precision && gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        var maxAnisotropy, precision = void 0 !== parameters.precision ? parameters.precision : "highp", maxPrecision = getMaxPrecision(precision);
        maxPrecision !== precision && (console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead."), 
        precision = maxPrecision);
        var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === !0 && !!extensions.get("EXT_frag_depth"), maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE), maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS), maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), vertexTextures = maxVertexTextures > 0, floatFragmentTextures = !!extensions.get("OES_texture_float"), floatVertexTextures = vertexTextures && floatFragmentTextures;
        return {
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: floatVertexTextures
        };
    }
    function WebGLExtensions(gl) {
        var extensions = {};
        return {
            get: function(name) {
                if (void 0 !== extensions[name]) return extensions[name];
                var extension;
                switch (name) {
                  case "WEBGL_depth_texture":
                    extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;

                  case "EXT_texture_filter_anisotropic":
                    extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;

                  case "WEBGL_compressed_texture_s3tc":
                    extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;

                  case "WEBGL_compressed_texture_pvrtc":
                    extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;

                  case "WEBGL_compressed_texture_etc1":
                    extension = gl.getExtension("WEBGL_compressed_texture_etc1");
                    break;

                  default:
                    extension = gl.getExtension(name);
                }
                return null === extension && console.warn("THREE.WebGLRenderer: " + name + " extension not supported."), 
                extensions[name] = extension, extension;
            }
        };
    }
    function WebGLClipping() {
        function resetGlobalState() {
            uniform.value !== globalState && (uniform.value = globalState, uniform.needsUpdate = numGlobalPlanes > 0), 
            scope.numPlanes = numGlobalPlanes, scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = null !== planes ? planes.length : 0, dstArray = null;
            if (0 !== nPlanes) {
                if (dstArray = uniform.value, skipTransform !== !0 || null === dstArray) {
                    var flatSize = dstOffset + 4 * nPlanes, viewMatrix = camera.matrixWorldInverse;
                    viewNormalMatrix.getNormalMatrix(viewMatrix), (null === dstArray || dstArray.length < flatSize) && (dstArray = new Float32Array(flatSize));
                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix), 
                    plane.normal.toArray(dstArray, i4), dstArray[i4 + 3] = plane.constant;
                }
                uniform.value = dstArray, uniform.needsUpdate = !0;
            }
            return scope.numPlanes = nPlanes, dstArray;
        }
        var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = !1, renderingShadows = !1, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = uniform, this.numPlanes = 0, this.numIntersection = 0, this.init = function(planes, enableLocalClipping, camera) {
            var enabled = 0 !== planes.length || enableLocalClipping || 0 !== numGlobalPlanes || localClippingEnabled;
            return localClippingEnabled = enableLocalClipping, globalState = projectPlanes(planes, camera, 0), 
            numGlobalPlanes = planes.length, enabled;
        }, this.beginShadows = function() {
            renderingShadows = !0, projectPlanes(null);
        }, this.endShadows = function() {
            renderingShadows = !1, resetGlobalState();
        }, this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
            if (!localClippingEnabled || null === planes || 0 === planes.length || renderingShadows && !clipShadows) renderingShadows ? projectPlanes(null) : resetGlobalState(); else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = 4 * nGlobal, dstArray = cache.clippingState || null;
                uniform.value = dstArray, dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) dstArray[i] = globalState[i];
                cache.clippingState = dstArray, this.numIntersection = clipIntersection ? this.numPlanes : 0, 
                this.numPlanes += nGlobal;
            }
        };
    }
    function WebGLRenderer(parameters) {
        function getTargetPixelRatio() {
            return null === _currentRenderTarget ? _pixelRatio : 1;
        }
        function glClearColor(r, g, b, a) {
            _premultipliedAlpha === !0 && (r *= a, g *= a, b *= a), state.clearColor(r, g, b, a);
        }
        function setDefaultGLState() {
            state.init(), state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio)), 
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio)), glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
        }
        function resetGLState() {
            _currentProgram = null, _currentCamera = null, _currentGeometryProgram = "", _currentMaterialId = -1, 
            state.reset();
        }
        function onContextLost(event) {
            event.preventDefault(), resetGLState(), setDefaultGLState(), properties.clear();
        }
        function onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener("dispose", onMaterialDispose), deallocateMaterial(material);
        }
        function deallocateMaterial(material) {
            releaseMaterialProgramReference(material), properties["delete"](material);
        }
        function releaseMaterialProgramReference(material) {
            var programInfo = properties.get(material).program;
            material.program = void 0, void 0 !== programInfo && programCache.releaseProgram(programInfo);
        }
        function setupVertexAttributes(material, program, geometry, startIndex) {
            var extension;
            if (geometry && geometry.isInstancedBufferGeometry && (extension = extensions.get("ANGLE_instanced_arrays"), 
            null === extension)) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            void 0 === startIndex && (startIndex = 0), state.initAttributes();
            var geometryAttributes = geometry.attributes, programAttributes = program.getAttributes(), materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    var geometryAttribute = geometryAttributes[name];
                    if (void 0 !== geometryAttribute) {
                        var type = _gl.FLOAT, array = geometryAttribute.array, normalized = geometryAttribute.normalized;
                        array instanceof Float32Array ? type = _gl.FLOAT : array instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : array instanceof Uint16Array ? type = _gl.UNSIGNED_SHORT : array instanceof Int16Array ? type = _gl.SHORT : array instanceof Uint32Array ? type = _gl.UNSIGNED_INT : array instanceof Int32Array ? type = _gl.INT : array instanceof Int8Array ? type = _gl.BYTE : array instanceof Uint8Array && (type = _gl.UNSIGNED_BYTE);
                        var size = geometryAttribute.itemSize, buffer = objects.getAttributeBuffer(geometryAttribute);
                        if (geometryAttribute.isInterleavedBufferAttribute) {
                            var data = geometryAttribute.data, stride = data.stride, offset = geometryAttribute.offset;
                            data && data.isInstancedInterleavedBuffer ? (state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute, extension), 
                            void 0 === geometry.maxInstancedCount && (geometry.maxInstancedCount = data.meshPerAttribute * data.count)) : state.enableAttribute(programAttribute), 
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer), _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, (startIndex * stride + offset) * data.array.BYTES_PER_ELEMENT);
                        } else geometryAttribute.isInstancedBufferAttribute ? (state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute, extension), 
                        void 0 === geometry.maxInstancedCount && (geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count)) : state.enableAttribute(programAttribute), 
                        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer), _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT);
                    } else if (void 0 !== materialDefaultAttributeValues) {
                        var value = materialDefaultAttributeValues[name];
                        if (void 0 !== value) switch (value.length) {
                          case 2:
                            _gl.vertexAttrib2fv(programAttribute, value);
                            break;

                          case 3:
                            _gl.vertexAttrib3fv(programAttribute, value);
                            break;

                          case 4:
                            _gl.vertexAttrib4fv(programAttribute, value);
                            break;

                          default:
                            _gl.vertexAttrib1fv(programAttribute, value);
                        }
                    }
                }
            }
            state.disableUnusedAttributes();
        }
        function absNumericalSort(a, b) {
            return Math.abs(b[0]) - Math.abs(a[0]);
        }
        function painterSortStable(a, b) {
            return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.program && b.material.program && a.material.program !== b.material.program ? a.material.program.id - b.material.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;
        }
        function reversePainterSortStable(a, b) {
            return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;
        }
        function pushRenderItem(object, geometry, material, z, group) {
            var array, index;
            material.transparent ? (array = transparentObjects, index = ++transparentObjectsLastIndex) : (array = opaqueObjects, 
            index = ++opaqueObjectsLastIndex);
            var renderItem = array[index];
            void 0 !== renderItem ? (renderItem.id = object.id, renderItem.object = object, 
            renderItem.geometry = geometry, renderItem.material = material, renderItem.z = _vector3.z, 
            renderItem.group = group) : (renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                z: _vector3.z,
                group: group
            }, array.push(renderItem));
        }
        function isObjectViewable(object) {
            var geometry = object.geometry;
            return null === geometry.boundingSphere && geometry.computeBoundingSphere(), _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld), 
            isSphereViewable(_sphere);
        }
        function isSpriteViewable(sprite) {
            return _sphere.center.set(0, 0, 0), _sphere.radius = .7071067811865476, _sphere.applyMatrix4(sprite.matrixWorld), 
            isSphereViewable(_sphere);
        }
        function isSphereViewable(sphere) {
            if (!_frustum.intersectsSphere(sphere)) return !1;
            var numPlanes = _clipping.numPlanes;
            if (0 === numPlanes) return !0;
            var planes = _this.clippingPlanes, center = sphere.center, negRad = -sphere.radius, i = 0;
            do if (planes[i].distanceToPoint(center) < negRad) return !1; while (++i !== numPlanes);
            return !0;
        }
        function projectObject(object, camera) {
            if (object.visible !== !1) {
                var visible = 0 !== (object.layers.mask & camera.layers.mask);
                if (visible) if (object.isLight) lights.push(object); else if (object.isSprite) object.frustumCulled !== !1 && isSpriteViewable(object) !== !0 || sprites.push(object); else if (object.isLensFlare) lensFlares.push(object); else if (object.isImmediateRenderObject) _this.sortObjects === !0 && (_vector3.setFromMatrixPosition(object.matrixWorld), 
                _vector3.applyProjection(_projScreenMatrix)), pushRenderItem(object, null, object.material, _vector3.z, null); else if ((object.isMesh || object.isLine || object.isPoints) && (object.isSkinnedMesh && object.skeleton.update(), 
                object.frustumCulled === !1 || isObjectViewable(object) === !0)) {
                    var material = object.material;
                    if (material.visible === !0) {
                        _this.sortObjects === !0 && (_vector3.setFromMatrixPosition(object.matrixWorld), 
                        _vector3.applyProjection(_projScreenMatrix));
                        var geometry = objects.update(object);
                        if (material.isMultiMaterial) for (var groups = geometry.groups, materials = material.materials, i = 0, l = groups.length; l > i; i++) {
                            var group = groups[i], groupMaterial = materials[group.materialIndex];
                            groupMaterial.visible === !0 && pushRenderItem(object, geometry, groupMaterial, _vector3.z, group);
                        } else pushRenderItem(object, geometry, material, _vector3.z, null);
                    }
                }
                for (var children = object.children, i = 0, l = children.length; l > i; i++) projectObject(children[i], camera);
            }
        }
        function renderObjects(renderList, scene, camera, overrideMaterial) {
            for (var i = 0, l = renderList.length; l > i; i++) {
                var renderItem = renderList[i], object = renderItem.object, geometry = renderItem.geometry, material = void 0 === overrideMaterial ? renderItem.material : overrideMaterial, group = renderItem.group;
                if (object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld), 
                object.normalMatrix.getNormalMatrix(object.modelViewMatrix), object.onBeforeRender(_this, scene, camera, geometry, material, group), 
                object.isImmediateRenderObject) {
                    setMaterial(material);
                    var program = setProgram(camera, scene.fog, material, object);
                    _currentGeometryProgram = "", object.render(function(object) {
                        _this.renderBufferImmediate(object, program, material);
                    });
                } else _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
                object.onAfterRender(_this, scene, camera, geometry, material, group);
            }
        }
        function initMaterial(material, fog, object) {
            var materialProperties = properties.get(material), parameters = programCache.getParameters(material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object), code = programCache.getProgramCode(material, parameters), program = materialProperties.program, programChange = !0;
            if (void 0 === program) material.addEventListener("dispose", onMaterialDispose); else if (program.code !== code) releaseMaterialProgramReference(material); else {
                if (void 0 !== parameters.shaderID) return;
                programChange = !1;
            }
            if (programChange) {
                if (parameters.shaderID) {
                    var shader = ShaderLib[parameters.shaderID];
                    materialProperties.__webglShader = {
                        name: material.type,
                        uniforms: UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                } else materialProperties.__webglShader = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };
                material.__webglShader = materialProperties.__webglShader, program = programCache.acquireProgram(material, parameters, code), 
                materialProperties.program = program, material.program = program;
            }
            var attributes = program.getAttributes();
            if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < _this.maxMorphTargets; i++) attributes["morphTarget" + i] >= 0 && material.numSupportedMorphTargets++;
            }
            if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < _this.maxMorphNormals; i++) attributes["morphNormal" + i] >= 0 && material.numSupportedMorphNormals++;
            }
            var uniforms = materialProperties.__webglShader.uniforms;
            (material.isShaderMaterial || material.isRawShaderMaterial) && material.clipping !== !0 || (materialProperties.numClippingPlanes = _clipping.numPlanes, 
            materialProperties.numIntersection = _clipping.numIntersection, uniforms.clippingPlanes = _clipping.uniform), 
            materialProperties.fog = fog, materialProperties.lightsHash = _lights.hash, material.lights && (uniforms.ambientLightColor.value = _lights.ambient, 
            uniforms.directionalLights.value = _lights.directional, uniforms.spotLights.value = _lights.spot, 
            uniforms.pointLights.value = _lights.point, uniforms.hemisphereLights.value = _lights.hemi, 
            uniforms.directionalShadowMap.value = _lights.directionalShadowMap, uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix, 
            uniforms.spotShadowMap.value = _lights.spotShadowMap, uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix, 
            uniforms.pointShadowMap.value = _lights.pointShadowMap, uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix);
            var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
            materialProperties.uniformsList = uniformsList;
        }
        function setMaterial(material) {
            material.side === DoubleSide ? state.disable(_gl.CULL_FACE) : state.enable(_gl.CULL_FACE), 
            state.setFlipSided(material.side === BackSide), material.transparent === !0 ? state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : state.setBlending(NoBlending), 
            state.setDepthFunc(material.depthFunc), state.setDepthTest(material.depthTest), 
            state.setDepthWrite(material.depthWrite), state.setColorWrite(material.colorWrite), 
            state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        function setProgram(camera, fog, material, object) {
            _usedTextureUnits = 0;
            var materialProperties = properties.get(material);
            if (_clippingEnabled && (_localClippingEnabled || camera !== _currentCamera)) {
                var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
            }
            material.needsUpdate === !1 && (void 0 === materialProperties.program ? material.needsUpdate = !0 : material.fog && materialProperties.fog !== fog ? material.needsUpdate = !0 : material.lights && materialProperties.lightsHash !== _lights.hash ? material.needsUpdate = !0 : void 0 === materialProperties.numClippingPlanes || materialProperties.numClippingPlanes === _clipping.numPlanes && materialProperties.numIntersection === _clipping.numIntersection || (material.needsUpdate = !0)), 
            material.needsUpdate && (initMaterial(material, fog, object), material.needsUpdate = !1);
            var refreshProgram = !1, refreshMaterial = !1, refreshLights = !1, program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.__webglShader.uniforms;
            if (program.id !== _currentProgram && (_gl.useProgram(program.program), _currentProgram = program.id, 
            refreshProgram = !0, refreshMaterial = !0, refreshLights = !0), material.id !== _currentMaterialId && (_currentMaterialId = material.id, 
            refreshMaterial = !0), refreshProgram || camera !== _currentCamera) {
                if (p_uniforms.set(_gl, camera, "projectionMatrix"), capabilities.logarithmicDepthBuffer && p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2)), 
                camera !== _currentCamera && (_currentCamera = camera, refreshMaterial = !0, refreshLights = !0), 
                material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    void 0 !== uCamPos && uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                }
                (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) && p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse), 
                p_uniforms.set(_gl, _this, "toneMappingExposure"), p_uniforms.set(_gl, _this, "toneMappingWhitePoint");
            }
            if (material.skinning) {
                p_uniforms.setOptional(_gl, object, "bindMatrix"), p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
                var skeleton = object.skeleton;
                skeleton && (capabilities.floatVertexTextures && skeleton.useVertexTexture ? (p_uniforms.set(_gl, skeleton, "boneTexture"), 
                p_uniforms.set(_gl, skeleton, "boneTextureWidth"), p_uniforms.set(_gl, skeleton, "boneTextureHeight")) : p_uniforms.setOptional(_gl, skeleton, "boneMatrices"));
            }
            return refreshMaterial && (material.lights && markUniformsLightsNeedsUpdate(m_uniforms, refreshLights), 
            fog && material.fog && refreshUniformsFog(m_uniforms, fog), (material.isMeshBasicMaterial || material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isMeshDepthMaterial) && refreshUniformsCommon(m_uniforms, material), 
            material.isLineBasicMaterial ? refreshUniformsLine(m_uniforms, material) : material.isLineDashedMaterial ? (refreshUniformsLine(m_uniforms, material), 
            refreshUniformsDash(m_uniforms, material)) : material.isPointsMaterial ? refreshUniformsPoints(m_uniforms, material) : material.isMeshLambertMaterial ? refreshUniformsLambert(m_uniforms, material) : material.isMeshPhongMaterial ? refreshUniformsPhong(m_uniforms, material) : material.isMeshPhysicalMaterial ? refreshUniformsPhysical(m_uniforms, material) : material.isMeshStandardMaterial ? refreshUniformsStandard(m_uniforms, material) : material.isMeshDepthMaterial ? material.displacementMap && (m_uniforms.displacementMap.value = material.displacementMap, 
            m_uniforms.displacementScale.value = material.displacementScale, m_uniforms.displacementBias.value = material.displacementBias) : material.isMeshNormalMaterial && (m_uniforms.opacity.value = material.opacity), 
            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this)), 
            p_uniforms.set(_gl, object, "modelViewMatrix"), p_uniforms.set(_gl, object, "normalMatrix"), 
            p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld), program;
        }
        function refreshUniformsCommon(uniforms, material) {
            uniforms.opacity.value = material.opacity, uniforms.diffuse.value = material.color, 
            material.emissive && uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity), 
            uniforms.map.value = material.map, uniforms.specularMap.value = material.specularMap, 
            uniforms.alphaMap.value = material.alphaMap, material.aoMap && (uniforms.aoMap.value = material.aoMap, 
            uniforms.aoMapIntensity.value = material.aoMapIntensity);
            var uvScaleMap;
            if (material.map ? uvScaleMap = material.map : material.specularMap ? uvScaleMap = material.specularMap : material.displacementMap ? uvScaleMap = material.displacementMap : material.normalMap ? uvScaleMap = material.normalMap : material.bumpMap ? uvScaleMap = material.bumpMap : material.roughnessMap ? uvScaleMap = material.roughnessMap : material.metalnessMap ? uvScaleMap = material.metalnessMap : material.alphaMap ? uvScaleMap = material.alphaMap : material.emissiveMap && (uvScaleMap = material.emissiveMap), 
            void 0 !== uvScaleMap) {
                uvScaleMap.isWebGLRenderTarget && (uvScaleMap = uvScaleMap.texture);
                var offset = uvScaleMap.offset, repeat = uvScaleMap.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
            uniforms.envMap.value = material.envMap, uniforms.flipEnvMap.value = material.envMap && material.envMap.isCubeTexture ? -1 : 1, 
            uniforms.reflectivity.value = material.reflectivity, uniforms.refractionRatio.value = material.refractionRatio;
        }
        function refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value = material.color, uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize, uniforms.totalSize.value = material.dashSize + material.gapSize, 
            uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material) {
            if (uniforms.diffuse.value = material.color, uniforms.opacity.value = material.opacity, 
            uniforms.size.value = material.size * _pixelRatio, uniforms.scale.value = .5 * _height, 
            uniforms.map.value = material.map, null !== material.map) {
                var offset = material.map.offset, repeat = material.map.repeat;
                uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
            }
        }
        function refreshUniformsFog(uniforms, fog) {
            uniforms.fogColor.value = fog.color, fog.isFog ? (uniforms.fogNear.value = fog.near, 
            uniforms.fogFar.value = fog.far) : fog.isFogExp2 && (uniforms.fogDensity.value = fog.density);
        }
        function refreshUniformsLambert(uniforms, material) {
            material.lightMap && (uniforms.lightMap.value = material.lightMap, uniforms.lightMapIntensity.value = material.lightMapIntensity), 
            material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap);
        }
        function refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value = material.specular, uniforms.shininess.value = Math.max(material.shininess, 1e-4), 
            material.lightMap && (uniforms.lightMap.value = material.lightMap, uniforms.lightMapIntensity.value = material.lightMapIntensity), 
            material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap), material.bumpMap && (uniforms.bumpMap.value = material.bumpMap, 
            uniforms.bumpScale.value = material.bumpScale), material.normalMap && (uniforms.normalMap.value = material.normalMap, 
            uniforms.normalScale.value.copy(material.normalScale)), material.displacementMap && (uniforms.displacementMap.value = material.displacementMap, 
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias);
        }
        function refreshUniformsStandard(uniforms, material) {
            uniforms.roughness.value = material.roughness, uniforms.metalness.value = material.metalness, 
            material.roughnessMap && (uniforms.roughnessMap.value = material.roughnessMap), 
            material.metalnessMap && (uniforms.metalnessMap.value = material.metalnessMap), 
            material.lightMap && (uniforms.lightMap.value = material.lightMap, uniforms.lightMapIntensity.value = material.lightMapIntensity), 
            material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap), material.bumpMap && (uniforms.bumpMap.value = material.bumpMap, 
            uniforms.bumpScale.value = material.bumpScale), material.normalMap && (uniforms.normalMap.value = material.normalMap, 
            uniforms.normalScale.value.copy(material.normalScale)), material.displacementMap && (uniforms.displacementMap.value = material.displacementMap, 
            uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias), 
            material.envMap && (uniforms.envMapIntensity.value = material.envMapIntensity);
        }
        function refreshUniformsPhysical(uniforms, material) {
            uniforms.clearCoat.value = material.clearCoat, uniforms.clearCoatRoughness.value = material.clearCoatRoughness, 
            refreshUniformsStandard(uniforms, material);
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value, uniforms.directionalLights.needsUpdate = value, 
            uniforms.pointLights.needsUpdate = value, uniforms.spotLights.needsUpdate = value, 
            uniforms.hemisphereLights.needsUpdate = value;
        }
        function setupShadows(lights) {
            for (var lightShadowsLength = 0, i = 0, l = lights.length; l > i; i++) {
                var light = lights[i];
                light.castShadow && (_lights.shadows[lightShadowsLength++] = light);
            }
            _lights.shadows.length = lightShadowsLength;
        }
        function setupLights(lights, camera) {
            var l, ll, light, color, intensity, distance, shadowMap, r = 0, g = 0, b = 0, viewMatrix = camera.matrixWorldInverse, directionalLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0;
            for (l = 0, ll = lights.length; ll > l; l++) if (light = lights[l], color = light.color, 
            intensity = light.intensity, distance = light.distance, shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null, 
            light.isAmbientLight) r += color.r * intensity, g += color.g * intensity, b += color.b * intensity; else if (light.isDirectionalLight) {
                var uniforms = lightCache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity), uniforms.direction.setFromMatrixPosition(light.matrixWorld), 
                _vector3.setFromMatrixPosition(light.target.matrixWorld), uniforms.direction.sub(_vector3), 
                uniforms.direction.transformDirection(viewMatrix), uniforms.shadow = light.castShadow, 
                light.castShadow && (uniforms.shadowBias = light.shadow.bias, uniforms.shadowRadius = light.shadow.radius, 
                uniforms.shadowMapSize = light.shadow.mapSize), _lights.directionalShadowMap[directionalLength] = shadowMap, 
                _lights.directionalShadowMatrix[directionalLength] = light.shadow.matrix, _lights.directional[directionalLength++] = uniforms;
            } else if (light.isSpotLight) {
                var uniforms = lightCache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), 
                uniforms.color.copy(color).multiplyScalar(intensity), uniforms.distance = distance, 
                uniforms.direction.setFromMatrixPosition(light.matrixWorld), _vector3.setFromMatrixPosition(light.target.matrixWorld), 
                uniforms.direction.sub(_vector3), uniforms.direction.transformDirection(viewMatrix), 
                uniforms.coneCos = Math.cos(light.angle), uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra)), 
                uniforms.decay = 0 === light.distance ? 0 : light.decay, uniforms.shadow = light.castShadow, 
                light.castShadow && (uniforms.shadowBias = light.shadow.bias, uniforms.shadowRadius = light.shadow.radius, 
                uniforms.shadowMapSize = light.shadow.mapSize), _lights.spotShadowMap[spotLength] = shadowMap, 
                _lights.spotShadowMatrix[spotLength] = light.shadow.matrix, _lights.spot[spotLength++] = uniforms;
            } else if (light.isPointLight) {
                var uniforms = lightCache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), 
                uniforms.color.copy(light.color).multiplyScalar(light.intensity), uniforms.distance = light.distance, 
                uniforms.decay = 0 === light.distance ? 0 : light.decay, uniforms.shadow = light.castShadow, 
                light.castShadow && (uniforms.shadowBias = light.shadow.bias, uniforms.shadowRadius = light.shadow.radius, 
                uniforms.shadowMapSize = light.shadow.mapSize), _lights.pointShadowMap[pointLength] = shadowMap, 
                void 0 === _lights.pointShadowMatrix[pointLength] && (_lights.pointShadowMatrix[pointLength] = new Matrix4()), 
                _vector3.setFromMatrixPosition(light.matrixWorld).negate(), _lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3), 
                _lights.point[pointLength++] = uniforms;
            } else if (light.isHemisphereLight) {
                var uniforms = lightCache.get(light);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld), uniforms.direction.transformDirection(viewMatrix), 
                uniforms.direction.normalize(), uniforms.skyColor.copy(light.color).multiplyScalar(intensity), 
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity), _lights.hemi[hemiLength++] = uniforms;
            }
            _lights.ambient[0] = r, _lights.ambient[1] = g, _lights.ambient[2] = b, _lights.directional.length = directionalLength, 
            _lights.spot.length = spotLength, _lights.point.length = pointLength, _lights.hemi.length = hemiLength, 
            _lights.hash = directionalLength + "," + pointLength + "," + spotLength + "," + hemiLength + "," + _lights.shadows.length;
        }
        function allocTextureUnit() {
            var textureUnit = _usedTextureUnits;
            return textureUnit >= capabilities.maxTextures && console.warn("WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures), 
            _usedTextureUnits += 1, textureUnit;
        }
        function paramThreeToGL(p) {
            var extension;
            if (p === RepeatWrapping) return _gl.REPEAT;
            if (p === ClampToEdgeWrapping) return _gl.CLAMP_TO_EDGE;
            if (p === MirroredRepeatWrapping) return _gl.MIRRORED_REPEAT;
            if (p === NearestFilter) return _gl.NEAREST;
            if (p === NearestMipMapNearestFilter) return _gl.NEAREST_MIPMAP_NEAREST;
            if (p === NearestMipMapLinearFilter) return _gl.NEAREST_MIPMAP_LINEAR;
            if (p === LinearFilter) return _gl.LINEAR;
            if (p === LinearMipMapNearestFilter) return _gl.LINEAR_MIPMAP_NEAREST;
            if (p === LinearMipMapLinearFilter) return _gl.LINEAR_MIPMAP_LINEAR;
            if (p === UnsignedByteType) return _gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type) return _gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type) return _gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedShort565Type) return _gl.UNSIGNED_SHORT_5_6_5;
            if (p === ByteType) return _gl.BYTE;
            if (p === ShortType) return _gl.SHORT;
            if (p === UnsignedShortType) return _gl.UNSIGNED_SHORT;
            if (p === IntType) return _gl.INT;
            if (p === UnsignedIntType) return _gl.UNSIGNED_INT;
            if (p === FloatType) return _gl.FLOAT;
            if (p === HalfFloatType && (extension = extensions.get("OES_texture_half_float"), 
            null !== extension)) return extension.HALF_FLOAT_OES;
            if (p === AlphaFormat) return _gl.ALPHA;
            if (p === RGBFormat) return _gl.RGB;
            if (p === RGBAFormat) return _gl.RGBA;
            if (p === LuminanceFormat) return _gl.LUMINANCE;
            if (p === LuminanceAlphaFormat) return _gl.LUMINANCE_ALPHA;
            if (p === DepthFormat) return _gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat) return _gl.DEPTH_STENCIL;
            if (p === AddEquation) return _gl.FUNC_ADD;
            if (p === SubtractEquation) return _gl.FUNC_SUBTRACT;
            if (p === ReverseSubtractEquation) return _gl.FUNC_REVERSE_SUBTRACT;
            if (p === ZeroFactor) return _gl.ZERO;
            if (p === OneFactor) return _gl.ONE;
            if (p === SrcColorFactor) return _gl.SRC_COLOR;
            if (p === OneMinusSrcColorFactor) return _gl.ONE_MINUS_SRC_COLOR;
            if (p === SrcAlphaFactor) return _gl.SRC_ALPHA;
            if (p === OneMinusSrcAlphaFactor) return _gl.ONE_MINUS_SRC_ALPHA;
            if (p === DstAlphaFactor) return _gl.DST_ALPHA;
            if (p === OneMinusDstAlphaFactor) return _gl.ONE_MINUS_DST_ALPHA;
            if (p === DstColorFactor) return _gl.DST_COLOR;
            if (p === OneMinusDstColorFactor) return _gl.ONE_MINUS_DST_COLOR;
            if (p === SrcAlphaSaturateFactor) return _gl.SRC_ALPHA_SATURATE;
            if ((p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) && (extension = extensions.get("WEBGL_compressed_texture_s3tc"), 
            null !== extension)) {
                if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
            if ((p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) && (extension = extensions.get("WEBGL_compressed_texture_pvrtc"), 
            null !== extension)) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (p === RGB_ETC1_Format && (extension = extensions.get("WEBGL_compressed_texture_etc1"), 
            null !== extension)) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            if ((p === MinEquation || p === MaxEquation) && (extension = extensions.get("EXT_blend_minmax"), 
            null !== extension)) {
                if (p === MinEquation) return extension.MIN_EXT;
                if (p === MaxEquation) return extension.MAX_EXT;
            }
            return p === UnsignedInt248Type && (extension = extensions.get("WEBGL_depth_texture"), 
            null !== extension) ? extension.UNSIGNED_INT_24_8_WEBGL : 0;
        }
        console.log("THREE.WebGLRenderer", REVISION), parameters = parameters || {};
        var _canvas = void 0 !== parameters.canvas ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = void 0 !== parameters.context ? parameters.context : null, _alpha = void 0 !== parameters.alpha ? parameters.alpha : !1, _depth = void 0 !== parameters.depth ? parameters.depth : !0, _stencil = void 0 !== parameters.stencil ? parameters.stencil : !0, _antialias = void 0 !== parameters.antialias ? parameters.antialias : !1, _premultipliedAlpha = void 0 !== parameters.premultipliedAlpha ? parameters.premultipliedAlpha : !0, _preserveDrawingBuffer = void 0 !== parameters.preserveDrawingBuffer ? parameters.preserveDrawingBuffer : !1, lights = [], opaqueObjects = [], opaqueObjectsLastIndex = -1, transparentObjects = [], transparentObjectsLastIndex = -1, morphInfluences = new Float32Array(8), sprites = [], lensFlares = [];
        this.domElement = _canvas, this.context = null, this.autoClear = !0, this.autoClearColor = !0, 
        this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], 
        this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, 
        this.physicallyCorrectLights = !1, this.toneMapping = LinearToneMapping, this.toneMappingExposure = 1, 
        this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var _this = this, _currentProgram = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = "", _currentCamera = null, _currentScissor = new Vector4(), _currentScissorTest = null, _currentViewport = new Vector4(), _usedTextureUnits = 0, _clearColor = new Color(0), _clearAlpha = 0, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _scissor = new Vector4(0, 0, _width, _height), _scissorTest = !1, _viewport = new Vector4(0, 0, _width, _height), _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = !1, _localClippingEnabled = !1, _sphere = new Sphere(), _projScreenMatrix = new Matrix4(), _vector3 = new Vector3(), _lights = {
            hash: "",
            ambient: [ 0, 0, 0 ],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            shadows: []
        }, _infoRender = {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        };
        this.info = {
            render: _infoRender,
            memory: {
                geometries: 0,
                textures: 0
            },
            programs: null
        };
        var _gl;
        try {
            var attributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer
            };
            if (_gl = _context || _canvas.getContext("webgl", attributes) || _canvas.getContext("experimental-webgl", attributes), 
            null === _gl) throw null !== _canvas.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
            void 0 === _gl.getShaderPrecisionFormat && (_gl.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                };
            }), _canvas.addEventListener("webglcontextlost", onContextLost, !1);
        } catch (error) {
            console.error("THREE.WebGLRenderer: " + error);
        }
        var extensions = new WebGLExtensions(_gl);
        extensions.get("WEBGL_depth_texture"), extensions.get("OES_texture_float"), extensions.get("OES_texture_float_linear"), 
        extensions.get("OES_texture_half_float"), extensions.get("OES_texture_half_float_linear"), 
        extensions.get("OES_standard_derivatives"), extensions.get("ANGLE_instanced_arrays"), 
        extensions.get("OES_element_index_uint") && (BufferGeometry.MaxIndex = 4294967296);
        var capabilities = new WebGLCapabilities(_gl, extensions, parameters), state = new WebGLState(_gl, extensions, paramThreeToGL), properties = new WebGLProperties(), textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, paramThreeToGL, this.info), objects = new WebGLObjects(_gl, properties, this.info), programCache = new WebGLPrograms(this, capabilities), lightCache = new WebGLLights();
        this.info.programs = programCache.programs;
        var bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender), indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender), backgroundCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1), backgroundCamera2 = new PerspectiveCamera(), backgroundPlaneMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), backgroundBoxShader = ShaderLib.cube, backgroundBoxMesh = new Mesh(new BoxBufferGeometry(5, 5, 5), new ShaderMaterial({
            uniforms: backgroundBoxShader.uniforms,
            vertexShader: backgroundBoxShader.vertexShader,
            fragmentShader: backgroundBoxShader.fragmentShader,
            side: BackSide,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        }));
        setDefaultGLState(), this.context = _gl, this.capabilities = capabilities, this.extensions = extensions, 
        this.properties = properties, this.state = state;
        var shadowMap = new WebGLShadowMap(this, _lights, objects, capabilities);
        this.shadowMap = shadowMap;
        var spritePlugin = new SpritePlugin(this, sprites), lensFlarePlugin = new LensFlarePlugin(this, lensFlares);
        this.getContext = function() {
            return _gl;
        }, this.getContextAttributes = function() {
            return _gl.getContextAttributes();
        }, this.forceContextLoss = function() {
            extensions.get("WEBGL_lose_context").loseContext();
        }, this.getMaxAnisotropy = function() {
            return capabilities.getMaxAnisotropy();
        }, this.getPrecision = function() {
            return capabilities.precision;
        }, this.getPixelRatio = function() {
            return _pixelRatio;
        }, this.setPixelRatio = function(value) {
            void 0 !== value && (_pixelRatio = value, this.setSize(_viewport.z, _viewport.w, !1));
        }, this.getSize = function() {
            return {
                width: _width,
                height: _height
            };
        }, this.setSize = function(width, height, updateStyle) {
            _width = width, _height = height, _canvas.width = width * _pixelRatio, _canvas.height = height * _pixelRatio, 
            updateStyle !== !1 && (_canvas.style.width = width + "px", _canvas.style.height = height + "px"), 
            this.setViewport(0, 0, width, height);
        }, this.setViewport = function(x, y, width, height) {
            state.viewport(_viewport.set(x, y, width, height));
        }, this.setScissor = function(x, y, width, height) {
            state.scissor(_scissor.set(x, y, width, height));
        }, this.setScissorTest = function(boolean) {
            state.setScissorTest(_scissorTest = boolean);
        }, this.getClearColor = function() {
            return _clearColor;
        }, this.setClearColor = function(color, alpha) {
            _clearColor.set(color), _clearAlpha = void 0 !== alpha ? alpha : 1, glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
        }, this.getClearAlpha = function() {
            return _clearAlpha;
        }, this.setClearAlpha = function(alpha) {
            _clearAlpha = alpha, glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
        }, this.clear = function(color, depth, stencil) {
            var bits = 0;
            (void 0 === color || color) && (bits |= _gl.COLOR_BUFFER_BIT), (void 0 === depth || depth) && (bits |= _gl.DEPTH_BUFFER_BIT), 
            (void 0 === stencil || stencil) && (bits |= _gl.STENCIL_BUFFER_BIT), _gl.clear(bits);
        }, this.clearColor = function() {
            this.clear(!0, !1, !1);
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1);
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0);
        }, this.clearTarget = function(renderTarget, color, depth, stencil) {
            this.setRenderTarget(renderTarget), this.clear(color, depth, stencil);
        }, this.resetGLState = resetGLState, this.dispose = function() {
            transparentObjects = [], transparentObjectsLastIndex = -1, opaqueObjects = [], opaqueObjectsLastIndex = -1, 
            _canvas.removeEventListener("webglcontextlost", onContextLost, !1);
        }, this.renderBufferImmediate = function(object, program, material) {
            state.initAttributes();
            var buffers = properties.get(object);
            object.hasPositions && !buffers.position && (buffers.position = _gl.createBuffer()), 
            object.hasNormals && !buffers.normal && (buffers.normal = _gl.createBuffer()), object.hasUvs && !buffers.uv && (buffers.uv = _gl.createBuffer()), 
            object.hasColors && !buffers.color && (buffers.color = _gl.createBuffer());
            var attributes = program.getAttributes();
            if (object.hasPositions && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position), 
            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW), state.enableAttribute(attributes.position), 
            _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, !1, 0, 0)), object.hasNormals) {
                if (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal), !material.isMeshPhongMaterial && !material.isMeshStandardMaterial && material.shading === FlatShading) for (var i = 0, l = 3 * object.count; l > i; i += 9) {
                    var array = object.normalArray, nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3, ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3, nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                    array[i + 0] = nx, array[i + 1] = ny, array[i + 2] = nz, array[i + 3] = nx, array[i + 4] = ny, 
                    array[i + 5] = nz, array[i + 6] = nx, array[i + 7] = ny, array[i + 8] = nz;
                }
                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW), state.enableAttribute(attributes.normal), 
                _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, !1, 0, 0);
            }
            object.hasUvs && material.map && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv), 
            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW), state.enableAttribute(attributes.uv), 
            _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, !1, 0, 0)), object.hasColors && material.vertexColors !== NoColors && (_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color), 
            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW), state.enableAttribute(attributes.color), 
            _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, !1, 0, 0)), state.disableUnusedAttributes(), 
            _gl.drawArrays(_gl.TRIANGLES, 0, object.count), object.count = 0;
        }, this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
            setMaterial(material);
            var program = setProgram(camera, fog, material, object), updateBuffers = !1, geometryProgram = geometry.id + "_" + program.id + "_" + material.wireframe;
            geometryProgram !== _currentGeometryProgram && (_currentGeometryProgram = geometryProgram, 
            updateBuffers = !0);
            var morphTargetInfluences = object.morphTargetInfluences;
            if (void 0 !== morphTargetInfluences) {
                for (var activeInfluences = [], i = 0, l = morphTargetInfluences.length; l > i; i++) {
                    var influence = morphTargetInfluences[i];
                    activeInfluences.push([ influence, i ]);
                }
                activeInfluences.sort(absNumericalSort), activeInfluences.length > 8 && (activeInfluences.length = 8);
                for (var morphAttributes = geometry.morphAttributes, i = 0, l = activeInfluences.length; l > i; i++) {
                    var influence = activeInfluences[i];
                    if (morphInfluences[i] = influence[0], 0 !== influence[0]) {
                        var index = influence[1];
                        material.morphTargets === !0 && morphAttributes.position && geometry.addAttribute("morphTarget" + i, morphAttributes.position[index]), 
                        material.morphNormals === !0 && morphAttributes.normal && geometry.addAttribute("morphNormal" + i, morphAttributes.normal[index]);
                    } else material.morphTargets === !0 && geometry.removeAttribute("morphTarget" + i), 
                    material.morphNormals === !0 && geometry.removeAttribute("morphNormal" + i);
                }
                for (var i = activeInfluences.length, il = morphInfluences.length; il > i; i++) morphInfluences[i] = 0;
                program.getUniforms().setValue(_gl, "morphTargetInfluences", morphInfluences), updateBuffers = !0;
            }
            var index = geometry.index, position = geometry.attributes.position, rangeFactor = 1;
            material.wireframe === !0 && (index = objects.getWireframeAttribute(geometry), rangeFactor = 2);
            var renderer;
            null !== index ? (renderer = indexedBufferRenderer, renderer.setIndex(index)) : renderer = bufferRenderer, 
            updateBuffers && (setupVertexAttributes(material, program, geometry), null !== index && _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer(index)));
            var dataCount = 0;
            null !== index ? dataCount = index.count : void 0 !== position && (dataCount = position.count);
            var rangeStart = geometry.drawRange.start * rangeFactor, rangeCount = geometry.drawRange.count * rangeFactor, groupStart = null !== group ? group.start * rangeFactor : 0, groupCount = null !== group ? group.count * rangeFactor : 1 / 0, drawStart = Math.max(rangeStart, groupStart), drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1, drawCount = Math.max(0, drawEnd - drawStart + 1);
            if (0 !== drawCount) {
                if (object.isMesh) if (material.wireframe === !0) state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio()), 
                renderer.setMode(_gl.LINES); else switch (object.drawMode) {
                  case TrianglesDrawMode:
                    renderer.setMode(_gl.TRIANGLES);
                    break;

                  case TriangleStripDrawMode:
                    renderer.setMode(_gl.TRIANGLE_STRIP);
                    break;

                  case TriangleFanDrawMode:
                    renderer.setMode(_gl.TRIANGLE_FAN);
                } else if (object.isLine) {
                    var lineWidth = material.linewidth;
                    void 0 === lineWidth && (lineWidth = 1), state.setLineWidth(lineWidth * getTargetPixelRatio()), 
                    object.isLineSegments ? renderer.setMode(_gl.LINES) : renderer.setMode(_gl.LINE_STRIP);
                } else object.isPoints && renderer.setMode(_gl.POINTS);
                geometry && geometry.isInstancedBufferGeometry ? geometry.maxInstancedCount > 0 && renderer.renderInstances(geometry, drawStart, drawCount) : renderer.render(drawStart, drawCount);
            }
        }, this.render = function(scene, camera, renderTarget, forceClear) {
            if (void 0 !== camera && camera.isCamera !== !0) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            _currentGeometryProgram = "", _currentMaterialId = -1, _currentCamera = null, scene.autoUpdate === !0 && scene.updateMatrixWorld(), 
            null === camera.parent && camera.updateMatrixWorld(), camera.matrixWorldInverse.getInverse(camera.matrixWorld), 
            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse), 
            _frustum.setFromMatrix(_projScreenMatrix), lights.length = 0, opaqueObjectsLastIndex = -1, 
            transparentObjectsLastIndex = -1, sprites.length = 0, lensFlares.length = 0, _localClippingEnabled = this.localClippingEnabled, 
            _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera), 
            projectObject(scene, camera), opaqueObjects.length = opaqueObjectsLastIndex + 1, 
            transparentObjects.length = transparentObjectsLastIndex + 1, _this.sortObjects === !0 && (opaqueObjects.sort(painterSortStable), 
            transparentObjects.sort(reversePainterSortStable)), _clippingEnabled && _clipping.beginShadows(), 
            setupShadows(lights), shadowMap.render(scene, camera), setupLights(lights, camera), 
            _clippingEnabled && _clipping.endShadows(), _infoRender.calls = 0, _infoRender.vertices = 0, 
            _infoRender.faces = 0, _infoRender.points = 0, void 0 === renderTarget && (renderTarget = null), 
            this.setRenderTarget(renderTarget);
            var background = scene.background;
            if (null === background ? glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha) : background && background.isColor && (glClearColor(background.r, background.g, background.b, 1), 
            forceClear = !0), (this.autoClear || forceClear) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), 
            background && background.isCubeTexture ? (backgroundCamera2.projectionMatrix.copy(camera.projectionMatrix), 
            backgroundCamera2.matrixWorld.extractRotation(camera.matrixWorld), backgroundCamera2.matrixWorldInverse.getInverse(backgroundCamera2.matrixWorld), 
            backgroundBoxMesh.material.uniforms.tCube.value = background, backgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld), 
            objects.update(backgroundBoxMesh), _this.renderBufferDirect(backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null)) : background && background.isTexture && (backgroundPlaneMesh.material.map = background, 
            objects.update(backgroundPlaneMesh), _this.renderBufferDirect(backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null)), 
            scene.overrideMaterial) {
                var overrideMaterial = scene.overrideMaterial;
                renderObjects(opaqueObjects, scene, camera, overrideMaterial), renderObjects(transparentObjects, scene, camera, overrideMaterial);
            } else state.setBlending(NoBlending), renderObjects(opaqueObjects, scene, camera), 
            renderObjects(transparentObjects, scene, camera);
            spritePlugin.render(scene, camera), lensFlarePlugin.render(scene, camera, _currentViewport), 
            renderTarget && textures.updateRenderTargetMipmap(renderTarget), state.setDepthTest(!0), 
            state.setDepthWrite(!0), state.setColorWrite(!0);
        }, this.setFaceCulling = function(cullFace, frontFaceDirection) {
            state.setCullFace(cullFace), state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
        }, this.allocTextureUnit = allocTextureUnit, this.setTexture2D = function() {
            var warned = !1;
            return function(texture, slot) {
                texture && texture.isWebGLRenderTarget && (warned || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), 
                warned = !0), texture = texture.texture), textures.setTexture2D(texture, slot);
            };
        }(), this.setTexture = function() {
            var warned = !1;
            return function(texture, slot) {
                warned || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), 
                warned = !0), textures.setTexture2D(texture, slot);
            };
        }(), this.setTextureCube = function() {
            var warned = !1;
            return function(texture, slot) {
                texture && texture.isWebGLRenderTargetCube && (warned || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), 
                warned = !0), texture = texture.texture), texture && texture.isCubeTexture || Array.isArray(texture.image) && 6 === texture.image.length ? textures.setTextureCube(texture, slot) : textures.setTextureCubeDynamic(texture, slot);
            };
        }(), this.getCurrentRenderTarget = function() {
            return _currentRenderTarget;
        }, this.setRenderTarget = function(renderTarget) {
            _currentRenderTarget = renderTarget, renderTarget && void 0 === properties.get(renderTarget).__webglFramebuffer && textures.setupRenderTarget(renderTarget);
            var framebuffer, isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
            if (renderTarget) {
                var renderTargetProperties = properties.get(renderTarget);
                framebuffer = isCube ? renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace] : renderTargetProperties.__webglFramebuffer, 
                _currentScissor.copy(renderTarget.scissor), _currentScissorTest = renderTarget.scissorTest, 
                _currentViewport.copy(renderTarget.viewport);
            } else framebuffer = null, _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio), 
            _currentScissorTest = _scissorTest, _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
            if (_currentFramebuffer !== framebuffer && (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), 
            _currentFramebuffer = framebuffer), state.scissor(_currentScissor), state.setScissorTest(_currentScissorTest), 
            state.viewport(_currentViewport), isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
            }
        }, this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
            if ((renderTarget && renderTarget.isWebGLRenderTarget) === !1) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            var framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (framebuffer) {
                var restore = !1;
                framebuffer !== _currentFramebuffer && (_gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), 
                restore = !0);
                try {
                    var texture = renderTarget.texture, textureFormat = texture.format, textureType = texture.type;
                    if (textureFormat !== RGBAFormat && paramThreeToGL(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    if (!(textureType === UnsignedByteType || paramThreeToGL(textureType) === _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) || textureType === FloatType && (extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float")) || textureType === HalfFloatType && extensions.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    _gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE ? x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height && _gl.readPixels(x, y, width, height, paramThreeToGL(textureFormat), paramThreeToGL(textureType), buffer) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
                } finally {
                    restore && _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                }
            }
        };
    }
    function FogExp2(color, density) {
        this.name = "", this.color = new Color(color), this.density = void 0 !== density ? density : 25e-5;
    }
    function Fog(color, near, far) {
        this.name = "", this.color = new Color(color), this.near = void 0 !== near ? near : 1, 
        this.far = void 0 !== far ? far : 1e3;
    }
    function Scene() {
        Object3D.call(this), this.type = "Scene", this.background = null, this.fog = null, 
        this.overrideMaterial = null, this.autoUpdate = !0;
    }
    function LensFlare(texture, size, distance, blending, color) {
        Object3D.call(this), this.lensFlares = [], this.positionScreen = new Vector3(), 
        this.customUpdateCallback = void 0, void 0 !== texture && this.add(texture, size, distance, blending, color);
    }
    function SpriteMaterial(parameters) {
        Material.call(this), this.type = "SpriteMaterial", this.color = new Color(16777215), 
        this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(parameters);
    }
    function Sprite(material) {
        Object3D.call(this), this.type = "Sprite", this.material = void 0 !== material ? material : new SpriteMaterial();
    }
    function LOD() {
        Object3D.call(this), this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        });
    }
    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding), 
        this.image = {
            data: data,
            width: width,
            height: height
        }, this.magFilter = void 0 !== magFilter ? magFilter : NearestFilter, this.minFilter = void 0 !== minFilter ? minFilter : NearestFilter, 
        this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
    }
    function Skeleton(bones, boneInverses, useVertexTexture) {
        if (this.useVertexTexture = void 0 !== useVertexTexture ? useVertexTexture : !0, 
        this.identityMatrix = new Matrix4(), bones = bones || [], this.bones = bones.slice(0), 
        this.useVertexTexture) {
            var size = Math.sqrt(4 * this.bones.length);
            size = _Math.nextPowerOfTwo(Math.ceil(size)), size = Math.max(size, 4), this.boneTextureWidth = size, 
            this.boneTextureHeight = size, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), 
            this.boneTexture = new DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType);
        } else this.boneMatrices = new Float32Array(16 * this.bones.length);
        if (void 0 === boneInverses) this.calculateInverses(); else if (this.bones.length === boneInverses.length) this.boneInverses = boneInverses.slice(0); else {
            console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [];
            for (var b = 0, bl = this.bones.length; bl > b; b++) this.boneInverses.push(new Matrix4());
        }
    }
    function Bone(skin) {
        Object3D.call(this), this.type = "Bone", this.skin = skin;
    }
    function SkinnedMesh(geometry, material, useVertexTexture) {
        Mesh.call(this, geometry, material), this.type = "SkinnedMesh", this.bindMode = "attached", 
        this.bindMatrix = new Matrix4(), this.bindMatrixInverse = new Matrix4();
        var bones = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
            for (var bone, gbone, b = 0, bl = this.geometry.bones.length; bl > b; ++b) gbone = this.geometry.bones[b], 
            bone = new Bone(this), bones.push(bone), bone.name = gbone.name, bone.position.fromArray(gbone.pos), 
            bone.quaternion.fromArray(gbone.rotq), void 0 !== gbone.scl && bone.scale.fromArray(gbone.scl);
            for (var b = 0, bl = this.geometry.bones.length; bl > b; ++b) gbone = this.geometry.bones[b], 
            -1 !== gbone.parent && null !== gbone.parent && void 0 !== bones[gbone.parent] ? bones[gbone.parent].add(bones[b]) : this.add(bones[b]);
        }
        this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new Skeleton(bones, void 0, useVertexTexture), this.matrixWorld);
    }
    function LineBasicMaterial(parameters) {
        Material.call(this), this.type = "LineBasicMaterial", this.color = new Color(16777215), 
        this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, 
        this.setValues(parameters);
    }
    function Line(geometry, material, mode) {
        return 1 === mode ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), 
        new LineSegments(geometry, material)) : (Object3D.call(this), this.type = "Line", 
        this.geometry = void 0 !== geometry ? geometry : new BufferGeometry(), void (this.material = void 0 !== material ? material : new LineBasicMaterial({
            color: 16777215 * Math.random()
        })));
    }
    function LineSegments(geometry, material) {
        Line.call(this, geometry, material), this.type = "LineSegments";
    }
    function PointsMaterial(parameters) {
        Material.call(this), this.type = "PointsMaterial", this.color = new Color(16777215), 
        this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(parameters);
    }
    function Points(geometry, material) {
        Object3D.call(this), this.type = "Points", this.geometry = void 0 !== geometry ? geometry : new BufferGeometry(), 
        this.material = void 0 !== material ? material : new PointsMaterial({
            color: 16777215 * Math.random()
        });
    }
    function Group() {
        Object3D.call(this), this.type = "Group";
    }
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        function update() {
            requestAnimationFrame(update), video.readyState >= video.HAVE_CURRENT_DATA && (scope.needsUpdate = !0);
        }
        Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy), 
        this.generateMipmaps = !1;
        var scope = this;
        update();
    }
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding), 
        this.image = {
            width: width,
            height: height
        }, this.mipmaps = mipmaps, this.flipY = !1, this.generateMipmaps = !1;
    }
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy), 
        this.needsUpdate = !0;
    }
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        if (format = void 0 !== format ? format : DepthFormat, format !== DepthFormat && format !== DepthStencilFormat) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy), 
        this.image = {
            width: width,
            height: height
        }, this.type = void 0 !== type ? type : UnsignedShortType, this.magFilter = void 0 !== magFilter ? magFilter : NearestFilter, 
        this.minFilter = void 0 !== minFilter ? minFilter : NearestFilter, this.flipY = !1, 
        this.generateMipmaps = !1;
    }
    function WireframeGeometry(geometry) {
        function sortFunction(a, b) {
            return a - b;
        }
        BufferGeometry.call(this);
        var edge = [ 0, 0 ], hash = {}, keys = [ "a", "b", "c" ];
        if (geometry && geometry.isGeometry) {
            for (var vertices = geometry.vertices, faces = geometry.faces, numEdges = 0, edges = new Uint32Array(6 * faces.length), i = 0, l = faces.length; l > i; i++) for (var face = faces[i], j = 0; 3 > j; j++) {
                edge[0] = face[keys[j]], edge[1] = face[keys[(j + 1) % 3]], edge.sort(sortFunction);
                var key = edge.toString();
                void 0 === hash[key] && (edges[2 * numEdges] = edge[0], edges[2 * numEdges + 1] = edge[1], 
                hash[key] = !0, numEdges++);
            }
            for (var coords = new Float32Array(2 * numEdges * 3), i = 0, l = numEdges; l > i; i++) for (var j = 0; 2 > j; j++) {
                var vertex = vertices[edges[2 * i + j]], index = 6 * i + 3 * j;
                coords[index + 0] = vertex.x, coords[index + 1] = vertex.y, coords[index + 2] = vertex.z;
            }
            this.addAttribute("position", new BufferAttribute(coords, 3));
        } else if (geometry && geometry.isBufferGeometry) if (null !== geometry.index) {
            var indices = geometry.index.array, vertices = geometry.attributes.position, groups = geometry.groups, numEdges = 0;
            0 === groups.length && geometry.addGroup(0, indices.length);
            for (var edges = new Uint32Array(2 * indices.length), o = 0, ol = groups.length; ol > o; ++o) for (var group = groups[o], start = group.start, count = group.count, i = start, il = start + count; il > i; i += 3) for (var j = 0; 3 > j; j++) {
                edge[0] = indices[i + j], edge[1] = indices[i + (j + 1) % 3], edge.sort(sortFunction);
                var key = edge.toString();
                void 0 === hash[key] && (edges[2 * numEdges] = edge[0], edges[2 * numEdges + 1] = edge[1], 
                hash[key] = !0, numEdges++);
            }
            for (var coords = new Float32Array(2 * numEdges * 3), i = 0, l = numEdges; l > i; i++) for (var j = 0; 2 > j; j++) {
                var index = 6 * i + 3 * j, index2 = edges[2 * i + j];
                coords[index + 0] = vertices.getX(index2), coords[index + 1] = vertices.getY(index2), 
                coords[index + 2] = vertices.getZ(index2);
            }
            this.addAttribute("position", new BufferAttribute(coords, 3));
        } else {
            for (var vertices = geometry.attributes.position.array, numEdges = vertices.length / 3, numTris = numEdges / 3, coords = new Float32Array(2 * numEdges * 3), i = 0, l = numTris; l > i; i++) for (var j = 0; 3 > j; j++) {
                var index = 18 * i + 6 * j, index1 = 9 * i + 3 * j;
                coords[index + 0] = vertices[index1], coords[index + 1] = vertices[index1 + 1], 
                coords[index + 2] = vertices[index1 + 2];
                var index2 = 9 * i + 3 * ((j + 1) % 3);
                coords[index + 3] = vertices[index2], coords[index + 4] = vertices[index2 + 1], 
                coords[index + 5] = vertices[index2 + 2];
            }
            this.addAttribute("position", new BufferAttribute(coords, 3));
        }
    }
    function ParametricBufferGeometry(func, slices, stacks) {
        BufferGeometry.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        var i, j, p, u, v, vertices = [], uvs = [], sliceCount = slices + 1;
        for (i = 0; stacks >= i; i++) for (v = i / stacks, j = 0; slices >= j; j++) u = j / slices, 
        p = func(u, v), vertices.push(p.x, p.y, p.z), uvs.push(u, v);
        var a, b, c, d, indices = [];
        for (i = 0; stacks > i; i++) for (j = 0; slices > j; j++) a = i * sliceCount + j, 
        b = i * sliceCount + j + 1, c = (i + 1) * sliceCount + j + 1, d = (i + 1) * sliceCount + j, 
        indices.push(a, b, d), indices.push(b, c, d);
        this.setIndex((indices.length > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1)), 
        this.addAttribute("position", Float32Attribute(vertices, 3)), this.addAttribute("uv", Float32Attribute(uvs, 2)), 
        this.computeVertexNormals();
    }
    function ParametricGeometry(func, slices, stacks) {
        Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        }, this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks)), 
        this.mergeVertices();
    }
    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
        function subdivide(detail) {
            for (var a = new Vector3(), b = new Vector3(), c = new Vector3(), i = 0; i < indices.length; i += 3) getVertexByIndex(indices[i + 0], a), 
            getVertexByIndex(indices[i + 1], b), getVertexByIndex(indices[i + 2], c), subdivideFace(a, b, c, detail);
        }
        function subdivideFace(a, b, c, detail) {
            var i, j, cols = Math.pow(2, detail), v = [];
            for (i = 0; cols >= i; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols), bj = b.clone().lerp(c, i / cols), rows = cols - i;
                for (j = 0; rows >= j; j++) 0 === j && i === cols ? v[i][j] = aj : v[i][j] = aj.clone().lerp(bj, j / rows);
            }
            for (i = 0; cols > i; i++) for (j = 0; 2 * (cols - i) - 1 > j; j++) {
                var k = Math.floor(j / 2);
                j % 2 === 0 ? (pushVertex(v[i][k + 1]), pushVertex(v[i + 1][k]), pushVertex(v[i][k])) : (pushVertex(v[i][k + 1]), 
                pushVertex(v[i + 1][k + 1]), pushVertex(v[i + 1][k]));
            }
        }
        function appplyRadius(radius) {
            for (var vertex = new Vector3(), i = 0; i < vertexBuffer.length; i += 3) vertex.x = vertexBuffer[i + 0], 
            vertex.y = vertexBuffer[i + 1], vertex.z = vertexBuffer[i + 2], vertex.normalize().multiplyScalar(radius), 
            vertexBuffer[i + 0] = vertex.x, vertexBuffer[i + 1] = vertex.y, vertexBuffer[i + 2] = vertex.z;
        }
        function generateUVs() {
            for (var vertex = new Vector3(), i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0], vertex.y = vertexBuffer[i + 1], vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + .5, v = inclination(vertex) / Math.PI + .5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs(), correctSeam();
        }
        function correctSeam() {
            for (var i = 0; i < uvBuffer.length; i += 6) {
                var x0 = uvBuffer[i + 0], x1 = uvBuffer[i + 2], x2 = uvBuffer[i + 4], max = Math.max(x0, x1, x2), min = Math.min(x0, x1, x2);
                max > .9 && .1 > min && (.2 > x0 && (uvBuffer[i + 0] += 1), .2 > x1 && (uvBuffer[i + 2] += 1), 
                .2 > x2 && (uvBuffer[i + 4] += 1));
            }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
            var stride = 3 * index;
            vertex.x = vertices[stride + 0], vertex.y = vertices[stride + 1], vertex.z = vertices[stride + 2];
        }
        function correctUVs() {
            for (var a = new Vector3(), b = new Vector3(), c = new Vector3(), centroid = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), i = 0, j = 0; i < vertexBuffer.length; i += 9, 
            j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]), b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]), 
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]), uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]), 
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]), uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]), 
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi), correctUV(uvB, j + 2, b, azi), correctUV(uvC, j + 4, c, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            0 > azimuth && 1 === uv.x && (uvBuffer[stride] = uv.x - 1), 0 === vector.x && 0 === vector.z && (uvBuffer[stride] = azimuth / 2 / Math.PI + .5);
        }
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
        BufferGeometry.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        }, radius = radius || 1, detail = detail || 0;
        var vertexBuffer = [], uvBuffer = [];
        subdivide(detail), appplyRadius(radius), generateUVs(), this.addAttribute("position", Float32Attribute(vertexBuffer, 3)), 
        this.addAttribute("normal", Float32Attribute(vertexBuffer.slice(), 3)), this.addAttribute("uv", Float32Attribute(uvBuffer, 2)), 
        this.normalizeNormals(), this.boundingSphere = new Sphere(new Vector3(), radius);
    }
    function TetrahedronBufferGeometry(radius, detail) {
        var vertices = [ 1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1 ], indices = [ 2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "TetrahedronBufferGeometry", 
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function TetrahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function OctahedronBufferGeometry(radius, detail) {
        var vertices = [ 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1 ], indices = [ 0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "OctahedronBufferGeometry", 
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function OctahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function IcosahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2, vertices = [ -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1 ], indices = [ 0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "IcosahedronBufferGeometry", 
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function IcosahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function DodecahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2, r = 1 / t, vertices = [ -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r ], indices = [ 3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9 ];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail), this.type = "DodecahedronBufferGeometry", 
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    function DodecahedronGeometry(radius, detail) {
        Geometry.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail)), this.mergeVertices();
    }
    function PolyhedronGeometry(vertices, indices, radius, detail) {
        Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        }, this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail)), 
        this.mergeVertices();
    }
    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
        function generateBufferData() {
            for (i = 0; tubularSegments > i; i++) generateSegment(i);
            generateSegment(closed === !1 ? tubularSegments : 0), generateUVs(), generateIndices();
        }
        function generateSegment(i) {
            var P = path.getPointAt(i / tubularSegments), N = frames.normals[i], B = frames.binormals[i];
            for (j = 0; radialSegments >= j; j++) {
                var v = j / radialSegments * Math.PI * 2, sin = Math.sin(v), cos = -Math.cos(v);
                normal.x = cos * N.x + sin * B.x, normal.y = cos * N.y + sin * B.y, normal.z = cos * N.z + sin * B.z, 
                normal.normalize(), normals.push(normal.x, normal.y, normal.z), vertex.x = P.x + radius * normal.x, 
                vertex.y = P.y + radius * normal.y, vertex.z = P.z + radius * normal.z, vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        function generateIndices() {
            for (j = 1; tubularSegments >= j; j++) for (i = 1; radialSegments >= i; i++) {
                var a = (radialSegments + 1) * (j - 1) + (i - 1), b = (radialSegments + 1) * j + (i - 1), c = (radialSegments + 1) * j + i, d = (radialSegments + 1) * (j - 1) + i;
                indices.push(a, b, d), indices.push(b, c, d);
            }
        }
        function generateUVs() {
            for (i = 0; tubularSegments >= i; i++) for (j = 0; radialSegments >= j; j++) uv.x = i / tubularSegments, 
            uv.y = j / radialSegments, uvs.push(uv.x, uv.y);
        }
        BufferGeometry.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        }, tubularSegments = tubularSegments || 64, radius = radius || 1, radialSegments = radialSegments || 8, 
        closed = closed || !1;
        var frames = path.computeFrenetFrames(tubularSegments, closed);
        this.tangents = frames.tangents, this.normals = frames.normals, this.binormals = frames.binormals;
        var i, j, vertex = new Vector3(), normal = new Vector3(), uv = new Vector2(), vertices = [], normals = [], uvs = [], indices = [];
        generateBufferData(), this.setIndex((indices.length > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1)), 
        this.addAttribute("position", Float32Attribute(vertices, 3)), this.addAttribute("normal", Float32Attribute(normals, 3)), 
        this.addAttribute("uv", Float32Attribute(uvs, 2));
    }
    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
        Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        }, void 0 !== taper && console.warn("THREE.TubeGeometry: taper has been removed.");
        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
        this.tangents = bufferGeometry.tangents, this.normals = bufferGeometry.normals, 
        this.binormals = bufferGeometry.binormals, this.fromBufferGeometry(bufferGeometry), 
        this.mergeVertices();
    }
    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
        function calculatePositionOnCurve(u, p, q, radius, position) {
            var cu = Math.cos(u), su = Math.sin(u), quOverP = q / p * u, cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * .5 * cu, position.y = radius * (2 + cs) * su * .5, 
            position.z = radius * Math.sin(quOverP) * .5;
        }
        BufferGeometry.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        }, radius = radius || 100, tube = tube || 40, tubularSegments = Math.floor(tubularSegments) || 64, 
        radialSegments = Math.floor(radialSegments) || 8, p = p || 2, q = q || 3;
        var i, j, vertexCount = (radialSegments + 1) * (tubularSegments + 1), indexCount = radialSegments * tubularSegments * 2 * 3, indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1), vertices = new BufferAttribute(new Float32Array(3 * vertexCount), 3), normals = new BufferAttribute(new Float32Array(3 * vertexCount), 3), uvs = new BufferAttribute(new Float32Array(2 * vertexCount), 2), index = 0, indexOffset = 0, vertex = new Vector3(), normal = new Vector3(), uv = new Vector2(), P1 = new Vector3(), P2 = new Vector3(), B = new Vector3(), T = new Vector3(), N = new Vector3();
        for (i = 0; tubularSegments >= i; ++i) {
            var u = i / tubularSegments * p * Math.PI * 2;
            for (calculatePositionOnCurve(u, p, q, radius, P1), calculatePositionOnCurve(u + .01, p, q, radius, P2), 
            T.subVectors(P2, P1), N.addVectors(P2, P1), B.crossVectors(T, N), N.crossVectors(B, T), 
            B.normalize(), N.normalize(), j = 0; radialSegments >= j; ++j) {
                var v = j / radialSegments * Math.PI * 2, cx = -tube * Math.cos(v), cy = tube * Math.sin(v);
                vertex.x = P1.x + (cx * N.x + cy * B.x), vertex.y = P1.y + (cx * N.y + cy * B.y), 
                vertex.z = P1.z + (cx * N.z + cy * B.z), vertices.setXYZ(index, vertex.x, vertex.y, vertex.z), 
                normal.subVectors(vertex, P1).normalize(), normals.setXYZ(index, normal.x, normal.y, normal.z), 
                uv.x = i / tubularSegments, uv.y = j / radialSegments, uvs.setXY(index, uv.x, uv.y), 
                index++;
            }
        }
        for (j = 1; tubularSegments >= j; j++) for (i = 1; radialSegments >= i; i++) {
            var a = (radialSegments + 1) * (j - 1) + (i - 1), b = (radialSegments + 1) * j + (i - 1), c = (radialSegments + 1) * j + i, d = (radialSegments + 1) * (j - 1) + i;
            indices.setX(indexOffset, a), indexOffset++, indices.setX(indexOffset, b), indexOffset++, 
            indices.setX(indexOffset, d), indexOffset++, indices.setX(indexOffset, b), indexOffset++, 
            indices.setX(indexOffset, c), indexOffset++, indices.setX(indexOffset, d), indexOffset++;
        }
        this.setIndex(indices), this.addAttribute("position", vertices), this.addAttribute("normal", normals), 
        this.addAttribute("uv", uvs);
    }
    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
        Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        }, void 0 !== heightScale && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), 
        this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q)), 
        this.mergeVertices();
    }
    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        BufferGeometry.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        }, radius = radius || 100, tube = tube || 40, radialSegments = Math.floor(radialSegments) || 8, 
        tubularSegments = Math.floor(tubularSegments) || 6, arc = arc || 2 * Math.PI;
        var j, i, vertexCount = (radialSegments + 1) * (tubularSegments + 1), indexCount = radialSegments * tubularSegments * 2 * 3, indices = new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), vertices = new Float32Array(3 * vertexCount), normals = new Float32Array(3 * vertexCount), uvs = new Float32Array(2 * vertexCount), vertexBufferOffset = 0, uvBufferOffset = 0, indexBufferOffset = 0, center = new Vector3(), vertex = new Vector3(), normal = new Vector3();
        for (j = 0; radialSegments >= j; j++) for (i = 0; tubularSegments >= i; i++) {
            var u = i / tubularSegments * arc, v = j / radialSegments * Math.PI * 2;
            vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u), vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u), 
            vertex.z = tube * Math.sin(v), vertices[vertexBufferOffset] = vertex.x, vertices[vertexBufferOffset + 1] = vertex.y, 
            vertices[vertexBufferOffset + 2] = vertex.z, center.x = radius * Math.cos(u), center.y = radius * Math.sin(u), 
            normal.subVectors(vertex, center).normalize(), normals[vertexBufferOffset] = normal.x, 
            normals[vertexBufferOffset + 1] = normal.y, normals[vertexBufferOffset + 2] = normal.z, 
            uvs[uvBufferOffset] = i / tubularSegments, uvs[uvBufferOffset + 1] = j / radialSegments, 
            vertexBufferOffset += 3, uvBufferOffset += 2;
        }
        for (j = 1; radialSegments >= j; j++) for (i = 1; tubularSegments >= i; i++) {
            var a = (tubularSegments + 1) * j + i - 1, b = (tubularSegments + 1) * (j - 1) + i - 1, c = (tubularSegments + 1) * (j - 1) + i, d = (tubularSegments + 1) * j + i;
            indices[indexBufferOffset] = a, indices[indexBufferOffset + 1] = b, indices[indexBufferOffset + 2] = d, 
            indices[indexBufferOffset + 3] = b, indices[indexBufferOffset + 4] = c, indices[indexBufferOffset + 5] = d, 
            indexBufferOffset += 6;
        }
        this.setIndex(new BufferAttribute(indices, 1)), this.addAttribute("position", new BufferAttribute(vertices, 3)), 
        this.addAttribute("normal", new BufferAttribute(normals, 3)), this.addAttribute("uv", new BufferAttribute(uvs, 2));
    }
    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        }, this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
    }
    function ExtrudeGeometry(shapes, options) {
        return "undefined" == typeof shapes ? void (shapes = []) : (Geometry.call(this), 
        this.type = "ExtrudeGeometry", shapes = Array.isArray(shapes) ? shapes : [ shapes ], 
        this.addShapeList(shapes, options), void this.computeFaceNormals());
    }
    function TextGeometry(text, parameters) {
        parameters = parameters || {};
        var font = parameters.font;
        if ((font && font.isFont) === !1) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), 
        new Geometry();
        var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
        parameters.amount = void 0 !== parameters.height ? parameters.height : 50, void 0 === parameters.bevelThickness && (parameters.bevelThickness = 10), 
        void 0 === parameters.bevelSize && (parameters.bevelSize = 8), void 0 === parameters.bevelEnabled && (parameters.bevelEnabled = !1), 
        ExtrudeGeometry.call(this, shapes, parameters), this.type = "TextGeometry";
    }
    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        BufferGeometry.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, radius = radius || 50, widthSegments = Math.max(3, Math.floor(widthSegments) || 8), 
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6), phiStart = void 0 !== phiStart ? phiStart : 0, 
        phiLength = void 0 !== phiLength ? phiLength : 2 * Math.PI, thetaStart = void 0 !== thetaStart ? thetaStart : 0, 
        thetaLength = void 0 !== thetaLength ? thetaLength : Math.PI;
        for (var thetaEnd = thetaStart + thetaLength, vertexCount = (widthSegments + 1) * (heightSegments + 1), positions = new BufferAttribute(new Float32Array(3 * vertexCount), 3), normals = new BufferAttribute(new Float32Array(3 * vertexCount), 3), uvs = new BufferAttribute(new Float32Array(2 * vertexCount), 2), index = 0, vertices = [], normal = new Vector3(), y = 0; heightSegments >= y; y++) {
            for (var verticesRow = [], v = y / heightSegments, x = 0; widthSegments >= x; x++) {
                var u = x / widthSegments, px = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), py = radius * Math.cos(thetaStart + v * thetaLength), pz = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                normal.set(px, py, pz).normalize(), positions.setXYZ(index, px, py, pz), normals.setXYZ(index, normal.x, normal.y, normal.z), 
                uvs.setXY(index, u, 1 - v), verticesRow.push(index), index++;
            }
            vertices.push(verticesRow);
        }
        for (var indices = [], y = 0; heightSegments > y; y++) for (var x = 0; widthSegments > x; x++) {
            var v1 = vertices[y][x + 1], v2 = vertices[y][x], v3 = vertices[y + 1][x], v4 = vertices[y + 1][x + 1];
            (0 !== y || thetaStart > 0) && indices.push(v1, v2, v4), (y !== heightSegments - 1 || thetaEnd < Math.PI) && indices.push(v2, v3, v4);
        }
        this.setIndex(new (positions.count > 65535 ? Uint32Attribute : Uint16Attribute)(indices, 1)), 
        this.addAttribute("position", positions), this.addAttribute("normal", normals), 
        this.addAttribute("uv", uvs), this.boundingSphere = new Sphere(new Vector3(), radius);
    }
    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    }
    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        BufferGeometry.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, innerRadius = innerRadius || 20, outerRadius = outerRadius || 50, thetaStart = void 0 !== thetaStart ? thetaStart : 0, 
        thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI, thetaSegments = void 0 !== thetaSegments ? Math.max(3, thetaSegments) : 8, 
        phiSegments = void 0 !== phiSegments ? Math.max(1, phiSegments) : 1;
        var segment, j, i, vertexCount = (thetaSegments + 1) * (phiSegments + 1), indexCount = thetaSegments * phiSegments * 2 * 3, indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1), vertices = new BufferAttribute(new Float32Array(3 * vertexCount), 3), normals = new BufferAttribute(new Float32Array(3 * vertexCount), 3), uvs = new BufferAttribute(new Float32Array(2 * vertexCount), 2), index = 0, indexOffset = 0, radius = innerRadius, radiusStep = (outerRadius - innerRadius) / phiSegments, vertex = new Vector3(), uv = new Vector2();
        for (j = 0; phiSegments >= j; j++) {
            for (i = 0; thetaSegments >= i; i++) segment = thetaStart + i / thetaSegments * thetaLength, 
            vertex.x = radius * Math.cos(segment), vertex.y = radius * Math.sin(segment), vertices.setXYZ(index, vertex.x, vertex.y, vertex.z), 
            normals.setXYZ(index, 0, 0, 1), uv.x = (vertex.x / outerRadius + 1) / 2, uv.y = (vertex.y / outerRadius + 1) / 2, 
            uvs.setXY(index, uv.x, uv.y), index++;
            radius += radiusStep;
        }
        for (j = 0; phiSegments > j; j++) {
            var thetaSegmentLevel = j * (thetaSegments + 1);
            for (i = 0; thetaSegments > i; i++) {
                segment = i + thetaSegmentLevel;
                var a = segment, b = segment + thetaSegments + 1, c = segment + thetaSegments + 2, d = segment + 1;
                indices.setX(indexOffset, a), indexOffset++, indices.setX(indexOffset, b), indexOffset++, 
                indices.setX(indexOffset, c), indexOffset++, indices.setX(indexOffset, a), indexOffset++, 
                indices.setX(indexOffset, c), indexOffset++, indices.setX(indexOffset, d), indexOffset++;
            }
        }
        this.setIndex(indices), this.addAttribute("position", vertices), this.addAttribute("normal", normals), 
        this.addAttribute("uv", uvs);
    }
    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
    }
    function PlaneGeometry(width, height, widthSegments, heightSegments) {
        Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        }, this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    }
    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
        BufferGeometry.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        }, segments = Math.floor(segments) || 12, phiStart = phiStart || 0, phiLength = phiLength || 2 * Math.PI, 
        phiLength = _Math.clamp(phiLength, 0, 2 * Math.PI);
        var base, i, j, vertexCount = (segments + 1) * points.length, indexCount = segments * points.length * 2 * 3, indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1), vertices = new BufferAttribute(new Float32Array(3 * vertexCount), 3), uvs = new BufferAttribute(new Float32Array(2 * vertexCount), 2), index = 0, indexOffset = 0, inverseSegments = 1 / segments, vertex = new Vector3(), uv = new Vector2();
        for (i = 0; segments >= i; i++) {
            var phi = phiStart + i * inverseSegments * phiLength, sin = Math.sin(phi), cos = Math.cos(phi);
            for (j = 0; j <= points.length - 1; j++) vertex.x = points[j].x * sin, vertex.y = points[j].y, 
            vertex.z = points[j].x * cos, vertices.setXYZ(index, vertex.x, vertex.y, vertex.z), 
            uv.x = i / segments, uv.y = j / (points.length - 1), uvs.setXY(index, uv.x, uv.y), 
            index++;
        }
        for (i = 0; segments > i; i++) for (j = 0; j < points.length - 1; j++) {
            base = j + i * points.length;
            var a = base, b = base + points.length, c = base + points.length + 1, d = base + 1;
            indices.setX(indexOffset, a), indexOffset++, indices.setX(indexOffset, b), indexOffset++, 
            indices.setX(indexOffset, d), indexOffset++, indices.setX(indexOffset, b), indexOffset++, 
            indices.setX(indexOffset, c), indexOffset++, indices.setX(indexOffset, d), indexOffset++;
        }
        if (this.setIndex(indices), this.addAttribute("position", vertices), this.addAttribute("uv", uvs), 
        this.computeVertexNormals(), phiLength === 2 * Math.PI) {
            var normals = this.attributes.normal.array, n1 = new Vector3(), n2 = new Vector3(), n = new Vector3();
            for (base = segments * points.length * 3, i = 0, j = 0; i < points.length; i++, 
            j += 3) n1.x = normals[j + 0], n1.y = normals[j + 1], n1.z = normals[j + 2], n2.x = normals[base + j + 0], 
            n2.y = normals[base + j + 1], n2.z = normals[base + j + 2], n.addVectors(n1, n2).normalize(), 
            normals[j + 0] = normals[base + j + 0] = n.x, normals[j + 1] = normals[base + j + 1] = n.y, 
            normals[j + 2] = normals[base + j + 2] = n.z;
        }
    }
    function LatheGeometry(points, segments, phiStart, phiLength) {
        Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        }, this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength)), 
        this.mergeVertices();
    }
    function ShapeGeometry(shapes, options) {
        Geometry.call(this), this.type = "ShapeGeometry", Array.isArray(shapes) === !1 && (shapes = [ shapes ]), 
        this.addShapeList(shapes, options), this.computeFaceNormals();
    }
    function EdgesGeometry(geometry, thresholdAngle) {
        function sortFunction(a, b) {
            return a - b;
        }
        BufferGeometry.call(this), thresholdAngle = void 0 !== thresholdAngle ? thresholdAngle : 1;
        var geometry2, thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle), edge = [ 0, 0 ], hash = {}, keys = [ "a", "b", "c" ];
        geometry && geometry.isBufferGeometry ? (geometry2 = new Geometry(), geometry2.fromBufferGeometry(geometry)) : geometry2 = geometry.clone(), 
        geometry2.mergeVertices(), geometry2.computeFaceNormals();
        for (var vertices = geometry2.vertices, faces = geometry2.faces, i = 0, l = faces.length; l > i; i++) for (var face = faces[i], j = 0; 3 > j; j++) {
            edge[0] = face[keys[j]], edge[1] = face[keys[(j + 1) % 3]], edge.sort(sortFunction);
            var key = edge.toString();
            void 0 === hash[key] ? hash[key] = {
                vert1: edge[0],
                vert2: edge[1],
                face1: i,
                face2: void 0
            } : hash[key].face2 = i;
        }
        var coords = [];
        for (var key in hash) {
            var h = hash[key];
            if (void 0 === h.face2 || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
                var vertex = vertices[h.vert1];
                coords.push(vertex.x), coords.push(vertex.y), coords.push(vertex.z), vertex = vertices[h.vert2], 
                coords.push(vertex.x), coords.push(vertex.y), coords.push(vertex.z);
            }
        }
        this.addAttribute("position", new BufferAttribute(new Float32Array(coords), 3));
    }
    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        function calculateVertexCount() {
            var count = (radialSegments + 1) * (heightSegments + 1);
            return openEnded === !1 && (count += (radialSegments + 1) * nbCap + radialSegments * nbCap), 
            count;
        }
        function calculateIndexCount() {
            var count = radialSegments * heightSegments * 2 * 3;
            return openEnded === !1 && (count += radialSegments * nbCap * 3), count;
        }
        function generateTorso() {
            var x, y, normal = new Vector3(), vertex = new Vector3(), groupCount = 0, slope = (radiusBottom - radiusTop) / height;
            for (y = 0; heightSegments >= y; y++) {
                var indexRow = [], v = y / heightSegments, radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; radialSegments >= x; x++) {
                    var u = x / radialSegments, theta = u * thetaLength + thetaStart, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                    vertex.x = radius * sinTheta, vertex.y = -v * height + halfHeight, vertex.z = radius * cosTheta, 
                    vertices.setXYZ(index, vertex.x, vertex.y, vertex.z), normal.set(sinTheta, slope, cosTheta).normalize(), 
                    normals.setXYZ(index, normal.x, normal.y, normal.z), uvs.setXY(index, u, 1 - v), 
                    indexRow.push(index), index++;
                }
                indexArray.push(indexRow);
            }
            for (x = 0; radialSegments > x; x++) for (y = 0; heightSegments > y; y++) {
                var i1 = indexArray[y][x], i2 = indexArray[y + 1][x], i3 = indexArray[y + 1][x + 1], i4 = indexArray[y][x + 1];
                indices.setX(indexOffset, i1), indexOffset++, indices.setX(indexOffset, i2), indexOffset++, 
                indices.setX(indexOffset, i4), indexOffset++, indices.setX(indexOffset, i2), indexOffset++, 
                indices.setX(indexOffset, i3), indexOffset++, indices.setX(indexOffset, i4), indexOffset++, 
                groupCount += 6;
            }
            scope.addGroup(groupStart, groupCount, 0), groupStart += groupCount;
        }
        function generateCap(top) {
            var x, centerIndexStart, centerIndexEnd, uv = new Vector2(), vertex = new Vector3(), groupCount = 0, radius = top === !0 ? radiusTop : radiusBottom, sign = top === !0 ? 1 : -1;
            for (centerIndexStart = index, x = 1; radialSegments >= x; x++) vertices.setXYZ(index, 0, halfHeight * sign, 0), 
            normals.setXYZ(index, 0, sign, 0), uv.x = .5, uv.y = .5, uvs.setXY(index, uv.x, uv.y), 
            index++;
            for (centerIndexEnd = index, x = 0; radialSegments >= x; x++) {
                var u = x / radialSegments, theta = u * thetaLength + thetaStart, cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
                vertex.x = radius * sinTheta, vertex.y = halfHeight * sign, vertex.z = radius * cosTheta, 
                vertices.setXYZ(index, vertex.x, vertex.y, vertex.z), normals.setXYZ(index, 0, sign, 0), 
                uv.x = .5 * cosTheta + .5, uv.y = .5 * sinTheta * sign + .5, uvs.setXY(index, uv.x, uv.y), 
                index++;
            }
            for (x = 0; radialSegments > x; x++) {
                var c = centerIndexStart + x, i = centerIndexEnd + x;
                top === !0 ? (indices.setX(indexOffset, i), indexOffset++, indices.setX(indexOffset, i + 1), 
                indexOffset++, indices.setX(indexOffset, c), indexOffset++) : (indices.setX(indexOffset, i + 1), 
                indexOffset++, indices.setX(indexOffset, i), indexOffset++, indices.setX(indexOffset, c), 
                indexOffset++), groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === !0 ? 1 : 2), groupStart += groupCount;
        }
        BufferGeometry.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        var scope = this;
        radiusTop = void 0 !== radiusTop ? radiusTop : 20, radiusBottom = void 0 !== radiusBottom ? radiusBottom : 20, 
        height = void 0 !== height ? height : 100, radialSegments = Math.floor(radialSegments) || 8, 
        heightSegments = Math.floor(heightSegments) || 1, openEnded = void 0 !== openEnded ? openEnded : !1, 
        thetaStart = void 0 !== thetaStart ? thetaStart : 0, thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI;
        var nbCap = 0;
        openEnded === !1 && (radiusTop > 0 && nbCap++, radiusBottom > 0 && nbCap++);
        var vertexCount = calculateVertexCount(), indexCount = calculateIndexCount(), indices = new BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1), vertices = new BufferAttribute(new Float32Array(3 * vertexCount), 3), normals = new BufferAttribute(new Float32Array(3 * vertexCount), 3), uvs = new BufferAttribute(new Float32Array(2 * vertexCount), 2), index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2, groupStart = 0;
        generateTorso(), openEnded === !1 && (radiusTop > 0 && generateCap(!0), radiusBottom > 0 && generateCap(!1)), 
        this.setIndex(indices), this.addAttribute("position", vertices), this.addAttribute("normal", normals), 
        this.addAttribute("uv", uvs);
    }
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength)), 
        this.mergeVertices();
    }
    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength), 
        this.type = "ConeGeometry", this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength), 
        this.type = "ConeBufferGeometry", this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
        BufferGeometry.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, radius = radius || 50, segments = void 0 !== segments ? Math.max(3, segments) : 8, 
        thetaStart = void 0 !== thetaStart ? thetaStart : 0, thetaLength = void 0 !== thetaLength ? thetaLength : 2 * Math.PI;
        var vertices = segments + 2, positions = new Float32Array(3 * vertices), normals = new Float32Array(3 * vertices), uvs = new Float32Array(2 * vertices);
        normals[2] = 1, uvs[0] = .5, uvs[1] = .5;
        for (var s = 0, i = 3, ii = 2; segments >= s; s++, i += 3, ii += 2) {
            var segment = thetaStart + s / segments * thetaLength;
            positions[i] = radius * Math.cos(segment), positions[i + 1] = radius * Math.sin(segment), 
            normals[i + 2] = 1, uvs[ii] = (positions[i] / radius + 1) / 2, uvs[ii + 1] = (positions[i + 1] / radius + 1) / 2;
        }
        for (var indices = [], i = 1; segments >= i; i++) indices.push(i, i + 1, 0);
        this.setIndex(new BufferAttribute(new Uint16Array(indices), 1)), this.addAttribute("position", new BufferAttribute(positions, 3)), 
        this.addAttribute("normal", new BufferAttribute(normals, 3)), this.addAttribute("uv", new BufferAttribute(uvs, 2)), 
        this.boundingSphere = new Sphere(new Vector3(), radius);
    }
    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
        Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        }, this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    }
    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        }, this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)), 
        this.mergeVertices();
    }
    function ShadowMaterial() {
        ShaderMaterial.call(this, {
            uniforms: UniformsUtils.merge([ UniformsLib.lights, {
                opacity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
        }), this.lights = !0, this.transparent = !0, Object.defineProperties(this, {
            opacity: {
                enumerable: !0,
                get: function() {
                    return this.uniforms.opacity.value;
                },
                set: function(value) {
                    this.uniforms.opacity.value = value;
                }
            }
        });
    }
    function RawShaderMaterial(parameters) {
        ShaderMaterial.call(this, parameters), this.type = "RawShaderMaterial";
    }
    function MultiMaterial(materials) {
        this.uuid = _Math.generateUUID(), this.type = "MultiMaterial", this.materials = materials instanceof Array ? materials : [], 
        this.visible = !0;
    }
    function MeshStandardMaterial(parameters) {
        Material.call(this), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = .5, 
        this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, 
        this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, 
        this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, 
        this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, 
        this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, 
        this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, 
        this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", 
        this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(parameters);
    }
    function MeshPhysicalMaterial(parameters) {
        MeshStandardMaterial.call(this), this.defines = {
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, 
        this.clearCoatRoughness = 0, this.setValues(parameters);
    }
    function MeshPhongMaterial(parameters) {
        Material.call(this), this.type = "MeshPhongMaterial", this.color = new Color(16777215), 
        this.specular = new Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, 
        this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), 
        this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, 
        this.normalMap = null, this.normalScale = new Vector2(1, 1), this.displacementMap = null, 
        this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, 
        this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, 
        this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", 
        this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, 
        this.setValues(parameters);
    }
    function MeshNormalMaterial(parameters) {
        Material.call(this, parameters), this.type = "MeshNormalMaterial", this.wireframe = !1, 
        this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.morphTargets = !1, 
        this.setValues(parameters);
    }
    function MeshLambertMaterial(parameters) {
        Material.call(this), this.type = "MeshLambertMaterial", this.color = new Color(16777215), 
        this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, 
        this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, 
        this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, 
        this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, 
        this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", 
        this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, 
        this.setValues(parameters);
    }
    function LineDashedMaterial(parameters) {
        Material.call(this), this.type = "LineDashedMaterial", this.color = new Color(16777215), 
        this.linewidth = 1, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, 
        this.setValues(parameters);
    }
    function LoadingManager(onLoad, onProgress, onError) {
        var scope = this, isLoading = !1, itemsLoaded = 0, itemsTotal = 0;
        this.onStart = void 0, this.onLoad = onLoad, this.onProgress = onProgress, this.onError = onError, 
        this.itemStart = function(url) {
            itemsTotal++, isLoading === !1 && void 0 !== scope.onStart && scope.onStart(url, itemsLoaded, itemsTotal), 
            isLoading = !0;
        }, this.itemEnd = function(url) {
            itemsLoaded++, void 0 !== scope.onProgress && scope.onProgress(url, itemsLoaded, itemsTotal), 
            itemsLoaded === itemsTotal && (isLoading = !1, void 0 !== scope.onLoad && scope.onLoad());
        }, this.itemError = function(url) {
            void 0 !== scope.onError && scope.onError(url);
        };
    }
    function XHRLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function CompressedTextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this._parser = null;
    }
    function BinaryTextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this._parser = null;
    }
    function ImageLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function CubeTextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function TextureLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function Light(color, intensity) {
        Object3D.call(this), this.type = "Light", this.color = new Color(color), this.intensity = void 0 !== intensity ? intensity : 1, 
        this.receiveShadow = void 0;
    }
    function HemisphereLight(skyColor, groundColor, intensity) {
        Light.call(this, skyColor, intensity), this.type = "HemisphereLight", this.castShadow = void 0, 
        this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color(groundColor);
    }
    function LightShadow(camera) {
        this.camera = camera, this.bias = 0, this.radius = 1, this.mapSize = new Vector2(512, 512), 
        this.map = null, this.matrix = new Matrix4();
    }
    function SpotLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(50, 1, .5, 500));
    }
    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
        Light.call(this, color, intensity), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), 
        this.updateMatrix(), this.target = new Object3D(), Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI;
            },
            set: function(power) {
                this.intensity = power / Math.PI;
            }
        }), this.distance = void 0 !== distance ? distance : 0, this.angle = void 0 !== angle ? angle : Math.PI / 3, 
        this.penumbra = void 0 !== penumbra ? penumbra : 0, this.decay = void 0 !== decay ? decay : 1, 
        this.shadow = new SpotLightShadow();
    }
    function PointLight(color, intensity, distance, decay) {
        Light.call(this, color, intensity), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI;
            },
            set: function(power) {
                this.intensity = power / (4 * Math.PI);
            }
        }), this.distance = void 0 !== distance ? distance : 0, this.decay = void 0 !== decay ? decay : 1, 
        this.shadow = new LightShadow(new PerspectiveCamera(90, 1, .5, 500));
    }
    function DirectionalLightShadow(light) {
        LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, .5, 500));
    }
    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), 
        this.updateMatrix(), this.target = new Object3D(), this.shadow = new DirectionalLightShadow();
    }
    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity), this.type = "AmbientLight", this.castShadow = void 0;
    }
    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions, this._cachedIndex = 0, this.resultBuffer = void 0 !== resultBuffer ? resultBuffer : new sampleValues.constructor(sampleSize), 
        this.sampleValues = sampleValues, this.valueSize = sampleSize;
    }
    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer), 
        this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
    }
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    function KeyframeTrackConstructor(name, times, values, interpolation) {
        if (void 0 === name) throw new Error("track name is undefined");
        if (void 0 === times || 0 === times.length) throw new Error("no keyframes in track named " + name);
        this.name = name, this.times = AnimationUtils.convertArray(times, this.TimeBufferType), 
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType), this.setInterpolation(interpolation || this.DefaultInterpolation), 
        this.validate(), this.optimize();
    }
    function VectorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    function QuaternionKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function NumberKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function StringKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function BooleanKeyframeTrack(name, times, values) {
        KeyframeTrackConstructor.call(this, name, times, values);
    }
    function ColorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.call(this, name, times, values, interpolation);
    }
    function KeyframeTrack(name, times, values, interpolation) {
        KeyframeTrackConstructor.apply(this, arguments);
    }
    function AnimationClip(name, duration, tracks) {
        this.name = name, this.tracks = tracks, this.duration = void 0 !== duration ? duration : -1, 
        this.uuid = _Math.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize();
    }
    function MaterialLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this.textures = {};
    }
    function BufferGeometryLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function Loader() {
        this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {};
    }
    function JSONLoader(manager) {
        "boolean" == typeof manager && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), 
        manager = void 0), this.manager = void 0 !== manager ? manager : DefaultLoadingManager, 
        this.withCredentials = !1;
    }
    function ObjectLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this.texturePath = "";
    }
    function Curve() {}
    function LineCurve(v1, v2) {
        this.v1 = v1, this.v2 = v2;
    }
    function CurvePath() {
        this.curves = [], this.autoClose = !1;
    }
    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        this.aX = aX, this.aY = aY, this.xRadius = xRadius, this.yRadius = yRadius, this.aStartAngle = aStartAngle, 
        this.aEndAngle = aEndAngle, this.aClockwise = aClockwise, this.aRotation = aRotation || 0;
    }
    function SplineCurve(points) {
        this.points = void 0 === points ? [] : points;
    }
    function CubicBezierCurve(v0, v1, v2, v3) {
        this.v0 = v0, this.v1 = v1, this.v2 = v2, this.v3 = v3;
    }
    function QuadraticBezierCurve(v0, v1, v2) {
        this.v0 = v0, this.v1 = v1, this.v2 = v2;
    }
    function Shape() {
        Path.apply(this, arguments), this.holes = [];
    }
    function Path(points) {
        CurvePath.call(this), this.currentPoint = new Vector2(), points && this.fromPoints(points);
    }
    function ShapePath() {
        this.subPaths = [], this.currentPath = null;
    }
    function Font(data) {
        this.data = data;
    }
    function FontLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function getAudioContext() {
        return void 0 === context && (context = new (window.AudioContext || window.webkitAudioContext)()), 
        context;
    }
    function AudioLoader(manager) {
        this.manager = void 0 !== manager ? manager : DefaultLoadingManager;
    }
    function StereoCamera() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new PerspectiveCamera(), 
        this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera(), 
        this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1;
    }
    function CubeCamera(near, far, cubeResolution) {
        Object3D.call(this), this.type = "CubeCamera";
        var fov = 90, aspect = 1, cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.up.set(0, -1, 0), cameraPX.lookAt(new Vector3(1, 0, 0)), this.add(cameraPX);
        var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.up.set(0, -1, 0), cameraNX.lookAt(new Vector3(-1, 0, 0)), this.add(cameraNX);
        var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.up.set(0, 0, 1), cameraPY.lookAt(new Vector3(0, 1, 0)), this.add(cameraPY);
        var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.up.set(0, 0, -1), cameraNY.lookAt(new Vector3(0, -1, 0)), this.add(cameraNY);
        var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.up.set(0, -1, 0), cameraPZ.lookAt(new Vector3(0, 0, 1)), this.add(cameraPZ);
        var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.up.set(0, -1, 0), cameraNZ.lookAt(new Vector3(0, 0, -1)), this.add(cameraNZ);
        var options = {
            format: RGBFormat,
            magFilter: LinearFilter,
            minFilter: LinearFilter
        };
        this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options), 
        this.updateCubeMap = function(renderer, scene) {
            null === this.parent && this.updateMatrixWorld();
            var renderTarget = this.renderTarget, generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = !1, renderTarget.activeCubeFace = 0, renderer.render(scene, cameraPX, renderTarget), 
            renderTarget.activeCubeFace = 1, renderer.render(scene, cameraNX, renderTarget), 
            renderTarget.activeCubeFace = 2, renderer.render(scene, cameraPY, renderTarget), 
            renderTarget.activeCubeFace = 3, renderer.render(scene, cameraNY, renderTarget), 
            renderTarget.activeCubeFace = 4, renderer.render(scene, cameraPZ, renderTarget), 
            renderTarget.texture.generateMipmaps = generateMipmaps, renderTarget.activeCubeFace = 5, 
            renderer.render(scene, cameraNZ, renderTarget), renderer.setRenderTarget(null);
        };
    }
    function AudioListener() {
        Object3D.call(this), this.type = "AudioListener", this.context = getAudioContext(), 
        this.gain = this.context.createGain(), this.gain.connect(this.context.destination), 
        this.filter = null;
    }
    function Audio(listener) {
        Object3D.call(this), this.type = "Audio", this.context = listener.context, this.source = this.context.createBufferSource(), 
        this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), 
        this.gain.connect(listener.getInput()), this.autoplay = !1, this.startTime = 0, 
        this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", 
        this.filters = [];
    }
    function PositionalAudio(listener) {
        Audio.call(this, listener), this.panner = this.context.createPanner(), this.panner.connect(this.gain);
    }
    function AudioAnalyser(audio, fftSize) {
        this.analyser = audio.context.createAnalyser(), this.analyser.fftSize = void 0 !== fftSize ? fftSize : 2048, 
        this.data = new Uint8Array(this.analyser.frequencyBinCount), audio.getOutput().connect(this.analyser);
    }
    function PropertyMixer(binding, typeName, valueSize) {
        this.binding = binding, this.valueSize = valueSize;
        var mixFunction, bufferType = Float64Array;
        switch (typeName) {
          case "quaternion":
            mixFunction = this._slerp;
            break;

          case "string":
          case "bool":
            bufferType = Array, mixFunction = this._select;
            break;

          default:
            mixFunction = this._lerp;
        }
        this.buffer = new bufferType(4 * valueSize), this._mixBufferRegion = mixFunction, 
        this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0;
    }
    function PropertyBinding(rootNode, path, parsedPath) {
        this.path = path, this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path), 
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode, 
        this.rootNode = rootNode;
    }
    function AnimationObjectGroup(var_args) {
        this.uuid = _Math.generateUUID(), this._objects = Array.prototype.slice.call(arguments), 
        this.nCachedObjects_ = 0;
        var indices = {};
        this._indicesByUUID = indices;
        for (var i = 0, n = arguments.length; i !== n; ++i) indices[arguments[i].uuid] = i;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var scope = this;
        this.stats = {
            objects: {
                get total() {
                    return scope._objects.length;
                },
                get inUse() {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject() {
                return scope._bindings.length;
            }
        };
    }
    function AnimationAction(mixer, clip, localRoot) {
        this._mixer = mixer, this._clip = clip, this._localRoot = localRoot || null;
        for (var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks), interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        }, i = 0; i !== nTracks; ++i) {
            var interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant, interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings, this._interpolants = interpolants, 
        this._propertyBindings = new Array(nTracks), this._cacheIndex = null, this._byClipCacheIndex = null, 
        this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, 
        this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, 
        this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, 
        this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, 
        this.zeroSlopeAtEnd = !0;
    }
    function AnimationMixer(root) {
        this._root = root, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, 
        this.timeScale = 1;
    }
    function Uniform(value) {
        "string" == typeof value && (console.warn("THREE.Uniform: Type parameter is no longer needed."), 
        value = arguments[1]), this.value = value;
    }
    function InstancedBufferGeometry() {
        BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0;
    }
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
        this.uuid = _Math.generateUUID(), this.data = interleavedBuffer, this.itemSize = itemSize, 
        this.offset = offset, this.normalized = normalized === !0;
    }
    function InterleavedBuffer(array, stride) {
        this.uuid = _Math.generateUUID(), this.array = array, this.stride = stride, this.count = void 0 !== array ? array.length / stride : 0, 
        this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0;
    }
    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
        InterleavedBuffer.call(this, array, stride), this.meshPerAttribute = meshPerAttribute || 1;
    }
    function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
        BufferAttribute.call(this, array, itemSize), this.meshPerAttribute = meshPerAttribute || 1;
    }
    function Raycaster(origin, direction, near, far) {
        this.ray = new Ray(origin, direction), this.near = near || 0, this.far = far || 1 / 0, 
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), 
                    this.Points;
                }
            }
        });
    }
    function ascSort(a, b) {
        return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects, recursive) {
        if (object.visible !== !1 && (object.raycast(raycaster, intersects), recursive === !0)) for (var children = object.children, i = 0, l = children.length; l > i; i++) intersectObject(children[i], raycaster, intersects, !0);
    }
    function Clock(autoStart) {
        this.autoStart = void 0 !== autoStart ? autoStart : !0, this.startTime = 0, this.oldTime = 0, 
        this.elapsedTime = 0, this.running = !1;
    }
    function Spline(points) {
        function interpolate(p0, p1, p2, p3, t, t2, t3) {
            var v0 = .5 * (p2 - p0), v1 = .5 * (p3 - p1);
            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
        this.points = points;
        var point, intPoint, weight, w2, w3, pa, pb, pc, pd, c = [], v3 = {
            x: 0,
            y: 0,
            z: 0
        };
        this.initFromArray = function(a) {
            this.points = [];
            for (var i = 0; i < a.length; i++) this.points[i] = {
                x: a[i][0],
                y: a[i][1],
                z: a[i][2]
            };
        }, this.getPoint = function(k) {
            return point = (this.points.length - 1) * k, intPoint = Math.floor(point), weight = point - intPoint, 
            c[0] = 0 === intPoint ? intPoint : intPoint - 1, c[1] = intPoint, c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1, 
            c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2, 
            pa = this.points[c[0]], pb = this.points[c[1]], pc = this.points[c[2]], pd = this.points[c[3]], 
            w2 = weight * weight, w3 = weight * w2, v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3), 
            v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3), v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3), 
            v3;
        }, this.getControlPointsArray = function() {
            var i, p, l = this.points.length, coords = [];
            for (i = 0; l > i; i++) p = this.points[i], coords[i] = [ p.x, p.y, p.z ];
            return coords;
        }, this.getLength = function(nSubDivisions) {
            var i, index, nSamples, position, point = 0, intPoint = 0, oldIntPoint = 0, oldPosition = new Vector3(), tmpVec = new Vector3(), chunkLengths = [], totalLength = 0;
            for (chunkLengths[0] = 0, nSubDivisions || (nSubDivisions = 100), nSamples = this.points.length * nSubDivisions, 
            oldPosition.copy(this.points[0]), i = 1; nSamples > i; i++) index = i / nSamples, 
            position = this.getPoint(index), tmpVec.copy(position), totalLength += tmpVec.distanceTo(oldPosition), 
            oldPosition.copy(position), point = (this.points.length - 1) * index, intPoint = Math.floor(point), 
            intPoint !== oldIntPoint && (chunkLengths[intPoint] = totalLength, oldIntPoint = intPoint);
            return chunkLengths[chunkLengths.length] = totalLength, {
                chunks: chunkLengths,
                total: totalLength
            };
        }, this.reparametrizeByArcLength = function(samplingCoef) {
            var i, j, index, indexCurrent, indexNext, realDistance, sampling, position, newpoints = [], tmpVec = new Vector3(), sl = this.getLength();
            for (newpoints.push(tmpVec.copy(this.points[0]).clone()), i = 1; i < this.points.length; i++) {
                for (realDistance = sl.chunks[i] - sl.chunks[i - 1], sampling = Math.ceil(samplingCoef * realDistance / sl.total), 
                indexCurrent = (i - 1) / (this.points.length - 1), indexNext = i / (this.points.length - 1), 
                j = 1; sampling - 1 > j; j++) index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent), 
                position = this.getPoint(index), newpoints.push(tmpVec.copy(position).clone());
                newpoints.push(tmpVec.copy(this.points[i]).clone());
            }
            this.points = newpoints;
        };
    }
    function Spherical(radius, phi, theta) {
        return this.radius = void 0 !== radius ? radius : 1, this.phi = void 0 !== phi ? phi : 0, 
        this.theta = void 0 !== theta ? theta : 0, this;
    }
    function MorphBlendMesh(geometry, material) {
        Mesh.call(this, geometry, material), this.animationsMap = {}, this.animationsList = [];
        var numFrames = this.geometry.morphTargets.length, name = "__default", startFrame = 0, endFrame = numFrames - 1, fps = numFrames / 1;
        this.createAnimation(name, startFrame, endFrame, fps), this.setAnimationWeight(name, 1);
    }
    function ImmediateRenderObject(material) {
        Object3D.call(this), this.material = material, this.render = function(renderCallback) {};
    }
    function VertexNormalsHelper(object, size, hex, linewidth) {
        this.object = object, this.size = void 0 !== size ? size : 1;
        var color = void 0 !== hex ? hex : 16711680, width = void 0 !== linewidth ? linewidth : 1, nNormals = 0, objGeometry = this.object.geometry;
        objGeometry && objGeometry.isGeometry ? nNormals = 3 * objGeometry.faces.length : objGeometry && objGeometry.isBufferGeometry && (nNormals = objGeometry.attributes.normal.count);
        var geometry = new BufferGeometry(), positions = new Float32Attribute(2 * nNormals * 3, 3);
        geometry.addAttribute("position", positions), LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function SpotLightHelper(light) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld, 
        this.matrixAutoUpdate = !1;
        for (var geometry = new BufferGeometry(), positions = [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1 ], i = 0, j = 1, l = 32; l > i; i++, 
        j++) {
            var p1 = i / l * Math.PI * 2, p2 = j / l * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.addAttribute("position", new Float32Attribute(positions, 3));
        var material = new LineBasicMaterial({
            fog: !1
        });
        this.cone = new LineSegments(geometry, material), this.add(this.cone), this.update();
    }
    function SkeletonHelper(object) {
        this.bones = this.getBoneList(object);
        for (var geometry = new Geometry(), i = 0; i < this.bones.length; i++) {
            var bone = this.bones[i];
            bone.parent && bone.parent.isBone && (geometry.vertices.push(new Vector3()), geometry.vertices.push(new Vector3()), 
            geometry.colors.push(new Color(0, 0, 1)), geometry.colors.push(new Color(0, 1, 0)));
        }
        geometry.dynamic = !0;
        var material = new LineBasicMaterial({
            vertexColors: VertexColors,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        LineSegments.call(this, geometry, material), this.root = object, this.matrix = object.matrixWorld, 
        this.matrixAutoUpdate = !1, this.update();
    }
    function PointLightHelper(light, sphereSize) {
        this.light = light, this.light.updateMatrixWorld();
        var geometry = new SphereBufferGeometry(sphereSize, 4, 2), material = new MeshBasicMaterial({
            wireframe: !0,
            fog: !1
        });
        material.color.copy(this.light.color).multiplyScalar(this.light.intensity), Mesh.call(this, geometry, material), 
        this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1;
    }
    function HemisphereLightHelper(light, sphereSize) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld, 
        this.matrixAutoUpdate = !1, this.colors = [ new Color(), new Color() ];
        var geometry = new SphereGeometry(sphereSize, 4, 2);
        geometry.rotateX(-Math.PI / 2);
        for (var i = 0, il = 8; il > i; i++) geometry.faces[i].color = this.colors[4 > i ? 0 : 1];
        var material = new MeshBasicMaterial({
            vertexColors: FaceColors,
            wireframe: !0
        });
        this.lightSphere = new Mesh(geometry, material), this.add(this.lightSphere), this.update();
    }
    function GridHelper(size, divisions, color1, color2) {
        divisions = divisions || 1, color1 = new Color(void 0 !== color1 ? color1 : 4473924), 
        color2 = new Color(void 0 !== color2 ? color2 : 8947848);
        for (var center = divisions / 2, step = 2 * size / divisions, vertices = [], colors = [], i = 0, j = 0, k = -size; divisions >= i; i++, 
        k += step) {
            vertices.push(-size, 0, k, size, 0, k), vertices.push(k, 0, -size, k, 0, size);
            var color = i === center ? color1 : color2;
            color.toArray(colors, j), j += 3, color.toArray(colors, j), j += 3, color.toArray(colors, j), 
            j += 3, color.toArray(colors, j), j += 3;
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32Attribute(vertices, 3)), geometry.addAttribute("color", new Float32Attribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    function FaceNormalsHelper(object, size, hex, linewidth) {
        this.object = object, this.size = void 0 !== size ? size : 1;
        var color = void 0 !== hex ? hex : 16776960, width = void 0 !== linewidth ? linewidth : 1, nNormals = 0, objGeometry = this.object.geometry;
        objGeometry && objGeometry.isGeometry ? nNormals = objGeometry.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var geometry = new BufferGeometry(), positions = new Float32Attribute(2 * nNormals * 3, 3);
        geometry.addAttribute("position", positions), LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        })), this.matrixAutoUpdate = !1, this.update();
    }
    function DirectionalLightHelper(light, size) {
        Object3D.call(this), this.light = light, this.light.updateMatrixWorld(), this.matrix = light.matrixWorld, 
        this.matrixAutoUpdate = !1, void 0 === size && (size = 1);
        var geometry = new BufferGeometry();
        geometry.addAttribute("position", new Float32Attribute([ -size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0 ], 3));
        var material = new LineBasicMaterial({
            fog: !1
        });
        this.add(new Line(geometry, material)), geometry = new BufferGeometry(), geometry.addAttribute("position", new Float32Attribute([ 0, 0, 0, 0, 0, 1 ], 3)), 
        this.add(new Line(geometry, material)), this.update();
    }
    function CameraHelper(camera) {
        function addLine(a, b, hex) {
            addPoint(a, hex), addPoint(b, hex);
        }
        function addPoint(id, hex) {
            geometry.vertices.push(new Vector3()), geometry.colors.push(new Color(hex)), void 0 === pointMap[id] && (pointMap[id] = []), 
            pointMap[id].push(geometry.vertices.length - 1);
        }
        var geometry = new Geometry(), material = new LineBasicMaterial({
            color: 16777215,
            vertexColors: FaceColors
        }), pointMap = {}, hexFrustum = 16755200, hexCone = 16711680, hexUp = 43775, hexTarget = 16777215, hexCross = 3355443;
        addLine("n1", "n2", hexFrustum), addLine("n2", "n4", hexFrustum), addLine("n4", "n3", hexFrustum), 
        addLine("n3", "n1", hexFrustum), addLine("f1", "f2", hexFrustum), addLine("f2", "f4", hexFrustum), 
        addLine("f4", "f3", hexFrustum), addLine("f3", "f1", hexFrustum), addLine("n1", "f1", hexFrustum), 
        addLine("n2", "f2", hexFrustum), addLine("n3", "f3", hexFrustum), addLine("n4", "f4", hexFrustum), 
        addLine("p", "n1", hexCone), addLine("p", "n2", hexCone), addLine("p", "n3", hexCone), 
        addLine("p", "n4", hexCone), addLine("u1", "u2", hexUp), addLine("u2", "u3", hexUp), 
        addLine("u3", "u1", hexUp), addLine("c", "t", hexTarget), addLine("p", "c", hexCross), 
        addLine("cn1", "cn2", hexCross), addLine("cn3", "cn4", hexCross), addLine("cf1", "cf2", hexCross), 
        addLine("cf3", "cf4", hexCross), LineSegments.call(this, geometry, material), this.camera = camera, 
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = camera.matrixWorld, 
        this.matrixAutoUpdate = !1, this.pointMap = pointMap, this.update();
    }
    function BoundingBoxHelper(object, hex) {
        var color = void 0 !== hex ? hex : 8947848;
        this.object = object, this.box = new Box3(), Mesh.call(this, new BoxGeometry(1, 1, 1), new MeshBasicMaterial({
            color: color,
            wireframe: !0
        }));
    }
    function BoxHelper(object, color) {
        void 0 === color && (color = 16776960);
        var indices = new Uint16Array([ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ]), positions = new Float32Array(24), geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1)), geometry.addAttribute("position", new BufferAttribute(positions, 3)), 
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        })), void 0 !== object && this.update(object);
    }
    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        Object3D.call(this), void 0 === color && (color = 16776960), void 0 === length && (length = 1), 
        void 0 === headLength && (headLength = .2 * length), void 0 === headWidth && (headWidth = .2 * headLength), 
        this.position.copy(origin), this.line = new Line(lineGeometry, new LineBasicMaterial({
            color: color
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
            color: color
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(dir), 
        this.setLength(length, headLength, headWidth);
    }
    function AxisHelper(size) {
        size = size || 1;
        var vertices = new Float32Array([ 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size ]), colors = new Float32Array([ 1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1 ]), geometry = new BufferGeometry();
        geometry.addAttribute("position", new BufferAttribute(vertices, 3)), geometry.addAttribute("color", new BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    function ClosedSplineCurve3(points) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."), 
        CatmullRomCurve3.call(this, points), this.type = "catmullrom", this.closed = !0;
    }
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    }
    function Face4(a, b, c, d, normal, color, materialIndex) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), 
        new Face3(a, b, c, normal, color, materialIndex);
    }
    function PointCloud(geometry, material) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Points(geometry, material);
    }
    function ParticleSystem(geometry, material) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Points(geometry, material);
    }
    function PointCloudMaterial(parameters) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), 
        new PointsMaterial(parameters);
    }
    function ParticleBasicMaterial(parameters) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), 
        new PointsMaterial(parameters);
    }
    function ParticleSystemMaterial(parameters) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), 
        new PointsMaterial(parameters);
    }
    function Vertex(x, y, z) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), 
        new Vector3(x, y, z);
    }
    function EdgesHelper(object, hex) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), 
        new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
            color: void 0 !== hex ? hex : 16777215
        }));
    }
    function WireframeHelper(object, hex) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), 
        new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
            color: void 0 !== hex ? hex : 16777215
        }));
    }
    function Projector() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), 
        this.projectVector = function(vector, camera) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), vector.project(camera);
        }, this.unprojectVector = function(vector, camera) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), 
            vector.unproject(camera);
        }, this.pickingRay = function(vector, camera) {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().");
        };
    }
    function CanvasRenderer() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), 
        this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), 
        this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, 
        this.setSize = function() {};
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function(x) {
        return 0 > x ? -1 : x > 0 ? 1 : +x;
    }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
        }
    }), void 0 === Object.assign && !function() {
        Object.assign = function(target) {
            if (void 0 === target || null === target) throw new TypeError("Cannot convert undefined or null to object");
            for (var output = Object(target), index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (void 0 !== source && null !== source) for (var nextKey in source) Object.prototype.hasOwnProperty.call(source, nextKey) && (output[nextKey] = source[nextKey]);
            }
            return output;
        };
    }(), Object.assign(EventDispatcher.prototype, {
        addEventListener: function(type, listener) {
            void 0 === this._listeners && (this._listeners = {});
            var listeners = this._listeners;
            void 0 === listeners[type] && (listeners[type] = []), -1 === listeners[type].indexOf(listener) && listeners[type].push(listener);
        },
        hasEventListener: function(type, listener) {
            if (void 0 === this._listeners) return !1;
            var listeners = this._listeners;
            return void 0 !== listeners[type] && -1 !== listeners[type].indexOf(listener);
        },
        removeEventListener: function(type, listener) {
            if (void 0 !== this._listeners) {
                var listeners = this._listeners, listenerArray = listeners[type];
                if (void 0 !== listenerArray) {
                    var index = listenerArray.indexOf(listener);
                    -1 !== index && listenerArray.splice(index, 1);
                }
            }
        },
        dispatchEvent: function(event) {
            if (void 0 !== this._listeners) {
                var listeners = this._listeners, listenerArray = listeners[event.type];
                if (void 0 !== listenerArray) {
                    event.target = this;
                    var array = [], i = 0, length = listenerArray.length;
                    for (i = 0; length > i; i++) array[i] = listenerArray[i];
                    for (i = 0; length > i; i++) array[i].call(this, event);
                }
            }
        }
    });
    var REVISION = "82", MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, CullFaceFrontBack = 3, FrontFaceDirectionCW = 0, FrontFaceDirectionCCW = 1, BasicShadowMap = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, FrontSide = 0, BackSide = 1, DoubleSide = 2, FlatShading = 1, SmoothShading = 2, NoColors = 0, FaceColors = 1, VertexColors = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, BlendingMode = {
        NoBlending: NoBlending,
        NormalBlending: NormalBlending,
        AdditiveBlending: AdditiveBlending,
        SubtractiveBlending: SubtractiveBlending,
        MultiplyBlending: MultiplyBlending,
        CustomBlending: CustomBlending
    }, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, Uncharted2ToneMapping = 3, CineonToneMapping = 4, UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, SphericalReflectionMapping = 305, CubeUVReflectionMapping = 306, CubeUVRefractionMapping = 307, TextureMapping = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    }, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, TextureWrapping = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    }, NearestFilter = 1003, NearestMipMapNearestFilter = 1004, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipMapNearestFilter = 1007, LinearMipMapLinearFilter = 1008, TextureFilter = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    }, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedShort565Type = 1019, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, RGBEFormat = RGBAFormat, DepthFormat = 1026, DepthStencilFormat = 1027, RGB_S3TC_DXT1_Format = 2001, RGBA_S3TC_DXT1_Format = 2002, RGBA_S3TC_DXT3_Format = 2003, RGBA_S3TC_DXT5_Format = 2004, RGB_PVRTC_4BPPV1_Format = 2100, RGB_PVRTC_2BPPV1_Format = 2101, RGBA_PVRTC_4BPPV1_Format = 2102, RGBA_PVRTC_2BPPV1_Format = 2103, RGB_ETC1_Format = 2151, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, LinearEncoding = 3e3, sRGBEncoding = 3001, GammaEncoding = 3007, RGBEEncoding = 3002, LogLuvEncoding = 3003, RGBM7Encoding = 3004, RGBM16Encoding = 3005, RGBDEncoding = 3006, BasicDepthPacking = 3200, RGBADepthPacking = 3201, _Math = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            var r, chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), uuid = new Array(36), rnd = 0;
            return function() {
                for (var i = 0; 36 > i; i++) 8 === i || 13 === i || 18 === i || 23 === i ? uuid[i] = "-" : 14 === i ? uuid[i] = "4" : (2 >= rnd && (rnd = 33554432 + 16777216 * Math.random() | 0), 
                r = 15 & rnd, rnd >>= 4, uuid[i] = chars[19 === i ? 3 & r | 8 : r]);
                return uuid.join("");
            };
        }(),
        clamp: function(value, min, max) {
            return Math.max(min, Math.min(max, value));
        },
        euclideanModulo: function(n, m) {
            return (n % m + m) % m;
        },
        mapLinear: function(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        lerp: function(x, y, t) {
            return (1 - t) * x + t * y;
        },
        smoothstep: function(x, min, max) {
            return min >= x ? 0 : x >= max ? 1 : (x = (x - min) / (max - min), x * x * (3 - 2 * x));
        },
        smootherstep: function(x, min, max) {
            return min >= x ? 0 : x >= max ? 1 : (x = (x - min) / (max - min), x * x * x * (x * (6 * x - 15) + 10));
        },
        random16: function() {
            return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), 
            Math.random();
        },
        randInt: function(low, high) {
            return low + Math.floor(Math.random() * (high - low + 1));
        },
        randFloat: function(low, high) {
            return low + Math.random() * (high - low);
        },
        randFloatSpread: function(range) {
            return range * (.5 - Math.random());
        },
        degToRad: function(degrees) {
            return degrees * _Math.DEG2RAD;
        },
        radToDeg: function(radians) {
            return radians * _Math.RAD2DEG;
        },
        isPowerOfTwo: function(value) {
            return 0 === (value & value - 1) && 0 !== value;
        },
        nearestPowerOfTwo: function(value) {
            return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
        },
        nextPowerOfTwo: function(value) {
            return value--, value |= value >> 1, value |= value >> 2, value |= value >> 4, value |= value >> 8, 
            value |= value >> 16, value++, value;
        }
    };
    Vector2.prototype = {
        constructor: Vector2,
        isVector2: !0,
        get width() {
            return this.x;
        },
        set width(value) {
            this.x = value;
        },
        get height() {
            return this.y;
        },
        set height(value) {
            this.y = value;
        },
        set: function(x, y) {
            return this.x = x, this.y = y, this;
        },
        setScalar: function(scalar) {
            return this.x = scalar, this.y = scalar, this;
        },
        setX: function(x) {
            return this.x = x, this;
        },
        setY: function(y) {
            return this.y = y, this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y);
        },
        copy: function(v) {
            return this.x = v.x, this.y = v.y, this;
        },
        add: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
            this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this);
        },
        addScalar: function(s) {
            return this.x += s, this.y += s, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this;
        },
        addScaledVector: function(v, s) {
            return this.x += v.x * s, this.y += v.y * s, this;
        },
        sub: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
            this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this);
        },
        subScalar: function(s) {
            return this.x -= s, this.y -= s, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this;
        },
        multiply: function(v) {
            return this.x *= v.x, this.y *= v.y, this;
        },
        multiplyScalar: function(scalar) {
            return isFinite(scalar) ? (this.x *= scalar, this.y *= scalar) : (this.x = 0, this.y = 0), 
            this;
        },
        divide: function(v) {
            return this.x /= v.x, this.y /= v.y, this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        min: function(v) {
            return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this;
        },
        max: function(v) {
            return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this;
        },
        clamp: function(min, max) {
            return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), 
            this;
        },
        clampScalar: function() {
            var min, max;
            return function(minVal, maxVal) {
                return void 0 === min && (min = new Vector2(), max = new Vector2()), min.set(minVal, minVal), 
                max.set(maxVal, maxVal), this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), 
            this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function() {
            return this.divideScalar(this.length());
        },
        angle: function() {
            var angle = Math.atan2(this.y, this.x);
            return 0 > angle && (angle += 2 * Math.PI), angle;
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
        },
        distanceToManhattan: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        },
        setLength: function(length) {
            return this.multiplyScalar(length / this.length());
        },
        lerp: function(v, alpha) {
            return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1], 
            this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x, 
            array[offset + 1] = this.y, array;
        },
        fromAttribute: function(attribute, index, offset) {
            return void 0 === offset && (offset = 0), index = index * attribute.itemSize + offset, 
            this.x = attribute.array[index], this.y = attribute.array[index + 1], this;
        },
        rotateAround: function(center, angle) {
            var c = Math.cos(angle), s = Math.sin(angle), x = this.x - center.x, y = this.y - center.y;
            return this.x = x * c - y * s + center.x, this.y = x * s + y * c + center.y, this;
        }
    }, Texture.DEFAULT_IMAGE = void 0, Texture.DEFAULT_MAPPING = UVMapping, Texture.prototype = {
        constructor: Texture,
        isTexture: !0,
        set needsUpdate(value) {
            value === !0 && this.version++;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            return this.image = source.image, this.mipmaps = source.mipmaps.slice(0), this.mapping = source.mapping, 
            this.wrapS = source.wrapS, this.wrapT = source.wrapT, this.magFilter = source.magFilter, 
            this.minFilter = source.minFilter, this.anisotropy = source.anisotropy, this.format = source.format, 
            this.type = source.type, this.offset.copy(source.offset), this.repeat.copy(source.repeat), 
            this.generateMipmaps = source.generateMipmaps, this.premultiplyAlpha = source.premultiplyAlpha, 
            this.flipY = source.flipY, this.unpackAlignment = source.unpackAlignment, this.encoding = source.encoding, 
            this;
        },
        toJSON: function(meta) {
            function getDataURL(image) {
                var canvas;
                return void 0 !== image.toDataURL ? canvas = image : (canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), 
                canvas.width = image.width, canvas.height = image.height, canvas.getContext("2d").drawImage(image, 0, 0, image.width, image.height)), 
                canvas.width > 2048 || canvas.height > 2048 ? canvas.toDataURL("image/jpeg", .6) : canvas.toDataURL("image/png");
            }
            if (void 0 !== meta.textures[this.uuid]) return meta.textures[this.uuid];
            var output = {
                metadata: {
                    version: 4.4,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [ this.repeat.x, this.repeat.y ],
                offset: [ this.offset.x, this.offset.y ],
                wrap: [ this.wrapS, this.wrapT ],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var image = this.image;
                void 0 === image.uuid && (image.uuid = _Math.generateUUID()), void 0 === meta.images[image.uuid] && (meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: getDataURL(image)
                }), output.image = image.uuid;
            }
            return meta.textures[this.uuid] = output, output;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        },
        transformUv: function(uv) {
            if (this.mapping === UVMapping) {
                if (uv.multiply(this.repeat), uv.add(this.offset), uv.x < 0 || uv.x > 1) switch (this.wrapS) {
                  case RepeatWrapping:
                    uv.x = uv.x - Math.floor(uv.x);
                    break;

                  case ClampToEdgeWrapping:
                    uv.x = uv.x < 0 ? 0 : 1;
                    break;

                  case MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(uv.x) % 2) ? uv.x = Math.ceil(uv.x) - uv.x : uv.x = uv.x - Math.floor(uv.x);
                }
                if (uv.y < 0 || uv.y > 1) switch (this.wrapT) {
                  case RepeatWrapping:
                    uv.y = uv.y - Math.floor(uv.y);
                    break;

                  case ClampToEdgeWrapping:
                    uv.y = uv.y < 0 ? 0 : 1;
                    break;

                  case MirroredRepeatWrapping:
                    1 === Math.abs(Math.floor(uv.y) % 2) ? uv.y = Math.ceil(uv.y) - uv.y : uv.y = uv.y - Math.floor(uv.y);
                }
                this.flipY && (uv.y = 1 - uv.y);
            }
        }
    }, Object.assign(Texture.prototype, EventDispatcher.prototype);
    var count = 0;
    Vector4.prototype = {
        constructor: Vector4,
        isVector4: !0,
        set: function(x, y, z, w) {
            return this.x = x, this.y = y, this.z = z, this.w = w, this;
        },
        setScalar: function(scalar) {
            return this.x = scalar, this.y = scalar, this.z = scalar, this.w = scalar, this;
        },
        setX: function(x) {
            return this.x = x, this;
        },
        setY: function(y) {
            return this.y = y, this;
        },
        setZ: function(z) {
            return this.z = z, this;
        },
        setW: function(w) {
            return this.w = w, this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              case 2:
                this.z = value;
                break;

              case 3:
                this.w = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              case 3:
                return this.w;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function(v) {
            return this.x = v.x, this.y = v.y, this.z = v.z, this.w = void 0 !== v.w ? v.w : 1, 
            this;
        },
        add: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
            this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this.z += v.z, this.w += v.w, 
            this);
        },
        addScalar: function(s) {
            return this.x += s, this.y += s, this.z += s, this.w += s, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, 
            this;
        },
        addScaledVector: function(v, s) {
            return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this.w += v.w * s, 
            this;
        },
        sub: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
            this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this.z -= v.z, this.w -= v.w, 
            this);
        },
        subScalar: function(s) {
            return this.x -= s, this.y -= s, this.z -= s, this.w -= s, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, 
            this;
        },
        multiplyScalar: function(scalar) {
            return isFinite(scalar) ? (this.x *= scalar, this.y *= scalar, this.z *= scalar, 
            this.w *= scalar) : (this.x = 0, this.y = 0, this.z = 0, this.w = 0), this;
        },
        applyMatrix4: function(m) {
            var x = this.x, y = this.y, z = this.z, w = this.w, e = m.elements;
            return this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w, this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w, 
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w, this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w, 
            this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        setAxisAngleFromQuaternion: function(q) {
            this.w = 2 * Math.acos(q.w);
            var s = Math.sqrt(1 - q.w * q.w);
            return 1e-4 > s ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = q.x / s, this.y = q.y / s, 
            this.z = q.z / s), this;
        },
        setAxisAngleFromRotationMatrix: function(m) {
            var angle, x, y, z, epsilon = .01, epsilon2 = .1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
                if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) return this.set(1, 0, 0, 0), 
                this;
                angle = Math.PI;
                var xx = (m11 + 1) / 2, yy = (m22 + 1) / 2, zz = (m33 + 1) / 2, xy = (m12 + m21) / 4, xz = (m13 + m31) / 4, yz = (m23 + m32) / 4;
                return xx > yy && xx > zz ? epsilon > xx ? (x = 0, y = .707106781, z = .707106781) : (x = Math.sqrt(xx), 
                y = xy / x, z = xz / x) : yy > zz ? epsilon > yy ? (x = .707106781, y = 0, z = .707106781) : (y = Math.sqrt(yy), 
                x = xy / y, z = yz / y) : epsilon > zz ? (x = .707106781, y = .707106781, z = 0) : (z = Math.sqrt(zz), 
                x = xz / z, y = yz / z), this.set(x, y, z, angle), this;
            }
            var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
            return Math.abs(s) < .001 && (s = 1), this.x = (m32 - m23) / s, this.y = (m13 - m31) / s, 
            this.z = (m21 - m12) / s, this.w = Math.acos((m11 + m22 + m33 - 1) / 2), this;
        },
        min: function(v) {
            return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), 
            this.w = Math.min(this.w, v.w), this;
        },
        max: function(v) {
            return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), 
            this.w = Math.max(this.w, v.w), this;
        },
        clamp: function(min, max) {
            return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), 
            this.z = Math.max(min.z, Math.min(max.z, this.z)), this.w = Math.max(min.w, Math.min(max.w, this.w)), 
            this;
        },
        clampScalar: function() {
            var min, max;
            return function(minVal, maxVal) {
                return void 0 === min && (min = new Vector4(), max = new Vector4()), min.set(minVal, minVal, minVal, minVal), 
                max.set(maxVal, maxVal, maxVal, maxVal), this.clamp(min, max);
            };
        }(),
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
            this.w = Math.floor(this.w), this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
            this.w = Math.ceil(this.w), this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
            this.w = Math.round(this.w), this;
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), 
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), 
            this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        },
        normalize: function() {
            return this.divideScalar(this.length());
        },
        setLength: function(length) {
            return this.multiplyScalar(length / this.length());
        },
        lerp: function(v, alpha) {
            return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha, 
            this.w += (v.w - this.w) * alpha, this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1], 
            this.z = array[offset + 2], this.w = array[offset + 3], this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x, 
            array[offset + 1] = this.y, array[offset + 2] = this.z, array[offset + 3] = this.w, 
            array;
        },
        fromAttribute: function(attribute, index, offset) {
            return void 0 === offset && (offset = 0), index = index * attribute.itemSize + offset, 
            this.x = attribute.array[index], this.y = attribute.array[index + 1], this.z = attribute.array[index + 2], 
            this.w = attribute.array[index + 3], this;
        }
    }, Object.assign(WebGLRenderTarget.prototype, EventDispatcher.prototype, {
        isWebGLRenderTarget: !0,
        setSize: function(width, height) {
            this.width === width && this.height === height || (this.width = width, this.height = height, 
            this.dispose()), this.viewport.set(0, 0, width, height), this.scissor.set(0, 0, width, height);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            return this.width = source.width, this.height = source.height, this.viewport.copy(source.viewport), 
            this.texture = source.texture.clone(), this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, 
            this.depthTexture = source.depthTexture, this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype), 
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube, WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = !0, 
    Quaternion.prototype = {
        constructor: Quaternion,
        get x() {
            return this._x;
        },
        set x(value) {
            this._x = value, this.onChangeCallback();
        },
        get y() {
            return this._y;
        },
        set y(value) {
            this._y = value, this.onChangeCallback();
        },
        get z() {
            return this._z;
        },
        set z(value) {
            this._z = value, this.onChangeCallback();
        },
        get w() {
            return this._w;
        },
        set w(value) {
            this._w = value, this.onChangeCallback();
        },
        set: function(x, y, z, w) {
            return this._x = x, this._y = y, this._z = z, this._w = w, this.onChangeCallback(), 
            this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function(quaternion) {
            return this._x = quaternion.x, this._y = quaternion.y, this._z = quaternion.z, this._w = quaternion.w, 
            this.onChangeCallback(), this;
        },
        setFromEuler: function(euler, update) {
            if ((euler && euler.isEuler) === !1) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var c1 = Math.cos(euler._x / 2), c2 = Math.cos(euler._y / 2), c3 = Math.cos(euler._z / 2), s1 = Math.sin(euler._x / 2), s2 = Math.sin(euler._y / 2), s3 = Math.sin(euler._z / 2), order = euler.order;
            return "XYZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, 
            this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "YXZ" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, 
            this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3) : "ZXY" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3, 
            this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "ZYX" === order ? (this._x = s1 * c2 * c3 - c1 * s2 * s3, 
            this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3) : "YZX" === order ? (this._x = s1 * c2 * c3 + c1 * s2 * s3, 
            this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3) : "XZY" === order && (this._x = s1 * c2 * c3 - c1 * s2 * s3, 
            this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3), 
            update !== !1 && this.onChangeCallback(), this;
        },
        setFromAxisAngle: function(axis, angle) {
            var halfAngle = angle / 2, s = Math.sin(halfAngle);
            return this._x = axis.x * s, this._y = axis.y * s, this._z = axis.z * s, this._w = Math.cos(halfAngle), 
            this.onChangeCallback(), this;
        },
        setFromRotationMatrix: function(m) {
            var s, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
            return trace > 0 ? (s = .5 / Math.sqrt(trace + 1), this._w = .25 / s, this._x = (m32 - m23) * s, 
            this._y = (m13 - m31) * s, this._z = (m21 - m12) * s) : m11 > m22 && m11 > m33 ? (s = 2 * Math.sqrt(1 + m11 - m22 - m33), 
            this._w = (m32 - m23) / s, this._x = .25 * s, this._y = (m12 + m21) / s, this._z = (m13 + m31) / s) : m22 > m33 ? (s = 2 * Math.sqrt(1 + m22 - m11 - m33), 
            this._w = (m13 - m31) / s, this._x = (m12 + m21) / s, this._y = .25 * s, this._z = (m23 + m32) / s) : (s = 2 * Math.sqrt(1 + m33 - m11 - m22), 
            this._w = (m21 - m12) / s, this._x = (m13 + m31) / s, this._y = (m23 + m32) / s, 
            this._z = .25 * s), this.onChangeCallback(), this;
        },
        setFromUnitVectors: function() {
            var v1, r, EPS = 1e-6;
            return function(vFrom, vTo) {
                return void 0 === v1 && (v1 = new Vector3()), r = vFrom.dot(vTo) + 1, EPS > r ? (r = 0, 
                Math.abs(vFrom.x) > Math.abs(vFrom.z) ? v1.set(-vFrom.y, vFrom.x, 0) : v1.set(0, -vFrom.z, vFrom.y)) : v1.crossVectors(vFrom, vTo), 
                this._x = v1.x, this._y = v1.y, this._z = v1.z, this._w = r, this.normalize();
            };
        }(),
        inverse: function() {
            return this.conjugate().normalize();
        },
        conjugate: function() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this;
        },
        dot: function(v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        },
        normalize: function() {
            var l = this.length();
            return 0 === l ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (l = 1 / l, 
            this._x = this._x * l, this._y = this._y * l, this._z = this._z * l, this._w = this._w * l), 
            this.onChangeCallback(), this;
        },
        multiply: function(q, p) {
            return void 0 !== p ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), 
            this.multiplyQuaternions(q, p)) : this.multiplyQuaternions(this, q);
        },
        premultiply: function(q) {
            return this.multiplyQuaternions(q, this);
        },
        multiplyQuaternions: function(a, b) {
            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w, qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
            return this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby, this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz, 
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx, this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz, 
            this.onChangeCallback(), this;
        },
        slerp: function(qb, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(qb);
            var x = this._x, y = this._y, z = this._z, w = this._w, cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (0 > cosHalfTheta ? (this._w = -qb._w, this._x = -qb._x, this._y = -qb._y, this._z = -qb._z, 
            cosHalfTheta = -cosHalfTheta) : this.copy(qb), cosHalfTheta >= 1) return this._w = w, 
            this._x = x, this._y = y, this._z = z, this;
            var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < .001) return this._w = .5 * (w + this._w), this._x = .5 * (x + this._x), 
            this._y = .5 * (y + this._y), this._z = .5 * (z + this._z), this;
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta), ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            return this._w = w * ratioA + this._w * ratioB, this._x = x * ratioA + this._x * ratioB, 
            this._y = y * ratioA + this._y * ratioB, this._z = z * ratioA + this._z * ratioB, 
            this.onChangeCallback(), this;
        },
        equals: function(quaternion) {
            return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this._x = array[offset], this._y = array[offset + 1], 
            this._z = array[offset + 2], this._w = array[offset + 3], this.onChangeCallback(), 
            this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this._x, 
            array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._w, 
            array;
        },
        onChange: function(callback) {
            return this.onChangeCallback = callback, this;
        },
        onChangeCallback: function() {}
    }, Object.assign(Quaternion, {
        slerp: function(qa, qb, qm, t) {
            return qm.copy(qa).slerp(qb, t);
        },
        slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
                if (sqrSin > Number.EPSILON) {
                    var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                    s = Math.sin(s * len) / sin, t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                if (x0 = x0 * s + x1 * tDir, y0 = y0 * s + y1 * tDir, z0 = z0 * s + z1 * tDir, w0 = w0 * s + w1 * tDir, 
                s === 1 - t) {
                    var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f, y0 *= f, z0 *= f, w0 *= f;
                }
            }
            dst[dstOffset] = x0, dst[dstOffset + 1] = y0, dst[dstOffset + 2] = z0, dst[dstOffset + 3] = w0;
        }
    }), Vector3.prototype = {
        constructor: Vector3,
        isVector3: !0,
        set: function(x, y, z) {
            return this.x = x, this.y = y, this.z = z, this;
        },
        setScalar: function(scalar) {
            return this.x = scalar, this.y = scalar, this.z = scalar, this;
        },
        setX: function(x) {
            return this.x = x, this;
        },
        setY: function(y) {
            return this.y = y, this;
        },
        setZ: function(z) {
            return this.z = z, this;
        },
        setComponent: function(index, value) {
            switch (index) {
              case 0:
                this.x = value;
                break;

              case 1:
                this.y = value;
                break;

              case 2:
                this.z = value;
                break;

              default:
                throw new Error("index is out of range: " + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
              case 0:
                return this.x;

              case 1:
                return this.y;

              case 2:
                return this.z;

              default:
                throw new Error("index is out of range: " + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z);
        },
        copy: function(v) {
            return this.x = v.x, this.y = v.y, this.z = v.z, this;
        },
        add: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), 
            this.addVectors(v, w)) : (this.x += v.x, this.y += v.y, this.z += v.z, this);
        },
        addScalar: function(s) {
            return this.x += s, this.y += s, this.z += s, this;
        },
        addVectors: function(a, b) {
            return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this;
        },
        addScaledVector: function(v, s) {
            return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this;
        },
        sub: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), 
            this.subVectors(v, w)) : (this.x -= v.x, this.y -= v.y, this.z -= v.z, this);
        },
        subScalar: function(s) {
            return this.x -= s, this.y -= s, this.z -= s, this;
        },
        subVectors: function(a, b) {
            return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this;
        },
        multiply: function(v, w) {
            return void 0 !== w ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), 
            this.multiplyVectors(v, w)) : (this.x *= v.x, this.y *= v.y, this.z *= v.z, this);
        },
        multiplyScalar: function(scalar) {
            return isFinite(scalar) ? (this.x *= scalar, this.y *= scalar, this.z *= scalar) : (this.x = 0, 
            this.y = 0, this.z = 0), this;
        },
        multiplyVectors: function(a, b) {
            return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this;
        },
        applyEuler: function() {
            var quaternion;
            return function(euler) {
                return (euler && euler.isEuler) === !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), 
                void 0 === quaternion && (quaternion = new Quaternion()), this.applyQuaternion(quaternion.setFromEuler(euler));
            };
        }(),
        applyAxisAngle: function() {
            var quaternion;
            return function(axis, angle) {
                return void 0 === quaternion && (quaternion = new Quaternion()), this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
            };
        }(),
        applyMatrix3: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements;
            return this.x = e[0] * x + e[3] * y + e[6] * z, this.y = e[1] * x + e[4] * y + e[7] * z, 
            this.z = e[2] * x + e[5] * y + e[8] * z, this;
        },
        applyMatrix4: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements;
            return this.x = e[0] * x + e[4] * y + e[8] * z + e[12], this.y = e[1] * x + e[5] * y + e[9] * z + e[13], 
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14], this;
        },
        applyProjection: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements, d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
            return this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d, this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d, 
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d, this;
        },
        applyQuaternion: function(q) {
            var x = this.x, y = this.y, z = this.z, qx = q.x, qy = q.y, qz = q.z, qw = q.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            return this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy, this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz, 
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx, this;
        },
        project: function() {
            var matrix;
            return function(camera) {
                return void 0 === matrix && (matrix = new Matrix4()), matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld)), 
                this.applyProjection(matrix);
            };
        }(),
        unproject: function() {
            var matrix;
            return function(camera) {
                return void 0 === matrix && (matrix = new Matrix4()), matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix)), 
                this.applyProjection(matrix);
            };
        }(),
        transformDirection: function(m) {
            var x = this.x, y = this.y, z = this.z, e = m.elements;
            return this.x = e[0] * x + e[4] * y + e[8] * z, this.y = e[1] * x + e[5] * y + e[9] * z, 
            this.z = e[2] * x + e[6] * y + e[10] * z, this.normalize();
        },
        divide: function(v) {
            return this.x /= v.x, this.y /= v.y, this.z /= v.z, this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        min: function(v) {
            return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), 
            this;
        },
        max: function(v) {
            return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), 
            this;
        },
        clamp: function(min, max) {
            return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), 
            this.z = Math.max(min.z, Math.min(max.z, this.z)), this;
        },
        clampScalar: function() {
            var min, max;
            return function(minVal, maxVal) {
                return void 0 === min && (min = new Vector3(), max = new Vector3()), min.set(minVal, minVal, minVal), 
                max.set(maxVal, maxVal, maxVal), this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
        },
        floor: function() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), 
            this;
        },
        ceil: function() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), 
            this;
        },
        round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), 
            this;
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), 
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
        },
        negate: function() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function() {
            return this.divideScalar(this.length());
        },
        setLength: function(length) {
            return this.multiplyScalar(length / this.length());
        },
        lerp: function(v, alpha) {
            return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha, 
            this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        cross: function(v, w) {
            if (void 0 !== w) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), 
            this.crossVectors(v, w);
            var x = this.x, y = this.y, z = this.z;
            return this.x = y * v.z - z * v.y, this.y = z * v.x - x * v.z, this.z = x * v.y - y * v.x, 
            this;
        },
        crossVectors: function(a, b) {
            var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
            return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
            this;
        },
        projectOnVector: function(vector) {
            var scalar = vector.dot(this) / vector.lengthSq();
            return this.copy(vector).multiplyScalar(scalar);
        },
        projectOnPlane: function() {
            var v1;
            return function(planeNormal) {
                return void 0 === v1 && (v1 = new Vector3()), v1.copy(this).projectOnVector(planeNormal), 
                this.sub(v1);
            };
        }(),
        reflect: function() {
            var v1;
            return function(normal) {
                return void 0 === v1 && (v1 = new Vector3()), this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
            };
        }(),
        angleTo: function(v) {
            var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
            return Math.acos(_Math.clamp(theta, -1, 1));
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        },
        distanceToManhattan: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        },
        setFromSpherical: function(s) {
            var sinPhiRadius = Math.sin(s.phi) * s.radius;
            return this.x = sinPhiRadius * Math.sin(s.theta), this.y = Math.cos(s.phi) * s.radius, 
            this.z = sinPhiRadius * Math.cos(s.theta), this;
        },
        setFromMatrixPosition: function(m) {
            return this.setFromMatrixColumn(m, 3);
        },
        setFromMatrixScale: function(m) {
            var sx = this.setFromMatrixColumn(m, 0).length(), sy = this.setFromMatrixColumn(m, 1).length(), sz = this.setFromMatrixColumn(m, 2).length();
            return this.x = sx, this.y = sy, this.z = sz, this;
        },
        setFromMatrixColumn: function(m, index) {
            if ("number" == typeof m) {
                console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
                var temp = m;
                m = index, index = temp;
            }
            return this.fromArray(m.elements, 4 * index);
        },
        equals: function(v) {
            return v.x === this.x && v.y === this.y && v.z === this.z;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.x = array[offset], this.y = array[offset + 1], 
            this.z = array[offset + 2], this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.x, 
            array[offset + 1] = this.y, array[offset + 2] = this.z, array;
        },
        fromAttribute: function(attribute, index, offset) {
            return void 0 === offset && (offset = 0), index = index * attribute.itemSize + offset, 
            this.x = attribute.array[index], this.y = attribute.array[index + 1], this.z = attribute.array[index + 2], 
            this;
        }
    }, Matrix4.prototype = {
        constructor: Matrix4,
        isMatrix4: !0,
        set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            return te[0] = n11, te[4] = n12, te[8] = n13, te[12] = n14, te[1] = n21, te[5] = n22, 
            te[9] = n23, te[13] = n24, te[2] = n31, te[6] = n32, te[10] = n33, te[14] = n34, 
            te[3] = n41, te[7] = n42, te[11] = n43, te[15] = n44, this;
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        },
        clone: function() {
            return new Matrix4().fromArray(this.elements);
        },
        copy: function(m) {
            return this.elements.set(m.elements), this;
        },
        copyPosition: function(m) {
            var te = this.elements, me = m.elements;
            return te[12] = me[12], te[13] = me[13], te[14] = me[14], this;
        },
        extractBasis: function(xAxis, yAxis, zAxis) {
            return xAxis.setFromMatrixColumn(this, 0), yAxis.setFromMatrixColumn(this, 1), zAxis.setFromMatrixColumn(this, 2), 
            this;
        },
        makeBasis: function(xAxis, yAxis, zAxis) {
            return this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1), 
            this;
        },
        extractRotation: function() {
            var v1;
            return function(m) {
                void 0 === v1 && (v1 = new Vector3());
                var te = this.elements, me = m.elements, scaleX = 1 / v1.setFromMatrixColumn(m, 0).length(), scaleY = 1 / v1.setFromMatrixColumn(m, 1).length(), scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                return te[0] = me[0] * scaleX, te[1] = me[1] * scaleX, te[2] = me[2] * scaleX, te[4] = me[4] * scaleY, 
                te[5] = me[5] * scaleY, te[6] = me[6] * scaleY, te[8] = me[8] * scaleZ, te[9] = me[9] * scaleZ, 
                te[10] = me[10] * scaleZ, this;
            };
        }(),
        makeRotationFromEuler: function(euler) {
            (euler && euler.isEuler) === !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var te = this.elements, x = euler.x, y = euler.y, z = euler.z, a = Math.cos(x), b = Math.sin(x), c = Math.cos(y), d = Math.sin(y), e = Math.cos(z), f = Math.sin(z);
            if ("XYZ" === euler.order) {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e, te[4] = -c * f, te[8] = d, te[1] = af + be * d, te[5] = ae - bf * d, 
                te[9] = -b * c, te[2] = bf - ae * d, te[6] = be + af * d, te[10] = a * c;
            } else if ("YXZ" === euler.order) {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b, te[4] = de * b - cf, te[8] = a * d, te[1] = a * f, te[5] = a * e, 
                te[9] = -b, te[2] = cf * b - de, te[6] = df + ce * b, te[10] = a * c;
            } else if ("ZXY" === euler.order) {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b, te[4] = -a * f, te[8] = de + cf * b, te[1] = cf + de * b, te[5] = a * e, 
                te[9] = df - ce * b, te[2] = -a * d, te[6] = b, te[10] = a * c;
            } else if ("ZYX" === euler.order) {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e, te[4] = be * d - af, te[8] = ae * d + bf, te[1] = c * f, te[5] = bf * d + ae, 
                te[9] = af * d - be, te[2] = -d, te[6] = b * c, te[10] = a * c;
            } else if ("YZX" === euler.order) {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e, te[4] = bd - ac * f, te[8] = bc * f + ad, te[1] = f, te[5] = a * e, 
                te[9] = -b * e, te[2] = -d * e, te[6] = ad * f + bc, te[10] = ac - bd * f;
            } else if ("XZY" === euler.order) {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e, te[4] = -f, te[8] = d * e, te[1] = ac * f + bd, te[5] = a * e, te[9] = ad * f - bc, 
                te[2] = bc * f - ad, te[6] = b * e, te[10] = bd * f + ac;
            }
            return te[3] = 0, te[7] = 0, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1, 
            this;
        },
        makeRotationFromQuaternion: function(q) {
            var te = this.elements, x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return te[0] = 1 - (yy + zz), te[4] = xy - wz, te[8] = xz + wy, te[1] = xy + wz, 
            te[5] = 1 - (xx + zz), te[9] = yz - wx, te[2] = xz - wy, te[6] = yz + wx, te[10] = 1 - (xx + yy), 
            te[3] = 0, te[7] = 0, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1, 
            this;
        },
        lookAt: function() {
            var x, y, z;
            return function(eye, target, up) {
                void 0 === x && (x = new Vector3(), y = new Vector3(), z = new Vector3());
                var te = this.elements;
                return z.subVectors(eye, target).normalize(), 0 === z.lengthSq() && (z.z = 1), x.crossVectors(up, z).normalize(), 
                0 === x.lengthSq() && (z.z += 1e-4, x.crossVectors(up, z).normalize()), y.crossVectors(z, x), 
                te[0] = x.x, te[4] = y.x, te[8] = z.x, te[1] = x.y, te[5] = y.y, te[9] = z.y, te[2] = x.z, 
                te[6] = y.z, te[10] = z.z, this;
            };
        }(),
        multiply: function(m, n) {
            return void 0 !== n ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), 
            this.multiplyMatrices(m, n)) : this.multiplyMatrices(this, m);
        },
        premultiply: function(m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function(a, b) {
            var ae = a.elements, be = b.elements, te = this.elements, a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12], a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13], a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14], a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15], b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12], b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13], b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14], b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            return te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, 
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, 
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, 
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, 
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, 
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, 
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, 
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44, 
            this;
        },
        multiplyToArray: function(a, b, r) {
            var te = this.elements;
            return this.multiplyMatrices(a, b), r[0] = te[0], r[1] = te[1], r[2] = te[2], r[3] = te[3], 
            r[4] = te[4], r[5] = te[5], r[6] = te[6], r[7] = te[7], r[8] = te[8], r[9] = te[9], 
            r[10] = te[10], r[11] = te[11], r[12] = te[12], r[13] = te[13], r[14] = te[14], 
            r[15] = te[15], this;
        },
        multiplyScalar: function(s) {
            var te = this.elements;
            return te[0] *= s, te[4] *= s, te[8] *= s, te[12] *= s, te[1] *= s, te[5] *= s, 
            te[9] *= s, te[13] *= s, te[2] *= s, te[6] *= s, te[10] *= s, te[14] *= s, te[3] *= s, 
            te[7] *= s, te[11] *= s, te[15] *= s, this;
        },
        applyToVector3Array: function() {
            var v1;
            return function(array, offset, length) {
                void 0 === v1 && (v1 = new Vector3()), void 0 === offset && (offset = 0), void 0 === length && (length = array.length);
                for (var i = 0, j = offset; length > i; i += 3, j += 3) v1.fromArray(array, j), 
                v1.applyMatrix4(this), v1.toArray(array, j);
                return array;
            };
        }(),
        applyToBuffer: function() {
            var v1;
            return function(buffer, offset, length) {
                void 0 === v1 && (v1 = new Vector3()), void 0 === offset && (offset = 0), void 0 === length && (length = buffer.length / buffer.itemSize);
                for (var i = 0, j = offset; length > i; i++, j++) v1.x = buffer.getX(j), v1.y = buffer.getY(j), 
                v1.z = buffer.getZ(j), v1.applyMatrix4(this), buffer.setXYZ(j, v1.x, v1.y, v1.z);
                return buffer;
            };
        }(),
        determinant: function() {
            var te = this.elements, n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12], n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13], n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14], n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
            return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
        },
        transpose: function() {
            var tmp, te = this.elements;
            return tmp = te[1], te[1] = te[4], te[4] = tmp, tmp = te[2], te[2] = te[8], te[8] = tmp, 
            tmp = te[6], te[6] = te[9], te[9] = tmp, tmp = te[3], te[3] = te[12], te[12] = tmp, 
            tmp = te[7], te[7] = te[13], te[13] = tmp, tmp = te[11], te[11] = te[14], te[14] = tmp, 
            this;
        },
        flattenToArrayOffset: function(array, offset) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."), 
            this.toArray(array, offset);
        },
        getPosition: function() {
            var v1;
            return function() {
                return void 0 === v1 && (v1 = new Vector3()), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), 
                v1.setFromMatrixColumn(this, 3);
            };
        }(),
        setPosition: function(v) {
            var te = this.elements;
            return te[12] = v.x, te[13] = v.y, te[14] = v.z, this;
        },
        getInverse: function(m, throwOnDegenerate) {
            var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34, det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (0 === det) {
                var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                if (throwOnDegenerate === !0) throw new Error(msg);
                return console.warn(msg), this.identity();
            }
            var detInv = 1 / det;
            return te[0] = t11 * detInv, te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv, 
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv, 
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv, 
            te[4] = t12 * detInv, te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv, 
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv, 
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv, 
            te[8] = t13 * detInv, te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv, 
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv, 
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv, 
            te[12] = t14 * detInv, te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv, 
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv, 
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv, 
            this;
        },
        scale: function(v) {
            var te = this.elements, x = v.x, y = v.y, z = v.z;
            return te[0] *= x, te[4] *= y, te[8] *= z, te[1] *= x, te[5] *= y, te[9] *= z, te[2] *= x, 
            te[6] *= y, te[10] *= z, te[3] *= x, te[7] *= y, te[11] *= z, this;
        },
        getMaxScaleOnAxis: function() {
            var te = this.elements, scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2], scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6], scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        },
        makeTranslation: function(x, y, z) {
            return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1), this;
        },
        makeRotationX: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1), this;
        },
        makeRotationY: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1), this;
        },
        makeRotationZ: function(theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        },
        makeRotationAxis: function(axis, angle) {
            var c = Math.cos(angle), s = Math.sin(angle), t = 1 - c, x = axis.x, y = axis.y, z = axis.z, tx = t * x, ty = t * y;
            return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1), 
            this;
        },
        makeScale: function(x, y, z) {
            return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1), this;
        },
        compose: function(position, quaternion, scale) {
            return this.makeRotationFromQuaternion(quaternion), this.scale(scale), this.setPosition(position), 
            this;
        },
        decompose: function() {
            var vector, matrix;
            return function(position, quaternion, scale) {
                void 0 === vector && (vector = new Vector3(), matrix = new Matrix4());
                var te = this.elements, sx = vector.set(te[0], te[1], te[2]).length(), sy = vector.set(te[4], te[5], te[6]).length(), sz = vector.set(te[8], te[9], te[10]).length(), det = this.determinant();
                0 > det && (sx = -sx), position.x = te[12], position.y = te[13], position.z = te[14], 
                matrix.elements.set(this.elements);
                var invSX = 1 / sx, invSY = 1 / sy, invSZ = 1 / sz;
                return matrix.elements[0] *= invSX, matrix.elements[1] *= invSX, matrix.elements[2] *= invSX, 
                matrix.elements[4] *= invSY, matrix.elements[5] *= invSY, matrix.elements[6] *= invSY, 
                matrix.elements[8] *= invSZ, matrix.elements[9] *= invSZ, matrix.elements[10] *= invSZ, 
                quaternion.setFromRotationMatrix(matrix), scale.x = sx, scale.y = sy, scale.z = sz, 
                this;
            };
        }(),
        makeFrustum: function(left, right, bottom, top, near, far) {
            var te = this.elements, x = 2 * near / (right - left), y = 2 * near / (top - bottom), a = (right + left) / (right - left), b = (top + bottom) / (top - bottom), c = -(far + near) / (far - near), d = -2 * far * near / (far - near);
            return te[0] = x, te[4] = 0, te[8] = a, te[12] = 0, te[1] = 0, te[5] = y, te[9] = b, 
            te[13] = 0, te[2] = 0, te[6] = 0, te[10] = c, te[14] = d, te[3] = 0, te[7] = 0, 
            te[11] = -1, te[15] = 0, this;
        },
        makePerspective: function(fov, aspect, near, far) {
            var ymax = near * Math.tan(_Math.DEG2RAD * fov * .5), ymin = -ymax, xmin = ymin * aspect, xmax = ymax * aspect;
            return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
        },
        makeOrthographic: function(left, right, top, bottom, near, far) {
            var te = this.elements, w = 1 / (right - left), h = 1 / (top - bottom), p = 1 / (far - near), x = (right + left) * w, y = (top + bottom) * h, z = (far + near) * p;
            return te[0] = 2 * w, te[4] = 0, te[8] = 0, te[12] = -x, te[1] = 0, te[5] = 2 * h, 
            te[9] = 0, te[13] = -y, te[2] = 0, te[6] = 0, te[10] = -2 * p, te[14] = -z, te[3] = 0, 
            te[7] = 0, te[11] = 0, te[15] = 1, this;
        },
        equals: function(matrix) {
            for (var te = this.elements, me = matrix.elements, i = 0; 16 > i; i++) if (te[i] !== me[i]) return !1;
            return !0;
        },
        fromArray: function(array, offset) {
            void 0 === offset && (offset = 0);
            for (var i = 0; 16 > i; i++) this.elements[i] = array[i + offset];
            return this;
        },
        toArray: function(array, offset) {
            void 0 === array && (array = []), void 0 === offset && (offset = 0);
            var te = this.elements;
            return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2], 
            array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5], 
            array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8], 
            array[offset + 9] = te[9], array[offset + 10] = te[10], array[offset + 11] = te[11], 
            array[offset + 12] = te[12], array[offset + 13] = te[13], array[offset + 14] = te[14], 
            array[offset + 15] = te[15], array;
        }
    }, CubeTexture.prototype = Object.create(Texture.prototype), CubeTexture.prototype.constructor = CubeTexture, 
    CubeTexture.prototype.isCubeTexture = !0, Object.defineProperty(CubeTexture.prototype, "images", {
        get: function() {
            return this.image;
        },
        set: function(value) {
            this.image = value;
        }
    });
    var emptyTexture = new Texture(), emptyCubeTexture = new CubeTexture(), arrayCacheF32 = [], arrayCacheI32 = [];
    StructuredUniform.prototype.setValue = function(gl, value) {
        for (var seq = this.seq, i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.setValue(gl, value[u.id]);
        }
    };
    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    WebGLUniforms.prototype.setValue = function(gl, name, value) {
        var u = this.map[name];
        void 0 !== u && u.setValue(gl, value, this.renderer);
    }, WebGLUniforms.prototype.set = function(gl, object, name) {
        var u = this.map[name];
        void 0 !== u && u.setValue(gl, object[name], this.renderer);
    }, WebGLUniforms.prototype.setOptional = function(gl, object, name) {
        var v = object[name];
        void 0 !== v && this.setValue(gl, name, v);
    }, WebGLUniforms.upload = function(gl, seq, values, renderer) {
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i], v = values[u.id];
            v.needsUpdate !== !1 && u.setValue(gl, v.value, renderer);
        }
    }, WebGLUniforms.seqWithValue = function(seq, values) {
        for (var r = [], i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.id in values && r.push(u);
        }
        return r;
    };
    var UniformsUtils = {
        merge: function(uniforms) {
            for (var merged = {}, u = 0; u < uniforms.length; u++) {
                var tmp = this.clone(uniforms[u]);
                for (var p in tmp) merged[p] = tmp[p];
            }
            return merged;
        },
        clone: function(uniforms_src) {
            var uniforms_dst = {};
            for (var u in uniforms_src) {
                uniforms_dst[u] = {};
                for (var p in uniforms_src[u]) {
                    var parameter_src = uniforms_src[u][p];
                    parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture) ? uniforms_dst[u][p] = parameter_src.clone() : Array.isArray(parameter_src) ? uniforms_dst[u][p] = parameter_src.slice() : uniforms_dst[u][p] = parameter_src;
                }
            }
            return uniforms_dst;
        }
    }, alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n", alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n", aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex = "\nvec3 transformed = vec3( position );\n", beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n", bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n		if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n			return distanceFalloff * maxDistanceCutoffFactor;\n#else\n			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n		}\n		return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n", clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n		vec4 plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n		\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n			vec4 plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	\n	#endif\n#endif\n", clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n", clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n", color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n", color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif", color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif", common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n", cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n", defaultnormal_vertex = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n", displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n", displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n", encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n", envmap_fragment = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n", envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n", envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n", envmap_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n", fog_fragment = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", lightmap_fragment = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n", lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#include <normal_flip>\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#include <normal_flip>\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n", lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n", lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n", lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifndef STANDARD\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifndef STANDARD\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		float dotNL = dotNV;\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	#ifndef STANDARD\n		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n	#else\n		vec3 clearCoatRadiance = vec3( 0.0 );\n	#endif\n		\n	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n", logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n", logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif", logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n", map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n", map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n", map_particle_fragment = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", map_particle_pars_fragment = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n", metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n", metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n", normal_flip = "#ifdef DOUBLE_SIDED\n	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n	float flipNormal = 1.0;\n#endif\n", normal_fragment = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n", packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", project_vertex = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n", roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n", roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n", shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n", shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n", shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n", skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n", skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n", skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif", uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n", uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif", uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif", uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif", worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n", cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	gl_FragColor.a *= opacity;\n}\n", cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n", depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n", depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n", distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n", distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition;\n}\n", equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n}\n", equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}\n", linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n", meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight;\n	reflectedLight.directDiffuse = vec3( 0.0 );\n	reflectedLight.directSpecular = vec3( 0.0 );\n	reflectedLight.indirectDiffuse = diffuseColor.rgb;\n	reflectedLight.indirectSpecular = vec3( 0.0 );\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n}\n", meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n}\n", meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n}\n", meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n", normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n	#include <logdepthbuf_fragment>\n}\n", normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vNormal = normalize( normalMatrix * normal );\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n", points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n", shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n", shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n", ShaderChunk = {
        alphamap_fragment: alphamap_fragment,
        alphamap_pars_fragment: alphamap_pars_fragment,
        alphatest_fragment: alphatest_fragment,
        aomap_fragment: aomap_fragment,
        aomap_pars_fragment: aomap_pars_fragment,
        begin_vertex: begin_vertex,
        beginnormal_vertex: beginnormal_vertex,
        bsdfs: bsdfs,
        bumpmap_pars_fragment: bumpmap_pars_fragment,
        clipping_planes_fragment: clipping_planes_fragment,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex,
        clipping_planes_vertex: clipping_planes_vertex,
        color_fragment: color_fragment,
        color_pars_fragment: color_pars_fragment,
        color_pars_vertex: color_pars_vertex,
        color_vertex: color_vertex,
        common: common,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment,
        defaultnormal_vertex: defaultnormal_vertex,
        displacementmap_pars_vertex: displacementmap_pars_vertex,
        displacementmap_vertex: displacementmap_vertex,
        emissivemap_fragment: emissivemap_fragment,
        emissivemap_pars_fragment: emissivemap_pars_fragment,
        encodings_fragment: encodings_fragment,
        encodings_pars_fragment: encodings_pars_fragment,
        envmap_fragment: envmap_fragment,
        envmap_pars_fragment: envmap_pars_fragment,
        envmap_pars_vertex: envmap_pars_vertex,
        envmap_vertex: envmap_vertex,
        fog_fragment: fog_fragment,
        fog_pars_fragment: fog_pars_fragment,
        lightmap_fragment: lightmap_fragment,
        lightmap_pars_fragment: lightmap_pars_fragment,
        lights_lambert_vertex: lights_lambert_vertex,
        lights_pars: lights_pars,
        lights_phong_fragment: lights_phong_fragment,
        lights_phong_pars_fragment: lights_phong_pars_fragment,
        lights_physical_fragment: lights_physical_fragment,
        lights_physical_pars_fragment: lights_physical_pars_fragment,
        lights_template: lights_template,
        logdepthbuf_fragment: logdepthbuf_fragment,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
        logdepthbuf_vertex: logdepthbuf_vertex,
        map_fragment: map_fragment,
        map_pars_fragment: map_pars_fragment,
        map_particle_fragment: map_particle_fragment,
        map_particle_pars_fragment: map_particle_pars_fragment,
        metalnessmap_fragment: metalnessmap_fragment,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment,
        morphnormal_vertex: morphnormal_vertex,
        morphtarget_pars_vertex: morphtarget_pars_vertex,
        morphtarget_vertex: morphtarget_vertex,
        normal_flip: normal_flip,
        normal_fragment: normal_fragment,
        normalmap_pars_fragment: normalmap_pars_fragment,
        packing: packing,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment,
        project_vertex: project_vertex,
        roughnessmap_fragment: roughnessmap_fragment,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment,
        shadowmap_pars_fragment: shadowmap_pars_fragment,
        shadowmap_pars_vertex: shadowmap_pars_vertex,
        shadowmap_vertex: shadowmap_vertex,
        shadowmask_pars_fragment: shadowmask_pars_fragment,
        skinbase_vertex: skinbase_vertex,
        skinning_pars_vertex: skinning_pars_vertex,
        skinning_vertex: skinning_vertex,
        skinnormal_vertex: skinnormal_vertex,
        specularmap_fragment: specularmap_fragment,
        specularmap_pars_fragment: specularmap_pars_fragment,
        tonemapping_fragment: tonemapping_fragment,
        tonemapping_pars_fragment: tonemapping_pars_fragment,
        uv_pars_fragment: uv_pars_fragment,
        uv_pars_vertex: uv_pars_vertex,
        uv_vertex: uv_vertex,
        uv2_pars_fragment: uv2_pars_fragment,
        uv2_pars_vertex: uv2_pars_vertex,
        uv2_vertex: uv2_vertex,
        worldpos_vertex: worldpos_vertex,
        cube_frag: cube_frag,
        cube_vert: cube_vert,
        depth_frag: depth_frag,
        depth_vert: depth_vert,
        distanceRGBA_frag: distanceRGBA_frag,
        distanceRGBA_vert: distanceRGBA_vert,
        equirect_frag: equirect_frag,
        equirect_vert: equirect_vert,
        linedashed_frag: linedashed_frag,
        linedashed_vert: linedashed_vert,
        meshbasic_frag: meshbasic_frag,
        meshbasic_vert: meshbasic_vert,
        meshlambert_frag: meshlambert_frag,
        meshlambert_vert: meshlambert_vert,
        meshphong_frag: meshphong_frag,
        meshphong_vert: meshphong_vert,
        meshphysical_frag: meshphysical_frag,
        meshphysical_vert: meshphysical_vert,
        normal_frag: normal_frag,
        normal_vert: normal_vert,
        points_frag: points_frag,
        points_vert: points_vert,
        shadow_frag: shadow_frag,
        shadow_vert: shadow_vert
    };
    Color.prototype = {
        constructor: Color,
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(value) {
            return value && value.isColor ? this.copy(value) : "number" == typeof value ? this.setHex(value) : "string" == typeof value && this.setStyle(value), 
            this;
        },
        setScalar: function(scalar) {
            return this.r = scalar, this.g = scalar, this.b = scalar, this;
        },
        setHex: function(hex) {
            return hex = Math.floor(hex), this.r = (hex >> 16 & 255) / 255, this.g = (hex >> 8 & 255) / 255, 
            this.b = (255 & hex) / 255, this;
        },
        setRGB: function(r, g, b) {
            return this.r = r, this.g = g, this.b = b, this;
        },
        setHSL: function() {
            function hue2rgb(p, q, t) {
                return 0 > t && (t += 1), t > 1 && (t -= 1), 1 / 6 > t ? p + 6 * (q - p) * t : .5 > t ? q : 2 / 3 > t ? p + 6 * (q - p) * (2 / 3 - t) : p;
            }
            return function(h, s, l) {
                if (h = _Math.euclideanModulo(h, 1), s = _Math.clamp(s, 0, 1), l = _Math.clamp(l, 0, 1), 
                0 === s) this.r = this.g = this.b = l; else {
                    var p = .5 >= l ? l * (1 + s) : l + s - l * s, q = 2 * l - p;
                    this.r = hue2rgb(q, p, h + 1 / 3), this.g = hue2rgb(q, p, h), this.b = hue2rgb(q, p, h - 1 / 3);
                }
                return this;
            };
        }(),
        setStyle: function(style) {
            function handleAlpha(string) {
                void 0 !== string && parseFloat(string) < 1 && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
            }
            var m;
            if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                var color, name = m[1], components = m[2];
                switch (name) {
                  case "rgb":
                  case "rgba":
                    if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) return this.r = Math.min(255, parseInt(color[1], 10)) / 255, 
                    this.g = Math.min(255, parseInt(color[2], 10)) / 255, this.b = Math.min(255, parseInt(color[3], 10)) / 255, 
                    handleAlpha(color[5]), this;
                    if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) return this.r = Math.min(100, parseInt(color[1], 10)) / 100, 
                    this.g = Math.min(100, parseInt(color[2], 10)) / 100, this.b = Math.min(100, parseInt(color[3], 10)) / 100, 
                    handleAlpha(color[5]), this;
                    break;

                  case "hsl":
                  case "hsla":
                    if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        var h = parseFloat(color[1]) / 360, s = parseInt(color[2], 10) / 100, l = parseInt(color[3], 10) / 100;
                        return handleAlpha(color[5]), this.setHSL(h, s, l);
                    }
                }
            } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                var hex = m[1], size = hex.length;
                if (3 === size) return this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255, 
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255, this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255, 
                this;
                if (6 === size) return this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255, 
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255, this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255, 
                this;
            }
            if (style && style.length > 0) {
                var hex = ColorKeywords[style];
                void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + style);
            }
            return this;
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b);
        },
        copy: function(color) {
            return this.r = color.r, this.g = color.g, this.b = color.b, this;
        },
        copyGammaToLinear: function(color, gammaFactor) {
            return void 0 === gammaFactor && (gammaFactor = 2), this.r = Math.pow(color.r, gammaFactor), 
            this.g = Math.pow(color.g, gammaFactor), this.b = Math.pow(color.b, gammaFactor), 
            this;
        },
        copyLinearToGamma: function(color, gammaFactor) {
            void 0 === gammaFactor && (gammaFactor = 2);
            var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
            return this.r = Math.pow(color.r, safeInverse), this.g = Math.pow(color.g, safeInverse), 
            this.b = Math.pow(color.b, safeInverse), this;
        },
        convertGammaToLinear: function() {
            var r = this.r, g = this.g, b = this.b;
            return this.r = r * r, this.g = g * g, this.b = b * b, this;
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), 
            this;
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function(optionalTarget) {
            var hue, saturation, hsl = optionalTarget || {
                h: 0,
                s: 0,
                l: 0
            }, r = this.r, g = this.g, b = this.b, max = Math.max(r, g, b), min = Math.min(r, g, b), lightness = (min + max) / 2;
            if (min === max) hue = 0, saturation = 0; else {
                var delta = max - min;
                switch (saturation = .5 >= lightness ? delta / (max + min) : delta / (2 - max - min), 
                max) {
                  case r:
                    hue = (g - b) / delta + (b > g ? 6 : 0);
                    break;

                  case g:
                    hue = (b - r) / delta + 2;
                    break;

                  case b:
                    hue = (r - g) / delta + 4;
                }
                hue /= 6;
            }
            return hsl.h = hue, hsl.s = saturation, hsl.l = lightness, hsl;
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
        },
        offsetHSL: function(h, s, l) {
            var hsl = this.getHSL();
            return hsl.h += h, hsl.s += s, hsl.l += l, this.setHSL(hsl.h, hsl.s, hsl.l), this;
        },
        add: function(color) {
            return this.r += color.r, this.g += color.g, this.b += color.b, this;
        },
        addColors: function(color1, color2) {
            return this.r = color1.r + color2.r, this.g = color1.g + color2.g, this.b = color1.b + color2.b, 
            this;
        },
        addScalar: function(s) {
            return this.r += s, this.g += s, this.b += s, this;
        },
        sub: function(color) {
            return this.r = Math.max(0, this.r - color.r), this.g = Math.max(0, this.g - color.g), 
            this.b = Math.max(0, this.b - color.b), this;
        },
        multiply: function(color) {
            return this.r *= color.r, this.g *= color.g, this.b *= color.b, this;
        },
        multiplyScalar: function(s) {
            return this.r *= s, this.g *= s, this.b *= s, this;
        },
        lerp: function(color, alpha) {
            return this.r += (color.r - this.r) * alpha, this.g += (color.g - this.g) * alpha, 
            this.b += (color.b - this.b) * alpha, this;
        },
        equals: function(c) {
            return c.r === this.r && c.g === this.g && c.b === this.b;
        },
        fromArray: function(array, offset) {
            return void 0 === offset && (offset = 0), this.r = array[offset], this.g = array[offset + 1], 
            this.b = array[offset + 2], this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this.r, 
            array[offset + 1] = this.g, array[offset + 2] = this.b, array;
        },
        toJSON: function() {
            return this.getHex();
        }
    };
    var ColorKeywords = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }, UniformsLib = {
        common: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            offsetRepeat: {
                value: new Vector4(0, 0, 1, 1)
            },
            specularMap: {
                value: null
            },
            alphaMap: {
                value: null
            },
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Color(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Color(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            offsetRepeat: {
                value: new Vector4(0, 0, 1, 1)
            }
        }
    }, ShaderLib = {
        basic: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.aomap, UniformsLib.fog ]),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                }
            } ]),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                },
                specular: {
                    value: new Color(1118481)
                },
                shininess: {
                    value: 30
                }
            } ]),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            } ]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        },
        points: {
            uniforms: UniformsUtils.merge([ UniformsLib.points, UniformsLib.fog ]),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            } ]),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: UniformsUtils.merge([ UniformsLib.common, UniformsLib.displacementmap ]),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
            uniforms: {
                opacity: {
                    value: 1
                }
            },
            vertexShader: ShaderChunk.normal_vert,
            fragmentShader: ShaderChunk.normal_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                },
                tFlip: {
                    value: -1
                }
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: {
                lightPos: {
                    value: new Vector3()
                }
            },
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
        }
    };
    ShaderLib.physical = {
        uniforms: UniformsUtils.merge([ ShaderLib.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        } ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    }, Box2.prototype = {
        constructor: Box2,
        set: function(min, max) {
            return this.min.copy(min), this.max.copy(max), this;
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; il > i; i++) this.expandByPoint(points[i]);
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector2();
            return function(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(.5);
                return this.min.copy(center).sub(halfSize), this.max.copy(center).add(halfSize), 
                this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            return this.min.copy(box.min), this.max.copy(box.max), this;
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = +(1 / 0), this.max.x = this.max.y = -(1 / 0), this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            return this.min.min(point), this.max.max(point), this;
        },
        expandByVector: function(vector) {
            return this.min.sub(vector), this.max.add(vector), this;
        },
        expandByScalar: function(scalar) {
            return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
        },
        containsPoint: function(point) {
            return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y);
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        },
        getParameter: function(point, optionalTarget) {
            var result = optionalTarget || new Vector2();
            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        },
        intersectsBox: function(box) {
            return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y);
        },
        clampPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector2();
            return result.copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector2();
            return function(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            };
        }(),
        intersect: function(box) {
            return this.min.max(box.min), this.max.min(box.max), this;
        },
        union: function(box) {
            return this.min.min(box.min), this.max.max(box.max), this;
        },
        translate: function(offset) {
            return this.min.add(offset), this.max.add(offset), this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    }, Material.prototype = {
        constructor: Material,
        isMaterial: !0,
        get needsUpdate() {
            return this._needsUpdate;
        },
        set needsUpdate(value) {
            value === !0 && this.update(), this._needsUpdate = value;
        },
        setValues: function(values) {
            if (void 0 !== values) for (var key in values) {
                var newValue = values[key];
                if (void 0 !== newValue) {
                    var currentValue = this[key];
                    void 0 !== currentValue ? currentValue && currentValue.isColor ? currentValue.set(newValue) : currentValue && currentValue.isVector3 && newValue && newValue.isVector3 ? currentValue.copy(newValue) : "overdraw" === key ? this[key] = Number(newValue) : this[key] = newValue : console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                } else console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            }
        },
        toJSON: function(meta) {
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata, values.push(data);
                }
                return values;
            }
            var isRoot = void 0 === meta;
            isRoot && (meta = {
                textures: {},
                images: {}
            });
            var data = {
                metadata: {
                    version: 4.4,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), 
            this.color && this.color.isColor && (data.color = this.color.getHex()), void 0 !== this.roughness && (data.roughness = this.roughness), 
            void 0 !== this.metalness && (data.metalness = this.metalness), this.emissive && this.emissive.isColor && (data.emissive = this.emissive.getHex()), 
            this.specular && this.specular.isColor && (data.specular = this.specular.getHex()), 
            void 0 !== this.shininess && (data.shininess = this.shininess), this.map && this.map.isTexture && (data.map = this.map.toJSON(meta).uuid), 
            this.alphaMap && this.alphaMap.isTexture && (data.alphaMap = this.alphaMap.toJSON(meta).uuid), 
            this.lightMap && this.lightMap.isTexture && (data.lightMap = this.lightMap.toJSON(meta).uuid), 
            this.bumpMap && this.bumpMap.isTexture && (data.bumpMap = this.bumpMap.toJSON(meta).uuid, 
            data.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (data.normalMap = this.normalMap.toJSON(meta).uuid, 
            data.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (data.displacementMap = this.displacementMap.toJSON(meta).uuid, 
            data.displacementScale = this.displacementScale, data.displacementBias = this.displacementBias), 
            this.roughnessMap && this.roughnessMap.isTexture && (data.roughnessMap = this.roughnessMap.toJSON(meta).uuid), 
            this.metalnessMap && this.metalnessMap.isTexture && (data.metalnessMap = this.metalnessMap.toJSON(meta).uuid), 
            this.emissiveMap && this.emissiveMap.isTexture && (data.emissiveMap = this.emissiveMap.toJSON(meta).uuid), 
            this.specularMap && this.specularMap.isTexture && (data.specularMap = this.specularMap.toJSON(meta).uuid), 
            this.envMap && this.envMap.isTexture && (data.envMap = this.envMap.toJSON(meta).uuid, 
            data.reflectivity = this.reflectivity), void 0 !== this.size && (data.size = this.size), 
            void 0 !== this.sizeAttenuation && (data.sizeAttenuation = this.sizeAttenuation), 
            this.blending !== NormalBlending && (data.blending = this.blending), this.shading !== SmoothShading && (data.shading = this.shading), 
            this.side !== FrontSide && (data.side = this.side), this.vertexColors !== NoColors && (data.vertexColors = this.vertexColors), 
            this.opacity < 1 && (data.opacity = this.opacity), this.transparent === !0 && (data.transparent = this.transparent), 
            data.depthFunc = this.depthFunc, data.depthTest = this.depthTest, data.depthWrite = this.depthWrite, 
            this.alphaTest > 0 && (data.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (data.premultipliedAlpha = this.premultipliedAlpha), 
            this.wireframe === !0 && (data.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (data.wireframeLinewidth = this.wireframeLinewidth), 
            "round" !== this.wireframeLinecap && (data.wireframeLinecap = this.wireframeLinecap), 
            "round" !== this.wireframeLinejoin && (data.wireframeLinejoin = this.wireframeLinejoin), 
            data.skinning = this.skinning, data.morphTargets = this.morphTargets, isRoot) {
                var textures = extractFromCache(meta.textures), images = extractFromCache(meta.images);
                textures.length > 0 && (data.textures = textures), images.length > 0 && (data.images = images);
            }
            return data;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.name = source.name, this.fog = source.fog, this.lights = source.lights, this.blending = source.blending, 
            this.side = source.side, this.shading = source.shading, this.vertexColors = source.vertexColors, 
            this.opacity = source.opacity, this.transparent = source.transparent, this.blendSrc = source.blendSrc, 
            this.blendDst = source.blendDst, this.blendEquation = source.blendEquation, this.blendSrcAlpha = source.blendSrcAlpha, 
            this.blendDstAlpha = source.blendDstAlpha, this.blendEquationAlpha = source.blendEquationAlpha, 
            this.depthFunc = source.depthFunc, this.depthTest = source.depthTest, this.depthWrite = source.depthWrite, 
            this.colorWrite = source.colorWrite, this.precision = source.precision, this.polygonOffset = source.polygonOffset, 
            this.polygonOffsetFactor = source.polygonOffsetFactor, this.polygonOffsetUnits = source.polygonOffsetUnits, 
            this.alphaTest = source.alphaTest, this.premultipliedAlpha = source.premultipliedAlpha, 
            this.overdraw = source.overdraw, this.visible = source.visible, this.clipShadows = source.clipShadows, 
            this.clipIntersection = source.clipIntersection;
            var srcPlanes = source.clippingPlanes, dstPlanes = null;
            if (null !== srcPlanes) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
            }
            return this.clippingPlanes = dstPlanes, this;
        },
        update: function() {
            this.dispatchEvent({
                type: "update"
            });
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }, Object.assign(Material.prototype, EventDispatcher.prototype);
    var count$1 = 0;
    ShaderMaterial.prototype = Object.create(Material.prototype), ShaderMaterial.prototype.constructor = ShaderMaterial, 
    ShaderMaterial.prototype.isShaderMaterial = !0, ShaderMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.fragmentShader = source.fragmentShader, 
        this.vertexShader = source.vertexShader, this.uniforms = UniformsUtils.clone(source.uniforms), 
        this.defines = source.defines, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this.lights = source.lights, this.clipping = source.clipping, this.skinning = source.skinning, 
        this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, 
        this.extensions = source.extensions, this;
    }, ShaderMaterial.prototype.toJSON = function(meta) {
        var data = Material.prototype.toJSON.call(this, meta);
        return data.uniforms = this.uniforms, data.vertexShader = this.vertexShader, data.fragmentShader = this.fragmentShader, 
        data;
    }, MeshDepthMaterial.prototype = Object.create(Material.prototype), MeshDepthMaterial.prototype.constructor = MeshDepthMaterial, 
    MeshDepthMaterial.prototype.isMeshDepthMaterial = !0, MeshDepthMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.depthPacking = source.depthPacking, 
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.map = source.map, 
        this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, 
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, 
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this;
    }, Box3.prototype = {
        constructor: Box3,
        isBox3: !0,
        set: function(min, max) {
            return this.min.copy(min), this.max.copy(max), this;
        },
        setFromArray: function(array) {
            for (var minX = +(1 / 0), minY = +(1 / 0), minZ = +(1 / 0), maxX = -(1 / 0), maxY = -(1 / 0), maxZ = -(1 / 0), i = 0, l = array.length; l > i; i += 3) {
                var x = array[i], y = array[i + 1], z = array[i + 2];
                minX > x && (minX = x), minY > y && (minY = y), minZ > z && (minZ = z), x > maxX && (maxX = x), 
                y > maxY && (maxY = y), z > maxZ && (maxZ = z);
            }
            this.min.set(minX, minY, minZ), this.max.set(maxX, maxY, maxZ);
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; il > i; i++) this.expandByPoint(points[i]);
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector3();
            return function(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(.5);
                return this.min.copy(center).sub(halfSize), this.max.copy(center).add(halfSize), 
                this;
            };
        }(),
        setFromObject: function() {
            var v1 = new Vector3();
            return function(object) {
                var scope = this;
                return object.updateMatrixWorld(!0), this.makeEmpty(), object.traverse(function(node) {
                    var geometry = node.geometry;
                    if (void 0 !== geometry) if (geometry && geometry.isGeometry) for (var vertices = geometry.vertices, i = 0, il = vertices.length; il > i; i++) v1.copy(vertices[i]), 
                    v1.applyMatrix4(node.matrixWorld), scope.expandByPoint(v1); else if (geometry && geometry.isBufferGeometry) {
                        var attribute = geometry.attributes.position;
                        if (void 0 !== attribute) {
                            var array, offset, stride;
                            attribute && attribute.isInterleavedBufferAttribute ? (array = attribute.data.array, 
                            offset = attribute.offset, stride = attribute.data.stride) : (array = attribute.array, 
                            offset = 0, stride = 3);
                            for (var i = offset, il = array.length; il > i; i += stride) v1.fromArray(array, i), 
                            v1.applyMatrix4(node.matrixWorld), scope.expandByPoint(v1);
                        }
                    }
                }), this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            return this.min.copy(box.min), this.max.copy(box.max), this;
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = +(1 / 0), this.max.x = this.max.y = this.max.z = -(1 / 0), 
            this;
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            return this.min.min(point), this.max.max(point), this;
        },
        expandByVector: function(vector) {
            return this.min.sub(vector), this.max.add(vector), this;
        },
        expandByScalar: function(scalar) {
            return this.min.addScalar(-scalar), this.max.addScalar(scalar), this;
        },
        containsPoint: function(point) {
            return !(point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z);
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        },
        getParameter: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        },
        intersectsBox: function(box) {
            return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z);
        },
        intersectsSphere: function() {
            var closestPoint;
            return function(sphere) {
                return void 0 === closestPoint && (closestPoint = new Vector3()), this.clampPoint(sphere.center, closestPoint), 
                closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
            };
        }(),
        intersectsPlane: function(plane) {
            var min, max;
            return plane.normal.x > 0 ? (min = plane.normal.x * this.min.x, max = plane.normal.x * this.max.x) : (min = plane.normal.x * this.max.x, 
            max = plane.normal.x * this.min.x), plane.normal.y > 0 ? (min += plane.normal.y * this.min.y, 
            max += plane.normal.y * this.max.y) : (min += plane.normal.y * this.max.y, max += plane.normal.y * this.min.y), 
            plane.normal.z > 0 ? (min += plane.normal.z * this.min.z, max += plane.normal.z * this.max.z) : (min += plane.normal.z * this.max.z, 
            max += plane.normal.z * this.min.z), min <= plane.constant && max >= plane.constant;
        },
        clampPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector3();
            return function(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            };
        }(),
        getBoundingSphere: function() {
            var v1 = new Vector3();
            return function(optionalTarget) {
                var result = optionalTarget || new Sphere();
                return this.getCenter(result.center), result.radius = .5 * this.getSize(v1).length(), 
                result;
            };
        }(),
        intersect: function(box) {
            return this.min.max(box.min), this.max.min(box.max), this.isEmpty() && this.makeEmpty(), 
            this;
        },
        union: function(box) {
            return this.min.min(box.min), this.max.max(box.max), this;
        },
        applyMatrix4: function() {
            var points = [ new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3() ];
            return function(matrix) {
                return this.isEmpty() ? this : (points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix), 
                points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix), points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix), 
                points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix), points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix), 
                points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix), points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix), 
                points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix), this.setFromPoints(points), 
                this);
            };
        }(),
        translate: function(offset) {
            return this.min.add(offset), this.max.add(offset), this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    }, Sphere.prototype = {
        constructor: Sphere,
        set: function(center, radius) {
            return this.center.copy(center), this.radius = radius, this;
        },
        setFromPoints: function() {
            var box = new Box3();
            return function(points, optionalCenter) {
                var center = this.center;
                void 0 !== optionalCenter ? center.copy(optionalCenter) : box.setFromPoints(points).getCenter(center);
                for (var maxRadiusSq = 0, i = 0, il = points.length; il > i; i++) maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                return this.radius = Math.sqrt(maxRadiusSq), this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(sphere) {
            return this.center.copy(sphere.center), this.radius = sphere.radius, this;
        },
        empty: function() {
            return this.radius <= 0;
        },
        containsPoint: function(point) {
            return point.distanceToSquared(this.center) <= this.radius * this.radius;
        },
        distanceToPoint: function(point) {
            return point.distanceTo(this.center) - this.radius;
        },
        intersectsSphere: function(sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
        },
        intersectsBox: function(box) {
            return box.intersectsSphere(this);
        },
        intersectsPlane: function(plane) {
            return Math.abs(this.center.dot(plane.normal) - plane.constant) <= this.radius;
        },
        clampPoint: function(point, optionalTarget) {
            var deltaLengthSq = this.center.distanceToSquared(point), result = optionalTarget || new Vector3();
            return result.copy(point), deltaLengthSq > this.radius * this.radius && (result.sub(this.center).normalize(), 
            result.multiplyScalar(this.radius).add(this.center)), result;
        },
        getBoundingBox: function(optionalTarget) {
            var box = optionalTarget || new Box3();
            return box.set(this.center, this.center), box.expandByScalar(this.radius), box;
        },
        applyMatrix4: function(matrix) {
            return this.center.applyMatrix4(matrix), this.radius = this.radius * matrix.getMaxScaleOnAxis(), 
            this;
        },
        translate: function(offset) {
            return this.center.add(offset), this;
        },
        equals: function(sphere) {
            return sphere.center.equals(this.center) && sphere.radius === this.radius;
        }
    }, Matrix3.prototype = {
        constructor: Matrix3,
        isMatrix3: !0,
        set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            return te[0] = n11, te[1] = n21, te[2] = n31, te[3] = n12, te[4] = n22, te[5] = n32, 
            te[6] = n13, te[7] = n23, te[8] = n33, this;
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        },
        clone: function() {
            return new this.constructor().fromArray(this.elements);
        },
        copy: function(m) {
            var me = m.elements;
            return this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]), 
            this;
        },
        setFromMatrix4: function(m) {
            var me = m.elements;
            return this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]), 
            this;
        },
        applyToVector3Array: function() {
            var v1;
            return function(array, offset, length) {
                void 0 === v1 && (v1 = new Vector3()), void 0 === offset && (offset = 0), void 0 === length && (length = array.length);
                for (var i = 0, j = offset; length > i; i += 3, j += 3) v1.fromArray(array, j), 
                v1.applyMatrix3(this), v1.toArray(array, j);
                return array;
            };
        }(),
        applyToBuffer: function() {
            var v1;
            return function(buffer, offset, length) {
                void 0 === v1 && (v1 = new Vector3()), void 0 === offset && (offset = 0), void 0 === length && (length = buffer.length / buffer.itemSize);
                for (var i = 0, j = offset; length > i; i++, j++) v1.x = buffer.getX(j), v1.y = buffer.getY(j), 
                v1.z = buffer.getZ(j), v1.applyMatrix3(this), buffer.setXYZ(j, v1.x, v1.y, v1.z);
                return buffer;
            };
        }(),
        multiplyScalar: function(s) {
            var te = this.elements;
            return te[0] *= s, te[3] *= s, te[6] *= s, te[1] *= s, te[4] *= s, te[7] *= s, te[2] *= s, 
            te[5] *= s, te[8] *= s, this;
        },
        determinant: function() {
            var te = this.elements, a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        },
        getInverse: function(matrix, throwOnDegenerate) {
            matrix && matrix.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
            var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (0 === det) {
                var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                if (throwOnDegenerate === !0) throw new Error(msg);
                return console.warn(msg), this.identity();
            }
            var detInv = 1 / det;
            return te[0] = t11 * detInv, te[1] = (n31 * n23 - n33 * n21) * detInv, te[2] = (n32 * n21 - n31 * n22) * detInv, 
            te[3] = t12 * detInv, te[4] = (n33 * n11 - n31 * n13) * detInv, te[5] = (n31 * n12 - n32 * n11) * detInv, 
            te[6] = t13 * detInv, te[7] = (n21 * n13 - n23 * n11) * detInv, te[8] = (n22 * n11 - n21 * n12) * detInv, 
            this;
        },
        transpose: function() {
            var tmp, m = this.elements;
            return tmp = m[1], m[1] = m[3], m[3] = tmp, tmp = m[2], m[2] = m[6], m[6] = tmp, 
            tmp = m[5], m[5] = m[7], m[7] = tmp, this;
        },
        flattenToArrayOffset: function(array, offset) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."), 
            this.toArray(array, offset);
        },
        getNormalMatrix: function(matrix4) {
            return this.setFromMatrix4(matrix4).getInverse(this).transpose();
        },
        transposeIntoArray: function(r) {
            var m = this.elements;
            return r[0] = m[0], r[1] = m[3], r[2] = m[6], r[3] = m[1], r[4] = m[4], r[5] = m[7], 
            r[6] = m[2], r[7] = m[5], r[8] = m[8], this;
        },
        fromArray: function(array, offset) {
            void 0 === offset && (offset = 0);
            for (var i = 0; 9 > i; i++) this.elements[i] = array[i + offset];
            return this;
        },
        toArray: function(array, offset) {
            void 0 === array && (array = []), void 0 === offset && (offset = 0);
            var te = this.elements;
            return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2], 
            array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5], 
            array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8], 
            array;
        }
    }, Plane.prototype = {
        constructor: Plane,
        set: function(normal, constant) {
            return this.normal.copy(normal), this.constant = constant, this;
        },
        setComponents: function(x, y, z, w) {
            return this.normal.set(x, y, z), this.constant = w, this;
        },
        setFromNormalAndCoplanarPoint: function(normal, point) {
            return this.normal.copy(normal), this.constant = -point.dot(this.normal), this;
        },
        setFromCoplanarPoints: function() {
            var v1 = new Vector3(), v2 = new Vector3();
            return function(a, b, c) {
                var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                return this.setFromNormalAndCoplanarPoint(normal, a), this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(plane) {
            return this.normal.copy(plane.normal), this.constant = plane.constant, this;
        },
        normalize: function() {
            var inverseNormalLength = 1 / this.normal.length();
            return this.normal.multiplyScalar(inverseNormalLength), this.constant *= inverseNormalLength, 
            this;
        },
        negate: function() {
            return this.constant *= -1, this.normal.negate(), this;
        },
        distanceToPoint: function(point) {
            return this.normal.dot(point) + this.constant;
        },
        distanceToSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        },
        projectPoint: function(point, optionalTarget) {
            return this.orthoPoint(point, optionalTarget).sub(point).negate();
        },
        orthoPoint: function(point, optionalTarget) {
            var perpendicularMagnitude = this.distanceToPoint(point), result = optionalTarget || new Vector3();
            return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
        },
        intersectLine: function() {
            var v1 = new Vector3();
            return function(line, optionalTarget) {
                var result = optionalTarget || new Vector3(), direction = line.delta(v1), denominator = this.normal.dot(direction);
                if (0 !== denominator) {
                    var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                    if (!(0 > t || t > 1)) return result.copy(direction).multiplyScalar(t).add(line.start);
                } else if (0 === this.distanceToPoint(line.start)) return result.copy(line.start);
            };
        }(),
        intersectsLine: function(line) {
            var startSign = this.distanceToPoint(line.start), endSign = this.distanceToPoint(line.end);
            return 0 > startSign && endSign > 0 || 0 > endSign && startSign > 0;
        },
        intersectsBox: function(box) {
            return box.intersectsPlane(this);
        },
        intersectsSphere: function(sphere) {
            return sphere.intersectsPlane(this);
        },
        coplanarPoint: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(this.normal).multiplyScalar(-this.constant);
        },
        applyMatrix4: function() {
            var v1 = new Vector3(), m1 = new Matrix3();
            return function(matrix, optionalNormalMatrix) {
                var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix), normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix), normal = this.normal.applyMatrix3(normalMatrix).normalize();
                return this.constant = -referencePoint.dot(normal), this;
            };
        }(),
        translate: function(offset) {
            return this.constant = this.constant - offset.dot(this.normal), this;
        },
        equals: function(plane) {
            return plane.normal.equals(this.normal) && plane.constant === this.constant;
        }
    }, Frustum.prototype = {
        constructor: Frustum,
        set: function(p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            return planes[0].copy(p0), planes[1].copy(p1), planes[2].copy(p2), planes[3].copy(p3), 
            planes[4].copy(p4), planes[5].copy(p5), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(frustum) {
            for (var planes = this.planes, i = 0; 6 > i; i++) planes[i].copy(frustum.planes[i]);
            return this;
        },
        setFromMatrix: function(m) {
            var planes = this.planes, me = m.elements, me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3], me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7], me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11], me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            return planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize(), 
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize(), 
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize(), 
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize(), 
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize(), 
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize(), 
            this;
        },
        intersectsObject: function() {
            var sphere = new Sphere();
            return function(object) {
                var geometry = object.geometry;
                return null === geometry.boundingSphere && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld), 
                this.intersectsSphere(sphere);
            };
        }(),
        intersectsSprite: function() {
            var sphere = new Sphere();
            return function(sprite) {
                return sphere.center.set(0, 0, 0), sphere.radius = .7071067811865476, sphere.applyMatrix4(sprite.matrixWorld), 
                this.intersectsSphere(sphere);
            };
        }(),
        intersectsSphere: function(sphere) {
            for (var planes = this.planes, center = sphere.center, negRadius = -sphere.radius, i = 0; 6 > i; i++) {
                var distance = planes[i].distanceToPoint(center);
                if (negRadius > distance) return !1;
            }
            return !0;
        },
        intersectsBox: function() {
            var p1 = new Vector3(), p2 = new Vector3();
            return function(box) {
                for (var planes = this.planes, i = 0; 6 > i; i++) {
                    var plane = planes[i];
                    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x, p2.x = plane.normal.x > 0 ? box.max.x : box.min.x, 
                    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y, p2.y = plane.normal.y > 0 ? box.max.y : box.min.y, 
                    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z, p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                    var d1 = plane.distanceToPoint(p1), d2 = plane.distanceToPoint(p2);
                    if (0 > d1 && 0 > d2) return !1;
                }
                return !0;
            };
        }(),
        containsPoint: function(point) {
            for (var planes = this.planes, i = 0; 6 > i; i++) if (planes[i].distanceToPoint(point) < 0) return !1;
            return !0;
        }
    }, Ray.prototype = {
        constructor: Ray,
        set: function(origin, direction) {
            return this.origin.copy(origin), this.direction.copy(direction), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(ray) {
            return this.origin.copy(ray.origin), this.direction.copy(ray.direction), this;
        },
        at: function(t, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(this.direction).multiplyScalar(t).add(this.origin);
        },
        lookAt: function(v) {
            return this.direction.copy(v).sub(this.origin).normalize(), this;
        },
        recast: function() {
            var v1 = new Vector3();
            return function(t) {
                return this.origin.copy(this.at(t, v1)), this;
            };
        }(),
        closestPointToPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            result.subVectors(point, this.origin);
            var directionDistance = result.dot(this.direction);
            return 0 > directionDistance ? result.copy(this.origin) : result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        },
        distanceToPoint: function(point) {
            return Math.sqrt(this.distanceSqToPoint(point));
        },
        distanceSqToPoint: function() {
            var v1 = new Vector3();
            return function(point) {
                var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                return 0 > directionDistance ? this.origin.distanceToSquared(point) : (v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin), 
                v1.distanceToSquared(point));
            };
        }(),
        distanceSqToSegment: function() {
            var segCenter = new Vector3(), segDir = new Vector3(), diff = new Vector3();
            return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                segCenter.copy(v0).add(v1).multiplyScalar(.5), segDir.copy(v1).sub(v0).normalize(), 
                diff.copy(this.origin).sub(segCenter);
                var s0, s1, sqrDist, extDet, segExtent = .5 * v0.distanceTo(v1), a01 = -this.direction.dot(segDir), b0 = diff.dot(this.direction), b1 = -diff.dot(segDir), c = diff.lengthSq(), det = Math.abs(1 - a01 * a01);
                if (det > 0) if (s0 = a01 * b1 - b0, s1 = a01 * b0 - b1, extDet = segExtent * det, 
                s0 >= 0) if (s1 >= -extDet) if (extDet >= s1) {
                    var invDet = 1 / det;
                    s0 *= invDet, s1 *= invDet, sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else s1 = segExtent, s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c; else s1 = -segExtent, 
                s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c; else -extDet >= s1 ? (s0 = Math.max(0, -(-a01 * segExtent + b0)), 
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c) : extDet >= s1 ? (s0 = 0, 
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = s1 * (s1 + 2 * b1) + c) : (s0 = Math.max(0, -(a01 * segExtent + b0)), 
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c); else s1 = a01 > 0 ? -segExtent : segExtent, 
                s0 = Math.max(0, -(a01 * s1 + b0)), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                return optionalPointOnRay && optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin), 
                optionalPointOnSegment && optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter), 
                sqrDist;
            };
        }(),
        intersectSphere: function() {
            var v1 = new Vector3();
            return function(sphere, optionalTarget) {
                v1.subVectors(sphere.center, this.origin);
                var tca = v1.dot(this.direction), d2 = v1.dot(v1) - tca * tca, radius2 = sphere.radius * sphere.radius;
                if (d2 > radius2) return null;
                var thc = Math.sqrt(radius2 - d2), t0 = tca - thc, t1 = tca + thc;
                return 0 > t0 && 0 > t1 ? null : 0 > t0 ? this.at(t1, optionalTarget) : this.at(t0, optionalTarget);
            };
        }(),
        intersectsSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) <= sphere.radius;
        },
        distanceToPlane: function(plane) {
            var denominator = plane.normal.dot(this.direction);
            if (0 === denominator) return 0 === plane.distanceToPoint(this.origin) ? 0 : null;
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
            return t >= 0 ? t : null;
        },
        intersectPlane: function(plane, optionalTarget) {
            var t = this.distanceToPlane(plane);
            return null === t ? null : this.at(t, optionalTarget);
        },
        intersectsPlane: function(plane) {
            var distToPoint = plane.distanceToPoint(this.origin);
            if (0 === distToPoint) return !0;
            var denominator = plane.normal.dot(this.direction);
            return 0 > denominator * distToPoint;
        },
        intersectBox: function(box, optionalTarget) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax, invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z, origin = this.origin;
            return invdirx >= 0 ? (tmin = (box.min.x - origin.x) * invdirx, tmax = (box.max.x - origin.x) * invdirx) : (tmin = (box.max.x - origin.x) * invdirx, 
            tmax = (box.min.x - origin.x) * invdirx), invdiry >= 0 ? (tymin = (box.min.y - origin.y) * invdiry, 
            tymax = (box.max.y - origin.y) * invdiry) : (tymin = (box.max.y - origin.y) * invdiry, 
            tymax = (box.min.y - origin.y) * invdiry), tmin > tymax || tymin > tmax ? null : ((tymin > tmin || tmin !== tmin) && (tmin = tymin), 
            (tmax > tymax || tmax !== tmax) && (tmax = tymax), invdirz >= 0 ? (tzmin = (box.min.z - origin.z) * invdirz, 
            tzmax = (box.max.z - origin.z) * invdirz) : (tzmin = (box.max.z - origin.z) * invdirz, 
            tzmax = (box.min.z - origin.z) * invdirz), tmin > tzmax || tzmin > tmax ? null : ((tzmin > tmin || tmin !== tmin) && (tmin = tzmin), 
            (tmax > tzmax || tmax !== tmax) && (tmax = tzmax), 0 > tmax ? null : this.at(tmin >= 0 ? tmin : tmax, optionalTarget)));
        },
        intersectsBox: function() {
            var v = new Vector3();
            return function(box) {
                return null !== this.intersectBox(box, v);
            };
        }(),
        intersectTriangle: function() {
            var diff = new Vector3(), edge1 = new Vector3(), edge2 = new Vector3(), normal = new Vector3();
            return function(a, b, c, backfaceCulling, optionalTarget) {
                edge1.subVectors(b, a), edge2.subVectors(c, a), normal.crossVectors(edge1, edge2);
                var sign, DdN = this.direction.dot(normal);
                if (DdN > 0) {
                    if (backfaceCulling) return null;
                    sign = 1;
                } else {
                    if (!(0 > DdN)) return null;
                    sign = -1, DdN = -DdN;
                }
                diff.subVectors(this.origin, a);
                var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                if (0 > DdQxE2) return null;
                var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                if (0 > DdE1xQ) return null;
                if (DdQxE2 + DdE1xQ > DdN) return null;
                var QdN = -sign * diff.dot(normal);
                return 0 > QdN ? null : this.at(QdN / DdN, optionalTarget);
            };
        }(),
        applyMatrix4: function(matrix4) {
            return this.direction.add(this.origin).applyMatrix4(matrix4), this.origin.applyMatrix4(matrix4), 
            this.direction.sub(this.origin), this.direction.normalize(), this;
        },
        equals: function(ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
    }, Euler.RotationOrders = [ "XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX" ], Euler.DefaultOrder = "XYZ", 
    Euler.prototype = {
        constructor: Euler,
        isEuler: !0,
        get x() {
            return this._x;
        },
        set x(value) {
            this._x = value, this.onChangeCallback();
        },
        get y() {
            return this._y;
        },
        set y(value) {
            this._y = value, this.onChangeCallback();
        },
        get z() {
            return this._z;
        },
        set z(value) {
            this._z = value, this.onChangeCallback();
        },
        get order() {
            return this._order;
        },
        set order(value) {
            this._order = value, this.onChangeCallback();
        },
        set: function(x, y, z, order) {
            return this._x = x, this._y = y, this._z = z, this._order = order || this._order, 
            this.onChangeCallback(), this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function(euler) {
            return this._x = euler._x, this._y = euler._y, this._z = euler._z, this._order = euler._order, 
            this.onChangeCallback(), this;
        },
        setFromRotationMatrix: function(m, order, update) {
            var clamp = _Math.clamp, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            return order = order || this._order, "XYZ" === order ? (this._y = Math.asin(clamp(m13, -1, 1)), 
            Math.abs(m13) < .99999 ? (this._x = Math.atan2(-m23, m33), this._z = Math.atan2(-m12, m11)) : (this._x = Math.atan2(m32, m22), 
            this._z = 0)) : "YXZ" === order ? (this._x = Math.asin(-clamp(m23, -1, 1)), Math.abs(m23) < .99999 ? (this._y = Math.atan2(m13, m33), 
            this._z = Math.atan2(m21, m22)) : (this._y = Math.atan2(-m31, m11), this._z = 0)) : "ZXY" === order ? (this._x = Math.asin(clamp(m32, -1, 1)), 
            Math.abs(m32) < .99999 ? (this._y = Math.atan2(-m31, m33), this._z = Math.atan2(-m12, m22)) : (this._y = 0, 
            this._z = Math.atan2(m21, m11))) : "ZYX" === order ? (this._y = Math.asin(-clamp(m31, -1, 1)), 
            Math.abs(m31) < .99999 ? (this._x = Math.atan2(m32, m33), this._z = Math.atan2(m21, m11)) : (this._x = 0, 
            this._z = Math.atan2(-m12, m22))) : "YZX" === order ? (this._z = Math.asin(clamp(m21, -1, 1)), 
            Math.abs(m21) < .99999 ? (this._x = Math.atan2(-m23, m22), this._y = Math.atan2(-m31, m11)) : (this._x = 0, 
            this._y = Math.atan2(m13, m33))) : "XZY" === order ? (this._z = Math.asin(-clamp(m12, -1, 1)), 
            Math.abs(m12) < .99999 ? (this._x = Math.atan2(m32, m22), this._y = Math.atan2(m13, m11)) : (this._x = Math.atan2(-m23, m33), 
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order), 
            this._order = order, update !== !1 && this.onChangeCallback(), this;
        },
        setFromQuaternion: function() {
            var matrix;
            return function(q, order, update) {
                return void 0 === matrix && (matrix = new Matrix4()), matrix.makeRotationFromQuaternion(q), 
                this.setFromRotationMatrix(matrix, order, update);
            };
        }(),
        setFromVector3: function(v, order) {
            return this.set(v.x, v.y, v.z, order || this._order);
        },
        reorder: function() {
            var q = new Quaternion();
            return function(newOrder) {
                return q.setFromEuler(this), this.setFromQuaternion(q, newOrder);
            };
        }(),
        equals: function(euler) {
            return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
        },
        fromArray: function(array) {
            return this._x = array[0], this._y = array[1], this._z = array[2], void 0 !== array[3] && (this._order = array[3]), 
            this.onChangeCallback(), this;
        },
        toArray: function(array, offset) {
            return void 0 === array && (array = []), void 0 === offset && (offset = 0), array[offset] = this._x, 
            array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._order, 
            array;
        },
        toVector3: function(optionalResult) {
            return optionalResult ? optionalResult.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z);
        },
        onChange: function(callback) {
            return this.onChangeCallback = callback, this;
        },
        onChangeCallback: function() {}
    }, Layers.prototype = {
        constructor: Layers,
        set: function(channel) {
            this.mask = 1 << channel;
        },
        enable: function(channel) {
            this.mask |= 1 << channel;
        },
        toggle: function(channel) {
            this.mask ^= 1 << channel;
        },
        disable: function(channel) {
            this.mask &= ~(1 << channel);
        },
        test: function(layers) {
            return 0 !== (this.mask & layers.mask);
        }
    }, Object3D.DefaultUp = new Vector3(0, 1, 0), Object3D.DefaultMatrixAutoUpdate = !0, 
    Object.assign(Object3D.prototype, EventDispatcher.prototype, {
        isObject3D: !0,
        applyMatrix: function(matrix) {
            this.matrix.multiplyMatrices(matrix, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        setRotationFromAxisAngle: function(axis, angle) {
            this.quaternion.setFromAxisAngle(axis, angle);
        },
        setRotationFromEuler: function(euler) {
            this.quaternion.setFromEuler(euler, !0);
        },
        setRotationFromMatrix: function(m) {
            this.quaternion.setFromRotationMatrix(m);
        },
        setRotationFromQuaternion: function(q) {
            this.quaternion.copy(q);
        },
        rotateOnAxis: function() {
            var q1 = new Quaternion();
            return function(axis, angle) {
                return q1.setFromAxisAngle(axis, angle), this.quaternion.multiply(q1), this;
            };
        }(),
        rotateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        translateOnAxis: function() {
            var v1 = new Vector3();
            return function(axis, distance) {
                return v1.copy(axis).applyQuaternion(this.quaternion), this.position.add(v1.multiplyScalar(distance)), 
                this;
            };
        }(),
        translateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        localToWorld: function(vector) {
            return vector.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function() {
            var m1 = new Matrix4();
            return function(vector) {
                return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
            };
        }(),
        lookAt: function() {
            var m1 = new Matrix4();
            return function(vector) {
                m1.lookAt(vector, this.position, this.up), this.quaternion.setFromRotationMatrix(m1);
            };
        }(),
        add: function(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) this.add(arguments[i]);
                return this;
            }
            return object === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", object), 
            this) : (object && object.isObject3D ? (null !== object.parent && object.parent.remove(object), 
            object.parent = this, object.dispatchEvent({
                type: "added"
            }), this.children.push(object)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object), 
            this);
        },
        remove: function(object) {
            if (arguments.length > 1) for (var i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            var index = this.children.indexOf(object);
            -1 !== index && (object.parent = null, object.dispatchEvent({
                type: "removed"
            }), this.children.splice(index, 1));
        },
        getObjectById: function(id) {
            return this.getObjectByProperty("id", id);
        },
        getObjectByName: function(name) {
            return this.getObjectByProperty("name", name);
        },
        getObjectByProperty: function(name, value) {
            if (this[name] === value) return this;
            for (var i = 0, l = this.children.length; l > i; i++) {
                var child = this.children[i], object = child.getObjectByProperty(name, value);
                if (void 0 !== object) return object;
            }
        },
        getWorldPosition: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.updateMatrixWorld(!0), result.setFromMatrixPosition(this.matrixWorld);
        },
        getWorldQuaternion: function() {
            var position = new Vector3(), scale = new Vector3();
            return function(optionalTarget) {
                var result = optionalTarget || new Quaternion();
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(position, result, scale), 
                result;
            };
        }(),
        getWorldRotation: function() {
            var quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Euler();
                return this.getWorldQuaternion(quaternion), result.setFromQuaternion(quaternion, this.rotation.order, !1);
            };
        }(),
        getWorldScale: function() {
            var position = new Vector3(), quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Vector3();
                return this.updateMatrixWorld(!0), this.matrixWorld.decompose(position, quaternion, result), 
                result;
            };
        }(),
        getWorldDirection: function() {
            var quaternion = new Quaternion();
            return function(optionalTarget) {
                var result = optionalTarget || new Vector3();
                return this.getWorldQuaternion(quaternion), result.set(0, 0, 1).applyQuaternion(quaternion);
            };
        }(),
        raycast: function() {},
        traverse: function(callback) {
            callback(this);
            for (var children = this.children, i = 0, l = children.length; l > i; i++) children[i].traverse(callback);
        },
        traverseVisible: function(callback) {
            if (this.visible !== !1) {
                callback(this);
                for (var children = this.children, i = 0, l = children.length; l > i; i++) children[i].traverseVisible(callback);
            }
        },
        traverseAncestors: function(callback) {
            var parent = this.parent;
            null !== parent && (callback(parent), parent.traverseAncestors(callback));
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
        },
        updateMatrixWorld: function(force) {
            this.matrixAutoUpdate === !0 && this.updateMatrix(), this.matrixWorldNeedsUpdate !== !0 && force !== !0 || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), 
            this.matrixWorldNeedsUpdate = !1, force = !0);
            for (var children = this.children, i = 0, l = children.length; l > i; i++) children[i].updateMatrixWorld(force);
        },
        toJSON: function(meta) {
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata, values.push(data);
                }
                return values;
            }
            var isRootObject = void 0 === meta || "" === meta, output = {};
            isRootObject && (meta = {
                geometries: {},
                materials: {},
                textures: {},
                images: {}
            }, output.metadata = {
                version: 4.4,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var object = {};
            if (object.uuid = this.uuid, object.type = this.type, "" !== this.name && (object.name = this.name), 
            "{}" !== JSON.stringify(this.userData) && (object.userData = this.userData), this.castShadow === !0 && (object.castShadow = !0), 
            this.receiveShadow === !0 && (object.receiveShadow = !0), this.visible === !1 && (object.visible = !1), 
            object.matrix = this.matrix.toArray(), void 0 !== this.geometry && (void 0 === meta.geometries[this.geometry.uuid] && (meta.geometries[this.geometry.uuid] = this.geometry.toJSON(meta)), 
            object.geometry = this.geometry.uuid), void 0 !== this.material && (void 0 === meta.materials[this.material.uuid] && (meta.materials[this.material.uuid] = this.material.toJSON(meta)), 
            object.material = this.material.uuid), this.children.length > 0) {
                object.children = [];
                for (var i = 0; i < this.children.length; i++) object.children.push(this.children[i].toJSON(meta).object);
            }
            if (isRootObject) {
                var geometries = extractFromCache(meta.geometries), materials = extractFromCache(meta.materials), textures = extractFromCache(meta.textures), images = extractFromCache(meta.images);
                geometries.length > 0 && (output.geometries = geometries), materials.length > 0 && (output.materials = materials), 
                textures.length > 0 && (output.textures = textures), images.length > 0 && (output.images = images);
            }
            return output.object = object, output;
        },
        clone: function(recursive) {
            return new this.constructor().copy(this, recursive);
        },
        copy: function(source, recursive) {
            if (void 0 === recursive && (recursive = !0), this.name = source.name, this.up.copy(source.up), 
            this.position.copy(source.position), this.quaternion.copy(source.quaternion), this.scale.copy(source.scale), 
            this.matrix.copy(source.matrix), this.matrixWorld.copy(source.matrixWorld), this.matrixAutoUpdate = source.matrixAutoUpdate, 
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate, this.visible = source.visible, 
            this.castShadow = source.castShadow, this.receiveShadow = source.receiveShadow, 
            this.frustumCulled = source.frustumCulled, this.renderOrder = source.renderOrder, 
            this.userData = JSON.parse(JSON.stringify(source.userData)), recursive === !0) for (var i = 0; i < source.children.length; i++) {
                var child = source.children[i];
                this.add(child.clone());
            }
            return this;
        }
    });
    var count$2 = 0;
    Line3.prototype = {
        constructor: Line3,
        set: function(start, end) {
            return this.start.copy(start), this.end.copy(end), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(line) {
            return this.start.copy(line.start), this.end.copy(line.end), this;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.addVectors(this.start, this.end).multiplyScalar(.5);
        },
        delta: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.subVectors(this.end, this.start);
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end);
        },
        distance: function() {
            return this.start.distanceTo(this.end);
        },
        at: function(t, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        closestPointToPointParameter: function() {
            var startP = new Vector3(), startEnd = new Vector3();
            return function(point, clampToLine) {
                startP.subVectors(point, this.start), startEnd.subVectors(this.end, this.start);
                var startEnd2 = startEnd.dot(startEnd), startEnd_startP = startEnd.dot(startP), t = startEnd_startP / startEnd2;
                return clampToLine && (t = _Math.clamp(t, 0, 1)), t;
            };
        }(),
        closestPointToPoint: function(point, clampToLine, optionalTarget) {
            var t = this.closestPointToPointParameter(point, clampToLine), result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        applyMatrix4: function(matrix) {
            return this.start.applyMatrix4(matrix), this.end.applyMatrix4(matrix), this;
        },
        equals: function(line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        }
    }, Triangle.normal = function() {
        var v0 = new Vector3();
        return function(a, b, c, optionalTarget) {
            var result = optionalTarget || new Vector3();
            result.subVectors(c, b), v0.subVectors(a, b), result.cross(v0);
            var resultLengthSq = result.lengthSq();
            return resultLengthSq > 0 ? result.multiplyScalar(1 / Math.sqrt(resultLengthSq)) : result.set(0, 0, 0);
        };
    }(), Triangle.barycoordFromPoint = function() {
        var v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3();
        return function(point, a, b, c, optionalTarget) {
            v0.subVectors(c, a), v1.subVectors(b, a), v2.subVectors(point, a);
            var dot00 = v0.dot(v0), dot01 = v0.dot(v1), dot02 = v0.dot(v2), dot11 = v1.dot(v1), dot12 = v1.dot(v2), denom = dot00 * dot11 - dot01 * dot01, result = optionalTarget || new Vector3();
            if (0 === denom) return result.set(-2, -1, -1);
            var invDenom = 1 / denom, u = (dot11 * dot02 - dot01 * dot12) * invDenom, v = (dot00 * dot12 - dot01 * dot02) * invDenom;
            return result.set(1 - u - v, v, u);
        };
    }(), Triangle.containsPoint = function() {
        var v1 = new Vector3();
        return function(point, a, b, c) {
            var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
            return result.x >= 0 && result.y >= 0 && result.x + result.y <= 1;
        };
    }(), Triangle.prototype = {
        constructor: Triangle,
        set: function(a, b, c) {
            return this.a.copy(a), this.b.copy(b), this.c.copy(c), this;
        },
        setFromPointsAndIndices: function(points, i0, i1, i2) {
            return this.a.copy(points[i0]), this.b.copy(points[i1]), this.c.copy(points[i2]), 
            this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(triangle) {
            return this.a.copy(triangle.a), this.b.copy(triangle.b), this.c.copy(triangle.c), 
            this;
        },
        area: function() {
            var v0 = new Vector3(), v1 = new Vector3();
            return function() {
                return v0.subVectors(this.c, this.b), v1.subVectors(this.a, this.b), .5 * v0.cross(v1).length();
            };
        }(),
        midpoint: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        },
        normal: function(optionalTarget) {
            return Triangle.normal(this.a, this.b, this.c, optionalTarget);
        },
        plane: function(optionalTarget) {
            var result = optionalTarget || new Plane();
            return result.setFromCoplanarPoints(this.a, this.b, this.c);
        },
        barycoordFromPoint: function(point, optionalTarget) {
            return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
        },
        containsPoint: function(point) {
            return Triangle.containsPoint(point, this.a, this.b, this.c);
        },
        closestPointToPoint: function() {
            var plane, edgeList, projectedPoint, closestPoint;
            return function(point, optionalTarget) {
                void 0 === plane && (plane = new Plane(), edgeList = [ new Line3(), new Line3(), new Line3() ], 
                projectedPoint = new Vector3(), closestPoint = new Vector3());
                var result = optionalTarget || new Vector3(), minDistance = 1 / 0;
                if (plane.setFromCoplanarPoints(this.a, this.b, this.c), plane.projectPoint(point, projectedPoint), 
                this.containsPoint(projectedPoint) === !0) result.copy(projectedPoint); else {
                    edgeList[0].set(this.a, this.b), edgeList[1].set(this.b, this.c), edgeList[2].set(this.c, this.a);
                    for (var i = 0; i < edgeList.length; i++) {
                        edgeList[i].closestPointToPoint(projectedPoint, !0, closestPoint);
                        var distance = projectedPoint.distanceToSquared(closestPoint);
                        minDistance > distance && (minDistance = distance, result.copy(closestPoint));
                    }
                }
                return result;
            };
        }(),
        equals: function(triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
    }, Face3.prototype = {
        constructor: Face3,
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.a = source.a, this.b = source.b, this.c = source.c, this.normal.copy(source.normal), 
            this.color.copy(source.color), this.materialIndex = source.materialIndex;
            for (var i = 0, il = source.vertexNormals.length; il > i; i++) this.vertexNormals[i] = source.vertexNormals[i].clone();
            for (var i = 0, il = source.vertexColors.length; il > i; i++) this.vertexColors[i] = source.vertexColors[i].clone();
            return this;
        }
    }, MeshBasicMaterial.prototype = Object.create(Material.prototype), MeshBasicMaterial.prototype.constructor = MeshBasicMaterial, 
    MeshBasicMaterial.prototype.isMeshBasicMaterial = !0, MeshBasicMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.map = source.map, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, 
        this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, 
        this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, 
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, 
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this;
    }, BufferAttribute.prototype = {
        constructor: BufferAttribute,
        isBufferAttribute: !0,
        set needsUpdate(value) {
            value === !0 && this.version++;
        },
        setArray: function(array) {
            if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== array ? array.length / this.itemSize : 0, this.array = array;
        },
        setDynamic: function(value) {
            return this.dynamic = value, this;
        },
        copy: function(source) {
            return this.array = new source.array.constructor(source.array), this.itemSize = source.itemSize, 
            this.count = source.count, this.normalized = source.normalized, this.dynamic = source.dynamic, 
            this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.itemSize, index2 *= attribute.itemSize;
            for (var i = 0, l = this.itemSize; l > i; i++) this.array[index1 + i] = attribute.array[index2 + i];
            return this;
        },
        copyArray: function(array) {
            return this.array.set(array), this;
        },
        copyColorsArray: function(colors) {
            for (var array = this.array, offset = 0, i = 0, l = colors.length; l > i; i++) {
                var color = colors[i];
                void 0 === color && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), 
                color = new Color()), array[offset++] = color.r, array[offset++] = color.g, array[offset++] = color.b;
            }
            return this;
        },
        copyIndicesArray: function(indices) {
            for (var array = this.array, offset = 0, i = 0, l = indices.length; l > i; i++) {
                var index = indices[i];
                array[offset++] = index.a, array[offset++] = index.b, array[offset++] = index.c;
            }
            return this;
        },
        copyVector2sArray: function(vectors) {
            for (var array = this.array, offset = 0, i = 0, l = vectors.length; l > i; i++) {
                var vector = vectors[i];
                void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), 
                vector = new Vector2()), array[offset++] = vector.x, array[offset++] = vector.y;
            }
            return this;
        },
        copyVector3sArray: function(vectors) {
            for (var array = this.array, offset = 0, i = 0, l = vectors.length; l > i; i++) {
                var vector = vectors[i];
                void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), 
                vector = new Vector3()), array[offset++] = vector.x, array[offset++] = vector.y, 
                array[offset++] = vector.z;
            }
            return this;
        },
        copyVector4sArray: function(vectors) {
            for (var array = this.array, offset = 0, i = 0, l = vectors.length; l > i; i++) {
                var vector = vectors[i];
                void 0 === vector && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), 
                vector = new Vector4()), array[offset++] = vector.x, array[offset++] = vector.y, 
                array[offset++] = vector.z, array[offset++] = vector.w;
            }
            return this;
        },
        set: function(value, offset) {
            return void 0 === offset && (offset = 0), this.array.set(value, offset), this;
        },
        getX: function(index) {
            return this.array[index * this.itemSize];
        },
        setX: function(index, x) {
            return this.array[index * this.itemSize] = x, this;
        },
        getY: function(index) {
            return this.array[index * this.itemSize + 1];
        },
        setY: function(index, y) {
            return this.array[index * this.itemSize + 1] = y, this;
        },
        getZ: function(index) {
            return this.array[index * this.itemSize + 2];
        },
        setZ: function(index, z) {
            return this.array[index * this.itemSize + 2] = z, this;
        },
        getW: function(index) {
            return this.array[index * this.itemSize + 3];
        },
        setW: function(index, w) {
            return this.array[index * this.itemSize + 3] = w, this;
        },
        setXY: function(index, x, y) {
            return index *= this.itemSize, this.array[index + 0] = x, this.array[index + 1] = y, 
            this;
        },
        setXYZ: function(index, x, y, z) {
            return index *= this.itemSize, this.array[index + 0] = x, this.array[index + 1] = y, 
            this.array[index + 2] = z, this;
        },
        setXYZW: function(index, x, y, z, w) {
            return index *= this.itemSize, this.array[index + 0] = x, this.array[index + 1] = y, 
            this.array[index + 2] = z, this.array[index + 3] = w, this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        }
    }, Object.assign(Geometry.prototype, EventDispatcher.prototype, {
        isGeometry: !0,
        applyMatrix: function(matrix) {
            for (var normalMatrix = new Matrix3().getNormalMatrix(matrix), i = 0, il = this.vertices.length; il > i; i++) {
                var vertex = this.vertices[i];
                vertex.applyMatrix4(matrix);
            }
            for (var i = 0, il = this.faces.length; il > i; i++) {
                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = face.vertexNormals.length; jl > j; j++) face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
            this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this;
        },
        rotateX: function() {
            var m1;
            return function(angle) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeRotationX(angle), this.applyMatrix(m1), 
                this;
            };
        }(),
        rotateY: function() {
            var m1;
            return function(angle) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeRotationY(angle), this.applyMatrix(m1), 
                this;
            };
        }(),
        rotateZ: function() {
            var m1;
            return function(angle) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeRotationZ(angle), this.applyMatrix(m1), 
                this;
            };
        }(),
        translate: function() {
            var m1;
            return function(x, y, z) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeTranslation(x, y, z), this.applyMatrix(m1), 
                this;
            };
        }(),
        scale: function() {
            var m1;
            return function(x, y, z) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeScale(x, y, z), this.applyMatrix(m1), 
                this;
            };
        }(),
        lookAt: function() {
            var obj;
            return function(vector) {
                void 0 === obj && (obj = new Object3D()), obj.lookAt(vector), obj.updateMatrix(), 
                this.applyMatrix(obj.matrix);
            };
        }(),
        fromBufferGeometry: function(geometry) {
            function addFace(a, b, c, materialIndex) {
                var vertexNormals = void 0 !== normals ? [ tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone() ] : [], vertexColors = void 0 !== colors ? [ scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone() ] : [], face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face), void 0 !== uvs && scope.faceVertexUvs[0].push([ tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone() ]), 
                void 0 !== uvs2 && scope.faceVertexUvs[1].push([ tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone() ]);
            }
            var scope = this, indices = null !== geometry.index ? geometry.index.array : void 0, attributes = geometry.attributes, positions = attributes.position.array, normals = void 0 !== attributes.normal ? attributes.normal.array : void 0, colors = void 0 !== attributes.color ? attributes.color.array : void 0, uvs = void 0 !== attributes.uv ? attributes.uv.array : void 0, uvs2 = void 0 !== attributes.uv2 ? attributes.uv2.array : void 0;
            void 0 !== uvs2 && (this.faceVertexUvs[1] = []);
            for (var tempNormals = [], tempUVs = [], tempUVs2 = [], i = 0, j = 0; i < positions.length; i += 3, 
            j += 2) scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2])), 
            void 0 !== normals && tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2])), 
            void 0 !== colors && scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2])), 
            void 0 !== uvs && tempUVs.push(new Vector2(uvs[j], uvs[j + 1])), void 0 !== uvs2 && tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
            if (void 0 !== indices) {
                var groups = geometry.groups;
                if (groups.length > 0) for (var i = 0; i < groups.length; i++) for (var group = groups[i], start = group.start, count = group.count, j = start, jl = start + count; jl > j; j += 3) addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex); else for (var i = 0; i < indices.length; i += 3) addFace(indices[i], indices[i + 1], indices[i + 2]);
            } else for (var i = 0; i < positions.length / 3; i += 3) addFace(i, i + 1, i + 2);
            return this.computeFaceNormals(), null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone()), 
            null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()), 
            this;
        },
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            return this.translate(offset.x, offset.y, offset.z), offset;
        },
        normalize: function() {
            this.computeBoundingSphere();
            var center = this.boundingSphere.center, radius = this.boundingSphere.radius, s = 0 === radius ? 1 : 1 / radius, matrix = new Matrix4();
            return matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1), 
            this.applyMatrix(matrix), this;
        },
        computeFaceNormals: function() {
            for (var cb = new Vector3(), ab = new Vector3(), f = 0, fl = this.faces.length; fl > f; f++) {
                var face = this.faces[f], vA = this.vertices[face.a], vB = this.vertices[face.b], vC = this.vertices[face.c];
                cb.subVectors(vC, vB), ab.subVectors(vA, vB), cb.cross(ab), cb.normalize(), face.normal.copy(cb);
            }
        },
        computeVertexNormals: function(areaWeighted) {
            void 0 === areaWeighted && (areaWeighted = !0);
            var v, vl, f, fl, face, vertices;
            for (vertices = new Array(this.vertices.length), v = 0, vl = this.vertices.length; vl > v; v++) vertices[v] = new Vector3();
            if (areaWeighted) {
                var vA, vB, vC, cb = new Vector3(), ab = new Vector3();
                for (f = 0, fl = this.faces.length; fl > f; f++) face = this.faces[f], vA = this.vertices[face.a], 
                vB = this.vertices[face.b], vC = this.vertices[face.c], cb.subVectors(vC, vB), ab.subVectors(vA, vB), 
                cb.cross(ab), vertices[face.a].add(cb), vertices[face.b].add(cb), vertices[face.c].add(cb);
            } else for (this.computeFaceNormals(), f = 0, fl = this.faces.length; fl > f; f++) face = this.faces[f], 
            vertices[face.a].add(face.normal), vertices[face.b].add(face.normal), vertices[face.c].add(face.normal);
            for (v = 0, vl = this.vertices.length; vl > v; v++) vertices[v].normalize();
            for (f = 0, fl = this.faces.length; fl > f; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                3 === vertexNormals.length ? (vertexNormals[0].copy(vertices[face.a]), vertexNormals[1].copy(vertices[face.b]), 
                vertexNormals[2].copy(vertices[face.c])) : (vertexNormals[0] = vertices[face.a].clone(), 
                vertexNormals[1] = vertices[face.b].clone(), vertexNormals[2] = vertices[face.c].clone());
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeFlatVertexNormals: function() {
            var f, fl, face;
            for (this.computeFaceNormals(), f = 0, fl = this.faces.length; fl > f; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                3 === vertexNormals.length ? (vertexNormals[0].copy(face.normal), vertexNormals[1].copy(face.normal), 
                vertexNormals[2].copy(face.normal)) : (vertexNormals[0] = face.normal.clone(), vertexNormals[1] = face.normal.clone(), 
                vertexNormals[2] = face.normal.clone());
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0);
        },
        computeMorphNormals: function() {
            var i, il, f, fl, face;
            for (f = 0, fl = this.faces.length; fl > f; f++) for (face = this.faces[f], face.__originalFaceNormal ? face.__originalFaceNormal.copy(face.normal) : face.__originalFaceNormal = face.normal.clone(), 
            face.__originalVertexNormals || (face.__originalVertexNormals = []), i = 0, il = face.vertexNormals.length; il > i; i++) face.__originalVertexNormals[i] ? face.__originalVertexNormals[i].copy(face.vertexNormals[i]) : face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
            var tmpGeo = new Geometry();
            for (tmpGeo.faces = this.faces, i = 0, il = this.morphTargets.length; il > i; i++) {
                if (!this.morphNormals[i]) {
                    this.morphNormals[i] = {}, this.morphNormals[i].faceNormals = [], this.morphNormals[i].vertexNormals = [];
                    var faceNormal, vertexNormals, dstNormalsFace = this.morphNormals[i].faceNormals, dstNormalsVertex = this.morphNormals[i].vertexNormals;
                    for (f = 0, fl = this.faces.length; fl > f; f++) faceNormal = new Vector3(), vertexNormals = {
                        a: new Vector3(),
                        b: new Vector3(),
                        c: new Vector3()
                    }, dstNormalsFace.push(faceNormal), dstNormalsVertex.push(vertexNormals);
                }
                var morphNormals = this.morphNormals[i];
                tmpGeo.vertices = this.morphTargets[i].vertices, tmpGeo.computeFaceNormals(), tmpGeo.computeVertexNormals();
                var faceNormal, vertexNormals;
                for (f = 0, fl = this.faces.length; fl > f; f++) face = this.faces[f], faceNormal = morphNormals.faceNormals[f], 
                vertexNormals = morphNormals.vertexNormals[f], faceNormal.copy(face.normal), vertexNormals.a.copy(face.vertexNormals[0]), 
                vertexNormals.b.copy(face.vertexNormals[1]), vertexNormals.c.copy(face.vertexNormals[2]);
            }
            for (f = 0, fl = this.faces.length; fl > f; f++) face = this.faces[f], face.normal = face.__originalFaceNormal, 
            face.vertexNormals = face.__originalVertexNormals;
        },
        computeTangents: function() {
            console.warn("THREE.Geometry: .computeTangents() has been removed.");
        },
        computeLineDistances: function() {
            for (var d = 0, vertices = this.vertices, i = 0, il = vertices.length; il > i; i++) i > 0 && (d += vertices[i].distanceTo(vertices[i - 1])), 
            this.lineDistances[i] = d;
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Box3()), this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Sphere()), this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function(geometry, matrix, materialIndexOffset) {
            if ((geometry && geometry.isGeometry) === !1) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
            var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
            void 0 === materialIndexOffset && (materialIndexOffset = 0), void 0 !== matrix && (normalMatrix = new Matrix3().getNormalMatrix(matrix));
            for (var i = 0, il = vertices2.length; il > i; i++) {
                var vertex = vertices2[i], vertexCopy = vertex.clone();
                void 0 !== matrix && vertexCopy.applyMatrix4(matrix), vertices1.push(vertexCopy);
            }
            for (var i = 0, il = colors2.length; il > i; i++) colors1.push(colors2[i].clone());
            for (i = 0, il = faces2.length; il > i; i++) {
                var faceCopy, normal, color, face = faces2[i], faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset), 
                faceCopy.normal.copy(face.normal), void 0 !== normalMatrix && faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = faceVertexNormals.length; jl > j; j++) normal = faceVertexNormals[j].clone(), 
                void 0 !== normalMatrix && normal.applyMatrix3(normalMatrix).normalize(), faceCopy.vertexNormals.push(normal);
                faceCopy.color.copy(face.color);
                for (var j = 0, jl = faceVertexColors.length; jl > j; j++) color = faceVertexColors[j], 
                faceCopy.vertexColors.push(color.clone());
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset, faces1.push(faceCopy);
            }
            for (i = 0, il = uvs2.length; il > i; i++) {
                var uv = uvs2[i], uvCopy = [];
                if (void 0 !== uv) {
                    for (var j = 0, jl = uv.length; jl > j; j++) uvCopy.push(uv[j].clone());
                    uvs1.push(uvCopy);
                }
            }
        },
        mergeMesh: function(mesh) {
            return (mesh && mesh.isMesh) === !1 ? void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh) : (mesh.matrixAutoUpdate && mesh.updateMatrix(), 
            void this.merge(mesh.geometry, mesh.matrix));
        },
        mergeVertices: function() {
            var v, key, i, il, face, indices, j, jl, verticesMap = {}, unique = [], changes = [], precisionPoints = 4, precision = Math.pow(10, precisionPoints);
            for (i = 0, il = this.vertices.length; il > i; i++) v = this.vertices[i], key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision), 
            void 0 === verticesMap[key] ? (verticesMap[key] = i, unique.push(this.vertices[i]), 
            changes[i] = unique.length - 1) : changes[i] = changes[verticesMap[key]];
            var faceIndicesToRemove = [];
            for (i = 0, il = this.faces.length; il > i; i++) {
                face = this.faces[i], face.a = changes[face.a], face.b = changes[face.b], face.c = changes[face.c], 
                indices = [ face.a, face.b, face.c ];
                for (var dupIndex = -1, n = 0; 3 > n; n++) if (indices[n] === indices[(n + 1) % 3]) {
                    dupIndex = n, faceIndicesToRemove.push(i);
                    break;
                }
            }
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                for (this.faces.splice(idx, 1), j = 0, jl = this.faceVertexUvs.length; jl > j; j++) this.faceVertexUvs[j].splice(idx, 1);
            }
            var diff = this.vertices.length - unique.length;
            return this.vertices = unique, diff;
        },
        sortFacesByMaterialIndex: function() {
            function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
            }
            for (var faces = this.faces, length = faces.length, i = 0; length > i; i++) faces[i]._id = i;
            faces.sort(materialIndexSort);
            var newUvs1, newUvs2, uvs1 = this.faceVertexUvs[0], uvs2 = this.faceVertexUvs[1];
            uvs1 && uvs1.length === length && (newUvs1 = []), uvs2 && uvs2.length === length && (newUvs2 = []);
            for (var i = 0; length > i; i++) {
                var id = faces[i]._id;
                newUvs1 && newUvs1.push(uvs1[id]), newUvs2 && newUvs2.push(uvs2[id]);
            }
            newUvs1 && (this.faceVertexUvs[0] = newUvs1), newUvs2 && (this.faceVertexUvs[1] = newUvs2);
        },
        toJSON: function() {
            function setBit(value, position, enabled) {
                return enabled ? value | 1 << position : value & ~(1 << position);
            }
            function getNormalIndex(normal) {
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                return void 0 !== normalsHash[hash] ? normalsHash[hash] : (normalsHash[hash] = normals.length / 3, 
                normals.push(normal.x, normal.y, normal.z), normalsHash[hash]);
            }
            function getColorIndex(color) {
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
                return void 0 !== colorsHash[hash] ? colorsHash[hash] : (colorsHash[hash] = colors.length, 
                colors.push(color.getHex()), colorsHash[hash]);
            }
            function getUvIndex(uv) {
                var hash = uv.x.toString() + uv.y.toString();
                return void 0 !== uvsHash[hash] ? uvsHash[hash] : (uvsHash[hash] = uvs.length / 2, 
                uvs.push(uv.x, uv.y), uvsHash[hash]);
            }
            var data = {
                metadata: {
                    version: 4.4,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), 
            void 0 !== this.parameters) {
                var parameters = this.parameters;
                for (var key in parameters) void 0 !== parameters[key] && (data[key] = parameters[key]);
                return data;
            }
            for (var vertices = [], i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
            for (var faces = [], normals = [], normalsHash = {}, colors = [], colorsHash = {}, uvs = [], uvsHash = {}, i = 0; i < this.faces.length; i++) {
                var face = this.faces[i], hasMaterial = !0, hasFaceUv = !1, hasFaceVertexUv = void 0 !== this.faceVertexUvs[0][i], hasFaceNormal = face.normal.length() > 0, hasFaceVertexNormal = face.vertexNormals.length > 0, hasFaceColor = 1 !== face.color.r || 1 !== face.color.g || 1 !== face.color.b, hasFaceVertexColor = face.vertexColors.length > 0, faceType = 0;
                if (faceType = setBit(faceType, 0, 0), faceType = setBit(faceType, 1, hasMaterial), 
                faceType = setBit(faceType, 2, hasFaceUv), faceType = setBit(faceType, 3, hasFaceVertexUv), 
                faceType = setBit(faceType, 4, hasFaceNormal), faceType = setBit(faceType, 5, hasFaceVertexNormal), 
                faceType = setBit(faceType, 6, hasFaceColor), faceType = setBit(faceType, 7, hasFaceVertexColor), 
                faces.push(faceType), faces.push(face.a, face.b, face.c), faces.push(face.materialIndex), 
                hasFaceVertexUv) {
                    var faceVertexUvs = this.faceVertexUvs[0][i];
                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }
                if (hasFaceNormal && faces.push(getNormalIndex(face.normal)), hasFaceVertexNormal) {
                    var vertexNormals = face.vertexNormals;
                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }
                if (hasFaceColor && faces.push(getColorIndex(face.color)), hasFaceVertexColor) {
                    var vertexColors = face.vertexColors;
                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }
            return data.data = {}, data.data.vertices = vertices, data.data.normals = normals, 
            colors.length > 0 && (data.data.colors = colors), uvs.length > 0 && (data.data.uvs = [ uvs ]), 
            data.data.faces = faces, data;
        },
        clone: function() {
            return new Geometry().copy(this);
        },
        copy: function(source) {
            this.vertices = [], this.faces = [], this.faceVertexUvs = [ [] ], this.colors = [];
            for (var vertices = source.vertices, i = 0, il = vertices.length; il > i; i++) this.vertices.push(vertices[i].clone());
            for (var colors = source.colors, i = 0, il = colors.length; il > i; i++) this.colors.push(colors[i].clone());
            for (var faces = source.faces, i = 0, il = faces.length; il > i; i++) this.faces.push(faces[i].clone());
            for (var i = 0, il = source.faceVertexUvs.length; il > i; i++) {
                var faceVertexUvs = source.faceVertexUvs[i];
                void 0 === this.faceVertexUvs[i] && (this.faceVertexUvs[i] = []);
                for (var j = 0, jl = faceVertexUvs.length; jl > j; j++) {
                    for (var uvs = faceVertexUvs[j], uvsCopy = [], k = 0, kl = uvs.length; kl > k; k++) {
                        var uv = uvs[k];
                        uvsCopy.push(uv.clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    });
    var count$3 = 0;
    Object.assign(DirectGeometry.prototype, EventDispatcher.prototype, {
        computeBoundingBox: Geometry.prototype.computeBoundingBox,
        computeBoundingSphere: Geometry.prototype.computeBoundingSphere,
        computeFaceNormals: function() {
            console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.");
        },
        computeVertexNormals: function() {
            console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.");
        },
        computeGroups: function(geometry) {
            for (var group, materialIndex, groups = [], faces = geometry.faces, i = 0; i < faces.length; i++) {
                var face = faces[i];
                face.materialIndex !== materialIndex && (materialIndex = face.materialIndex, void 0 !== group && (group.count = 3 * i - group.start, 
                groups.push(group)), group = {
                    start: 3 * i,
                    materialIndex: materialIndex
                });
            }
            void 0 !== group && (group.count = 3 * i - group.start, groups.push(group)), this.groups = groups;
        },
        fromGeometry: function(geometry) {
            var morphTargetsPosition, faces = geometry.faces, vertices = geometry.vertices, faceVertexUvs = geometry.faceVertexUvs, hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0, hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0, morphTargets = geometry.morphTargets, morphTargetsLength = morphTargets.length;
            if (morphTargetsLength > 0) {
                morphTargetsPosition = [];
                for (var i = 0; morphTargetsLength > i; i++) morphTargetsPosition[i] = [];
                this.morphTargets.position = morphTargetsPosition;
            }
            var morphTargetsNormal, morphNormals = geometry.morphNormals, morphNormalsLength = morphNormals.length;
            if (morphNormalsLength > 0) {
                morphTargetsNormal = [];
                for (var i = 0; morphNormalsLength > i; i++) morphTargetsNormal[i] = [];
                this.morphTargets.normal = morphTargetsNormal;
            }
            for (var skinIndices = geometry.skinIndices, skinWeights = geometry.skinWeights, hasSkinIndices = skinIndices.length === vertices.length, hasSkinWeights = skinWeights.length === vertices.length, i = 0; i < faces.length; i++) {
                var face = faces[i];
                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                var vertexNormals = face.vertexNormals;
                if (3 === vertexNormals.length) this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]); else {
                    var normal = face.normal;
                    this.normals.push(normal, normal, normal);
                }
                var vertexColors = face.vertexColors;
                if (3 === vertexColors.length) this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]); else {
                    var color = face.color;
                    this.colors.push(color, color, color);
                }
                if (hasFaceVertexUv === !0) {
                    var vertexUvs = faceVertexUvs[0][i];
                    void 0 !== vertexUvs ? this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i), 
                    this.uvs.push(new Vector2(), new Vector2(), new Vector2()));
                }
                if (hasFaceVertexUv2 === !0) {
                    var vertexUvs = faceVertexUvs[1][i];
                    void 0 !== vertexUvs ? this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i), 
                    this.uvs2.push(new Vector2(), new Vector2(), new Vector2()));
                }
                for (var j = 0; morphTargetsLength > j; j++) {
                    var morphTarget = morphTargets[j].vertices;
                    morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }
                for (var j = 0; morphNormalsLength > j; j++) {
                    var morphNormal = morphNormals[j].vertexNormals[i];
                    morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }
                hasSkinIndices && this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]), 
                hasSkinWeights && this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
            }
            return this.computeGroups(geometry), this.verticesNeedUpdate = geometry.verticesNeedUpdate, 
            this.normalsNeedUpdate = geometry.normalsNeedUpdate, this.colorsNeedUpdate = geometry.colorsNeedUpdate, 
            this.uvsNeedUpdate = geometry.uvsNeedUpdate, this.groupsNeedUpdate = geometry.groupsNeedUpdate, 
            this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), Object.assign(BufferGeometry.prototype, EventDispatcher.prototype, {
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index;
        },
        setIndex: function(index) {
            this.index = index;
        },
        addAttribute: function(name, attribute) {
            return (attribute && attribute.isBufferAttribute) === !1 && (attribute && attribute.isInterleavedBufferAttribute) === !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), 
            void this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]))) : "index" === name ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), 
            void this.setIndex(attribute)) : (this.attributes[name] = attribute, this);
        },
        getAttribute: function(name) {
            return this.attributes[name];
        },
        removeAttribute: function(name) {
            return delete this.attributes[name], this;
        },
        addGroup: function(start, count, materialIndex) {
            this.groups.push({
                start: start,
                count: count,
                materialIndex: void 0 !== materialIndex ? materialIndex : 0
            });
        },
        clearGroups: function() {
            this.groups = [];
        },
        setDrawRange: function(start, count) {
            this.drawRange.start = start, this.drawRange.count = count;
        },
        applyMatrix: function(matrix) {
            var position = this.attributes.position;
            void 0 !== position && (matrix.applyToVector3Array(position.array), position.needsUpdate = !0);
            var normal = this.attributes.normal;
            if (void 0 !== normal) {
                var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                normalMatrix.applyToVector3Array(normal.array), normal.needsUpdate = !0;
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), 
            this;
        },
        rotateX: function() {
            var m1;
            return function(angle) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeRotationX(angle), this.applyMatrix(m1), 
                this;
            };
        }(),
        rotateY: function() {
            var m1;
            return function(angle) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeRotationY(angle), this.applyMatrix(m1), 
                this;
            };
        }(),
        rotateZ: function() {
            var m1;
            return function(angle) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeRotationZ(angle), this.applyMatrix(m1), 
                this;
            };
        }(),
        translate: function() {
            var m1;
            return function(x, y, z) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeTranslation(x, y, z), this.applyMatrix(m1), 
                this;
            };
        }(),
        scale: function() {
            var m1;
            return function(x, y, z) {
                return void 0 === m1 && (m1 = new Matrix4()), m1.makeScale(x, y, z), this.applyMatrix(m1), 
                this;
            };
        }(),
        lookAt: function() {
            var obj;
            return function(vector) {
                void 0 === obj && (obj = new Object3D()), obj.lookAt(vector), obj.updateMatrix(), 
                this.applyMatrix(obj.matrix);
            };
        }(),
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            return this.translate(offset.x, offset.y, offset.z), offset;
        },
        setFromObject: function(object) {
            var geometry = object.geometry;
            if (object && object.isPoints || object && object.isLine) {
                var positions = new Float32Attribute(3 * geometry.vertices.length, 3), colors = new Float32Attribute(3 * geometry.colors.length, 3);
                if (this.addAttribute("position", positions.copyVector3sArray(geometry.vertices)), 
                this.addAttribute("color", colors.copyColorsArray(geometry.colors)), geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                    var lineDistances = new Float32Attribute(geometry.lineDistances.length, 1);
                    this.addAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
                }
                null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()), 
                null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone());
            } else object && object.isMesh && geometry && geometry.isGeometry && this.fromGeometry(geometry);
            return this;
        },
        updateFromObject: function(object) {
            var geometry = object.geometry;
            if (object && object.isMesh) {
                var direct = geometry.__directGeometry;
                if (geometry.elementsNeedUpdate === !0 && (direct = void 0, geometry.elementsNeedUpdate = !1), 
                void 0 === direct) return this.fromGeometry(geometry);
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate, direct.normalsNeedUpdate = geometry.normalsNeedUpdate, 
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate, direct.uvsNeedUpdate = geometry.uvsNeedUpdate, 
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate, geometry.verticesNeedUpdate = !1, 
                geometry.normalsNeedUpdate = !1, geometry.colorsNeedUpdate = !1, geometry.uvsNeedUpdate = !1, 
                geometry.groupsNeedUpdate = !1, geometry = direct;
            }
            var attribute;
            return geometry.verticesNeedUpdate === !0 && (attribute = this.attributes.position, 
            void 0 !== attribute && (attribute.copyVector3sArray(geometry.vertices), attribute.needsUpdate = !0), 
            geometry.verticesNeedUpdate = !1), geometry.normalsNeedUpdate === !0 && (attribute = this.attributes.normal, 
            void 0 !== attribute && (attribute.copyVector3sArray(geometry.normals), attribute.needsUpdate = !0), 
            geometry.normalsNeedUpdate = !1), geometry.colorsNeedUpdate === !0 && (attribute = this.attributes.color, 
            void 0 !== attribute && (attribute.copyColorsArray(geometry.colors), attribute.needsUpdate = !0), 
            geometry.colorsNeedUpdate = !1), geometry.uvsNeedUpdate && (attribute = this.attributes.uv, 
            void 0 !== attribute && (attribute.copyVector2sArray(geometry.uvs), attribute.needsUpdate = !0), 
            geometry.uvsNeedUpdate = !1), geometry.lineDistancesNeedUpdate && (attribute = this.attributes.lineDistance, 
            void 0 !== attribute && (attribute.copyArray(geometry.lineDistances), attribute.needsUpdate = !0), 
            geometry.lineDistancesNeedUpdate = !1), geometry.groupsNeedUpdate && (geometry.computeGroups(object.geometry), 
            this.groups = geometry.groups, geometry.groupsNeedUpdate = !1), this;
        },
        fromGeometry: function(geometry) {
            return geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry), 
            this.fromDirectGeometry(geometry.__directGeometry);
        },
        fromDirectGeometry: function(geometry) {
            var positions = new Float32Array(3 * geometry.vertices.length);
            if (this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices)), 
            geometry.normals.length > 0) {
                var normals = new Float32Array(3 * geometry.normals.length);
                this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
            }
            if (geometry.colors.length > 0) {
                var colors = new Float32Array(3 * geometry.colors.length);
                this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
            }
            if (geometry.uvs.length > 0) {
                var uvs = new Float32Array(2 * geometry.uvs.length);
                this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
            }
            if (geometry.uvs2.length > 0) {
                var uvs2 = new Float32Array(2 * geometry.uvs2.length);
                this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
            }
            if (geometry.indices.length > 0) {
                var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array, indices = new TypeArray(3 * geometry.indices.length);
                this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
            }
            this.groups = geometry.groups;
            for (var name in geometry.morphTargets) {
                for (var array = [], morphTargets = geometry.morphTargets[name], i = 0, l = morphTargets.length; l > i; i++) {
                    var morphTarget = morphTargets[i], attribute = new Float32Attribute(3 * morphTarget.length, 3);
                    array.push(attribute.copyVector3sArray(morphTarget));
                }
                this.morphAttributes[name] = array;
            }
            if (geometry.skinIndices.length > 0) {
                var skinIndices = new Float32Attribute(4 * geometry.skinIndices.length, 4);
                this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
            }
            if (geometry.skinWeights.length > 0) {
                var skinWeights = new Float32Attribute(4 * geometry.skinWeights.length, 4);
                this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
            }
            return null !== geometry.boundingSphere && (this.boundingSphere = geometry.boundingSphere.clone()), 
            null !== geometry.boundingBox && (this.boundingBox = geometry.boundingBox.clone()), 
            this;
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Box3());
            var positions = this.attributes.position.array;
            void 0 !== positions ? this.boundingBox.setFromArray(positions) : this.boundingBox.makeEmpty(), 
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        },
        computeBoundingSphere: function() {
            var box = new Box3(), vector = new Vector3();
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new Sphere());
                var positions = this.attributes.position;
                if (positions) {
                    var array = positions.array, center = this.boundingSphere.center;
                    box.setFromArray(array), box.getCenter(center);
                    for (var maxRadiusSq = 0, i = 0, il = array.length; il > i; i += 3) vector.fromArray(array, i), 
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
            };
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var index = this.index, attributes = this.attributes, groups = this.groups;
            if (attributes.position) {
                var positions = attributes.position.array;
                if (void 0 === attributes.normal) this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3)); else for (var array = attributes.normal.array, i = 0, il = array.length; il > i; i++) array[i] = 0;
                var vA, vB, vC, normals = attributes.normal.array, pA = new Vector3(), pB = new Vector3(), pC = new Vector3(), cb = new Vector3(), ab = new Vector3();
                if (index) {
                    var indices = index.array;
                    0 === groups.length && this.addGroup(0, indices.length);
                    for (var j = 0, jl = groups.length; jl > j; ++j) for (var group = groups[j], start = group.start, count = group.count, i = start, il = start + count; il > i; i += 3) vA = 3 * indices[i + 0], 
                    vB = 3 * indices[i + 1], vC = 3 * indices[i + 2], pA.fromArray(positions, vA), pB.fromArray(positions, vB), 
                    pC.fromArray(positions, vC), cb.subVectors(pC, pB), ab.subVectors(pA, pB), cb.cross(ab), 
                    normals[vA] += cb.x, normals[vA + 1] += cb.y, normals[vA + 2] += cb.z, normals[vB] += cb.x, 
                    normals[vB + 1] += cb.y, normals[vB + 2] += cb.z, normals[vC] += cb.x, normals[vC + 1] += cb.y, 
                    normals[vC + 2] += cb.z;
                } else for (var i = 0, il = positions.length; il > i; i += 9) pA.fromArray(positions, i), 
                pB.fromArray(positions, i + 3), pC.fromArray(positions, i + 6), cb.subVectors(pC, pB), 
                ab.subVectors(pA, pB), cb.cross(ab), normals[i] = cb.x, normals[i + 1] = cb.y, normals[i + 2] = cb.z, 
                normals[i + 3] = cb.x, normals[i + 4] = cb.y, normals[i + 5] = cb.z, normals[i + 6] = cb.x, 
                normals[i + 7] = cb.y, normals[i + 8] = cb.z;
                this.normalizeNormals(), attributes.normal.needsUpdate = !0;
            }
        },
        merge: function(geometry, offset) {
            if ((geometry && geometry.isBufferGeometry) === !1) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
            void 0 === offset && (offset = 0);
            var attributes = this.attributes;
            for (var key in attributes) if (void 0 !== geometry.attributes[key]) for (var attribute1 = attributes[key], attributeArray1 = attribute1.array, attribute2 = geometry.attributes[key], attributeArray2 = attribute2.array, attributeSize = attribute2.itemSize, i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, 
            j++) attributeArray1[j] = attributeArray2[i];
            return this;
        },
        normalizeNormals: function() {
            for (var x, y, z, n, normals = this.attributes.normal.array, i = 0, il = normals.length; il > i; i += 3) x = normals[i], 
            y = normals[i + 1], z = normals[i + 2], n = 1 / Math.sqrt(x * x + y * y + z * z), 
            normals[i] *= n, normals[i + 1] *= n, normals[i + 2] *= n;
        },
        toNonIndexed: function() {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), 
            this;
            var geometry2 = new BufferGeometry(), indices = this.index.array, attributes = this.attributes;
            for (var name in attributes) {
                for (var attribute = attributes[name], array = attribute.array, itemSize = attribute.itemSize, array2 = new array.constructor(indices.length * itemSize), index = 0, index2 = 0, i = 0, l = indices.length; l > i; i++) {
                    index = indices[i] * itemSize;
                    for (var j = 0; itemSize > j; j++) array2[index2++] = array[index++];
                }
                geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
            }
            return geometry2;
        },
        toJSON: function() {
            var data = {
                metadata: {
                    version: 4.4,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), 
            void 0 !== this.parameters) {
                var parameters = this.parameters;
                for (var key in parameters) void 0 !== parameters[key] && (data[key] = parameters[key]);
                return data;
            }
            data.data = {
                attributes: {}
            };
            var index = this.index;
            if (null !== index) {
                var array = Array.prototype.slice.call(index.array);
                data.data.index = {
                    type: index.array.constructor.name,
                    array: array
                };
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                var attribute = attributes[key], array = Array.prototype.slice.call(attribute.array);
                data.data.attributes[key] = {
                    itemSize: attribute.itemSize,
                    type: attribute.array.constructor.name,
                    array: array,
                    normalized: attribute.normalized
                };
            }
            var groups = this.groups;
            groups.length > 0 && (data.data.groups = JSON.parse(JSON.stringify(groups)));
            var boundingSphere = this.boundingSphere;
            return null !== boundingSphere && (data.data.boundingSphere = {
                center: boundingSphere.center.toArray(),
                radius: boundingSphere.radius
            }), data;
        },
        clone: function() {
            return new BufferGeometry().copy(this);
        },
        copy: function(source) {
            var index = source.index;
            null !== index && this.setIndex(index.clone());
            var attributes = source.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            for (var groups = source.groups, i = 0, l = groups.length; l > i; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            });
        }
    }), BufferGeometry.MaxIndex = 65535, Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Mesh,
        isMesh: !0,
        setDrawMode: function(value) {
            this.drawMode = value;
        },
        copy: function(source) {
            return Object3D.prototype.copy.call(this, source), this.drawMode = source.drawMode, 
            this;
        },
        updateMorphTargets: function() {
            var morphTargets = this.geometry.morphTargets;
            if (void 0 !== morphTargets && morphTargets.length > 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (var m = 0, ml = morphTargets.length; ml > m; m++) this.morphTargetInfluences.push(0), 
                this.morphTargetDictionary[morphTargets[m].name] = m;
            }
        },
        raycast: function() {
            function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                return Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord), uv1.multiplyScalar(barycoord.x), 
                uv2.multiplyScalar(barycoord.y), uv3.multiplyScalar(barycoord.z), uv1.add(uv2).add(uv3), 
                uv1.clone();
            }
            function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
                var intersect, material = object.material;
                if (intersect = material.side === BackSide ? ray.intersectTriangle(pC, pB, pA, !0, point) : ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point), 
                null === intersect) return null;
                intersectionPointWorld.copy(point), intersectionPointWorld.applyMatrix4(object.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                return distance < raycaster.near || distance > raycaster.far ? null : {
                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    object: object
                };
            }
            function checkBufferGeometryIntersection(object, raycaster, ray, positions, uvs, a, b, c) {
                vA.fromArray(positions, 3 * a), vB.fromArray(positions, 3 * b), vC.fromArray(positions, 3 * c);
                var intersection = checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
                return intersection && (uvs && (uvA.fromArray(uvs, 2 * a), uvB.fromArray(uvs, 2 * b), 
                uvC.fromArray(uvs, 2 * c), intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC)), 
                intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC)), intersection.faceIndex = a), 
                intersection;
            }
            var inverseMatrix = new Matrix4(), ray = new Ray(), sphere = new Sphere(), vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), tempA = new Vector3(), tempB = new Vector3(), tempC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), barycoord = new Vector3(), intersectionPoint = new Vector3(), intersectionPointWorld = new Vector3();
            return function(raycaster, intersects) {
                var geometry = this.geometry, material = this.material, matrixWorld = this.matrixWorld;
                if (void 0 !== material && (null === geometry.boundingSphere && geometry.computeBoundingSphere(), 
                sphere.copy(geometry.boundingSphere), sphere.applyMatrix4(matrixWorld), raycaster.ray.intersectsSphere(sphere) !== !1 && (inverseMatrix.getInverse(matrixWorld), 
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix), null === geometry.boundingBox || ray.intersectsBox(geometry.boundingBox) !== !1))) {
                    var uvs, intersection;
                    if (geometry && geometry.isBufferGeometry) {
                        var a, b, c, index = geometry.index, attributes = geometry.attributes, positions = attributes.position.array;
                        if (void 0 !== attributes.uv && (uvs = attributes.uv.array), null !== index) for (var indices = index.array, i = 0, l = indices.length; l > i; i += 3) a = indices[i], 
                        b = indices[i + 1], c = indices[i + 2], intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c), 
                        intersection && (intersection.faceIndex = Math.floor(i / 3), intersects.push(intersection)); else for (var i = 0, l = positions.length; l > i; i += 9) a = i / 3, 
                        b = a + 1, c = a + 2, intersection = checkBufferGeometryIntersection(this, raycaster, ray, positions, uvs, a, b, c), 
                        intersection && (intersection.index = a, intersects.push(intersection));
                    } else if (geometry && geometry.isGeometry) {
                        var fvA, fvB, fvC, isFaceMaterial = material && material.isMultiMaterial, materials = isFaceMaterial === !0 ? material.materials : null, vertices = geometry.vertices, faces = geometry.faces, faceVertexUvs = geometry.faceVertexUvs[0];
                        faceVertexUvs.length > 0 && (uvs = faceVertexUvs);
                        for (var f = 0, fl = faces.length; fl > f; f++) {
                            var face = faces[f], faceMaterial = isFaceMaterial === !0 ? materials[face.materialIndex] : material;
                            if (void 0 !== faceMaterial) {
                                if (fvA = vertices[face.a], fvB = vertices[face.b], fvC = vertices[face.c], faceMaterial.morphTargets === !0) {
                                    var morphTargets = geometry.morphTargets, morphInfluences = this.morphTargetInfluences;
                                    vA.set(0, 0, 0), vB.set(0, 0, 0), vC.set(0, 0, 0);
                                    for (var t = 0, tl = morphTargets.length; tl > t; t++) {
                                        var influence = morphInfluences[t];
                                        if (0 !== influence) {
                                            var targets = morphTargets[t].vertices;
                                            vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence), vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence), 
                                            vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                                        }
                                    }
                                    vA.add(fvA), vB.add(fvB), vC.add(fvC), fvA = vA, fvB = vB, fvC = vC;
                                }
                                if (intersection = checkIntersection(this, raycaster, ray, fvA, fvB, fvC, intersectionPoint)) {
                                    if (uvs) {
                                        var uvs_f = uvs[f];
                                        uvA.copy(uvs_f[0]), uvB.copy(uvs_f[1]), uvC.copy(uvs_f[2]), intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                                    }
                                    intersection.face = face, intersection.faceIndex = f, intersects.push(intersection);
                                }
                            }
                        }
                    }
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype), BoxBufferGeometry.prototype.constructor = BoxBufferGeometry, 
    PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype), PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry, 
    Camera.prototype = Object.create(Object3D.prototype), Camera.prototype.constructor = Camera, 
    Camera.prototype.isCamera = !0, Camera.prototype.getWorldDirection = function() {
        var quaternion = new Quaternion();
        return function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.getWorldQuaternion(quaternion), result.set(0, 0, -1).applyQuaternion(quaternion);
        };
    }(), Camera.prototype.lookAt = function() {
        var m1 = new Matrix4();
        return function(vector) {
            m1.lookAt(this.position, vector, this.up), this.quaternion.setFromRotationMatrix(m1);
        };
    }(), Camera.prototype.clone = function() {
        return new this.constructor().copy(this);
    }, Camera.prototype.copy = function(source) {
        return Object3D.prototype.copy.call(this, source), this.matrixWorldInverse.copy(source.matrixWorldInverse), 
        this.projectionMatrix.copy(source.projectionMatrix), this;
    }, PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: PerspectiveCamera,
        isPerspectiveCamera: !0,
        copy: function(source) {
            return Camera.prototype.copy.call(this, source), this.fov = source.fov, this.zoom = source.zoom, 
            this.near = source.near, this.far = source.far, this.focus = source.focus, this.aspect = source.aspect, 
            this.view = null === source.view ? null : Object.assign({}, source.view), this.filmGauge = source.filmGauge, 
            this.filmOffset = source.filmOffset, this;
        },
        setFocalLength: function(focalLength) {
            var vExtentSlope = .5 * this.getFilmHeight() / focalLength;
            this.fov = 2 * _Math.RAD2DEG * Math.atan(vExtentSlope), this.updateProjectionMatrix();
        },
        getFocalLength: function() {
            var vExtentSlope = Math.tan(.5 * _Math.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / vExtentSlope;
        },
        getEffectiveFOV: function() {
            return 2 * _Math.RAD2DEG * Math.atan(Math.tan(.5 * _Math.DEG2RAD * this.fov) / this.zoom);
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight, this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            }, this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            this.view = null, this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var near = this.near, top = near * Math.tan(.5 * _Math.DEG2RAD * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -.5 * width, view = this.view;
            if (null !== view) {
                var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth, top -= view.offsetY * height / fullHeight, 
                width *= view.width / fullWidth, height *= view.height / fullHeight;
            }
            var skew = this.filmOffset;
            0 !== skew && (left += near * skew / this.getFilmWidth()), this.projectionMatrix.makeFrustum(left, left + width, top - height, top, near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return data.object.fov = this.fov, data.object.zoom = this.zoom, data.object.near = this.near, 
            data.object.far = this.far, data.object.focus = this.focus, data.object.aspect = this.aspect, 
            null !== this.view && (data.object.view = Object.assign({}, this.view)), data.object.filmGauge = this.filmGauge, 
            data.object.filmOffset = this.filmOffset, data;
        }
    }), OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: OrthographicCamera,
        isOrthographicCamera: !0,
        copy: function(source) {
            return Camera.prototype.copy.call(this, source), this.left = source.left, this.right = source.right, 
            this.top = source.top, this.bottom = source.bottom, this.near = source.near, this.far = source.far, 
            this.zoom = source.zoom, this.view = null === source.view ? null : Object.assign({}, source.view), 
            this;
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            this.view = {
                fullWidth: fullWidth,
                fullHeight: fullHeight,
                offsetX: x,
                offsetY: y,
                width: width,
                height: height
            }, this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            this.view = null, this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var dx = (this.right - this.left) / (2 * this.zoom), dy = (this.top - this.bottom) / (2 * this.zoom), cx = (this.right + this.left) / 2, cy = (this.top + this.bottom) / 2, left = cx - dx, right = cx + dx, top = cy + dy, bottom = cy - dy;
            if (null !== this.view) {
                var zoomW = this.zoom / (this.view.width / this.view.fullWidth), zoomH = this.zoom / (this.view.height / this.view.fullHeight), scaleW = (this.right - this.left) / this.view.width, scaleH = (this.top - this.bottom) / this.view.height;
                left += scaleW * (this.view.offsetX / zoomW), right = left + scaleW * (this.view.width / zoomW), 
                top -= scaleH * (this.view.offsetY / zoomH), bottom = top - scaleH * (this.view.height / zoomH);
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return data.object.zoom = this.zoom, data.object.left = this.left, data.object.right = this.right, 
            data.object.top = this.top, data.object.bottom = this.bottom, data.object.near = this.near, 
            data.object.far = this.far, null !== this.view && (data.object.view = Object.assign({}, this.view)), 
            data;
        }
    });
    var programIdCount = 0;
    FogExp2.prototype.isFogExp2 = !0, FogExp2.prototype.clone = function() {
        return new FogExp2(this.color.getHex(), this.density);
    }, FogExp2.prototype.toJSON = function(meta) {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        };
    }, Fog.prototype.isFog = !0, Fog.prototype.clone = function() {
        return new Fog(this.color.getHex(), this.near, this.far);
    }, Fog.prototype.toJSON = function(meta) {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }, Scene.prototype = Object.create(Object3D.prototype), Scene.prototype.constructor = Scene, 
    Scene.prototype.copy = function(source, recursive) {
        return Object3D.prototype.copy.call(this, source, recursive), null !== source.background && (this.background = source.background.clone()), 
        null !== source.fog && (this.fog = source.fog.clone()), null !== source.overrideMaterial && (this.overrideMaterial = source.overrideMaterial.clone()), 
        this.autoUpdate = source.autoUpdate, this.matrixAutoUpdate = source.matrixAutoUpdate, 
        this;
    }, Scene.prototype.toJSON = function(meta) {
        var data = Object3D.prototype.toJSON.call(this, meta);
        return null !== this.background && (data.object.background = this.background.toJSON(meta)), 
        null !== this.fog && (data.object.fog = this.fog.toJSON()), data;
    }, LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LensFlare,
        isLensFlare: !0,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source), this.positionScreen.copy(source.positionScreen), 
            this.customUpdateCallback = source.customUpdateCallback;
            for (var i = 0, l = source.lensFlares.length; l > i; i++) this.lensFlares.push(source.lensFlares[i]);
            return this;
        },
        add: function(texture, size, distance, blending, color, opacity) {
            void 0 === size && (size = -1), void 0 === distance && (distance = 0), void 0 === opacity && (opacity = 1), 
            void 0 === color && (color = new Color(16777215)), void 0 === blending && (blending = NormalBlending), 
            distance = Math.min(distance, Math.max(0, distance)), this.lensFlares.push({
                texture: texture,
                size: size,
                distance: distance,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: opacity,
                color: color,
                blending: blending
            });
        },
        updateLensFlares: function() {
            var f, flare, fl = this.lensFlares.length, vecX = 2 * -this.positionScreen.x, vecY = 2 * -this.positionScreen.y;
            for (f = 0; fl > f; f++) flare = this.lensFlares[f], flare.x = this.positionScreen.x + vecX * flare.distance, 
            flare.y = this.positionScreen.y + vecY * flare.distance, flare.wantedRotation = flare.x * Math.PI * .25, 
            flare.rotation += .25 * (flare.wantedRotation - flare.rotation);
        }
    }), SpriteMaterial.prototype = Object.create(Material.prototype), SpriteMaterial.prototype.constructor = SpriteMaterial, 
    SpriteMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.map = source.map, this.rotation = source.rotation, this;
    }, Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Sprite,
        isSprite: !0,
        raycast: function() {
            var matrixPosition = new Vector3();
            return function(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distanceSq = raycaster.ray.distanceSqToPoint(matrixPosition), guessSizeSq = this.scale.x * this.scale.y / 4;
                distanceSq > guessSizeSq || intersects.push({
                    distance: Math.sqrt(distanceSq),
                    point: this.position,
                    face: null,
                    object: this
                });
            };
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this);
        }
    }), LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LOD,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source, !1);
            for (var levels = source.levels, i = 0, l = levels.length; l > i; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance);
            }
            return this;
        },
        addLevel: function(object, distance) {
            void 0 === distance && (distance = 0), distance = Math.abs(distance);
            for (var levels = this.levels, l = 0; l < levels.length && !(distance < levels[l].distance); l++) ;
            levels.splice(l, 0, {
                distance: distance,
                object: object
            }), this.add(object);
        },
        getObjectForDistance: function(distance) {
            for (var levels = this.levels, i = 1, l = levels.length; l > i && !(distance < levels[i].distance); i++) ;
            return levels[i - 1].object;
        },
        raycast: function() {
            var matrixPosition = new Vector3();
            return function(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(matrixPosition);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
            };
        }(),
        update: function() {
            var v1 = new Vector3(), v2 = new Vector3();
            return function(camera) {
                var levels = this.levels;
                if (levels.length > 1) {
                    v1.setFromMatrixPosition(camera.matrixWorld), v2.setFromMatrixPosition(this.matrixWorld);
                    var distance = v1.distanceTo(v2);
                    levels[0].object.visible = !0;
                    for (var i = 1, l = levels.length; l > i && distance >= levels[i].distance; i++) levels[i - 1].object.visible = !1, 
                    levels[i].object.visible = !0;
                    for (;l > i; i++) levels[i].object.visible = !1;
                }
            };
        }(),
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.levels = [];
            for (var levels = this.levels, i = 0, l = levels.length; l > i; i++) {
                var level = levels[i];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }
            return data;
        }
    }), DataTexture.prototype = Object.create(Texture.prototype), DataTexture.prototype.constructor = DataTexture, 
    DataTexture.prototype.isDataTexture = !0, Object.assign(Skeleton.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var b = 0, bl = this.bones.length; bl > b; b++) {
                var inverse = new Matrix4();
                this.bones[b] && inverse.getInverse(this.bones[b].matrixWorld), this.boneInverses.push(inverse);
            }
        },
        pose: function() {
            for (var bone, b = 0, bl = this.bones.length; bl > b; b++) bone = this.bones[b], 
            bone && bone.matrixWorld.getInverse(this.boneInverses[b]);
            for (var b = 0, bl = this.bones.length; bl > b; b++) bone = this.bones[b], bone && (bone.parent && bone.parent.isBone ? (bone.matrix.getInverse(bone.parent.matrixWorld), 
            bone.matrix.multiply(bone.matrixWorld)) : bone.matrix.copy(bone.matrixWorld), bone.matrix.decompose(bone.position, bone.quaternion, bone.scale));
        },
        update: function() {
            var offsetMatrix = new Matrix4();
            return function() {
                for (var b = 0, bl = this.bones.length; bl > b; b++) {
                    var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
                    offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]), offsetMatrix.toArray(this.boneMatrices, 16 * b);
                }
                this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
            };
        }(),
        clone: function() {
            return new Skeleton(this.bones, this.boneInverses, this.useVertexTexture);
        }
    }), Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Bone,
        isBone: !0,
        copy: function(source) {
            return Object3D.prototype.copy.call(this, source), this.skin = source.skin, this;
        }
    }), SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
        constructor: SkinnedMesh,
        isSkinnedMesh: !0,
        bind: function(skeleton, bindMatrix) {
            this.skeleton = skeleton, void 0 === bindMatrix && (this.updateMatrixWorld(!0), 
            this.skeleton.calculateInverses(), bindMatrix = this.matrixWorld), this.bindMatrix.copy(bindMatrix), 
            this.bindMatrixInverse.getInverse(bindMatrix);
        },
        pose: function() {
            this.skeleton.pose();
        },
        normalizeSkinWeights: function() {
            if (this.geometry && this.geometry.isGeometry) for (var i = 0; i < this.geometry.skinWeights.length; i++) {
                var sw = this.geometry.skinWeights[i], scale = 1 / sw.lengthManhattan();
                scale !== 1 / 0 ? sw.multiplyScalar(scale) : sw.set(1, 0, 0, 0);
            } else if (this.geometry && this.geometry.isBufferGeometry) for (var vec = new Vector4(), skinWeight = this.geometry.attributes.skinWeight, i = 0; i < skinWeight.count; i++) {
                vec.x = skinWeight.getX(i), vec.y = skinWeight.getY(i), vec.z = skinWeight.getZ(i), 
                vec.w = skinWeight.getW(i);
                var scale = 1 / vec.lengthManhattan();
                scale !== 1 / 0 ? vec.multiplyScalar(scale) : vec.set(1, 0, 0, 0), skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
            }
        },
        updateMatrixWorld: function(force) {
            Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode);
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this);
        }
    }), LineBasicMaterial.prototype = Object.create(Material.prototype), LineBasicMaterial.prototype.constructor = LineBasicMaterial, 
    LineBasicMaterial.prototype.isLineBasicMaterial = !0, LineBasicMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.linewidth = source.linewidth, this.linecap = source.linecap, this.linejoin = source.linejoin, 
        this;
    }, Line.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Line,
        isLine: !0,
        raycast: function() {
            var inverseMatrix = new Matrix4(), ray = new Ray(), sphere = new Sphere();
            return function(raycaster, intersects) {
                var precision = raycaster.linePrecision, precisionSq = precision * precision, geometry = this.geometry, matrixWorld = this.matrixWorld;
                if (null === geometry.boundingSphere && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere), 
                sphere.applyMatrix4(matrixWorld), raycaster.ray.intersectsSphere(sphere) !== !1) {
                    inverseMatrix.getInverse(matrixWorld), ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                    var vStart = new Vector3(), vEnd = new Vector3(), interSegment = new Vector3(), interRay = new Vector3(), step = this && this.isLineSegments ? 2 : 1;
                    if (geometry && geometry.isBufferGeometry) {
                        var index = geometry.index, attributes = geometry.attributes, positions = attributes.position.array;
                        if (null !== index) for (var indices = index.array, i = 0, l = indices.length - 1; l > i; i += step) {
                            var a = indices[i], b = indices[i + 1];
                            vStart.fromArray(positions, 3 * a), vEnd.fromArray(positions, 3 * b);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (!(distSq > precisionSq)) {
                                interRay.applyMatrix4(this.matrixWorld);
                                var distance = raycaster.ray.origin.distanceTo(interRay);
                                distance < raycaster.near || distance > raycaster.far || intersects.push({
                                    distance: distance,
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                });
                            }
                        } else for (var i = 0, l = positions.length / 3 - 1; l > i; i += step) {
                            vStart.fromArray(positions, 3 * i), vEnd.fromArray(positions, 3 * i + 3);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (!(distSq > precisionSq)) {
                                interRay.applyMatrix4(this.matrixWorld);
                                var distance = raycaster.ray.origin.distanceTo(interRay);
                                distance < raycaster.near || distance > raycaster.far || intersects.push({
                                    distance: distance,
                                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                });
                            }
                        }
                    } else if (geometry && geometry.isGeometry) for (var vertices = geometry.vertices, nbVertices = vertices.length, i = 0; nbVertices - 1 > i; i += step) {
                        var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                        if (!(distSq > precisionSq)) {
                            interRay.applyMatrix4(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            distance < raycaster.near || distance > raycaster.far || intersects.push({
                                distance: distance,
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    }
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineSegments,
        isLineSegments: !0
    }), PointsMaterial.prototype = Object.create(Material.prototype), PointsMaterial.prototype.constructor = PointsMaterial, 
    PointsMaterial.prototype.isPointsMaterial = !0, PointsMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.map = source.map, this.size = source.size, this.sizeAttenuation = source.sizeAttenuation, 
        this;
    }, Points.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Points,
        isPoints: !0,
        raycast: function() {
            var inverseMatrix = new Matrix4(), ray = new Ray(), sphere = new Sphere();
            return function(raycaster, intersects) {
                function testPoint(point, index) {
                    var rayPointDistanceSq = ray.distanceSqToPoint(point);
                    if (localThresholdSq > rayPointDistanceSq) {
                        var intersectPoint = ray.closestPointToPoint(point);
                        intersectPoint.applyMatrix4(matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far) return;
                        intersects.push({
                            distance: distance,
                            distanceToRay: Math.sqrt(rayPointDistanceSq),
                            point: intersectPoint.clone(),
                            index: index,
                            face: null,
                            object: object
                        });
                    }
                }
                var object = this, geometry = this.geometry, matrixWorld = this.matrixWorld, threshold = raycaster.params.Points.threshold;
                if (null === geometry.boundingSphere && geometry.computeBoundingSphere(), sphere.copy(geometry.boundingSphere), 
                sphere.applyMatrix4(matrixWorld), raycaster.ray.intersectsSphere(sphere) !== !1) {
                    inverseMatrix.getInverse(matrixWorld), ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3), localThresholdSq = localThreshold * localThreshold, position = new Vector3();
                    if (geometry && geometry.isBufferGeometry) {
                        var index = geometry.index, attributes = geometry.attributes, positions = attributes.position.array;
                        if (null !== index) for (var indices = index.array, i = 0, il = indices.length; il > i; i++) {
                            var a = indices[i];
                            position.fromArray(positions, 3 * a), testPoint(position, a);
                        } else for (var i = 0, l = positions.length / 3; l > i; i++) position.fromArray(positions, 3 * i), 
                        testPoint(position, i);
                    } else for (var vertices = geometry.vertices, i = 0, l = vertices.length; l > i; i++) testPoint(vertices[i], i);
                }
            };
        }(),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    }), Group.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Group
    }), VideoTexture.prototype = Object.create(Texture.prototype), VideoTexture.prototype.constructor = VideoTexture, 
    CompressedTexture.prototype = Object.create(Texture.prototype), CompressedTexture.prototype.constructor = CompressedTexture, 
    CompressedTexture.prototype.isCompressedTexture = !0, CanvasTexture.prototype = Object.create(Texture.prototype), 
    CanvasTexture.prototype.constructor = CanvasTexture, DepthTexture.prototype = Object.create(Texture.prototype), 
    DepthTexture.prototype.constructor = DepthTexture, DepthTexture.prototype.isDepthTexture = !0, 
    WireframeGeometry.prototype = Object.create(BufferGeometry.prototype), WireframeGeometry.prototype.constructor = WireframeGeometry, 
    ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype), ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry, 
    ParametricGeometry.prototype = Object.create(Geometry.prototype), ParametricGeometry.prototype.constructor = ParametricGeometry, 
    PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype), PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry, 
    TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype), 
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry, TetrahedronGeometry.prototype = Object.create(Geometry.prototype), 
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry, OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype), 
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry, OctahedronGeometry.prototype = Object.create(Geometry.prototype), 
    OctahedronGeometry.prototype.constructor = OctahedronGeometry, IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype), 
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry, IcosahedronGeometry.prototype = Object.create(Geometry.prototype), 
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry, DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype), 
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry, DodecahedronGeometry.prototype = Object.create(Geometry.prototype), 
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry, PolyhedronGeometry.prototype = Object.create(Geometry.prototype), 
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry, TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype), 
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry, TubeGeometry.prototype = Object.create(Geometry.prototype), 
    TubeGeometry.prototype.constructor = TubeGeometry, TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype), 
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry, TorusKnotGeometry.prototype = Object.create(Geometry.prototype), 
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry, TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype), 
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry, TorusGeometry.prototype = Object.create(Geometry.prototype), 
    TorusGeometry.prototype.constructor = TorusGeometry;
    var ShapeUtils = {
        area: function(contour) {
            for (var n = contour.length, a = 0, p = n - 1, q = 0; n > q; p = q++) a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            return .5 * a;
        },
        triangulate: function() {
            function snip(contour, u, v, w, n, verts) {
                var p, ax, ay, bx, by, cx, cy, px, py;
                if (ax = contour[verts[u]].x, ay = contour[verts[u]].y, bx = contour[verts[v]].x, 
                by = contour[verts[v]].y, cx = contour[verts[w]].x, cy = contour[verts[w]].y, 0 >= (bx - ax) * (cy - ay) - (by - ay) * (cx - ax)) return !1;
                var aX, aY, bX, bY, cX, cY, apx, apy, bpx, bpy, cpx, cpy, cCROSSap, bCROSScp, aCROSSbp;
                for (aX = cx - bx, aY = cy - by, bX = ax - cx, bY = ay - cy, cX = bx - ax, cY = by - ay, 
                p = 0; n > p; p++) if (px = contour[verts[p]].x, py = contour[verts[p]].y, !(px === ax && py === ay || px === bx && py === by || px === cx && py === cy) && (apx = px - ax, 
                apy = py - ay, bpx = px - bx, bpy = py - by, cpx = px - cx, cpy = py - cy, aCROSSbp = aX * bpy - aY * bpx, 
                cCROSSap = cX * apy - cY * apx, bCROSScp = bX * cpy - bY * cpx, aCROSSbp >= -Number.EPSILON && bCROSScp >= -Number.EPSILON && cCROSSap >= -Number.EPSILON)) return !1;
                return !0;
            }
            return function(contour, indices) {
                var n = contour.length;
                if (3 > n) return null;
                var u, v, w, result = [], verts = [], vertIndices = [];
                if (ShapeUtils.area(contour) > 0) for (v = 0; n > v; v++) verts[v] = v; else for (v = 0; n > v; v++) verts[v] = n - 1 - v;
                var nv = n, count = 2 * nv;
                for (v = nv - 1; nv > 2; ) {
                    if (count-- <= 0) return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"), 
                    indices ? vertIndices : result;
                    if (u = v, u >= nv && (u = 0), v = u + 1, v >= nv && (v = 0), w = v + 1, w >= nv && (w = 0), 
                    snip(contour, u, v, w, nv, verts)) {
                        var a, b, c, s, t;
                        for (a = verts[u], b = verts[v], c = verts[w], result.push([ contour[a], contour[b], contour[c] ]), 
                        vertIndices.push([ verts[u], verts[v], verts[w] ]), s = v, t = v + 1; nv > t; s++, 
                        t++) verts[s] = verts[t];
                        nv--, count = 2 * nv;
                    }
                }
                return indices ? vertIndices : result;
            };
        }(),
        triangulateShape: function(contour, holes) {
            function removeDupEndPts(points) {
                var l = points.length;
                l > 2 && points[l - 1].equals(points[0]) && points.pop();
            }
            function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
                return inSegPt1.x !== inSegPt2.x ? inSegPt1.x < inSegPt2.x ? inSegPt1.x <= inOtherPt.x && inOtherPt.x <= inSegPt2.x : inSegPt2.x <= inOtherPt.x && inOtherPt.x <= inSegPt1.x : inSegPt1.y < inSegPt2.y ? inSegPt1.y <= inOtherPt.y && inOtherPt.y <= inSegPt2.y : inSegPt2.y <= inOtherPt.y && inOtherPt.y <= inSegPt1.y;
            }
            function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
                var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x, seg1dy = inSeg1Pt2.y - inSeg1Pt1.y, seg2dx = inSeg2Pt2.x - inSeg2Pt1.x, seg2dy = inSeg2Pt2.y - inSeg2Pt1.y, seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x, seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y, limit = seg1dy * seg2dx - seg1dx * seg2dy, perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
                if (Math.abs(limit) > Number.EPSILON) {
                    var perpSeg2;
                    if (limit > 0) {
                        if (0 > perpSeg1 || perpSeg1 > limit) return [];
                        if (perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy, 0 > perpSeg2 || perpSeg2 > limit) return [];
                    } else {
                        if (perpSeg1 > 0 || limit > perpSeg1) return [];
                        if (perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy, perpSeg2 > 0 || limit > perpSeg2) return [];
                    }
                    if (0 === perpSeg2) return !inExcludeAdjacentSegs || 0 !== perpSeg1 && perpSeg1 !== limit ? [ inSeg1Pt1 ] : [];
                    if (perpSeg2 === limit) return !inExcludeAdjacentSegs || 0 !== perpSeg1 && perpSeg1 !== limit ? [ inSeg1Pt2 ] : [];
                    if (0 === perpSeg1) return [ inSeg2Pt1 ];
                    if (perpSeg1 === limit) return [ inSeg2Pt2 ];
                    var factorSeg1 = perpSeg2 / limit;
                    return [ {
                        x: inSeg1Pt1.x + factorSeg1 * seg1dx,
                        y: inSeg1Pt1.y + factorSeg1 * seg1dy
                    } ];
                }
                if (0 !== perpSeg1 || seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy) return [];
                var seg1Pt = 0 === seg1dx && 0 === seg1dy, seg2Pt = 0 === seg2dx && 0 === seg2dy;
                if (seg1Pt && seg2Pt) return inSeg1Pt1.x !== inSeg2Pt1.x || inSeg1Pt1.y !== inSeg2Pt1.y ? [] : [ inSeg1Pt1 ];
                if (seg1Pt) return point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1) ? [ inSeg1Pt1 ] : [];
                if (seg2Pt) return point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1) ? [ inSeg2Pt1 ] : [];
                var seg1min, seg1max, seg1minVal, seg1maxVal, seg2min, seg2max, seg2minVal, seg2maxVal;
                return 0 !== seg1dx ? (inSeg1Pt1.x < inSeg1Pt2.x ? (seg1min = inSeg1Pt1, seg1minVal = inSeg1Pt1.x, 
                seg1max = inSeg1Pt2, seg1maxVal = inSeg1Pt2.x) : (seg1min = inSeg1Pt2, seg1minVal = inSeg1Pt2.x, 
                seg1max = inSeg1Pt1, seg1maxVal = inSeg1Pt1.x), inSeg2Pt1.x < inSeg2Pt2.x ? (seg2min = inSeg2Pt1, 
                seg2minVal = inSeg2Pt1.x, seg2max = inSeg2Pt2, seg2maxVal = inSeg2Pt2.x) : (seg2min = inSeg2Pt2, 
                seg2minVal = inSeg2Pt2.x, seg2max = inSeg2Pt1, seg2maxVal = inSeg2Pt1.x)) : (inSeg1Pt1.y < inSeg1Pt2.y ? (seg1min = inSeg1Pt1, 
                seg1minVal = inSeg1Pt1.y, seg1max = inSeg1Pt2, seg1maxVal = inSeg1Pt2.y) : (seg1min = inSeg1Pt2, 
                seg1minVal = inSeg1Pt2.y, seg1max = inSeg1Pt1, seg1maxVal = inSeg1Pt1.y), inSeg2Pt1.y < inSeg2Pt2.y ? (seg2min = inSeg2Pt1, 
                seg2minVal = inSeg2Pt1.y, seg2max = inSeg2Pt2, seg2maxVal = inSeg2Pt2.y) : (seg2min = inSeg2Pt2, 
                seg2minVal = inSeg2Pt2.y, seg2max = inSeg2Pt1, seg2maxVal = inSeg2Pt1.y)), seg2minVal >= seg1minVal ? seg2minVal > seg1maxVal ? [] : seg1maxVal === seg2minVal ? inExcludeAdjacentSegs ? [] : [ seg2min ] : seg2maxVal >= seg1maxVal ? [ seg2min, seg1max ] : [ seg2min, seg2max ] : seg1minVal > seg2maxVal ? [] : seg1minVal === seg2maxVal ? inExcludeAdjacentSegs ? [] : [ seg1min ] : seg2maxVal >= seg1maxVal ? [ seg1min, seg1max ] : [ seg1min, seg2max ];
            }
            function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
                var legFromPtX = inLegFromPt.x - inVertex.x, legFromPtY = inLegFromPt.y - inVertex.y, legToPtX = inLegToPt.x - inVertex.x, legToPtY = inLegToPt.y - inVertex.y, otherPtX = inOtherPt.x - inVertex.x, otherPtY = inOtherPt.y - inVertex.y, from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX, from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
                if (Math.abs(from2toAngle) > Number.EPSILON) {
                    var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
                    return from2toAngle > 0 ? from2otherAngle >= 0 && other2toAngle >= 0 : from2otherAngle >= 0 || other2toAngle >= 0;
                }
                return from2otherAngle > 0;
            }
            function removeHoles(contour, holes) {
                function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
                    var lastShapeIdx = shape.length - 1, prevShapeIdx = inShapeIdx - 1;
                    0 > prevShapeIdx && (prevShapeIdx = lastShapeIdx);
                    var nextShapeIdx = inShapeIdx + 1;
                    nextShapeIdx > lastShapeIdx && (nextShapeIdx = 0);
                    var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
                    if (!insideAngle) return !1;
                    var lastHoleIdx = hole.length - 1, prevHoleIdx = inHoleIdx - 1;
                    0 > prevHoleIdx && (prevHoleIdx = lastHoleIdx);
                    var nextHoleIdx = inHoleIdx + 1;
                    return nextHoleIdx > lastHoleIdx && (nextHoleIdx = 0), insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]), 
                    !!insideAngle;
                }
                function intersectsShapeEdge(inShapePt, inHolePt) {
                    var sIdx, nextIdx, intersection;
                    for (sIdx = 0; sIdx < shape.length; sIdx++) if (nextIdx = sIdx + 1, nextIdx %= shape.length, 
                    intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], !0), 
                    intersection.length > 0) return !0;
                    return !1;
                }
                function intersectsHoleEdge(inShapePt, inHolePt) {
                    var ihIdx, chkHole, hIdx, nextIdx, intersection;
                    for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) for (chkHole = holes[indepHoles[ihIdx]], 
                    hIdx = 0; hIdx < chkHole.length; hIdx++) if (nextIdx = hIdx + 1, nextIdx %= chkHole.length, 
                    intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], !0), 
                    intersection.length > 0) return !0;
                    return !1;
                }
                for (var hole, holeIndex, shapeIndex, shapePt, holePt, holeIdx, cutKey, tmpShape1, tmpShape2, tmpHole1, tmpHole2, shape = contour.concat(), indepHoles = [], failedCuts = [], h = 0, hl = holes.length; hl > h; h++) indepHoles.push(h);
                for (var minShapeIndex = 0, counter = 2 * indepHoles.length; indepHoles.length > 0; ) {
                    if (counter--, 0 > counter) {
                        console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
                        break;
                    }
                    for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
                        shapePt = shape[shapeIndex], holeIndex = -1;
                        for (var h = 0; h < indepHoles.length; h++) if (holeIdx = indepHoles[h], cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx, 
                        void 0 === failedCuts[cutKey]) {
                            hole = holes[holeIdx];
                            for (var h2 = 0; h2 < hole.length; h2++) if (holePt = hole[h2], isCutLineInsideAngles(shapeIndex, h2) && !intersectsShapeEdge(shapePt, holePt) && !intersectsHoleEdge(shapePt, holePt)) {
                                holeIndex = h2, indepHoles.splice(h, 1), tmpShape1 = shape.slice(0, shapeIndex + 1), 
                                tmpShape2 = shape.slice(shapeIndex), tmpHole1 = hole.slice(holeIndex), tmpHole2 = hole.slice(0, holeIndex + 1), 
                                shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2), minShapeIndex = shapeIndex;
                                break;
                            }
                            if (holeIndex >= 0) break;
                            failedCuts[cutKey] = !0;
                        }
                        if (holeIndex >= 0) break;
                    }
                }
                return shape;
            }
            removeDupEndPts(contour), holes.forEach(removeDupEndPts);
            for (var i, il, f, face, key, index, allPointsMap = {}, allpoints = contour.concat(), h = 0, hl = holes.length; hl > h; h++) Array.prototype.push.apply(allpoints, holes[h]);
            for (i = 0, il = allpoints.length; il > i; i++) key = allpoints[i].x + ":" + allpoints[i].y, 
            void 0 !== allPointsMap[key] && console.warn("THREE.ShapeUtils: Duplicate point", key, i), 
            allPointsMap[key] = i;
            var shapeWithoutHoles = removeHoles(contour, holes), triangles = ShapeUtils.triangulate(shapeWithoutHoles, !1);
            for (i = 0, il = triangles.length; il > i; i++) for (face = triangles[i], f = 0; 3 > f; f++) key = face[f].x + ":" + face[f].y, 
            index = allPointsMap[key], void 0 !== index && (face[f] = index);
            return triangles.concat();
        },
        isClockWise: function(pts) {
            return ShapeUtils.area(pts) < 0;
        },
        b2: function() {
            function b2p0(t, p) {
                var k = 1 - t;
                return k * k * p;
            }
            function b2p1(t, p) {
                return 2 * (1 - t) * t * p;
            }
            function b2p2(t, p) {
                return t * t * p;
            }
            return function(t, p0, p1, p2) {
                return b2p0(t, p0) + b2p1(t, p1) + b2p2(t, p2);
            };
        }(),
        b3: function() {
            function b3p0(t, p) {
                var k = 1 - t;
                return k * k * k * p;
            }
            function b3p1(t, p) {
                var k = 1 - t;
                return 3 * k * k * t * p;
            }
            function b3p2(t, p) {
                var k = 1 - t;
                return 3 * k * t * t * p;
            }
            function b3p3(t, p) {
                return t * t * t * p;
            }
            return function(t, p0, p1, p2, p3) {
                return b3p0(t, p0) + b3p1(t, p1) + b3p2(t, p2) + b3p3(t, p3);
            };
        }()
    };
    ExtrudeGeometry.prototype = Object.create(Geometry.prototype), ExtrudeGeometry.prototype.constructor = ExtrudeGeometry, 
    ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
        for (var sl = shapes.length, s = 0; sl > s; s++) {
            var shape = shapes[s];
            this.addShape(shape, options);
        }
    }, ExtrudeGeometry.prototype.addShape = function(shape, options) {
        function scalePt2(pt, vec, size) {
            return vec || console.error("THREE.ExtrudeGeometry: vec does not exist"), vec.clone().multiplyScalar(size).add(pt);
        }
        function getBevelVec(inPt, inPrev, inNext) {
            var v_trans_x, v_trans_y, shrink_by = 1, v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y, v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y, v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y, collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
                var v_prev_len = Math.sqrt(v_prev_lensq), v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y), ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len, ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len, ptNextShift_x = inNext.x - v_next_y / v_next_len, ptNextShift_y = inNext.y + v_next_x / v_next_len, sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x, v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                if (2 >= v_trans_lensq) return new Vector2(v_trans_x, v_trans_y);
                shrink_by = Math.sqrt(v_trans_lensq / 2);
            } else {
                var direction_eq = !1;
                v_prev_x > Number.EPSILON ? v_next_x > Number.EPSILON && (direction_eq = !0) : v_prev_x < -Number.EPSILON ? v_next_x < -Number.EPSILON && (direction_eq = !0) : Math.sign(v_prev_y) === Math.sign(v_next_y) && (direction_eq = !0), 
                direction_eq ? (v_trans_x = -v_prev_y, v_trans_y = v_prev_x, shrink_by = Math.sqrt(v_prev_lensq)) : (v_trans_x = v_prev_x, 
                v_trans_y = v_prev_y, shrink_by = Math.sqrt(v_prev_lensq / 2));
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        function buildLidFaces() {
            if (bevelEnabled) {
                var layer = 0, offset = vlen * layer;
                for (i = 0; flen > i; i++) face = faces[i], f3(face[2] + offset, face[1] + offset, face[0] + offset);
                for (layer = steps + 2 * bevelSegments, offset = vlen * layer, i = 0; flen > i; i++) face = faces[i], 
                f3(face[0] + offset, face[1] + offset, face[2] + offset);
            } else {
                for (i = 0; flen > i; i++) face = faces[i], f3(face[2], face[1], face[0]);
                for (i = 0; flen > i; i++) face = faces[i], f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
        }
        function buildSideFaces() {
            var layeroffset = 0;
            for (sidewalls(contour, layeroffset), layeroffset += contour.length, h = 0, hl = holes.length; hl > h; h++) ahole = holes[h], 
            sidewalls(ahole, layeroffset), layeroffset += ahole.length;
        }
        function sidewalls(contour, layeroffset) {
            var j, k;
            for (i = contour.length; --i >= 0; ) {
                j = i, k = i - 1, 0 > k && (k = contour.length - 1);
                var s = 0, sl = steps + 2 * bevelSegments;
                for (s = 0; sl > s; s++) {
                    var slen1 = vlen * s, slen2 = vlen * (s + 1), a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
                    f4(a, b, c, d, contour, s, sl, j, k);
                }
            }
        }
        function v(x, y, z) {
            scope.vertices.push(new Vector3(x, y, z));
        }
        function f3(a, b, c) {
            a += shapesOffset, b += shapesOffset, c += shapesOffset, scope.faces.push(new Face3(a, b, c, null, null, 0));
            var uvs = uvgen.generateTopUV(scope, a, b, c);
            scope.faceVertexUvs[0].push(uvs);
        }
        function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
            a += shapesOffset, b += shapesOffset, c += shapesOffset, d += shapesOffset, scope.faces.push(new Face3(a, b, d, null, null, 1)), 
            scope.faces.push(new Face3(b, c, d, null, null, 1));
            var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
            scope.faceVertexUvs[0].push([ uvs[0], uvs[1], uvs[3] ]), scope.faceVertexUvs[0].push([ uvs[1], uvs[2], uvs[3] ]);
        }
        var extrudePts, splineTube, binormal, normal, position2, amount = void 0 !== options.amount ? options.amount : 100, bevelThickness = void 0 !== options.bevelThickness ? options.bevelThickness : 6, bevelSize = void 0 !== options.bevelSize ? options.bevelSize : bevelThickness - 2, bevelSegments = void 0 !== options.bevelSegments ? options.bevelSegments : 3, bevelEnabled = void 0 !== options.bevelEnabled ? options.bevelEnabled : !0, curveSegments = void 0 !== options.curveSegments ? options.curveSegments : 12, steps = void 0 !== options.steps ? options.steps : 1, extrudePath = options.extrudePath, extrudeByPath = !1, uvgen = void 0 !== options.UVGenerator ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
        extrudePath && (extrudePts = extrudePath.getSpacedPoints(steps), extrudeByPath = !0, 
        bevelEnabled = !1, splineTube = void 0 !== options.frames ? options.frames : extrudePath.computeFrenetFrames(steps, !1), 
        binormal = new Vector3(), normal = new Vector3(), position2 = new Vector3()), bevelEnabled || (bevelSegments = 0, 
        bevelThickness = 0, bevelSize = 0);
        var ahole, h, hl, scope = this, shapesOffset = this.vertices.length, shapePoints = shape.extractPoints(curveSegments), vertices = shapePoints.shape, holes = shapePoints.holes, reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
            for (vertices = vertices.reverse(), h = 0, hl = holes.length; hl > h; h++) ahole = holes[h], 
            ShapeUtils.isClockWise(ahole) && (holes[h] = ahole.reverse());
            reverse = !1;
        }
        var faces = ShapeUtils.triangulateShape(vertices, holes), contour = vertices;
        for (h = 0, hl = holes.length; hl > h; h++) ahole = holes[h], vertices = vertices.concat(ahole);
        for (var b, bs, t, z, vert, face, vlen = vertices.length, flen = faces.length, contourMovements = [], i = 0, il = contour.length, j = il - 1, k = i + 1; il > i; i++, 
        j++, k++) j === il && (j = 0), k === il && (k = 0), contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        var oneHoleMovements, holesMovements = [], verticesMovements = contourMovements.concat();
        for (h = 0, hl = holes.length; hl > h; h++) {
            for (ahole = holes[h], oneHoleMovements = [], i = 0, il = ahole.length, j = il - 1, 
            k = i + 1; il > i; i++, j++, k++) j === il && (j = 0), k === il && (k = 0), oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
            holesMovements.push(oneHoleMovements), verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (b = 0; bevelSegments > b; b++) {
            for (t = b / bevelSegments, z = bevelThickness * Math.cos(t * Math.PI / 2), bs = bevelSize * Math.sin(t * Math.PI / 2), 
            i = 0, il = contour.length; il > i; i++) vert = scalePt2(contour[i], contourMovements[i], bs), 
            v(vert.x, vert.y, -z);
            for (h = 0, hl = holes.length; hl > h; h++) for (ahole = holes[h], oneHoleMovements = holesMovements[h], 
            i = 0, il = ahole.length; il > i; i++) vert = scalePt2(ahole[i], oneHoleMovements[i], bs), 
            v(vert.x, vert.y, -z);
        }
        for (bs = bevelSize, i = 0; vlen > i; i++) vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i], 
        extrudeByPath ? (normal.copy(splineTube.normals[0]).multiplyScalar(vert.x), binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y), 
        position2.copy(extrudePts[0]).add(normal).add(binormal), v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, 0);
        var s;
        for (s = 1; steps >= s; s++) for (i = 0; vlen > i; i++) vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i], 
        extrudeByPath ? (normal.copy(splineTube.normals[s]).multiplyScalar(vert.x), binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y), 
        position2.copy(extrudePts[s]).add(normal).add(binormal), v(position2.x, position2.y, position2.z)) : v(vert.x, vert.y, amount / steps * s);
        for (b = bevelSegments - 1; b >= 0; b--) {
            for (t = b / bevelSegments, z = bevelThickness * Math.cos(t * Math.PI / 2), bs = bevelSize * Math.sin(t * Math.PI / 2), 
            i = 0, il = contour.length; il > i; i++) vert = scalePt2(contour[i], contourMovements[i], bs), 
            v(vert.x, vert.y, amount + z);
            for (h = 0, hl = holes.length; hl > h; h++) for (ahole = holes[h], oneHoleMovements = holesMovements[h], 
            i = 0, il = ahole.length; il > i; i++) vert = scalePt2(ahole[i], oneHoleMovements[i], bs), 
            extrudeByPath ? v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z) : v(vert.x, vert.y, amount + z);
        }
        buildLidFaces(), buildSideFaces();
    }, ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function(geometry, indexA, indexB, indexC) {
            var vertices = geometry.vertices, a = vertices[indexA], b = vertices[indexB], c = vertices[indexC];
            return [ new Vector2(a.x, a.y), new Vector2(b.x, b.y), new Vector2(c.x, c.y) ];
        },
        generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
            var vertices = geometry.vertices, a = vertices[indexA], b = vertices[indexB], c = vertices[indexC], d = vertices[indexD];
            return Math.abs(a.y - b.y) < .01 ? [ new Vector2(a.x, 1 - a.z), new Vector2(b.x, 1 - b.z), new Vector2(c.x, 1 - c.z), new Vector2(d.x, 1 - d.z) ] : [ new Vector2(a.y, 1 - a.z), new Vector2(b.y, 1 - b.z), new Vector2(c.y, 1 - c.z), new Vector2(d.y, 1 - d.z) ];
        }
    }, TextGeometry.prototype = Object.create(ExtrudeGeometry.prototype), TextGeometry.prototype.constructor = TextGeometry, 
    SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype), SphereBufferGeometry.prototype.constructor = SphereBufferGeometry, 
    SphereGeometry.prototype = Object.create(Geometry.prototype), SphereGeometry.prototype.constructor = SphereGeometry, 
    RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype), RingBufferGeometry.prototype.constructor = RingBufferGeometry, 
    RingGeometry.prototype = Object.create(Geometry.prototype), RingGeometry.prototype.constructor = RingGeometry, 
    PlaneGeometry.prototype = Object.create(Geometry.prototype), PlaneGeometry.prototype.constructor = PlaneGeometry, 
    LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype), LatheBufferGeometry.prototype.constructor = LatheBufferGeometry, 
    LatheGeometry.prototype = Object.create(Geometry.prototype), LatheGeometry.prototype.constructor = LatheGeometry, 
    ShapeGeometry.prototype = Object.create(Geometry.prototype), ShapeGeometry.prototype.constructor = ShapeGeometry, 
    ShapeGeometry.prototype.addShapeList = function(shapes, options) {
        for (var i = 0, l = shapes.length; l > i; i++) this.addShape(shapes[i], options);
        return this;
    }, ShapeGeometry.prototype.addShape = function(shape, options) {
        void 0 === options && (options = {});
        var i, l, hole, curveSegments = void 0 !== options.curveSegments ? options.curveSegments : 12, material = options.material, uvgen = void 0 === options.UVGenerator ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator, shapesOffset = this.vertices.length, shapePoints = shape.extractPoints(curveSegments), vertices = shapePoints.shape, holes = shapePoints.holes, reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
            for (vertices = vertices.reverse(), i = 0, l = holes.length; l > i; i++) hole = holes[i], 
            ShapeUtils.isClockWise(hole) && (holes[i] = hole.reverse());
            reverse = !1;
        }
        var faces = ShapeUtils.triangulateShape(vertices, holes);
        for (i = 0, l = holes.length; l > i; i++) hole = holes[i], vertices = vertices.concat(hole);
        var vert, face, vlen = vertices.length, flen = faces.length;
        for (i = 0; vlen > i; i++) vert = vertices[i], this.vertices.push(new Vector3(vert.x, vert.y, 0));
        for (i = 0; flen > i; i++) {
            face = faces[i];
            var a = face[0] + shapesOffset, b = face[1] + shapesOffset, c = face[2] + shapesOffset;
            this.faces.push(new Face3(a, b, c, null, null, material)), this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
        }
    }, EdgesGeometry.prototype = Object.create(BufferGeometry.prototype), EdgesGeometry.prototype.constructor = EdgesGeometry, 
    CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype), CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry, 
    CylinderGeometry.prototype = Object.create(Geometry.prototype), CylinderGeometry.prototype.constructor = CylinderGeometry, 
    ConeGeometry.prototype = Object.create(CylinderGeometry.prototype), ConeGeometry.prototype.constructor = ConeGeometry, 
    ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype), 
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry, CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype), 
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry, CircleGeometry.prototype = Object.create(Geometry.prototype), 
    CircleGeometry.prototype.constructor = CircleGeometry, BoxGeometry.prototype = Object.create(Geometry.prototype), 
    BoxGeometry.prototype.constructor = BoxGeometry;
    var Geometries = Object.freeze({
        WireframeGeometry: WireframeGeometry,
        ParametricGeometry: ParametricGeometry,
        ParametricBufferGeometry: ParametricBufferGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronBufferGeometry,
        OctahedronGeometry: OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronBufferGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronBufferGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronBufferGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronBufferGeometry,
        TubeGeometry: TubeGeometry,
        TubeBufferGeometry: TubeBufferGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotBufferGeometry,
        TorusGeometry: TorusGeometry,
        TorusBufferGeometry: TorusBufferGeometry,
        TextGeometry: TextGeometry,
        SphereBufferGeometry: SphereBufferGeometry,
        SphereGeometry: SphereGeometry,
        RingGeometry: RingGeometry,
        RingBufferGeometry: RingBufferGeometry,
        PlaneBufferGeometry: PlaneBufferGeometry,
        PlaneGeometry: PlaneGeometry,
        LatheGeometry: LatheGeometry,
        LatheBufferGeometry: LatheBufferGeometry,
        ShapeGeometry: ShapeGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        EdgesGeometry: EdgesGeometry,
        ConeGeometry: ConeGeometry,
        ConeBufferGeometry: ConeBufferGeometry,
        CylinderGeometry: CylinderGeometry,
        CylinderBufferGeometry: CylinderBufferGeometry,
        CircleBufferGeometry: CircleBufferGeometry,
        CircleGeometry: CircleGeometry,
        BoxBufferGeometry: BoxBufferGeometry,
        BoxGeometry: BoxGeometry
    });
    ShadowMaterial.prototype = Object.create(ShaderMaterial.prototype), ShadowMaterial.prototype.constructor = ShadowMaterial, 
    ShadowMaterial.prototype.isShadowMaterial = !0, RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype), 
    RawShaderMaterial.prototype.constructor = RawShaderMaterial, RawShaderMaterial.prototype.isRawShaderMaterial = !0, 
    MultiMaterial.prototype = {
        constructor: MultiMaterial,
        isMultiMaterial: !0,
        toJSON: function(meta) {
            for (var output = {
                metadata: {
                    version: 4.2,
                    type: "material",
                    generator: "MaterialExporter"
                },
                uuid: this.uuid,
                type: this.type,
                materials: []
            }, materials = this.materials, i = 0, l = materials.length; l > i; i++) {
                var material = materials[i].toJSON(meta);
                delete material.metadata, output.materials.push(material);
            }
            return output.visible = this.visible, output;
        },
        clone: function() {
            for (var material = new this.constructor(), i = 0; i < this.materials.length; i++) material.materials.push(this.materials[i].clone());
            return material.visible = this.visible, material;
        }
    }, MeshStandardMaterial.prototype = Object.create(Material.prototype), MeshStandardMaterial.prototype.constructor = MeshStandardMaterial, 
    MeshStandardMaterial.prototype.isMeshStandardMaterial = !0, MeshStandardMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.defines = {
            STANDARD: ""
        }, this.color.copy(source.color), this.roughness = source.roughness, this.metalness = source.metalness, 
        this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, 
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), 
        this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, 
        this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, 
        this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, 
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, 
        this.roughnessMap = source.roughnessMap, this.metalnessMap = source.metalnessMap, 
        this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapIntensity = source.envMapIntensity, 
        this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, 
        this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, 
        this.wireframeLinejoin = source.wireframeLinejoin, this.skinning = source.skinning, 
        this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, 
        this;
    }, MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype), 
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial, MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0, 
    MeshPhysicalMaterial.prototype.copy = function(source) {
        return MeshStandardMaterial.prototype.copy.call(this, source), this.defines = {
            PHYSICAL: ""
        }, this.reflectivity = source.reflectivity, this.clearCoat = source.clearCoat, this.clearCoatRoughness = source.clearCoatRoughness, 
        this;
    }, MeshPhongMaterial.prototype = Object.create(Material.prototype), MeshPhongMaterial.prototype.constructor = MeshPhongMaterial, 
    MeshPhongMaterial.prototype.isMeshPhongMaterial = !0, MeshPhongMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.specular.copy(source.specular), this.shininess = source.shininess, this.map = source.map, 
        this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, 
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), 
        this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, 
        this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, 
        this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, 
        this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, 
        this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, 
        this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, 
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, 
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, 
        this;
    }, MeshNormalMaterial.prototype = Object.create(Material.prototype), MeshNormalMaterial.prototype.constructor = MeshNormalMaterial, 
    MeshNormalMaterial.prototype.isMeshNormalMaterial = !0, MeshNormalMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.wireframe = source.wireframe, 
        this.wireframeLinewidth = source.wireframeLinewidth, this;
    }, MeshLambertMaterial.prototype = Object.create(Material.prototype), MeshLambertMaterial.prototype.constructor = MeshLambertMaterial, 
    MeshLambertMaterial.prototype.isMeshLambertMaterial = !0, MeshLambertMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, 
        this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), 
        this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, 
        this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, 
        this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, 
        this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, 
        this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, 
        this.skinning = source.skinning, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, 
        this;
    }, LineDashedMaterial.prototype = Object.create(Material.prototype), LineDashedMaterial.prototype.constructor = LineDashedMaterial, 
    LineDashedMaterial.prototype.isLineDashedMaterial = !0, LineDashedMaterial.prototype.copy = function(source) {
        return Material.prototype.copy.call(this, source), this.color.copy(source.color), 
        this.linewidth = source.linewidth, this.scale = source.scale, this.dashSize = source.dashSize, 
        this.gapSize = source.gapSize, this;
    };
    var Materials = Object.freeze({
        ShadowMaterial: ShadowMaterial,
        SpriteMaterial: SpriteMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShaderMaterial: ShaderMaterial,
        PointsMaterial: PointsMaterial,
        MultiMaterial: MultiMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        LineDashedMaterial: LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial,
        Material: Material
    }), Cache = {
        enabled: !1,
        files: {},
        add: function(key, file) {
            this.enabled !== !1 && (this.files[key] = file);
        },
        get: function(key) {
            return this.enabled !== !1 ? this.files[key] : void 0;
        },
        remove: function(key) {
            delete this.files[key];
        },
        clear: function() {
            this.files = {};
        }
    }, DefaultLoadingManager = new LoadingManager();
    Object.assign(XHRLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            void 0 === url && (url = ""), void 0 !== this.path && (url = this.path + url);
            var scope = this, cached = Cache.get(url);
            if (void 0 !== cached) return scope.manager.itemStart(url), setTimeout(function() {
                onLoad && onLoad(cached), scope.manager.itemEnd(url);
            }, 0), cached;
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/, dataUriRegexResult = url.match(dataUriRegex);
            if (dataUriRegexResult) {
                var mimeType = dataUriRegexResult[1], isBase64 = !!dataUriRegexResult[2], data = dataUriRegexResult[3];
                data = window.decodeURIComponent(data), isBase64 && (data = window.atob(data));
                try {
                    var response, responseType = (this.responseType || "").toLowerCase();
                    switch (responseType) {
                      case "arraybuffer":
                      case "blob":
                        response = new ArrayBuffer(data.length);
                        for (var view = new Uint8Array(response), i = 0; i < data.length; i++) view[i] = data.charCodeAt(i);
                        "blob" === responseType && (response = new Blob([ response ], {
                            type: mimeType
                        }));
                        break;

                      case "document":
                        var parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;

                      case "json":
                        response = JSON.parse(data);
                        break;

                      default:
                        response = data;
                    }
                    window.setTimeout(function() {
                        onLoad && onLoad(response), scope.manager.itemEnd(url);
                    }, 0);
                } catch (error) {
                    window.setTimeout(function() {
                        onError && onError(error), scope.manager.itemError(url);
                    }, 0);
                }
            } else {
                var request = new XMLHttpRequest();
                request.open("GET", url, !0), request.addEventListener("load", function(event) {
                    var response = event.target.response;
                    Cache.add(url, response), 200 === this.status ? (onLoad && onLoad(response), scope.manager.itemEnd(url)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."), 
                    onLoad && onLoad(response), scope.manager.itemEnd(url)) : (onError && onError(event), 
                    scope.manager.itemError(url));
                }, !1), void 0 !== onProgress && request.addEventListener("progress", function(event) {
                    onProgress(event);
                }, !1), request.addEventListener("error", function(event) {
                    onError && onError(event), scope.manager.itemError(url);
                }, !1), void 0 !== this.responseType && (request.responseType = this.responseType), 
                void 0 !== this.withCredentials && (request.withCredentials = this.withCredentials), 
                request.overrideMimeType && request.overrideMimeType("text/plain"), request.send(null);
            }
            return scope.manager.itemStart(url), request;
        },
        setPath: function(value) {
            return this.path = value, this;
        },
        setResponseType: function(value) {
            return this.responseType = value, this;
        },
        setWithCredentials: function(value) {
            return this.withCredentials = value, this;
        }
    }), Object.assign(CompressedTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            function loadTexture(i) {
                loader.load(url[i], function(buffer) {
                    var texDatas = scope._parser(buffer, !0);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    }, loaded += 1, 6 === loaded && (1 === texDatas.mipmapCount && (texture.minFilter = LinearFilter), 
                    texture.format = texDatas.format, texture.needsUpdate = !0, onLoad && onLoad(texture));
                }, onProgress, onError);
            }
            var scope = this, images = [], texture = new CompressedTexture();
            texture.image = images;
            var loader = new XHRLoader(this.manager);
            if (loader.setPath(this.path), loader.setResponseType("arraybuffer"), Array.isArray(url)) for (var loaded = 0, i = 0, il = url.length; il > i; ++i) loadTexture(i); else loader.load(url, function(buffer) {
                var texDatas = scope._parser(buffer, !0);
                if (texDatas.isCubemap) for (var faces = texDatas.mipmaps.length / texDatas.mipmapCount, f = 0; faces > f; f++) {
                    images[f] = {
                        mipmaps: []
                    };
                    for (var i = 0; i < texDatas.mipmapCount; i++) images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]), 
                    images[f].format = texDatas.format, images[f].width = texDatas.width, images[f].height = texDatas.height;
                } else texture.image.width = texDatas.width, texture.image.height = texDatas.height, 
                texture.mipmaps = texDatas.mipmaps;
                1 === texDatas.mipmapCount && (texture.minFilter = LinearFilter), texture.format = texDatas.format, 
                texture.needsUpdate = !0, onLoad && onLoad(texture);
            }, onProgress, onError);
            return texture;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    });
    var DataTextureLoader = BinaryTextureLoader;
    Object.assign(BinaryTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, texture = new DataTexture(), loader = new XHRLoader(this.manager);
            return loader.setResponseType("arraybuffer"), loader.load(url, function(buffer) {
                var texData = scope._parser(buffer);
                texData && (void 0 !== texData.image ? texture.image = texData.image : void 0 !== texData.data && (texture.image.width = texData.width, 
                texture.image.height = texData.height, texture.image.data = texData.data), texture.wrapS = void 0 !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping, 
                texture.wrapT = void 0 !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping, 
                texture.magFilter = void 0 !== texData.magFilter ? texData.magFilter : LinearFilter, 
                texture.minFilter = void 0 !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter, 
                texture.anisotropy = void 0 !== texData.anisotropy ? texData.anisotropy : 1, void 0 !== texData.format && (texture.format = texData.format), 
                void 0 !== texData.type && (texture.type = texData.type), void 0 !== texData.mipmaps && (texture.mipmaps = texData.mipmaps), 
                1 === texData.mipmapCount && (texture.minFilter = LinearFilter), texture.needsUpdate = !0, 
                onLoad && onLoad(texture, texData));
            }, onProgress, onError), texture;
        }
    }), Object.assign(ImageLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            if (image.onload = function() {
                image.onload = null, URL.revokeObjectURL(image.src), onLoad && onLoad(image), scope.manager.itemEnd(url);
            }, image.onerror = onError, 0 === url.indexOf("data:")) image.src = url; else {
                var loader = new XHRLoader();
                loader.setPath(this.path), loader.setResponseType("blob"), loader.setWithCredentials(this.withCredentials), 
                loader.load(url, function(blob) {
                    image.src = URL.createObjectURL(blob);
                }, onProgress, onError);
            }
            return scope.manager.itemStart(url), image;
        },
        setCrossOrigin: function(value) {
            return this.crossOrigin = value, this;
        },
        setWithCredentials: function(value) {
            return this.withCredentials = value, this;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Object.assign(CubeTextureLoader.prototype, {
        load: function(urls, onLoad, onProgress, onError) {
            function loadTexture(i) {
                loader.load(urls[i], function(image) {
                    texture.images[i] = image, loaded++, 6 === loaded && (texture.needsUpdate = !0, 
                    onLoad && onLoad(texture));
                }, void 0, onError);
            }
            var texture = new CubeTexture(), loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin), loader.setPath(this.path);
            for (var loaded = 0, i = 0; i < urls.length; ++i) loadTexture(i);
            return texture;
        },
        setCrossOrigin: function(value) {
            return this.crossOrigin = value, this;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Object.assign(TextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var texture = new Texture(), loader = new ImageLoader(this.manager);
            return loader.setCrossOrigin(this.crossOrigin), loader.setWithCredentials(this.withCredentials), 
            loader.setPath(this.path), loader.load(url, function(image) {
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || 0 === url.search(/^data\:image\/jpeg/);
                texture.format = isJPEG ? RGBFormat : RGBAFormat, texture.image = image, texture.needsUpdate = !0, 
                void 0 !== onLoad && onLoad(texture);
            }, onProgress, onError), texture;
        },
        setCrossOrigin: function(value) {
            return this.crossOrigin = value, this;
        },
        setWithCredentials: function(value) {
            return this.withCredentials = value, this;
        },
        setPath: function(value) {
            return this.path = value, this;
        }
    }), Light.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Light,
        isLight: !0,
        copy: function(source) {
            return Object3D.prototype.copy.call(this, source), this.color.copy(source.color), 
            this.intensity = source.intensity, this;
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            return data.object.color = this.color.getHex(), data.object.intensity = this.intensity, 
            void 0 !== this.groundColor && (data.object.groundColor = this.groundColor.getHex()), 
            void 0 !== this.distance && (data.object.distance = this.distance), void 0 !== this.angle && (data.object.angle = this.angle), 
            void 0 !== this.decay && (data.object.decay = this.decay), void 0 !== this.penumbra && (data.object.penumbra = this.penumbra), 
            void 0 !== this.shadow && (data.object.shadow = this.shadow.toJSON()), data;
        }
    }), HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: HemisphereLight,
        isHemisphereLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.groundColor.copy(source.groundColor), 
            this;
        }
    }), Object.assign(LightShadow.prototype, {
        copy: function(source) {
            return this.camera = source.camera.clone(), this.bias = source.bias, this.radius = source.radius, 
            this.mapSize.copy(source.mapSize), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        toJSON: function() {
            var object = {};
            return 0 !== this.bias && (object.bias = this.bias), 1 !== this.radius && (object.radius = this.radius), 
            512 === this.mapSize.x && 512 === this.mapSize.y || (object.mapSize = this.mapSize.toArray()), 
            object.camera = this.camera.toJSON(!1).object, delete object.camera.matrix, object;
        }
    }), SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: SpotLightShadow,
        isSpotLightShadow: !0,
        update: function(light) {
            var fov = 2 * _Math.RAD2DEG * light.angle, aspect = this.mapSize.width / this.mapSize.height, far = light.distance || 500, camera = this.camera;
            fov === camera.fov && aspect === camera.aspect && far === camera.far || (camera.fov = fov, 
            camera.aspect = aspect, camera.far = far, camera.updateProjectionMatrix());
        }
    }), SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: SpotLight,
        isSpotLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.distance = source.distance, 
            this.angle = source.angle, this.penumbra = source.penumbra, this.decay = source.decay, 
            this.target = source.target.clone(), this.shadow = source.shadow.clone(), this;
        }
    }), PointLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: PointLight,
        isPointLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.distance = source.distance, 
            this.decay = source.decay, this.shadow = source.shadow.clone(), this;
        }
    }), DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: DirectionalLightShadow
    }), DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: DirectionalLight,
        isDirectionalLight: !0,
        copy: function(source) {
            return Light.prototype.copy.call(this, source), this.target = source.target.clone(), 
            this.shadow = source.shadow.clone(), this;
        }
    }), AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: AmbientLight,
        isAmbientLight: !0
    });
    var AnimationUtils = {
        arraySlice: function(array, from, to) {
            return AnimationUtils.isTypedArray(array) ? new array.constructor(array.subarray(from, to)) : array.slice(from, to);
        },
        convertArray: function(array, type, forceClone) {
            return !array || !forceClone && array.constructor === type ? array : "number" == typeof type.BYTES_PER_ELEMENT ? new type(array) : Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
            return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
            function compareTime(i, j) {
                return times[i] - times[j];
            }
            for (var n = times.length, result = new Array(n), i = 0; i !== n; ++i) result[i] = i;
            return result.sort(compareTime), result;
        },
        sortedArray: function(values, stride, order) {
            for (var nValues = values.length, result = new values.constructor(nValues), i = 0, dstOffset = 0; dstOffset !== nValues; ++i) for (var srcOffset = order[i] * stride, j = 0; j !== stride; ++j) result[dstOffset++] = values[srcOffset + j];
            return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
            for (var i = 1, key = jsonKeys[0]; void 0 !== key && void 0 === key[valuePropertyName]; ) key = jsonKeys[i++];
            if (void 0 !== key) {
                var value = key[valuePropertyName];
                if (void 0 !== value) if (Array.isArray(value)) {
                    do value = key[valuePropertyName], void 0 !== value && (times.push(key.time), values.push.apply(values, value)), 
                    key = jsonKeys[i++]; while (void 0 !== key);
                } else if (void 0 !== value.toArray) {
                    do value = key[valuePropertyName], void 0 !== value && (times.push(key.time), value.toArray(values, values.length)), 
                    key = jsonKeys[i++]; while (void 0 !== key);
                } else do value = key[valuePropertyName], void 0 !== value && (times.push(key.time), 
                values.push(value)), key = jsonKeys[i++]; while (void 0 !== key);
            }
        }
    };
    Interpolant.prototype = {
        constructor: Interpolant,
        evaluate: function(t) {
            var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
            validate_interval: {
                seek: {
                    var right;
                    linear_scan: {
                        forward_scan: if (!(t1 > t)) {
                            for (var giveUpAt = i1 + 2; ;) {
                                if (void 0 === t1) {
                                    if (t0 > t) break forward_scan;
                                    return i1 = pp.length, this._cachedIndex = i1, this.afterEnd_(i1 - 1, t, t0);
                                }
                                if (i1 === giveUpAt) break;
                                if (t0 = t1, t1 = pp[++i1], t1 > t) break seek;
                            }
                            right = pp.length;
                            break linear_scan;
                        }
                        {
                            if (t >= t0) break validate_interval;
                            var t1global = pp[1];
                            t1global > t && (i1 = 2, t0 = t1global);
                            for (var giveUpAt = i1 - 2; ;) {
                                if (void 0 === t0) return this._cachedIndex = 0, this.beforeStart_(0, t, t1);
                                if (i1 === giveUpAt) break;
                                if (t1 = t0, t0 = pp[--i1 - 1], t >= t0) break seek;
                            }
                            right = i1, i1 = 0;
                        }
                    }
                    for (;right > i1; ) {
                        var mid = i1 + right >>> 1;
                        t < pp[mid] ? right = mid : i1 = mid + 1;
                    }
                    if (t1 = pp[i1], t0 = pp[i1 - 1], void 0 === t0) return this._cachedIndex = 0, this.beforeStart_(0, t, t1);
                    if (void 0 === t1) return i1 = pp.length, this._cachedIndex = i1, this.afterEnd_(i1 - 1, t0, t);
                }
                this._cachedIndex = i1, this.intervalChanged_(i1, t0, t1);
            }
            return this.interpolate_(i1, t0, t, t1);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function(index) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride, i = 0; i !== stride; ++i) result[i] = values[offset + i];
            return result;
        },
        interpolate_: function(i1, t0, t, t1) {
            throw new Error("call to abstract method");
        },
        intervalChanged_: function(i1, t0, t1) {}
    }, Object.assign(Interpolant.prototype, {
        beforeStart_: Interpolant.prototype.copySampleValue_,
        afterEnd_: Interpolant.prototype.copySampleValue_
    }), CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: CubicInterpolant,
        DefaultSettings_: {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        },
        intervalChanged_: function(i1, t0, t1) {
            var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
            if (void 0 === tPrev) switch (this.getSettings_().endingStart) {
              case ZeroSlopeEnding:
                iPrev = i1, tPrev = 2 * t0 - t1;
                break;

              case WrapAroundEnding:
                iPrev = pp.length - 2, tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;

              default:
                iPrev = i1, tPrev = t1;
            }
            if (void 0 === tNext) switch (this.getSettings_().endingEnd) {
              case ZeroSlopeEnding:
                iNext = i1, tNext = 2 * t1 - t0;
                break;

              case WrapAroundEnding:
                iNext = 1, tNext = t1 + pp[1] - pp[0];
                break;

              default:
                iNext = i1 - 1, tNext = t0;
            }
            var halfDt = .5 * (t1 - t0), stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev), this._weightNext = halfDt / (tNext - t1), 
            this._offsetPrev = iPrev * stride, this._offsetNext = iNext * stride;
        },
        interpolate_: function(i1, t0, t, t1) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p, sP = -wP * ppp + 2 * wP * pp - wP * p, s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-.5 + wP) * p + 1, s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + .5 * p, sN = wN * ppp - wN * pp, i = 0; i !== stride; ++i) result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
            return result;
        }
    }), LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: LinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1, i = 0; i !== stride; ++i) result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
            return result;
        }
    }), DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: DiscreteInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            return this.copySampleValue_(i1 - 1);
        }
    });
    var KeyframeTrackPrototype;
    KeyframeTrackPrototype = {
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodDiscrete: function(result) {
            return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodLinear: function(result) {
            return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: function(result) {
            return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        setInterpolation: function(interpolation) {
            var factoryMethod;
            switch (interpolation) {
              case InterpolateDiscrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;

              case InterpolateLinear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;

              case InterpolateSmooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === factoryMethod) {
                var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (interpolation === this.DefaultInterpolation) throw new Error(message);
                    this.setInterpolation(this.DefaultInterpolation);
                }
                return void console.warn(message);
            }
            this.createInterpolant = factoryMethod;
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;

              case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;

              case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth;
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length;
        },
        shift: function(timeOffset) {
            if (0 !== timeOffset) for (var times = this.times, i = 0, n = times.length; i !== n; ++i) times[i] += timeOffset;
            return this;
        },
        scale: function(timeScale) {
            if (1 !== timeScale) for (var times = this.times, i = 0, n = times.length; i !== n; ++i) times[i] *= timeScale;
            return this;
        },
        trim: function(startTime, endTime) {
            for (var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1; from !== nKeys && times[from] < startTime; ) ++from;
            for (;-1 !== to && times[to] > endTime; ) --to;
            if (++to, 0 !== from || to !== nKeys) {
                from >= to && (to = Math.max(to, 1), from = to - 1);
                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice(times, from, to), this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
            }
            return this;
        },
        validate: function() {
            var valid = !0, valueSize = this.getValueSize();
            valueSize - Math.floor(valueSize) !== 0 && (console.error("invalid value size in track", this), 
            valid = !1);
            var times = this.times, values = this.values, nKeys = times.length;
            0 === nKeys && (console.error("track is empty", this), valid = !1);
            for (var prevTime = null, i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if ("number" == typeof currTime && isNaN(currTime)) {
                    console.error("time is not a valid number", this, i, currTime), valid = !1;
                    break;
                }
                if (null !== prevTime && prevTime > currTime) {
                    console.error("out of order keys", this, i, currTime, prevTime), valid = !1;
                    break;
                }
                prevTime = currTime;
            }
            if (void 0 !== values && AnimationUtils.isTypedArray(values)) for (var i = 0, n = values.length; i !== n; ++i) {
                var value = values[i];
                if (isNaN(value)) {
                    console.error("value is not a valid number", this, i, value), valid = !1;
                    break;
                }
            }
            return valid;
        },
        optimize: function() {
            for (var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1, i = 1; lastIndex > i; ++i) {
                var keep = !1, time = times[i], timeNext = times[i + 1];
                if (time !== timeNext && (1 !== i || time !== time[0])) if (smoothInterpolation) keep = !0; else for (var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride, j = 0; j !== stride; ++j) {
                    var value = values[offset + j];
                    if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                        keep = !0;
                        break;
                    }
                }
                if (keep) {
                    if (i !== writeIndex) {
                        times[writeIndex] = times[i];
                        for (var readOffset = i * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
                    }
                    ++writeIndex;
                }
            }
            if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
                ++writeIndex;
            }
            return writeIndex !== times.length && (this.times = AnimationUtils.arraySlice(times, 0, writeIndex), 
            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride)), this;
        }
    }, VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: VectorKeyframeTrack,
        ValueTypeName: "vector"
    }), QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: QuaternionLinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            for (var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0), end = offset + stride; offset !== end; offset += 4) Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            return result;
        }
    }), QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: QuaternionKeyframeTrack,
        ValueTypeName: "quaternion",
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodLinear: function(result) {
            return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: void 0
    }), NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: NumberKeyframeTrack,
        ValueTypeName: "number"
    }), StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: StringKeyframeTrack,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: BooleanKeyframeTrack,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrackPrototype), {
        constructor: ColorKeyframeTrack,
        ValueTypeName: "color"
    }), KeyframeTrack.prototype = KeyframeTrackPrototype, KeyframeTrackPrototype.constructor = KeyframeTrack, 
    Object.assign(KeyframeTrack, {
        parse: function(json) {
            if (void 0 === json.type) throw new Error("track type undefined, can not parse");
            var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
            if (void 0 === json.times) {
                var times = [], values = [];
                AnimationUtils.flattenJSON(json.keys, times, values, "value"), json.times = times, 
                json.values = values;
            }
            return void 0 !== trackType.parse ? trackType.parse(json) : new trackType(json.name, json.times, json.values, json.interpolation);
        },
        toJSON: function(track) {
            var json, trackType = track.constructor;
            if (void 0 !== trackType.toJSON) json = trackType.toJSON(track); else {
                json = {
                    name: track.name,
                    times: AnimationUtils.convertArray(track.times, Array),
                    values: AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                interpolation !== track.DefaultInterpolation && (json.interpolation = interpolation);
            }
            return json.type = track.ValueTypeName, json;
        },
        _getTrackTypeForValueTypeName: function(typeName) {
            switch (typeName.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return NumberKeyframeTrack;

              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return VectorKeyframeTrack;

              case "color":
                return ColorKeyframeTrack;

              case "quaternion":
                return QuaternionKeyframeTrack;

              case "bool":
              case "boolean":
                return BooleanKeyframeTrack;

              case "string":
                return StringKeyframeTrack;
            }
            throw new Error("Unsupported typeName: " + typeName);
        }
    }), AnimationClip.prototype = {
        constructor: AnimationClip,
        resetDuration: function() {
            for (var tracks = this.tracks, duration = 0, i = 0, n = tracks.length; i !== n; ++i) {
                var track = this.tracks[i];
                duration = Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
        },
        trim: function() {
            for (var i = 0; i < this.tracks.length; i++) this.tracks[i].trim(0, this.duration);
            return this;
        },
        optimize: function() {
            for (var i = 0; i < this.tracks.length; i++) this.tracks[i].optimize();
            return this;
        }
    }, Object.assign(AnimationClip, {
        parse: function(json) {
            for (var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1), i = 0, n = jsonTracks.length; i !== n; ++i) tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
            return new AnimationClip(json.name, json.duration, tracks);
        },
        toJSON: function(clip) {
            for (var tracks = [], clipTracks = clip.tracks, json = {
                name: clip.name,
                duration: clip.duration,
                tracks: tracks
            }, i = 0, n = clipTracks.length; i !== n; ++i) tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
            return json;
        },
        CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
            for (var numMorphTargets = morphTargetSequence.length, tracks = [], i = 0; numMorphTargets > i; i++) {
                var times = [], values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets), 
                values.push(0, 1, 0);
                var order = AnimationUtils.getKeyframeOrder(times);
                times = AnimationUtils.sortedArray(times, 1, order), values = AnimationUtils.sortedArray(values, 1, order), 
                noLoop || 0 !== times[0] || (times.push(numMorphTargets), values.push(values[0])), 
                tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
            }
            return new AnimationClip(name, -1, tracks);
        },
        findByName: function(objectOrClipArray, name) {
            var clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for (var i = 0; i < clipArray.length; i++) if (clipArray[i].name === name) return clipArray[i];
            return null;
        },
        CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
            for (var animationToMorphTargets = {}, pattern = /^([\w-]*?)([\d]+)$/, i = 0, il = morphTargets.length; il > i; i++) {
                var morphTarget = morphTargets[i], parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    var name = parts[1], animationMorphTargets = animationToMorphTargets[name];
                    animationMorphTargets || (animationToMorphTargets[name] = animationMorphTargets = []), 
                    animationMorphTargets.push(morphTarget);
                }
            }
            var clips = [];
            for (var name in animationToMorphTargets) clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
            return clips;
        },
        parseAnimation: function(animation, bones) {
            if (!animation) return console.error("  no animation in JSONLoader data"), null;
            for (var addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                if (0 !== animationKeys.length) {
                    var times = [], values = [];
                    AnimationUtils.flattenJSON(animationKeys, times, values, propertyName), 0 !== times.length && destTracks.push(new trackType(trackName, times, values));
                }
            }, tracks = [], clipName = animation.name || "default", duration = animation.length || -1, fps = animation.fps || 30, hierarchyTracks = animation.hierarchy || [], h = 0; h < hierarchyTracks.length; h++) {
                var animationKeys = hierarchyTracks[h].keys;
                if (animationKeys && 0 !== animationKeys.length) if (animationKeys[0].morphTargets) {
                    for (var morphTargetNames = {}, k = 0; k < animationKeys.length; k++) if (animationKeys[k].morphTargets) for (var m = 0; m < animationKeys[k].morphTargets.length; m++) morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                    for (var morphTargetName in morphTargetNames) {
                        for (var times = [], values = [], m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                            var animationKey = animationKeys[k];
                            times.push(animationKey.time), values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                        }
                        tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
                    }
                    duration = morphTargetNames.length * (fps || 1);
                } else {
                    var boneName = ".bones[" + bones[h].name + "]";
                    addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks), 
                    addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks), 
                    addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
                }
            }
            if (0 === tracks.length) return null;
            var clip = new AnimationClip(clipName, duration, tracks);
            return clip;
        }
    }), Object.assign(MaterialLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, loader = new XHRLoader(scope.manager);
            loader.load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        setTextures: function(value) {
            this.textures = value;
        },
        parse: function(json) {
            function getTexture(name) {
                return void 0 === textures[name] && console.warn("THREE.MaterialLoader: Undefined texture", name), 
                textures[name];
            }
            var textures = this.textures, material = new Materials[json.type]();
            if (void 0 !== json.uuid && (material.uuid = json.uuid), void 0 !== json.name && (material.name = json.name), 
            void 0 !== json.color && material.color.setHex(json.color), void 0 !== json.roughness && (material.roughness = json.roughness), 
            void 0 !== json.metalness && (material.metalness = json.metalness), void 0 !== json.emissive && material.emissive.setHex(json.emissive), 
            void 0 !== json.specular && material.specular.setHex(json.specular), void 0 !== json.shininess && (material.shininess = json.shininess), 
            void 0 !== json.uniforms && (material.uniforms = json.uniforms), void 0 !== json.vertexShader && (material.vertexShader = json.vertexShader), 
            void 0 !== json.fragmentShader && (material.fragmentShader = json.fragmentShader), 
            void 0 !== json.vertexColors && (material.vertexColors = json.vertexColors), void 0 !== json.fog && (material.fog = json.fog), 
            void 0 !== json.shading && (material.shading = json.shading), void 0 !== json.blending && (material.blending = json.blending), 
            void 0 !== json.side && (material.side = json.side), void 0 !== json.opacity && (material.opacity = json.opacity), 
            void 0 !== json.transparent && (material.transparent = json.transparent), void 0 !== json.alphaTest && (material.alphaTest = json.alphaTest), 
            void 0 !== json.depthTest && (material.depthTest = json.depthTest), void 0 !== json.depthWrite && (material.depthWrite = json.depthWrite), 
            void 0 !== json.colorWrite && (material.colorWrite = json.colorWrite), void 0 !== json.wireframe && (material.wireframe = json.wireframe), 
            void 0 !== json.wireframeLinewidth && (material.wireframeLinewidth = json.wireframeLinewidth), 
            void 0 !== json.wireframeLinecap && (material.wireframeLinecap = json.wireframeLinecap), 
            void 0 !== json.wireframeLinejoin && (material.wireframeLinejoin = json.wireframeLinejoin), 
            void 0 !== json.skinning && (material.skinning = json.skinning), void 0 !== json.morphTargets && (material.morphTargets = json.morphTargets), 
            void 0 !== json.size && (material.size = json.size), void 0 !== json.sizeAttenuation && (material.sizeAttenuation = json.sizeAttenuation), 
            void 0 !== json.map && (material.map = getTexture(json.map)), void 0 !== json.alphaMap && (material.alphaMap = getTexture(json.alphaMap), 
            material.transparent = !0), void 0 !== json.bumpMap && (material.bumpMap = getTexture(json.bumpMap)), 
            void 0 !== json.bumpScale && (material.bumpScale = json.bumpScale), void 0 !== json.normalMap && (material.normalMap = getTexture(json.normalMap)), 
            void 0 !== json.normalScale) {
                var normalScale = json.normalScale;
                Array.isArray(normalScale) === !1 && (normalScale = [ normalScale, normalScale ]), 
                material.normalScale = new Vector2().fromArray(normalScale);
            }
            if (void 0 !== json.displacementMap && (material.displacementMap = getTexture(json.displacementMap)), 
            void 0 !== json.displacementScale && (material.displacementScale = json.displacementScale), 
            void 0 !== json.displacementBias && (material.displacementBias = json.displacementBias), 
            void 0 !== json.roughnessMap && (material.roughnessMap = getTexture(json.roughnessMap)), 
            void 0 !== json.metalnessMap && (material.metalnessMap = getTexture(json.metalnessMap)), 
            void 0 !== json.emissiveMap && (material.emissiveMap = getTexture(json.emissiveMap)), 
            void 0 !== json.emissiveIntensity && (material.emissiveIntensity = json.emissiveIntensity), 
            void 0 !== json.specularMap && (material.specularMap = getTexture(json.specularMap)), 
            void 0 !== json.envMap && (material.envMap = getTexture(json.envMap)), void 0 !== json.reflectivity && (material.reflectivity = json.reflectivity), 
            void 0 !== json.lightMap && (material.lightMap = getTexture(json.lightMap)), void 0 !== json.lightMapIntensity && (material.lightMapIntensity = json.lightMapIntensity), 
            void 0 !== json.aoMap && (material.aoMap = getTexture(json.aoMap)), void 0 !== json.aoMapIntensity && (material.aoMapIntensity = json.aoMapIntensity), 
            void 0 !== json.materials) for (var i = 0, l = json.materials.length; l > i; i++) material.materials.push(this.parse(json.materials[i]));
            return material;
        }
    }), Object.assign(BufferGeometryLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, loader = new XHRLoader(scope.manager);
            loader.load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        parse: function(json) {
            var geometry = new BufferGeometry(), index = json.data.index, TYPED_ARRAYS = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: Uint8ClampedArray,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };
            if (void 0 !== index) {
                var typedArray = new TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
            }
            var attributes = json.data.attributes;
            for (var key in attributes) {
                var attribute = attributes[key], typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
            }
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (void 0 !== groups) for (var i = 0, n = groups.length; i !== n; ++i) {
                var group = groups[i];
                geometry.addGroup(group.start, group.count, group.materialIndex);
            }
            var boundingSphere = json.data.boundingSphere;
            if (void 0 !== boundingSphere) {
                var center = new Vector3();
                void 0 !== boundingSphere.center && center.fromArray(boundingSphere.center), geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
            }
            return geometry;
        }
    }), Loader.prototype = {
        constructor: Loader,
        crossOrigin: void 0,
        extractUrlBase: function(url) {
            var parts = url.split("/");
            return 1 === parts.length ? "./" : (parts.pop(), parts.join("/") + "/");
        },
        initMaterials: function(materials, texturePath, crossOrigin) {
            for (var array = [], i = 0; i < materials.length; ++i) array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
            return array;
        },
        createMaterial: function() {
            var color, textureLoader, materialLoader;
            return function(m, texturePath, crossOrigin) {
                function loadTexture(path, repeat, offset, wrap, anisotropy) {
                    var texture, fullPath = texturePath + path, loader = Loader.Handlers.get(fullPath);
                    null !== loader ? texture = loader.load(fullPath) : (textureLoader.setCrossOrigin(crossOrigin), 
                    texture = textureLoader.load(fullPath)), void 0 !== repeat && (texture.repeat.fromArray(repeat), 
                    1 !== repeat[0] && (texture.wrapS = RepeatWrapping), 1 !== repeat[1] && (texture.wrapT = RepeatWrapping)), 
                    void 0 !== offset && texture.offset.fromArray(offset), void 0 !== wrap && ("repeat" === wrap[0] && (texture.wrapS = RepeatWrapping), 
                    "mirror" === wrap[0] && (texture.wrapS = MirroredRepeatWrapping), "repeat" === wrap[1] && (texture.wrapT = RepeatWrapping), 
                    "mirror" === wrap[1] && (texture.wrapT = MirroredRepeatWrapping)), void 0 !== anisotropy && (texture.anisotropy = anisotropy);
                    var uuid = _Math.generateUUID();
                    return textures[uuid] = texture, uuid;
                }
                void 0 === color && (color = new Color()), void 0 === textureLoader && (textureLoader = new TextureLoader()), 
                void 0 === materialLoader && (materialLoader = new MaterialLoader());
                var textures = {}, json = {
                    uuid: _Math.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (var name in m) {
                    var value = m[name];
                    switch (name) {
                      case "DbgColor":
                      case "DbgIndex":
                      case "opticalDensity":
                      case "illumination":
                        break;

                      case "DbgName":
                        json.name = value;
                        break;

                      case "blending":
                        json.blending = BlendingMode[value];
                        break;

                      case "colorAmbient":
                      case "mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
                        break;

                      case "colorDiffuse":
                        json.color = color.fromArray(value).getHex();
                        break;

                      case "colorSpecular":
                        json.specular = color.fromArray(value).getHex();
                        break;

                      case "colorEmissive":
                        json.emissive = color.fromArray(value).getHex();
                        break;

                      case "specularCoef":
                        json.shininess = value;
                        break;

                      case "shading":
                        "basic" === value.toLowerCase() && (json.type = "MeshBasicMaterial"), "phong" === value.toLowerCase() && (json.type = "MeshPhongMaterial"), 
                        "standard" === value.toLowerCase() && (json.type = "MeshStandardMaterial");
                        break;

                      case "mapDiffuse":
                        json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                        break;

                      case "mapDiffuseRepeat":
                      case "mapDiffuseOffset":
                      case "mapDiffuseWrap":
                      case "mapDiffuseAnisotropy":
                        break;

                      case "mapEmissive":
                        json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                        break;

                      case "mapEmissiveRepeat":
                      case "mapEmissiveOffset":
                      case "mapEmissiveWrap":
                      case "mapEmissiveAnisotropy":
                        break;

                      case "mapLight":
                        json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                        break;

                      case "mapLightRepeat":
                      case "mapLightOffset":
                      case "mapLightWrap":
                      case "mapLightAnisotropy":
                        break;

                      case "mapAO":
                        json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                        break;

                      case "mapAORepeat":
                      case "mapAOOffset":
                      case "mapAOWrap":
                      case "mapAOAnisotropy":
                        break;

                      case "mapBump":
                        json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                        break;

                      case "mapBumpScale":
                        json.bumpScale = value;
                        break;

                      case "mapBumpRepeat":
                      case "mapBumpOffset":
                      case "mapBumpWrap":
                      case "mapBumpAnisotropy":
                        break;

                      case "mapNormal":
                        json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                        break;

                      case "mapNormalFactor":
                        json.normalScale = [ value, value ];
                        break;

                      case "mapNormalRepeat":
                      case "mapNormalOffset":
                      case "mapNormalWrap":
                      case "mapNormalAnisotropy":
                        break;

                      case "mapSpecular":
                        json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                        break;

                      case "mapSpecularRepeat":
                      case "mapSpecularOffset":
                      case "mapSpecularWrap":
                      case "mapSpecularAnisotropy":
                        break;

                      case "mapMetalness":
                        json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                        break;

                      case "mapMetalnessRepeat":
                      case "mapMetalnessOffset":
                      case "mapMetalnessWrap":
                      case "mapMetalnessAnisotropy":
                        break;

                      case "mapRoughness":
                        json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                        break;

                      case "mapRoughnessRepeat":
                      case "mapRoughnessOffset":
                      case "mapRoughnessWrap":
                      case "mapRoughnessAnisotropy":
                        break;

                      case "mapAlpha":
                        json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                        break;

                      case "mapAlphaRepeat":
                      case "mapAlphaOffset":
                      case "mapAlphaWrap":
                      case "mapAlphaAnisotropy":
                        break;

                      case "flipSided":
                        json.side = BackSide;
                        break;

                      case "doubleSided":
                        json.side = DoubleSide;
                        break;

                      case "transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), 
                        json.opacity = value;
                        break;

                      case "depthTest":
                      case "depthWrite":
                      case "colorWrite":
                      case "opacity":
                      case "reflectivity":
                      case "transparent":
                      case "visible":
                      case "wireframe":
                        json[name] = value;
                        break;

                      case "vertexColors":
                        value === !0 && (json.vertexColors = VertexColors), "face" === value && (json.vertexColors = FaceColors);
                        break;

                      default:
                        console.error("THREE.Loader.createMaterial: Unsupported", name, value);
                    }
                }
                return "MeshBasicMaterial" === json.type && delete json.emissive, "MeshPhongMaterial" !== json.type && delete json.specular, 
                json.opacity < 1 && (json.transparent = !0), materialLoader.setTextures(textures), 
                materialLoader.parse(json);
            };
        }()
    }, Loader.Handlers = {
        handlers: [],
        add: function(regex, loader) {
            this.handlers.push(regex, loader);
        },
        get: function(file) {
            for (var handlers = this.handlers, i = 0, l = handlers.length; l > i; i += 2) {
                var regex = handlers[i], loader = handlers[i + 1];
                if (regex.test(file)) return loader;
            }
            return null;
        }
    }, Object.assign(JSONLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, texturePath = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Loader.prototype.extractUrlBase(url), loader = new XHRLoader(this.manager);
            loader.setWithCredentials(this.withCredentials), loader.load(url, function(text) {
                var json = JSON.parse(text), metadata = json.metadata;
                if (void 0 !== metadata) {
                    var type = metadata.type;
                    if (void 0 !== type) {
                        if ("object" === type.toLowerCase()) return void console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === type.toLowerCase()) return void console.error("THREE.JSONLoader: " + url + " should be loaded with THREE.SceneLoader instead.");
                    }
                }
                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        parse: function(json, texturePath) {
            function parseModel(scale) {
                function isBitSet(value, position) {
                    return value & 1 << position;
                }
                var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, nUvLayers = 0;
                if (void 0 !== json.uvs) {
                    for (i = 0; i < json.uvs.length; i++) json.uvs[i].length && nUvLayers++;
                    for (i = 0; nUvLayers > i; i++) geometry.faceVertexUvs[i] = [];
                }
                for (offset = 0, zLength = vertices.length; zLength > offset; ) vertex = new Vector3(), 
                vertex.x = vertices[offset++] * scale, vertex.y = vertices[offset++] * scale, vertex.z = vertices[offset++] * scale, 
                geometry.vertices.push(vertex);
                for (offset = 0, zLength = faces.length; zLength > offset; ) if (type = faces[offset++], 
                isQuad = isBitSet(type, 0), hasMaterial = isBitSet(type, 1), hasFaceVertexUv = isBitSet(type, 3), 
                hasFaceNormal = isBitSet(type, 4), hasFaceVertexNormal = isBitSet(type, 5), hasFaceColor = isBitSet(type, 6), 
                hasFaceVertexColor = isBitSet(type, 7), isQuad) {
                    if (faceA = new Face3(), faceA.a = faces[offset], faceA.b = faces[offset + 1], faceA.c = faces[offset + 3], 
                    faceB = new Face3(), faceB.a = faces[offset + 1], faceB.b = faces[offset + 2], faceB.c = faces[offset + 3], 
                    offset += 4, hasMaterial && (materialIndex = faces[offset++], faceA.materialIndex = materialIndex, 
                    faceB.materialIndex = materialIndex), fi = geometry.faces.length, hasFaceVertexUv) for (i = 0; nUvLayers > i; i++) for (uvLayer = json.uvs[i], 
                    geometry.faceVertexUvs[i][fi] = [], geometry.faceVertexUvs[i][fi + 1] = [], j = 0; 4 > j; j++) uvIndex = faces[offset++], 
                    u = uvLayer[2 * uvIndex], v = uvLayer[2 * uvIndex + 1], uv = new Vector2(u, v), 
                    2 !== j && geometry.faceVertexUvs[i][fi].push(uv), 0 !== j && geometry.faceVertexUvs[i][fi + 1].push(uv);
                    if (hasFaceNormal && (normalIndex = 3 * faces[offset++], faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]), 
                    faceB.normal.copy(faceA.normal)), hasFaceVertexNormal) for (i = 0; 4 > i; i++) normalIndex = 3 * faces[offset++], 
                    normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]), 
                    2 !== i && faceA.vertexNormals.push(normal), 0 !== i && faceB.vertexNormals.push(normal);
                    if (hasFaceColor && (colorIndex = faces[offset++], hex = colors[colorIndex], faceA.color.setHex(hex), 
                    faceB.color.setHex(hex)), hasFaceVertexColor) for (i = 0; 4 > i; i++) colorIndex = faces[offset++], 
                    hex = colors[colorIndex], 2 !== i && faceA.vertexColors.push(new Color(hex)), 0 !== i && faceB.vertexColors.push(new Color(hex));
                    geometry.faces.push(faceA), geometry.faces.push(faceB);
                } else {
                    if (face = new Face3(), face.a = faces[offset++], face.b = faces[offset++], face.c = faces[offset++], 
                    hasMaterial && (materialIndex = faces[offset++], face.materialIndex = materialIndex), 
                    fi = geometry.faces.length, hasFaceVertexUv) for (i = 0; nUvLayers > i; i++) for (uvLayer = json.uvs[i], 
                    geometry.faceVertexUvs[i][fi] = [], j = 0; 3 > j; j++) uvIndex = faces[offset++], 
                    u = uvLayer[2 * uvIndex], v = uvLayer[2 * uvIndex + 1], uv = new Vector2(u, v), 
                    geometry.faceVertexUvs[i][fi].push(uv);
                    if (hasFaceNormal && (normalIndex = 3 * faces[offset++], face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex])), 
                    hasFaceVertexNormal) for (i = 0; 3 > i; i++) normalIndex = 3 * faces[offset++], 
                    normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]), 
                    face.vertexNormals.push(normal);
                    if (hasFaceColor && (colorIndex = faces[offset++], face.color.setHex(colors[colorIndex])), 
                    hasFaceVertexColor) for (i = 0; 3 > i; i++) colorIndex = faces[offset++], face.vertexColors.push(new Color(colors[colorIndex]));
                    geometry.faces.push(face);
                }
            }
            function parseSkin() {
                var influencesPerVertex = void 0 !== json.influencesPerVertex ? json.influencesPerVertex : 2;
                if (json.skinWeights) for (var i = 0, l = json.skinWeights.length; l > i; i += influencesPerVertex) {
                    var x = json.skinWeights[i], y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0, z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0, w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
                    geometry.skinWeights.push(new Vector4(x, y, z, w));
                }
                if (json.skinIndices) for (var i = 0, l = json.skinIndices.length; l > i; i += influencesPerVertex) {
                    var a = json.skinIndices[i], b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0, c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0, d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
                    geometry.skinIndices.push(new Vector4(a, b, c, d));
                }
                geometry.bones = json.bones, geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length) && console.warn("When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.");
            }
            function parseMorphing(scale) {
                if (void 0 !== json.morphTargets) for (var i = 0, l = json.morphTargets.length; l > i; i++) {
                    geometry.morphTargets[i] = {}, geometry.morphTargets[i].name = json.morphTargets[i].name, 
                    geometry.morphTargets[i].vertices = [];
                    for (var dstVertices = geometry.morphTargets[i].vertices, srcVertices = json.morphTargets[i].vertices, v = 0, vl = srcVertices.length; vl > v; v += 3) {
                        var vertex = new Vector3();
                        vertex.x = srcVertices[v] * scale, vertex.y = srcVertices[v + 1] * scale, vertex.z = srcVertices[v + 2] * scale, 
                        dstVertices.push(vertex);
                    }
                }
                if (void 0 !== json.morphColors && json.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    for (var faces = geometry.faces, morphColors = json.morphColors[0].colors, i = 0, l = faces.length; l > i; i++) faces[i].color.fromArray(morphColors, 3 * i);
                }
            }
            function parseAnimations() {
                var outputAnimations = [], animations = [];
                void 0 !== json.animation && animations.push(json.animation), void 0 !== json.animations && (json.animations.length ? animations = animations.concat(json.animations) : animations.push(json.animations));
                for (var i = 0; i < animations.length; i++) {
                    var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                    clip && outputAnimations.push(clip);
                }
                if (geometry.morphTargets) {
                    var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                    outputAnimations = outputAnimations.concat(morphAnimationClips);
                }
                outputAnimations.length > 0 && (geometry.animations = outputAnimations);
            }
            var geometry = new Geometry(), scale = void 0 !== json.scale ? 1 / json.scale : 1;
            if (parseModel(scale), parseSkin(), parseMorphing(scale), parseAnimations(), geometry.computeFaceNormals(), 
            geometry.computeBoundingSphere(), void 0 === json.materials || 0 === json.materials.length) return {
                geometry: geometry
            };
            var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
            return {
                geometry: geometry,
                materials: materials
            };
        }
    }), Object.assign(ObjectLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            "" === this.texturePath && (this.texturePath = url.substring(0, url.lastIndexOf("/") + 1));
            var scope = this, loader = new XHRLoader(scope.manager);
            loader.load(url, function(text) {
                scope.parse(JSON.parse(text), onLoad);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
        },
        parse: function(json, onLoad) {
            var geometries = this.parseGeometries(json.geometries), images = this.parseImages(json.images, function() {
                void 0 !== onLoad && onLoad(object);
            }), textures = this.parseTextures(json.textures, images), materials = this.parseMaterials(json.materials, textures), object = this.parseObject(json.object, geometries, materials);
            return json.animations && (object.animations = this.parseAnimations(json.animations)), 
            void 0 !== json.images && 0 !== json.images.length || void 0 !== onLoad && onLoad(object), 
            object;
        },
        parseGeometries: function(json) {
            var geometries = {};
            if (void 0 !== json) for (var geometryLoader = new JSONLoader(), bufferGeometryLoader = new BufferGeometryLoader(), i = 0, l = json.length; l > i; i++) {
                var geometry, data = json[i];
                switch (data.type) {
                  case "PlaneGeometry":
                  case "PlaneBufferGeometry":
                    geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                    break;

                  case "BoxGeometry":
                  case "BoxBufferGeometry":
                  case "CubeGeometry":
                    geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                    break;

                  case "CircleGeometry":
                  case "CircleBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                    break;

                  case "CylinderGeometry":
                  case "CylinderBufferGeometry":
                    geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    break;

                  case "ConeGeometry":
                  case "ConeBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    break;

                  case "SphereGeometry":
                  case "SphereBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                    break;

                  case "DodecahedronGeometry":
                  case "IcosahedronGeometry":
                  case "OctahedronGeometry":
                  case "TetrahedronGeometry":
                    geometry = new Geometries[data.type](data.radius, data.detail);
                    break;

                  case "RingGeometry":
                  case "RingBufferGeometry":
                    geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                    break;

                  case "TorusGeometry":
                  case "TorusBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                    break;

                  case "TorusKnotGeometry":
                  case "TorusKnotBufferGeometry":
                    geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                    break;

                  case "LatheGeometry":
                  case "LatheBufferGeometry":
                    geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                    break;

                  case "BufferGeometry":
                    geometry = bufferGeometryLoader.parse(data);
                    break;

                  case "Geometry":
                    geometry = geometryLoader.parse(data.data, this.texturePath).geometry;
                    break;

                  default:
                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                    continue;
                }
                geometry.uuid = data.uuid, void 0 !== data.name && (geometry.name = data.name), 
                geometries[data.uuid] = geometry;
            }
            return geometries;
        },
        parseMaterials: function(json, textures) {
            var materials = {};
            if (void 0 !== json) {
                var loader = new MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; l > i; i++) {
                    var material = loader.parse(json[i]);
                    materials[material.uuid] = material;
                }
            }
            return materials;
        },
        parseAnimations: function(json) {
            for (var animations = [], i = 0; i < json.length; i++) {
                var clip = AnimationClip.parse(json[i]);
                animations.push(clip);
            }
            return animations;
        },
        parseImages: function(json, onLoad) {
            function loadImage(url) {
                return scope.manager.itemStart(url), loader.load(url, function() {
                    scope.manager.itemEnd(url);
                }, void 0, function() {
                    scope.manager.itemError(url);
                });
            }
            var scope = this, images = {};
            if (void 0 !== json && json.length > 0) {
                var manager = new LoadingManager(onLoad), loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, l = json.length; l > i; i++) {
                    var image = json[i], path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                    images[image.uuid] = loadImage(path);
                }
            }
            return images;
        },
        parseTextures: function(json, images) {
            function parseConstant(value, type) {
                return "number" == typeof value ? value : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value), 
                type[value]);
            }
            var textures = {};
            if (void 0 !== json) for (var i = 0, l = json.length; l > i; i++) {
                var data = json[i];
                void 0 === data.image && console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid), 
                void 0 === images[data.image] && console.warn("THREE.ObjectLoader: Undefined image", data.image);
                var texture = new Texture(images[data.image]);
                texture.needsUpdate = !0, texture.uuid = data.uuid, void 0 !== data.name && (texture.name = data.name), 
                void 0 !== data.mapping && (texture.mapping = parseConstant(data.mapping, TextureMapping)), 
                void 0 !== data.offset && texture.offset.fromArray(data.offset), void 0 !== data.repeat && texture.repeat.fromArray(data.repeat), 
                void 0 !== data.wrap && (texture.wrapS = parseConstant(data.wrap[0], TextureWrapping), 
                texture.wrapT = parseConstant(data.wrap[1], TextureWrapping)), void 0 !== data.minFilter && (texture.minFilter = parseConstant(data.minFilter, TextureFilter)), 
                void 0 !== data.magFilter && (texture.magFilter = parseConstant(data.magFilter, TextureFilter)), 
                void 0 !== data.anisotropy && (texture.anisotropy = data.anisotropy), void 0 !== data.flipY && (texture.flipY = data.flipY), 
                textures[data.uuid] = texture;
            }
            return textures;
        },
        parseObject: function() {
            var matrix = new Matrix4();
            return function(data, geometries, materials) {
                function getGeometry(name) {
                    return void 0 === geometries[name] && console.warn("THREE.ObjectLoader: Undefined geometry", name), 
                    geometries[name];
                }
                function getMaterial(name) {
                    return void 0 !== name ? (void 0 === materials[name] && console.warn("THREE.ObjectLoader: Undefined material", name), 
                    materials[name]) : void 0;
                }
                var object;
                switch (data.type) {
                  case "Scene":
                    object = new Scene(), void 0 !== data.background && Number.isInteger(data.background) && (object.background = new Color(data.background)), 
                    void 0 !== data.fog && ("Fog" === data.fog.type ? object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far) : "FogExp2" === data.fog.type && (object.fog = new FogExp2(data.fog.color, data.fog.density)));
                    break;

                  case "PerspectiveCamera":
                    object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far), void 0 !== data.focus && (object.focus = data.focus), 
                    void 0 !== data.zoom && (object.zoom = data.zoom), void 0 !== data.filmGauge && (object.filmGauge = data.filmGauge), 
                    void 0 !== data.filmOffset && (object.filmOffset = data.filmOffset), void 0 !== data.view && (object.view = Object.assign({}, data.view));
                    break;

                  case "OrthographicCamera":
                    object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    break;

                  case "AmbientLight":
                    object = new AmbientLight(data.color, data.intensity);
                    break;

                  case "DirectionalLight":
                    object = new DirectionalLight(data.color, data.intensity);
                    break;

                  case "PointLight":
                    object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;

                  case "SpotLight":
                    object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    break;

                  case "HemisphereLight":
                    object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;

                  case "Mesh":
                    var geometry = getGeometry(data.geometry), material = getMaterial(data.material);
                    object = geometry.bones && geometry.bones.length > 0 ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
                    break;

                  case "LOD":
                    object = new LOD();
                    break;

                  case "Line":
                    object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                    break;

                  case "LineSegments":
                    object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "PointCloud":
                  case "Points":
                    object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;

                  case "Sprite":
                    object = new Sprite(getMaterial(data.material));
                    break;

                  case "Group":
                    object = new Group();
                    break;

                  default:
                    object = new Object3D();
                }
                if (object.uuid = data.uuid, void 0 !== data.name && (object.name = data.name), 
                void 0 !== data.matrix ? (matrix.fromArray(data.matrix), matrix.decompose(object.position, object.quaternion, object.scale)) : (void 0 !== data.position && object.position.fromArray(data.position), 
                void 0 !== data.rotation && object.rotation.fromArray(data.rotation), void 0 !== data.quaternion && object.quaternion.fromArray(data.quaternion), 
                void 0 !== data.scale && object.scale.fromArray(data.scale)), void 0 !== data.castShadow && (object.castShadow = data.castShadow), 
                void 0 !== data.receiveShadow && (object.receiveShadow = data.receiveShadow), data.shadow && (void 0 !== data.shadow.bias && (object.shadow.bias = data.shadow.bias), 
                void 0 !== data.shadow.radius && (object.shadow.radius = data.shadow.radius), void 0 !== data.shadow.mapSize && object.shadow.mapSize.fromArray(data.shadow.mapSize), 
                void 0 !== data.shadow.camera && (object.shadow.camera = this.parseObject(data.shadow.camera))), 
                void 0 !== data.visible && (object.visible = data.visible), void 0 !== data.userData && (object.userData = data.userData), 
                void 0 !== data.children) for (var child in data.children) object.add(this.parseObject(data.children[child], geometries, materials));
                if ("LOD" === data.type) for (var levels = data.levels, l = 0; l < levels.length; l++) {
                    var level = levels[l], child = object.getObjectByProperty("uuid", level.object);
                    void 0 !== child && object.addLevel(child, level.distance);
                }
                return object;
            };
        }()
    }), Curve.prototype = {
        constructor: Curve,
        getPoint: function(t) {
            return console.warn("THREE.Curve: Warning, getPoint() not implemented!"), null;
        },
        getPointAt: function(u) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t);
        },
        getPoints: function(divisions) {
            divisions || (divisions = 5);
            for (var points = [], d = 0; divisions >= d; d++) points.push(this.getPoint(d / divisions));
            return points;
        },
        getSpacedPoints: function(divisions) {
            divisions || (divisions = 5);
            for (var points = [], d = 0; divisions >= d; d++) points.push(this.getPointAt(d / divisions));
            return points;
        },
        getLength: function() {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        },
        getLengths: function(divisions) {
            if (divisions || (divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), 
            this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var current, p, cache = [], last = this.getPoint(0), sum = 0;
            for (cache.push(0), p = 1; divisions >= p; p++) current = this.getPoint(p / divisions), 
            sum += current.distanceTo(last), cache.push(sum), last = current;
            return this.cacheArcLengths = cache, cache;
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.getLengths();
        },
        getUtoTmapping: function(u, distance) {
            var targetArcLength, arcLengths = this.getLengths(), i = 0, il = arcLengths.length;
            targetArcLength = distance ? distance : u * arcLengths[il - 1];
            for (var comparison, low = 0, high = il - 1; high >= low; ) if (i = Math.floor(low + (high - low) / 2), 
            comparison = arcLengths[i] - targetArcLength, 0 > comparison) low = i + 1; else {
                if (!(comparison > 0)) {
                    high = i;
                    break;
                }
                high = i - 1;
            }
            if (i = high, arcLengths[i] === targetArcLength) {
                var t = i / (il - 1);
                return t;
            }
            var lengthBefore = arcLengths[i], lengthAfter = arcLengths[i + 1], segmentLength = lengthAfter - lengthBefore, segmentFraction = (targetArcLength - lengthBefore) / segmentLength, t = (i + segmentFraction) / (il - 1);
            return t;
        },
        getTangent: function(t) {
            var delta = 1e-4, t1 = t - delta, t2 = t + delta;
            0 > t1 && (t1 = 0), t2 > 1 && (t2 = 1);
            var pt1 = this.getPoint(t1), pt2 = this.getPoint(t2), vec = pt2.clone().sub(pt1);
            return vec.normalize();
        },
        getTangentAt: function(u) {
            var t = this.getUtoTmapping(u);
            return this.getTangent(t);
        },
        computeFrenetFrames: function(segments, closed) {
            var i, u, theta, normal = new Vector3(), tangents = [], normals = [], binormals = [], vec = new Vector3(), mat = new Matrix4();
            for (i = 0; segments >= i; i++) u = i / segments, tangents[i] = this.getTangentAt(u), 
            tangents[i].normalize();
            normals[0] = new Vector3(), binormals[0] = new Vector3();
            var min = Number.MAX_VALUE, tx = Math.abs(tangents[0].x), ty = Math.abs(tangents[0].y), tz = Math.abs(tangents[0].z);
            for (min >= tx && (min = tx, normal.set(1, 0, 0)), min >= ty && (min = ty, normal.set(0, 1, 0)), 
            min >= tz && normal.set(0, 0, 1), vec.crossVectors(tangents[0], normal).normalize(), 
            normals[0].crossVectors(tangents[0], vec), binormals[0].crossVectors(tangents[0], normals[0]), 
            i = 1; segments >= i; i++) normals[i] = normals[i - 1].clone(), binormals[i] = binormals[i - 1].clone(), 
            vec.crossVectors(tangents[i - 1], tangents[i]), vec.length() > Number.EPSILON && (vec.normalize(), 
            theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)), normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))), 
            binormals[i].crossVectors(tangents[i], normals[i]);
            if (closed === !0) for (theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1)), 
            theta /= segments, tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0 && (theta = -theta), 
            i = 1; segments >= i; i++) normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i)), 
            binormals[i].crossVectors(tangents[i], normals[i]);
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        }
    }, Curve.create = function(constructor, getPointFunc) {
        return constructor.prototype = Object.create(Curve.prototype), constructor.prototype.constructor = constructor, 
        constructor.prototype.getPoint = getPointFunc, constructor;
    }, LineCurve.prototype = Object.create(Curve.prototype), LineCurve.prototype.constructor = LineCurve, 
    LineCurve.prototype.isLineCurve = !0, LineCurve.prototype.getPoint = function(t) {
        if (1 === t) return this.v2.clone();
        var point = this.v2.clone().sub(this.v1);
        return point.multiplyScalar(t).add(this.v1), point;
    }, LineCurve.prototype.getPointAt = function(u) {
        return this.getPoint(u);
    }, LineCurve.prototype.getTangent = function(t) {
        var tangent = this.v2.clone().sub(this.v1);
        return tangent.normalize();
    }, CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
        constructor: CurvePath,
        add: function(curve) {
            this.curves.push(curve);
        },
        closePath: function() {
            var startPoint = this.curves[0].getPoint(0), endPoint = this.curves[this.curves.length - 1].getPoint(1);
            startPoint.equals(endPoint) || this.curves.push(new LineCurve(endPoint, startPoint));
        },
        getPoint: function(t) {
            for (var d = t * this.getLength(), curveLengths = this.getCurveLengths(), i = 0; i < curveLengths.length; ) {
                if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d, curve = this.curves[i], segmentLength = curve.getLength(), u = 0 === segmentLength ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u);
                }
                i++;
            }
            return null;
        },
        getLength: function() {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        },
        updateArcLengths: function() {
            this.needsUpdate = !0, this.cacheLengths = null, this.getLengths();
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var lengths = [], sums = 0, i = 0, l = this.curves.length; l > i; i++) sums += this.curves[i].getLength(), 
            lengths.push(sums);
            return this.cacheLengths = lengths, lengths;
        },
        getSpacedPoints: function(divisions) {
            divisions || (divisions = 40);
            for (var points = [], i = 0; divisions >= i; i++) points.push(this.getPoint(i / divisions));
            return this.autoClose && points.push(points[0]), points;
        },
        getPoints: function(divisions) {
            divisions = divisions || 12;
            for (var last, points = [], i = 0, curves = this.curves; i < curves.length; i++) for (var curve = curves[i], resolution = curve && curve.isEllipseCurve ? 2 * divisions : curve && curve.isLineCurve ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions, pts = curve.getPoints(resolution), j = 0; j < pts.length; j++) {
                var point = pts[j];
                last && last.equals(point) || (points.push(point), last = point);
            }
            return this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0]) && points.push(points[0]), 
            points;
        },
        createPointsGeometry: function(divisions) {
            var pts = this.getPoints(divisions);
            return this.createGeometry(pts);
        },
        createSpacedPointsGeometry: function(divisions) {
            var pts = this.getSpacedPoints(divisions);
            return this.createGeometry(pts);
        },
        createGeometry: function(points) {
            for (var geometry = new Geometry(), i = 0, l = points.length; l > i; i++) {
                var point = points[i];
                geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }
            return geometry;
        }
    }), EllipseCurve.prototype = Object.create(Curve.prototype), EllipseCurve.prototype.constructor = EllipseCurve, 
    EllipseCurve.prototype.isEllipseCurve = !0, EllipseCurve.prototype.getPoint = function(t) {
        for (var twoPi = 2 * Math.PI, deltaAngle = this.aEndAngle - this.aStartAngle, samePoints = Math.abs(deltaAngle) < Number.EPSILON; 0 > deltaAngle; ) deltaAngle += twoPi;
        for (;deltaAngle > twoPi; ) deltaAngle -= twoPi;
        deltaAngle < Number.EPSILON && (deltaAngle = samePoints ? 0 : twoPi), this.aClockwise !== !0 || samePoints || (deltaAngle === twoPi ? deltaAngle = -twoPi : deltaAngle -= twoPi);
        var angle = this.aStartAngle + t * deltaAngle, x = this.aX + this.xRadius * Math.cos(angle), y = this.aY + this.yRadius * Math.sin(angle);
        if (0 !== this.aRotation) {
            var cos = Math.cos(this.aRotation), sin = Math.sin(this.aRotation), tx = x - this.aX, ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX, y = tx * sin + ty * cos + this.aY;
        }
        return new Vector2(x, y);
    };
    var CurveUtils = {
        tangentQuadraticBezier: function(t, p0, p1, p2) {
            return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
        },
        tangentCubicBezier: function(t, p0, p1, p2, p3) {
            return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
        },
        tangentSpline: function(t, p0, p1, p2, p3) {
            var h00 = 6 * t * t - 6 * t, h10 = 3 * t * t - 4 * t + 1, h01 = -6 * t * t + 6 * t, h11 = 3 * t * t - 2 * t;
            return h00 + h10 + h01 + h11;
        },
        interpolate: function(p0, p1, p2, p3, t) {
            var v0 = .5 * (p2 - p0), v1 = .5 * (p3 - p1), t2 = t * t, t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
    };
    SplineCurve.prototype = Object.create(Curve.prototype), SplineCurve.prototype.constructor = SplineCurve, 
    SplineCurve.prototype.isSplineCurve = !0, SplineCurve.prototype.getPoint = function(t) {
        var points = this.points, point = (points.length - 1) * t, intPoint = Math.floor(point), weight = point - intPoint, point0 = points[0 === intPoint ? intPoint : intPoint - 1], point1 = points[intPoint], point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1], point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2], interpolate = CurveUtils.interpolate;
        return new Vector2(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight));
    }, CubicBezierCurve.prototype = Object.create(Curve.prototype), CubicBezierCurve.prototype.constructor = CubicBezierCurve, 
    CubicBezierCurve.prototype.getPoint = function(t) {
        var b3 = ShapeUtils.b3;
        return new Vector2(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y));
    }, CubicBezierCurve.prototype.getTangent = function(t) {
        var tangentCubicBezier = CurveUtils.tangentCubicBezier;
        return new Vector2(tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize();
    }, QuadraticBezierCurve.prototype = Object.create(Curve.prototype), QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve, 
    QuadraticBezierCurve.prototype.getPoint = function(t) {
        var b2 = ShapeUtils.b2;
        return new Vector2(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y));
    }, QuadraticBezierCurve.prototype.getTangent = function(t) {
        var tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;
        return new Vector2(tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x), tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y)).normalize();
    };
    var PathPrototype = Object.assign(Object.create(CurvePath.prototype), {
        fromPoints: function(vectors) {
            this.moveTo(vectors[0].x, vectors[0].y);
            for (var i = 1, l = vectors.length; l > i; i++) this.lineTo(vectors[i].x, vectors[i].y);
        },
        moveTo: function(x, y) {
            this.currentPoint.set(x, y);
        },
        lineTo: function(x, y) {
            var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
            this.curves.push(curve), this.currentPoint.set(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
            this.curves.push(curve), this.currentPoint.set(aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
            this.curves.push(curve), this.currentPoint.set(aX, aY);
        },
        splineThru: function(pts) {
            var npts = [ this.currentPoint.clone() ].concat(pts), curve = new SplineCurve(npts);
            this.curves.push(curve), this.currentPoint.copy(pts[pts.length - 1]);
        },
        arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var x0 = this.currentPoint.x, y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var x0 = this.currentPoint.x, y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        },
        absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                var firstPoint = curve.getPoint(0);
                firstPoint.equals(this.currentPoint) || this.lineTo(firstPoint.x, firstPoint.y);
            }
            this.curves.push(curve);
            var lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
        }
    });
    Shape.prototype = Object.assign(Object.create(PathPrototype), {
        constructor: Shape,
        getPointsHoles: function(divisions) {
            for (var holesPts = [], i = 0, l = this.holes.length; l > i; i++) holesPts[i] = this.holes[i].getPoints(divisions);
            return holesPts;
        },
        extractAllPoints: function(divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        },
        extractPoints: function(divisions) {
            return this.extractAllPoints(divisions);
        }
    }), Path.prototype = PathPrototype, PathPrototype.constructor = Path, ShapePath.prototype = {
        moveTo: function(x, y) {
            this.currentPath = new Path(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(x, y);
        },
        lineTo: function(x, y) {
            this.currentPath.lineTo(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        },
        splineThru: function(pts) {
            this.currentPath.splineThru(pts);
        },
        toShapes: function(isCCW, noHoles) {
            function toShapesNoHoles(inSubpaths) {
                for (var shapes = [], i = 0, l = inSubpaths.length; l > i; i++) {
                    var tmpPath = inSubpaths[i], tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves, shapes.push(tmpShape);
                }
                return shapes;
            }
            function isPointInsidePolygon(inPt, inPolygon) {
                for (var polyLen = inPolygon.length, inside = !1, p = polyLen - 1, q = 0; polyLen > q; p = q++) {
                    var edgeLowPt = inPolygon[p], edgeHighPt = inPolygon[q], edgeDx = edgeHighPt.x - edgeLowPt.x, edgeDy = edgeHighPt.y - edgeLowPt.y;
                    if (Math.abs(edgeDy) > Number.EPSILON) {
                        if (0 > edgeDy && (edgeLowPt = inPolygon[q], edgeDx = -edgeDx, edgeHighPt = inPolygon[p], 
                        edgeDy = -edgeDy), inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                        if (inPt.y === edgeLowPt.y) {
                            if (inPt.x === edgeLowPt.x) return !0;
                        } else {
                            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                            if (0 === perpEdge) return !0;
                            if (0 > perpEdge) continue;
                            inside = !inside;
                        }
                    } else {
                        if (inPt.y !== edgeLowPt.y) continue;
                        if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return !0;
                    }
                }
                return inside;
            }
            var isClockWise = ShapeUtils.isClockWise, subPaths = this.subPaths;
            if (0 === subPaths.length) return [];
            if (noHoles === !0) return toShapesNoHoles(subPaths);
            var solid, tmpPath, tmpShape, shapes = [];
            if (1 === subPaths.length) return tmpPath = subPaths[0], tmpShape = new Shape(), 
            tmpShape.curves = tmpPath.curves, shapes.push(tmpShape), shapes;
            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;
            var tmpPoints, betterShapeHoles = [], newShapes = [], newShapeHoles = [], mainIdx = 0;
            newShapes[mainIdx] = void 0, newShapeHoles[mainIdx] = [];
            for (var i = 0, l = subPaths.length; l > i; i++) tmpPath = subPaths[i], tmpPoints = tmpPath.getPoints(), 
            solid = isClockWise(tmpPoints), solid = isCCW ? !solid : solid, solid ? (!holesFirst && newShapes[mainIdx] && mainIdx++, 
            newShapes[mainIdx] = {
                s: new Shape(),
                p: tmpPoints
            }, newShapes[mainIdx].s.curves = tmpPath.curves, holesFirst && mainIdx++, newShapeHoles[mainIdx] = []) : newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
            if (!newShapes[0]) return toShapesNoHoles(subPaths);
            if (newShapes.length > 1) {
                for (var ambiguous = !1, toChange = [], sIdx = 0, sLen = newShapes.length; sLen > sIdx; sIdx++) betterShapeHoles[sIdx] = [];
                for (var sIdx = 0, sLen = newShapes.length; sLen > sIdx; sIdx++) for (var sho = newShapeHoles[sIdx], hIdx = 0; hIdx < sho.length; hIdx++) {
                    for (var ho = sho[hIdx], hole_unassigned = !0, s2Idx = 0; s2Idx < newShapes.length; s2Idx++) isPointInsidePolygon(ho.p, newShapes[s2Idx].p) && (sIdx !== s2Idx && toChange.push({
                        froms: sIdx,
                        tos: s2Idx,
                        hole: hIdx
                    }), hole_unassigned ? (hole_unassigned = !1, betterShapeHoles[s2Idx].push(ho)) : ambiguous = !0);
                    hole_unassigned && betterShapeHoles[sIdx].push(ho);
                }
                toChange.length > 0 && (ambiguous || (newShapeHoles = betterShapeHoles));
            }
            for (var tmpHoles, i = 0, il = newShapes.length; il > i; i++) {
                tmpShape = newShapes[i].s, shapes.push(tmpShape), tmpHoles = newShapeHoles[i];
                for (var j = 0, jl = tmpHoles.length; jl > j; j++) tmpShape.holes.push(tmpHoles[j].h);
            }
            return shapes;
        }
    }, Object.assign(Font.prototype, {
        isFont: !0,
        generateShapes: function(text, size, divisions) {
            function createPaths(text) {
                for (var chars = String(text).split(""), scale = size / data.resolution, offset = 0, paths = [], i = 0; i < chars.length; i++) {
                    var ret = createPath(chars[i], scale, offset);
                    offset += ret.offset, paths.push(ret.path);
                }
                return paths;
            }
            function createPath(c, scale, offset) {
                var glyph = data.glyphs[c] || data.glyphs["?"];
                if (glyph) {
                    var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste, path = new ShapePath(), pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;
                    if (glyph.o) for (var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" ")), i = 0, l = outline.length; l > i; ) {
                        var action = outline[i++];
                        switch (action) {
                          case "m":
                            x = outline[i++] * scale + offset, y = outline[i++] * scale, path.moveTo(x, y);
                            break;

                          case "l":
                            x = outline[i++] * scale + offset, y = outline[i++] * scale, path.lineTo(x, y);
                            break;

                          case "q":
                            if (cpx = outline[i++] * scale + offset, cpy = outline[i++] * scale, cpx1 = outline[i++] * scale + offset, 
                            cpy1 = outline[i++] * scale, path.quadraticCurveTo(cpx1, cpy1, cpx, cpy), laste = pts[pts.length - 1]) {
                                cpx0 = laste.x, cpy0 = laste.y;
                                for (var i2 = 1; divisions >= i2; i2++) {
                                    var t = i2 / divisions;
                                    b2(t, cpx0, cpx1, cpx), b2(t, cpy0, cpy1, cpy);
                                }
                            }
                            break;

                          case "b":
                            if (cpx = outline[i++] * scale + offset, cpy = outline[i++] * scale, cpx1 = outline[i++] * scale + offset, 
                            cpy1 = outline[i++] * scale, cpx2 = outline[i++] * scale + offset, cpy2 = outline[i++] * scale, 
                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy), laste = pts[pts.length - 1]) {
                                cpx0 = laste.x, cpy0 = laste.y;
                                for (var i2 = 1; divisions >= i2; i2++) {
                                    var t = i2 / divisions;
                                    b3(t, cpx0, cpx1, cpx2, cpx), b3(t, cpy0, cpy1, cpy2, cpy);
                                }
                            }
                        }
                    }
                    return {
                        offset: glyph.ha * scale,
                        path: path
                    };
                }
            }
            void 0 === size && (size = 100), void 0 === divisions && (divisions = 4);
            for (var data = this.data, paths = createPaths(text), shapes = [], p = 0, pl = paths.length; pl > p; p++) Array.prototype.push.apply(shapes, paths[p].toShapes());
            return shapes;
        }
    }), Object.assign(FontLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this, loader = new XHRLoader(this.manager);
            loader.load(url, function(text) {
                var json;
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), 
                    json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                onLoad && onLoad(font);
            }, onProgress, onError);
        },
        parse: function(json) {
            return new Font(json);
        }
    });
    var context;
    Object.assign(AudioLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var loader = new XHRLoader(this.manager);
            loader.setResponseType("arraybuffer"), loader.load(url, function(buffer) {
                var context = getAudioContext();
                context.decodeAudioData(buffer, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            }, onProgress, onError);
        }
    }), Object.assign(StereoCamera.prototype, {
        update: function() {
            var instance, focus, fov, aspect, near, far, zoom, eyeRight = new Matrix4(), eyeLeft = new Matrix4();
            return function(camera) {
                var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom;
                if (needsUpdate) {
                    instance = this, focus = camera.focus, fov = camera.fov, aspect = camera.aspect * this.aspect, 
                    near = camera.near, far = camera.far, zoom = camera.zoom;
                    var xmin, xmax, projectionMatrix = camera.projectionMatrix.clone(), eyeSep = this.eyeSep / 2, eyeSepOnProjection = eyeSep * near / focus, ymax = near * Math.tan(_Math.DEG2RAD * fov * .5) / zoom;
                    eyeLeft.elements[12] = -eyeSep, eyeRight.elements[12] = eyeSep, xmin = -ymax * aspect + eyeSepOnProjection, 
                    xmax = ymax * aspect + eyeSepOnProjection, projectionMatrix.elements[0] = 2 * near / (xmax - xmin), 
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin), this.cameraL.projectionMatrix.copy(projectionMatrix), 
                    xmin = -ymax * aspect - eyeSepOnProjection, xmax = ymax * aspect - eyeSepOnProjection, 
                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin), projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin), 
                    this.cameraR.projectionMatrix.copy(projectionMatrix);
                }
                this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft), this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
            };
        }()
    }), CubeCamera.prototype = Object.create(Object3D.prototype), CubeCamera.prototype.constructor = CubeCamera, 
    AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: AudioListener,
        getInput: function() {
            return this.gain;
        },
        removeFilter: function() {
            null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), 
            this.gain.connect(this.context.destination), this.filter = null);
        },
        getFilter: function() {
            return this.filter;
        },
        setFilter: function(value) {
            null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), 
            this.filter = value, this.gain.connect(this.filter), this.filter.connect(this.context.destination);
        },
        getMasterVolume: function() {
            return this.gain.gain.value;
        },
        setMasterVolume: function(value) {
            this.gain.gain.value = value;
        },
        updateMatrixWorld: function() {
            var position = new Vector3(), quaternion = new Quaternion(), scale = new Vector3(), orientation = new Vector3();
            return function(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                var listener = this.context.listener, up = this.up;
                this.matrixWorld.decompose(position, quaternion, scale), orientation.set(0, 0, -1).applyQuaternion(quaternion), 
                listener.setPosition(position.x, position.y, position.z), listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
            };
        }()
    }), Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Audio,
        getOutput: function() {
            return this.gain;
        },
        setNodeSource: function(audioNode) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = audioNode, 
            this.connect(), this;
        },
        setBuffer: function(audioBuffer) {
            return this.source.buffer = audioBuffer, this.sourceType = "buffer", this.autoplay && this.play(), 
            this;
        },
        play: function() {
            if (this.isPlaying === !0) return void console.warn("THREE.Audio: Audio is already playing.");
            if (this.hasPlaybackControl === !1) return void console.warn("THREE.Audio: this Audio has no playback control.");
            var source = this.context.createBufferSource();
            return source.buffer = this.source.buffer, source.loop = this.source.loop, source.onended = this.source.onended, 
            source.start(0, this.startTime), source.playbackRate.value = this.playbackRate, 
            this.isPlaying = !0, this.source = source, this.connect();
        },
        pause: function() {
            return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), 
            this.startTime = this.context.currentTime, this.isPlaying = !1, this);
        },
        stop: function() {
            return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), 
            this.startTime = 0, this.isPlaying = !1, this);
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; l > i; i++) this.filters[i - 1].connect(this.filters[i]);
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return this;
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; l > i; i++) this.filters[i - 1].disconnect(this.filters[i]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else this.source.disconnect(this.getOutput());
            return this;
        },
        getFilters: function() {
            return this.filters;
        },
        setFilters: function(value) {
            return value || (value = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = value, 
            this.connect()) : this.filters = value, this;
        },
        getFilter: function() {
            return this.getFilters()[0];
        },
        setFilter: function(filter) {
            return this.setFilters(filter ? [ filter ] : []);
        },
        setPlaybackRate: function(value) {
            return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = value, 
            this.isPlaying === !0 && (this.source.playbackRate.value = this.playbackRate), this);
        },
        getPlaybackRate: function() {
            return this.playbackRate;
        },
        onEnded: function() {
            this.isPlaying = !1;
        },
        getLoop: function() {
            return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), 
            !1) : this.source.loop;
        },
        setLoop: function(value) {
            return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : void (this.source.loop = value);
        },
        getVolume: function() {
            return this.gain.gain.value;
        },
        setVolume: function(value) {
            return this.gain.gain.value = value, this;
        }
    }), PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
        constructor: PositionalAudio,
        getOutput: function() {
            return this.panner;
        },
        getRefDistance: function() {
            return this.panner.refDistance;
        },
        setRefDistance: function(value) {
            this.panner.refDistance = value;
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor;
        },
        setRolloffFactor: function(value) {
            this.panner.rolloffFactor = value;
        },
        getDistanceModel: function() {
            return this.panner.distanceModel;
        },
        setDistanceModel: function(value) {
            this.panner.distanceModel = value;
        },
        getMaxDistance: function() {
            return this.panner.maxDistance;
        },
        setMaxDistance: function(value) {
            this.panner.maxDistance = value;
        },
        updateMatrixWorld: function() {
            var position = new Vector3();
            return function(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force), position.setFromMatrixPosition(this.matrixWorld), 
                this.panner.setPosition(position.x, position.y, position.z);
            };
        }()
    }), Object.assign(AudioAnalyser.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
        },
        getAverageFrequency: function() {
            for (var value = 0, data = this.getFrequencyData(), i = 0; i < data.length; i++) value += data[i];
            return value / data.length;
        }
    }), PropertyMixer.prototype = {
        constructor: PropertyMixer,
        accumulate: function(accuIndex, weight) {
            var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
            if (0 === currentWeight) {
                for (var i = 0; i !== stride; ++i) buffer[offset + i] = buffer[i];
                currentWeight = weight;
            } else {
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        },
        apply: function(accuIndex) {
            var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
            if (this.cumulativeWeight = 0, 1 > weight) {
                var originalValueOffset = 3 * stride;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            for (var i = stride, e = stride + stride; i !== e; ++i) if (buffer[i] !== buffer[i + stride]) {
                binding.setValue(buffer, offset);
                break;
            }
        },
        saveOriginalState: function() {
            var binding = this.binding, buffer = this.buffer, stride = this.valueSize, originalValueOffset = 3 * stride;
            binding.getValue(buffer, originalValueOffset);
            for (var i = stride, e = originalValueOffset; i !== e; ++i) buffer[i] = buffer[originalValueOffset + i % stride];
            this.cumulativeWeight = 0;
        },
        restoreOriginalState: function() {
            var originalValueOffset = 3 * this.valueSize;
            this.binding.setValue(this.buffer, originalValueOffset);
        },
        _select: function(buffer, dstOffset, srcOffset, t, stride) {
            if (t >= .5) for (var i = 0; i !== stride; ++i) buffer[dstOffset + i] = buffer[srcOffset + i];
        },
        _slerp: function(buffer, dstOffset, srcOffset, t, stride) {
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        },
        _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
            for (var s = 1 - t, i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        }
    }, PropertyBinding.prototype = {
        constructor: PropertyBinding,
        getValue: function(targetArray, offset) {
            this.bind(), this.getValue(targetArray, offset);
        },
        setValue: function(sourceArray, offset) {
            this.bind(), this.setValue(sourceArray, offset);
        },
        bind: function() {
            var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
            if (targetObject || (targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode, 
            this.node = targetObject), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, 
            !targetObject) return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
            if (objectName) {
                var objectIndex = parsedPath.objectIndex;
                switch (objectName) {
                  case "materials":
                    if (!targetObject.material) return void console.error("  can not bind to material as node does not have a material", this);
                    if (!targetObject.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                    targetObject = targetObject.material.materials;
                    break;

                  case "bones":
                    if (!targetObject.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
                    targetObject = targetObject.skeleton.bones;
                    for (var i = 0; i < targetObject.length; i++) if (targetObject[i].name === objectIndex) {
                        objectIndex = i;
                        break;
                    }
                    break;

                  default:
                    if (void 0 === targetObject[objectName]) return void console.error("  can not bind to objectName of node, undefined", this);
                    targetObject = targetObject[objectName];
                }
                if (void 0 !== objectIndex) {
                    if (void 0 === targetObject[objectIndex]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject);
                    targetObject = targetObject[objectIndex];
                }
            }
            var nodeProperty = targetObject[propertyName];
            if (void 0 === nodeProperty) {
                var nodeName = parsedPath.nodeName;
                return void console.error("  trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
            }
            var versioning = this.Versioning.None;
            void 0 !== targetObject.needsUpdate ? (versioning = this.Versioning.NeedsUpdate, 
            this.targetObject = targetObject) : void 0 !== targetObject.matrixWorldNeedsUpdate && (versioning = this.Versioning.MatrixWorldNeedsUpdate, 
            this.targetObject = targetObject);
            var bindingType = this.BindingType.Direct;
            if (void 0 !== propertyIndex) {
                if ("morphTargetInfluences" === propertyName) {
                    if (!targetObject.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                    if (!targetObject.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                    for (var i = 0; i < this.node.geometry.morphTargets.length; i++) if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                        propertyIndex = i;
                        break;
                    }
                }
                bindingType = this.BindingType.ArrayElement, this.resolvedProperty = nodeProperty, 
                this.propertyIndex = propertyIndex;
            } else void 0 !== nodeProperty.fromArray && void 0 !== nodeProperty.toArray ? (bindingType = this.BindingType.HasFromToArray, 
            this.resolvedProperty = nodeProperty) : void 0 !== nodeProperty.length ? (bindingType = this.BindingType.EntireArray, 
            this.resolvedProperty = nodeProperty) : this.propertyName = propertyName;
            this.getValue = this.GetterByBindingType[bindingType], this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        },
        unbind: function() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
    }, Object.assign(PropertyBinding.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        _getValue_unbound: PropertyBinding.prototype.getValue,
        _setValue_unbound: PropertyBinding.prototype.setValue,
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [ function(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        }, function(buffer, offset) {
            for (var source = this.resolvedProperty, i = 0, n = source.length; i !== n; ++i) buffer[offset++] = source[i];
        }, function(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }, function(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        } ],
        SetterByBindingTypeAndVersioning: [ [ function(buffer, offset) {
            this.node[this.propertyName] = buffer[offset];
        }, function(buffer, offset) {
            this.node[this.propertyName] = buffer[offset], this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            this.node[this.propertyName] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(buffer, offset) {
            for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
        }, function(buffer, offset) {
            for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
            this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            for (var dest = this.resolvedProperty, i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }, function(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0;
        } ], [ function(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
        }, function(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset), this.targetObject.needsUpdate = !0;
        }, function(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset), this.targetObject.matrixWorldNeedsUpdate = !0;
        } ] ]
    }), PropertyBinding.Composite = function(targetGroup, path, optionalParsedPath) {
        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup, this._bindings = targetGroup.subscribe_(path, parsedPath);
    }, PropertyBinding.Composite.prototype = {
        constructor: PropertyBinding.Composite,
        getValue: function(array, offset) {
            this.bind();
            var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
            void 0 !== binding && binding.getValue(array, offset);
        },
        setValue: function(array, offset) {
            for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].setValue(array, offset);
        },
        bind: function() {
            for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].bind();
        },
        unbind: function() {
            for (var bindings = this._bindings, i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].unbind();
        }
    }, PropertyBinding.create = function(root, path, parsedPath) {
        return root && root.isAnimationObjectGroup ? new PropertyBinding.Composite(root, path, parsedPath) : new PropertyBinding(root, path, parsedPath);
    }, PropertyBinding.parseTrackName = function(trackName) {
        var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/, matches = re.exec(trackName);
        if (!matches) throw new Error("cannot parse trackName at all: " + trackName);
        var results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        if (null === results.propertyName || 0 === results.propertyName.length) throw new Error("can not parse propertyName from trackName: " + trackName);
        return results;
    }, PropertyBinding.findNode = function(root, nodeName) {
        if (!nodeName || "" === nodeName || "root" === nodeName || "." === nodeName || -1 === nodeName || nodeName === root.name || nodeName === root.uuid) return root;
        if (root.skeleton) {
            var searchSkeleton = function(skeleton) {
                for (var i = 0; i < skeleton.bones.length; i++) {
                    var bone = skeleton.bones[i];
                    if (bone.name === nodeName) return bone;
                }
                return null;
            }, bone = searchSkeleton(root.skeleton);
            if (bone) return bone;
        }
        if (root.children) {
            var searchNodeSubtree = function(children) {
                for (var i = 0; i < children.length; i++) {
                    var childNode = children[i];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                    var result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            }, subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) return subTreeNode;
        }
        return null;
    }, AnimationObjectGroup.prototype = {
        constructor: AnimationObjectGroup,
        isAnimationObjectGroup: !0,
        add: function(var_args) {
            for (var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (void 0 === index) {
                    index = nObjects++, indicesByUUID[uuid] = index, objects.push(object);
                    for (var j = 0, m = nBindings; j !== m; ++j) bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                } else if (nCachedObjects > index) {
                    var knownObject = objects[index], firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index, objects[index] = lastCachedObject, 
                    indicesByUUID[uuid] = firstActiveIndex, objects[firstActiveIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached, void 0 === binding && (binding = new PropertyBinding(object, paths[j], parsedPaths[j])), 
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                } else objects[index] !== knownObject && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...");
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        remove: function(var_args) {
            for (var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (void 0 !== index && index >= nCachedObjects) {
                    var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index, objects[index] = firstActiveObject, 
                    indicesByUUID[uuid] = lastCachedIndex, objects[lastCachedIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive, bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        uncache: function(var_args) {
            for (var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length, i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
                if (void 0 !== index) if (delete indicesByUUID[uuid], nCachedObjects > index) {
                    var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastCachedObject.uuid] = index, objects[index] = lastCachedObject, 
                    indicesByUUID[lastObject.uuid] = firstActiveIndex, objects[firstActiveIndex] = lastObject, 
                    objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index] = lastCached, bindingsForPath[firstActiveIndex] = last, bindingsForPath.pop();
                    }
                } else {
                    var lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastObject.uuid] = index, objects[index] = lastObject, objects.pop();
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j];
                        bindingsForPath[index] = bindingsForPath[lastIndex], bindingsForPath.pop();
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        subscribe_: function(path, parsedPath) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
            if (void 0 !== index) return bindings[index];
            var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
            index = bindings.length, indicesByPath[path] = index, paths.push(path), parsedPaths.push(parsedPath), 
            bindings.push(bindingsForPath);
            for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        },
        unsubscribe_: function(path) {
            var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
            if (void 0 !== index) {
                var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index, bindings[index] = lastBindings, bindings.pop(), 
                parsedPaths[index] = parsedPaths[lastBindingsIndex], parsedPaths.pop(), paths[index] = paths[lastBindingsIndex], 
                paths.pop();
            }
        }
    }, AnimationAction.prototype = {
        constructor: AnimationAction,
        play: function() {
            return this._mixer._activateAction(this), this;
        },
        stop: function() {
            return this._mixer._deactivateAction(this), this.reset();
        },
        reset: function() {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, 
            this._startTime = null, this.stopFading().stopWarping();
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this);
        },
        startAt: function(time) {
            return this._startTime = time, this;
        },
        setLoop: function(mode, repetitions) {
            return this.loop = mode, this.repetitions = repetitions, this;
        },
        setEffectiveWeight: function(weight) {
            return this.weight = weight, this._effectiveWeight = this.enabled ? weight : 0, 
            this.stopFading();
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight;
        },
        fadeIn: function(duration) {
            return this._scheduleFading(duration, 0, 1);
        },
        fadeOut: function(duration) {
            return this._scheduleFading(duration, 1, 0);
        },
        crossFadeFrom: function(fadeOutAction, duration, warp) {
            if (fadeOutAction.fadeOut(duration), this.fadeIn(duration), warp) {
                var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1, startEndRatio, duration), this.warp(endStartRatio, 1, duration);
            }
            return this;
        },
        crossFadeTo: function(fadeInAction, duration, warp) {
            return fadeInAction.crossFadeFrom(this, duration, warp);
        },
        stopFading: function() {
            var weightInterpolant = this._weightInterpolant;
            return null !== weightInterpolant && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(weightInterpolant)), 
            this;
        },
        setEffectiveTimeScale: function(timeScale) {
            return this.timeScale = timeScale, this._effectiveTimeScale = this.paused ? 0 : timeScale, 
            this.stopWarping();
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale;
        },
        setDuration: function(duration) {
            return this.timeScale = this._clip.duration / duration, this.stopWarping();
        },
        syncWith: function(action) {
            return this.time = action.time, this.timeScale = action.timeScale, this.stopWarping();
        },
        halt: function(duration) {
            return this.warp(this._effectiveTimeScale, 0, duration);
        },
        warp: function(startTimeScale, endTimeScale, duration) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
            null === interpolant && (interpolant = mixer._lendControlInterpolant(), this._timeScaleInterpolant = interpolant);
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            return times[0] = now, times[1] = now + duration, values[0] = startTimeScale / timeScale, 
            values[1] = endTimeScale / timeScale, this;
        },
        stopWarping: function() {
            var timeScaleInterpolant = this._timeScaleInterpolant;
            return null !== timeScaleInterpolant && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(timeScaleInterpolant)), 
            this;
        },
        getMixer: function() {
            return this._mixer;
        },
        getClip: function() {
            return this._clip;
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root;
        },
        _update: function(time, deltaTime, timeDirection, accuIndex) {
            var startTime = this._startTime;
            if (null !== startTime) {
                var timeRunning = (time - startTime) * timeDirection;
                if (0 > timeRunning || 0 === timeDirection) return;
                this._startTime = null, deltaTime = timeDirection * timeRunning;
            }
            deltaTime *= this._updateTimeScale(time);
            var clipTime = this._updateTime(deltaTime), weight = this._updateWeight(time);
            if (weight > 0) for (var interpolants = this._interpolants, propertyMixers = this._propertyBindings, j = 0, m = interpolants.length; j !== m; ++j) interpolants[j].evaluate(clipTime), 
            propertyMixers[j].accumulate(accuIndex, weight);
        },
        _updateWeight: function(time) {
            var weight = 0;
            if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (null !== interpolant) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    weight *= interpolantValue, time > interpolant.parameterPositions[1] && (this.stopFading(), 
                    0 === interpolantValue && (this.enabled = !1));
                }
            }
            return this._effectiveWeight = weight, weight;
        },
        _updateTimeScale: function(time) {
            var timeScale = 0;
            if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (null !== interpolant) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    timeScale *= interpolantValue, time > interpolant.parameterPositions[1] && (this.stopWarping(), 
                    0 === timeScale ? this.paused = !0 : this.timeScale = timeScale);
                }
            }
            return this._effectiveTimeScale = timeScale, timeScale;
        },
        _updateTime: function(deltaTime) {
            var time = this.time + deltaTime;
            if (0 === deltaTime) return time;
            var duration = this._clip.duration, loop = this.loop, loopCount = this._loopCount;
            if (loop === LoopOnce) {
                -1 === loopCount && (this.loopCount = 0, this._setEndings(!0, !0, !1));
                handle_stop: {
                    if (time >= duration) time = duration; else {
                        if (!(0 > time)) break handle_stop;
                        time = 0;
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 > deltaTime ? -1 : 1
                    });
                }
            } else {
                var pingPong = loop === LoopPingPong;
                if (-1 === loopCount && (deltaTime >= 0 ? (loopCount = 0, this._setEndings(!0, 0 === this.repetitions, pingPong)) : this._setEndings(0 === this.repetitions, !0, pingPong)), 
                time >= duration || 0 > time) {
                    var loopDelta = Math.floor(time / duration);
                    time -= duration * loopDelta, loopCount += Math.abs(loopDelta);
                    var pending = this.repetitions - loopCount;
                    if (0 > pending) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, 
                    time = deltaTime > 0 ? duration : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    }); else {
                        if (0 === pending) {
                            var atStart = 0 > deltaTime;
                            this._setEndings(atStart, !atStart, pingPong);
                        } else this._setEndings(!1, !1, pingPong);
                        this._loopCount = loopCount, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: loopDelta
                        });
                    }
                }
                if (pingPong && 1 === (1 & loopCount)) return this.time = time, duration - time;
            }
            return this.time = time, time;
        },
        _setEndings: function(atStart, atEnd, pingPong) {
            var settings = this._interpolantSettings;
            pingPong ? (settings.endingStart = ZeroSlopeEnding, settings.endingEnd = ZeroSlopeEnding) : (atStart ? settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : settings.endingStart = WrapAroundEnding, 
            atEnd ? settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : settings.endingEnd = WrapAroundEnding);
        },
        _scheduleFading: function(duration, weightNow, weightThen) {
            var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
            null === interpolant && (interpolant = mixer._lendControlInterpolant(), this._weightInterpolant = interpolant);
            var times = interpolant.parameterPositions, values = interpolant.sampleValues;
            return times[0] = now, values[0] = weightNow, times[1] = now + duration, values[1] = weightThen, 
            this;
        }
    }, Object.assign(AnimationMixer.prototype, EventDispatcher.prototype, {
        clipAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = "string" == typeof clip ? AnimationClip.findByName(root, clip) : clip, clipUuid = null !== clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
            if (void 0 !== actionsForClip) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (void 0 !== existingAction) return existingAction;
                prototypeAction = actionsForClip.knownActions[0], null === clipObject && (clipObject = prototypeAction._clip);
            }
            if (null === clipObject) return null;
            var newAction = new AnimationAction(this, clipObject, optionalRoot);
            return this._bindAction(newAction, prototypeAction), this._addInactiveAction(newAction, clipUuid, rootUuid), 
            newAction;
        },
        existingAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = "string" == typeof clip ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
            return void 0 !== actionsForClip ? actionsForClip.actionByRoot[rootUuid] || null : null;
        },
        stopAllAction: function() {
            var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
            this._nActiveActions = 0, this._nActiveBindings = 0;
            for (var i = 0; i !== nActions; ++i) actions[i].reset();
            for (var i = 0; i !== nBindings; ++i) bindings[i].useCount = 0;
            return this;
        },
        update: function(deltaTime) {
            deltaTime *= this.timeScale;
            for (var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1, i = 0; i !== nActions; ++i) {
                var action = actions[i];
                action.enabled && action._update(time, deltaTime, timeDirection, accuIndex);
            }
            for (var bindings = this._bindings, nBindings = this._nActiveBindings, i = 0; i !== nBindings; ++i) bindings[i].apply(accuIndex);
            return this;
        },
        getRoot: function() {
            return this._root;
        },
        uncacheClip: function(clip) {
            var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (void 0 !== actionsForClip) {
                for (var actionsToRemove = actionsForClip.knownActions, i = 0, n = actionsToRemove.length; i !== n; ++i) {
                    var action = actionsToRemove[i];
                    this._deactivateAction(action);
                    var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null, action._byClipCacheIndex = null, lastInactiveAction._cacheIndex = cacheIndex, 
                    actions[cacheIndex] = lastInactiveAction, actions.pop(), this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        },
        uncacheRoot: function(root) {
            var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
            for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
                void 0 !== action && (this._deactivateAction(action), this._removeInactiveAction(action));
            }
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
            if (void 0 !== bindingByName) for (var trackName in bindingByName) {
                var binding = bindingByName[trackName];
                binding.restoreOriginalState(), this._removeInactiveBinding(binding);
            }
        },
        uncacheAction: function(clip, optionalRoot) {
            var action = this.existingAction(clip, optionalRoot);
            null !== action && (this._deactivateAction(action), this._removeInactiveAction(action));
        }
    }), Object.assign(AnimationMixer.prototype, {
        _bindAction: function(action, prototypeAction) {
            var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
            void 0 === bindingsByName && (bindingsByName = {}, bindingsByRoot[rootUuid] = bindingsByName);
            for (var i = 0; i !== nTracks; ++i) {
                var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
                if (void 0 !== binding) bindings[i] = binding; else {
                    if (binding = bindings[i], void 0 !== binding) {
                        null === binding._cacheIndex && (++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName));
                        continue;
                    }
                    var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                    binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize()), 
                    ++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName), 
                    bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
            }
        },
        _activateAction: function(action) {
            if (!this._isActiveAction(action)) {
                if (null === action._cacheIndex) {
                    var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]), this._addInactiveAction(action, clipUuid, rootUuid);
                }
                for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    0 === binding.useCount++ && (this._lendBinding(binding), binding.saveOriginalState());
                }
                this._lendAction(action);
            }
        },
        _deactivateAction: function(action) {
            if (this._isActiveAction(action)) {
                for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    0 === --binding.useCount && (binding.restoreOriginalState(), this._takeBackBinding(binding));
                }
                this._takeBackAction(action);
            }
        },
        _initMemoryManager: function() {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], 
            this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], 
            this._nActiveControlInterpolants = 0;
            var scope = this;
            this.stats = {
                actions: {
                    get total() {
                        return scope._actions.length;
                    },
                    get inUse() {
                        return scope._nActiveActions;
                    }
                },
                bindings: {
                    get total() {
                        return scope._bindings.length;
                    },
                    get inUse() {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total() {
                        return scope._controlInterpolants.length;
                    },
                    get inUse() {
                        return scope._nActiveControlInterpolants;
                    }
                }
            };
        },
        _isActiveAction: function(action) {
            var index = action._cacheIndex;
            return null !== index && index < this._nActiveActions;
        },
        _addInactiveAction: function(action, clipUuid, rootUuid) {
            var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
            if (void 0 === actionsForClip) actionsForClip = {
                knownActions: [ action ],
                actionByRoot: {}
            }, action._byClipCacheIndex = 0, actionsByClip[clipUuid] = actionsForClip; else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length, knownActions.push(action);
            }
            action._cacheIndex = actions.length, actions.push(action), actionsForClip.actionByRoot[rootUuid] = action;
        },
        _removeInactiveAction: function(action) {
            var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex, actions[cacheIndex] = lastInactiveAction, 
            actions.pop(), action._cacheIndex = null;
            var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex, knownActionsForClip[byClipCacheIndex] = lastKnownAction, 
            knownActionsForClip.pop(), action._byClipCacheIndex = null;
            var actionByRoot = actionsForClip.actionByRoot, rootUuid = (actions._localRoot || this._root).uuid;
            delete actionByRoot[rootUuid], 0 === knownActionsForClip.length && delete actionsByClip[clipUuid], 
            this._removeInactiveBindingsForAction(action);
        },
        _removeInactiveBindingsForAction: function(action) {
            for (var bindings = action._propertyBindings, i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                0 === --binding.referenceCount && this._removeInactiveBinding(binding);
            }
        },
        _lendAction: function(action) {
            var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex, actions[lastActiveIndex] = action, firstInactiveAction._cacheIndex = prevIndex, 
            actions[prevIndex] = firstInactiveAction;
        },
        _takeBackAction: function(action) {
            var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex, actions[firstInactiveIndex] = action, lastActiveAction._cacheIndex = prevIndex, 
            actions[prevIndex] = lastActiveAction;
        },
        _addInactiveBinding: function(binding, rootUuid, trackName) {
            var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
            void 0 === bindingByName && (bindingByName = {}, bindingsByRoot[rootUuid] = bindingByName), 
            bindingByName[trackName] = binding, binding._cacheIndex = bindings.length, bindings.push(binding);
        },
        _removeInactiveBinding: function(binding) {
            var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex, bindings[cacheIndex] = lastInactiveBinding, 
            bindings.pop(), delete bindingByName[trackName];
            remove_empty_map: {
                for (var _ in bindingByName) break remove_empty_map;
                delete bindingsByRoot[rootUuid];
            }
        },
        _lendBinding: function(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex, bindings[lastActiveIndex] = binding, firstInactiveBinding._cacheIndex = prevIndex, 
            bindings[prevIndex] = firstInactiveBinding;
        },
        _takeBackBinding: function(binding) {
            var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex, bindings[firstInactiveIndex] = binding, 
            lastActiveBinding._cacheIndex = prevIndex, bindings[prevIndex] = lastActiveBinding;
        },
        _lendControlInterpolant: function() {
            var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
            return void 0 === interpolant && (interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), 
            interpolant.__cacheIndex = lastActiveIndex, interpolants[lastActiveIndex] = interpolant), 
            interpolant;
        },
        _takeBackControlInterpolant: function(interpolant) {
            var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex, interpolants[firstInactiveIndex] = interpolant, 
            lastActiveInterpolant.__cacheIndex = prevIndex, interpolants[prevIndex] = lastActiveInterpolant;
        },
        _controlInterpolantsResultBuffer: new Float32Array(1)
    }), InstancedBufferGeometry.prototype = Object.create(BufferGeometry.prototype), 
    InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry, InstancedBufferGeometry.prototype.isInstancedBufferGeometry = !0, 
    InstancedBufferGeometry.prototype.addGroup = function(start, count, materialIndex) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex
        });
    }, InstancedBufferGeometry.prototype.copy = function(source) {
        var index = source.index;
        null !== index && this.setIndex(index.clone());
        var attributes = source.attributes;
        for (var name in attributes) {
            var attribute = attributes[name];
            this.addAttribute(name, attribute.clone());
        }
        for (var groups = source.groups, i = 0, l = groups.length; l > i; i++) {
            var group = groups[i];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        return this;
    }, InterleavedBufferAttribute.prototype = {
        constructor: InterleavedBufferAttribute,
        isInterleavedBufferAttribute: !0,
        get count() {
            return this.data.count;
        },
        get array() {
            return this.data.array;
        },
        setX: function(index, x) {
            return this.data.array[index * this.data.stride + this.offset] = x, this;
        },
        setY: function(index, y) {
            return this.data.array[index * this.data.stride + this.offset + 1] = y, this;
        },
        setZ: function(index, z) {
            return this.data.array[index * this.data.stride + this.offset + 2] = z, this;
        },
        setW: function(index, w) {
            return this.data.array[index * this.data.stride + this.offset + 3] = w, this;
        },
        getX: function(index) {
            return this.data.array[index * this.data.stride + this.offset];
        },
        getY: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 1];
        },
        getZ: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 2];
        },
        getW: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 3];
        },
        setXY: function(index, x, y) {
            return index = index * this.data.stride + this.offset, this.data.array[index + 0] = x, 
            this.data.array[index + 1] = y, this;
        },
        setXYZ: function(index, x, y, z) {
            return index = index * this.data.stride + this.offset, this.data.array[index + 0] = x, 
            this.data.array[index + 1] = y, this.data.array[index + 2] = z, this;
        },
        setXYZW: function(index, x, y, z, w) {
            return index = index * this.data.stride + this.offset, this.data.array[index + 0] = x, 
            this.data.array[index + 1] = y, this.data.array[index + 2] = z, this.data.array[index + 3] = w, 
            this;
        }
    }, InterleavedBuffer.prototype = {
        constructor: InterleavedBuffer,
        isInterleavedBuffer: !0,
        set needsUpdate(value) {
            value === !0 && this.version++;
        },
        setArray: function(array) {
            if (Array.isArray(array)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== array ? array.length / this.stride : 0, this.array = array;
        },
        setDynamic: function(value) {
            return this.dynamic = value, this;
        },
        copy: function(source) {
            return this.array = new source.array.constructor(source.array), this.count = source.count, 
            this.stride = source.stride, this.dynamic = source.dynamic, this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.stride, index2 *= attribute.stride;
            for (var i = 0, l = this.stride; l > i; i++) this.array[index1 + i] = attribute.array[index2 + i];
            return this;
        },
        set: function(value, offset) {
            return void 0 === offset && (offset = 0), this.array.set(value, offset), this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        }
    }, InstancedInterleavedBuffer.prototype = Object.create(InterleavedBuffer.prototype), 
    InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer, InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = !0, 
    InstancedInterleavedBuffer.prototype.copy = function(source) {
        return InterleavedBuffer.prototype.copy.call(this, source), this.meshPerAttribute = source.meshPerAttribute, 
        this;
    }, InstancedBufferAttribute.prototype = Object.create(BufferAttribute.prototype), 
    InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute, InstancedBufferAttribute.prototype.isInstancedBufferAttribute = !0, 
    InstancedBufferAttribute.prototype.copy = function(source) {
        return BufferAttribute.prototype.copy.call(this, source), this.meshPerAttribute = source.meshPerAttribute, 
        this;
    }, Raycaster.prototype = {
        constructor: Raycaster,
        linePrecision: 1,
        set: function(origin, direction) {
            this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
            camera && camera.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(camera.matrixWorld), 
            this.ray.direction.set(coords.x, coords.y, .5).unproject(camera).sub(this.ray.origin).normalize()) : camera && camera.isOrthographicCamera ? (this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera), 
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function(object, recursive) {
            var intersects = [];
            return intersectObject(object, this, intersects, recursive), intersects.sort(ascSort), 
            intersects;
        },
        intersectObjects: function(objects, recursive) {
            var intersects = [];
            if (Array.isArray(objects) === !1) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), 
            intersects;
            for (var i = 0, l = objects.length; l > i; i++) intersectObject(objects[i], this, intersects, recursive);
            return intersects.sort(ascSort), intersects;
        }
    }, Clock.prototype = {
        constructor: Clock,
        start: function() {
            this.startTime = (performance || Date).now(), this.oldTime = this.startTime, this.elapsedTime = 0, 
            this.running = !0;
        },
        stop: function() {
            this.getElapsedTime(), this.running = !1;
        },
        getElapsedTime: function() {
            return this.getDelta(), this.elapsedTime;
        },
        getDelta: function() {
            var diff = 0;
            if (this.autoStart && !this.running && this.start(), this.running) {
                var newTime = (performance || Date).now();
                diff = (newTime - this.oldTime) / 1e3, this.oldTime = newTime, this.elapsedTime += diff;
            }
            return diff;
        }
    }, Spherical.prototype = {
        constructor: Spherical,
        set: function(radius, phi, theta) {
            return this.radius = radius, this.phi = phi, this.theta = theta, this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(other) {
            return this.radius = other.radius, this.phi = other.phi, this.theta = other.theta, 
            this;
        },
        makeSafe: function() {
            var EPS = 1e-6;
            return this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi)), this;
        },
        setFromVector3: function(vec3) {
            return this.radius = vec3.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(vec3.x, vec3.z), 
            this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1))), this;
        }
    }, MorphBlendMesh.prototype = Object.create(Mesh.prototype), MorphBlendMesh.prototype.constructor = MorphBlendMesh, 
    MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
        var animation = {
            start: start,
            end: end,
            length: end - start + 1,
            fps: fps,
            duration: (end - start) / fps,
            lastFrame: 0,
            currentFrame: 0,
            active: !1,
            time: 0,
            direction: 1,
            weight: 1,
            directionBackwards: !1,
            mirroredLoop: !1
        };
        this.animationsMap[name] = animation, this.animationsList.push(animation);
    }, MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
        for (var firstAnimation, pattern = /([a-z]+)_?(\d+)/i, frameRanges = {}, geometry = this.geometry, i = 0, il = geometry.morphTargets.length; il > i; i++) {
            var morph = geometry.morphTargets[i], chunks = morph.name.match(pattern);
            if (chunks && chunks.length > 1) {
                var name = chunks[1];
                frameRanges[name] || (frameRanges[name] = {
                    start: 1 / 0,
                    end: -(1 / 0)
                });
                var range = frameRanges[name];
                i < range.start && (range.start = i), i > range.end && (range.end = i), firstAnimation || (firstAnimation = name);
            }
        }
        for (var name in frameRanges) {
            var range = frameRanges[name];
            this.createAnimation(name, range.start, range.end, fps);
        }
        this.firstAnimation = firstAnimation;
    }, MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
        var animation = this.animationsMap[name];
        animation && (animation.direction = 1, animation.directionBackwards = !1);
    }, MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
        var animation = this.animationsMap[name];
        animation && (animation.direction = -1, animation.directionBackwards = !0);
    }, MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
        var animation = this.animationsMap[name];
        animation && (animation.fps = fps, animation.duration = (animation.end - animation.start) / animation.fps);
    }, MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
        var animation = this.animationsMap[name];
        animation && (animation.duration = duration, animation.fps = (animation.end - animation.start) / animation.duration);
    }, MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
        var animation = this.animationsMap[name];
        animation && (animation.weight = weight);
    }, MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
        var animation = this.animationsMap[name];
        animation && (animation.time = time);
    }, MorphBlendMesh.prototype.getAnimationTime = function(name) {
        var time = 0, animation = this.animationsMap[name];
        return animation && (time = animation.time), time;
    }, MorphBlendMesh.prototype.getAnimationDuration = function(name) {
        var duration = -1, animation = this.animationsMap[name];
        return animation && (duration = animation.duration), duration;
    }, MorphBlendMesh.prototype.playAnimation = function(name) {
        var animation = this.animationsMap[name];
        animation ? (animation.time = 0, animation.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
    }, MorphBlendMesh.prototype.stopAnimation = function(name) {
        var animation = this.animationsMap[name];
        animation && (animation.active = !1);
    }, MorphBlendMesh.prototype.update = function(delta) {
        for (var i = 0, il = this.animationsList.length; il > i; i++) {
            var animation = this.animationsList[i];
            if (animation.active) {
                var frameTime = animation.duration / animation.length;
                animation.time += animation.direction * delta, animation.mirroredLoop ? (animation.time > animation.duration || animation.time < 0) && (animation.direction *= -1, 
                animation.time > animation.duration && (animation.time = animation.duration, animation.directionBackwards = !0), 
                animation.time < 0 && (animation.time = 0, animation.directionBackwards = !1)) : (animation.time = animation.time % animation.duration, 
                animation.time < 0 && (animation.time += animation.duration));
                var keyframe = animation.start + _Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1), weight = animation.weight;
                keyframe !== animation.currentFrame && (this.morphTargetInfluences[animation.lastFrame] = 0, 
                this.morphTargetInfluences[animation.currentFrame] = 1 * weight, this.morphTargetInfluences[keyframe] = 0, 
                animation.lastFrame = animation.currentFrame, animation.currentFrame = keyframe);
                var mix = animation.time % frameTime / frameTime;
                animation.directionBackwards && (mix = 1 - mix), animation.currentFrame !== animation.lastFrame ? (this.morphTargetInfluences[animation.currentFrame] = mix * weight, 
                this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight) : this.morphTargetInfluences[animation.currentFrame] = weight;
            }
        }
    }, ImmediateRenderObject.prototype = Object.create(Object3D.prototype), ImmediateRenderObject.prototype.constructor = ImmediateRenderObject, 
    ImmediateRenderObject.prototype.isImmediateRenderObject = !0, VertexNormalsHelper.prototype = Object.create(LineSegments.prototype), 
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper, VertexNormalsHelper.prototype.update = function() {
        var v1 = new Vector3(), v2 = new Vector3(), normalMatrix = new Matrix3();
        return function() {
            var keys = [ "a", "b", "c" ];
            this.object.updateMatrixWorld(!0), normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld, position = this.geometry.attributes.position, objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) for (var vertices = objGeometry.vertices, faces = objGeometry.faces, idx = 0, i = 0, l = faces.length; l > i; i++) for (var face = faces[i], j = 0, jl = face.vertexNormals.length; jl > j; j++) {
                var vertex = vertices[face[keys[j]]], normal = face.vertexNormals[j];
                v1.copy(vertex).applyMatrix4(matrixWorld), v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1), 
                position.setXYZ(idx, v1.x, v1.y, v1.z), idx += 1, position.setXYZ(idx, v2.x, v2.y, v2.z), 
                idx += 1;
            } else if (objGeometry && objGeometry.isBufferGeometry) for (var objPos = objGeometry.attributes.position, objNorm = objGeometry.attributes.normal, idx = 0, j = 0, jl = objPos.count; jl > j; j++) v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld), 
            v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j)), v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1), 
            position.setXYZ(idx, v1.x, v1.y, v1.z), idx += 1, position.setXYZ(idx, v2.x, v2.y, v2.z), 
            idx += 1;
            return position.needsUpdate = !0, this;
        };
    }(), SpotLightHelper.prototype = Object.create(Object3D.prototype), SpotLightHelper.prototype.constructor = SpotLightHelper, 
    SpotLightHelper.prototype.dispose = function() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
    }, SpotLightHelper.prototype.update = function() {
        var vector = new Vector3(), vector2 = new Vector3();
        return function() {
            var coneLength = this.light.distance ? this.light.distance : 1e3, coneWidth = coneLength * Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength), vector.setFromMatrixPosition(this.light.matrixWorld), 
            vector2.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(vector2.sub(vector)), 
            this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        };
    }(), SkeletonHelper.prototype = Object.create(LineSegments.prototype), SkeletonHelper.prototype.constructor = SkeletonHelper, 
    SkeletonHelper.prototype.getBoneList = function(object) {
        var boneList = [];
        object && object.isBone && boneList.push(object);
        for (var i = 0; i < object.children.length; i++) boneList.push.apply(boneList, this.getBoneList(object.children[i]));
        return boneList;
    }, SkeletonHelper.prototype.update = function() {
        for (var geometry = this.geometry, matrixWorldInv = new Matrix4().getInverse(this.root.matrixWorld), boneMatrix = new Matrix4(), j = 0, i = 0; i < this.bones.length; i++) {
            var bone = this.bones[i];
            bone.parent && bone.parent.isBone && (boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld), 
            geometry.vertices[j].setFromMatrixPosition(boneMatrix), boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld), 
            geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix), j += 2);
        }
        geometry.verticesNeedUpdate = !0, geometry.computeBoundingSphere();
    }, PointLightHelper.prototype = Object.create(Mesh.prototype), PointLightHelper.prototype.constructor = PointLightHelper, 
    PointLightHelper.prototype.dispose = function() {
        this.geometry.dispose(), this.material.dispose();
    }, PointLightHelper.prototype.update = function() {
        this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    }, HemisphereLightHelper.prototype = Object.create(Object3D.prototype), HemisphereLightHelper.prototype.constructor = HemisphereLightHelper, 
    HemisphereLightHelper.prototype.dispose = function() {
        this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose();
    }, HemisphereLightHelper.prototype.update = function() {
        var vector = new Vector3();
        return function() {
            this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), 
            this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate()), 
            this.lightSphere.geometry.colorsNeedUpdate = !0;
        };
    }(), GridHelper.prototype = Object.create(LineSegments.prototype), GridHelper.prototype.constructor = GridHelper, 
    GridHelper.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    }, FaceNormalsHelper.prototype = Object.create(LineSegments.prototype), FaceNormalsHelper.prototype.constructor = FaceNormalsHelper, 
    FaceNormalsHelper.prototype.update = function() {
        var v1 = new Vector3(), v2 = new Vector3(), normalMatrix = new Matrix3();
        return function() {
            this.object.updateMatrixWorld(!0), normalMatrix.getNormalMatrix(this.object.matrixWorld);
            for (var matrixWorld = this.object.matrixWorld, position = this.geometry.attributes.position, objGeometry = this.object.geometry, vertices = objGeometry.vertices, faces = objGeometry.faces, idx = 0, i = 0, l = faces.length; l > i; i++) {
                var face = faces[i], normal = face.normal;
                v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld), 
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1), 
                position.setXYZ(idx, v1.x, v1.y, v1.z), idx += 1, position.setXYZ(idx, v2.x, v2.y, v2.z), 
                idx += 1;
            }
            return position.needsUpdate = !0, this;
        };
    }(), DirectionalLightHelper.prototype = Object.create(Object3D.prototype), DirectionalLightHelper.prototype.constructor = DirectionalLightHelper, 
    DirectionalLightHelper.prototype.dispose = function() {
        var lightPlane = this.children[0], targetLine = this.children[1];
        lightPlane.geometry.dispose(), lightPlane.material.dispose(), targetLine.geometry.dispose(), 
        targetLine.material.dispose();
    }, DirectionalLightHelper.prototype.update = function() {
        var v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3();
        return function() {
            v1.setFromMatrixPosition(this.light.matrixWorld), v2.setFromMatrixPosition(this.light.target.matrixWorld), 
            v3.subVectors(v2, v1);
            var lightPlane = this.children[0], targetLine = this.children[1];
            lightPlane.lookAt(v3), lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), 
            targetLine.lookAt(v3), targetLine.scale.z = v3.length();
        };
    }(), CameraHelper.prototype = Object.create(LineSegments.prototype), CameraHelper.prototype.constructor = CameraHelper, 
    CameraHelper.prototype.update = function() {
        function setPoint(point, x, y, z) {
            vector.set(x, y, z).unproject(camera);
            var points = pointMap[point];
            if (void 0 !== points) for (var i = 0, il = points.length; il > i; i++) geometry.vertices[points[i]].copy(vector);
        }
        var geometry, pointMap, vector = new Vector3(), camera = new Camera();
        return function() {
            geometry = this.geometry, pointMap = this.pointMap;
            var w = 1, h = 1;
            camera.projectionMatrix.copy(this.camera.projectionMatrix), setPoint("c", 0, 0, -1), 
            setPoint("t", 0, 0, 1), setPoint("n1", -w, -h, -1), setPoint("n2", w, -h, -1), setPoint("n3", -w, h, -1), 
            setPoint("n4", w, h, -1), setPoint("f1", -w, -h, 1), setPoint("f2", w, -h, 1), setPoint("f3", -w, h, 1), 
            setPoint("f4", w, h, 1), setPoint("u1", .7 * w, 1.1 * h, -1), setPoint("u2", .7 * -w, 1.1 * h, -1), 
            setPoint("u3", 0, 2 * h, -1), setPoint("cf1", -w, 0, 1), setPoint("cf2", w, 0, 1), 
            setPoint("cf3", 0, -h, 1), setPoint("cf4", 0, h, 1), setPoint("cn1", -w, 0, -1), 
            setPoint("cn2", w, 0, -1), setPoint("cn3", 0, -h, -1), setPoint("cn4", 0, h, -1), 
            geometry.verticesNeedUpdate = !0;
        };
    }(), BoundingBoxHelper.prototype = Object.create(Mesh.prototype), BoundingBoxHelper.prototype.constructor = BoundingBoxHelper, 
    BoundingBoxHelper.prototype.update = function() {
        this.box.setFromObject(this.object), this.box.getSize(this.scale), this.box.getCenter(this.position);
    }, BoxHelper.prototype = Object.create(LineSegments.prototype), BoxHelper.prototype.constructor = BoxHelper, 
    BoxHelper.prototype.update = function() {
        var box = new Box3();
        return function(object) {
            if (object && object.isBox3 ? box.copy(object) : box.setFromObject(object), !box.isEmpty()) {
                var min = box.min, max = box.max, position = this.geometry.attributes.position, array = position.array;
                array[0] = max.x, array[1] = max.y, array[2] = max.z, array[3] = min.x, array[4] = max.y, 
                array[5] = max.z, array[6] = min.x, array[7] = min.y, array[8] = max.z, array[9] = max.x, 
                array[10] = min.y, array[11] = max.z, array[12] = max.x, array[13] = max.y, array[14] = min.z, 
                array[15] = min.x, array[16] = max.y, array[17] = min.z, array[18] = min.x, array[19] = min.y, 
                array[20] = min.z, array[21] = max.x, array[22] = min.y, array[23] = min.z, position.needsUpdate = !0, 
                this.geometry.computeBoundingSphere();
            }
        };
    }();
    var lineGeometry = new BufferGeometry();
    lineGeometry.addAttribute("position", new Float32Attribute([ 0, 0, 0, 0, 1, 0 ], 3));
    var coneGeometry = new CylinderBufferGeometry(0, .5, 1, 5, 1);
    coneGeometry.translate(0, -.5, 0), ArrowHelper.prototype = Object.create(Object3D.prototype), 
    ArrowHelper.prototype.constructor = ArrowHelper, ArrowHelper.prototype.setDirection = function() {
        var radians, axis = new Vector3();
        return function(dir) {
            dir.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : dir.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (axis.set(dir.z, 0, -dir.x).normalize(), 
            radians = Math.acos(dir.y), this.quaternion.setFromAxisAngle(axis, radians));
        };
    }(), ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
        void 0 === headLength && (headLength = .2 * length), void 0 === headWidth && (headWidth = .2 * headLength), 
        this.line.scale.set(1, Math.max(0, length - headLength), 1), this.line.updateMatrix(), 
        this.cone.scale.set(headWidth, headLength, headWidth), this.cone.position.y = length, 
        this.cone.updateMatrix();
    }, ArrowHelper.prototype.setColor = function(color) {
        this.line.material.color.copy(color), this.cone.material.color.copy(color);
    }, AxisHelper.prototype = Object.create(LineSegments.prototype), AxisHelper.prototype.constructor = AxisHelper;
    var CatmullRomCurve3 = function() {
        function CubicPoly() {}
        var tmp = new Vector3(), px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
        return CubicPoly.prototype.init = function(x0, x1, t0, t1) {
            this.c0 = x0, this.c1 = t0, this.c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1, this.c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }, CubicPoly.prototype.initNonuniformCatmullRom = function(x0, x1, x2, x3, dt0, dt1, dt2) {
            var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1, t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
            t1 *= dt1, t2 *= dt1, this.init(x1, x2, t1, t2);
        }, CubicPoly.prototype.initCatmullRom = function(x0, x1, x2, x3, tension) {
            this.init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
        }, CubicPoly.prototype.calc = function(t) {
            var t2 = t * t, t3 = t2 * t;
            return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;
        }, Curve.create(function(p) {
            this.points = p || [], this.closed = !1;
        }, function(t) {
            var point, intPoint, weight, l, points = this.points;
            l = points.length, 2 > l && console.log("duh, you need at least 2 points"), point = (l - (this.closed ? 0 : 1)) * t, 
            intPoint = Math.floor(point), weight = point - intPoint, this.closed ? intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length : 0 === weight && intPoint === l - 1 && (intPoint = l - 2, 
            weight = 1);
            var p0, p1, p2, p3;
            if (this.closed || intPoint > 0 ? p0 = points[(intPoint - 1) % l] : (tmp.subVectors(points[0], points[1]).add(points[0]), 
            p0 = tmp), p1 = points[intPoint % l], p2 = points[(intPoint + 1) % l], this.closed || l > intPoint + 2 ? p3 = points[(intPoint + 2) % l] : (tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]), 
            p3 = tmp), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                var pow = "chordal" === this.type ? .5 : .25, dt0 = Math.pow(p0.distanceToSquared(p1), pow), dt1 = Math.pow(p1.distanceToSquared(p2), pow), dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                1e-4 > dt1 && (dt1 = 1), 1e-4 > dt0 && (dt0 = dt1), 1e-4 > dt2 && (dt2 = dt1), px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2), 
                py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2), pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
            } else if ("catmullrom" === this.type) {
                var tension = void 0 !== this.tension ? this.tension : .5;
                px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, tension), py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, tension), 
                pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, tension);
            }
            var v = new Vector3(px.calc(weight), py.calc(weight), pz.calc(weight));
            return v;
        });
    }();
    ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
    var SplineCurve3 = Curve.create(function(points) {
        console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"), 
        this.points = void 0 === points ? [] : points;
    }, function(t) {
        var points = this.points, point = (points.length - 1) * t, intPoint = Math.floor(point), weight = point - intPoint, point0 = points[0 == intPoint ? intPoint : intPoint - 1], point1 = points[intPoint], point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1], point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2], interpolate = CurveUtils.interpolate;
        return new Vector3(interpolate(point0.x, point1.x, point2.x, point3.x, weight), interpolate(point0.y, point1.y, point2.y, point3.y, weight), interpolate(point0.z, point1.z, point2.z, point3.z, weight));
    }), CubicBezierCurve3 = Curve.create(function(v0, v1, v2, v3) {
        this.v0 = v0, this.v1 = v1, this.v2 = v2, this.v3 = v3;
    }, function(t) {
        var b3 = ShapeUtils.b3;
        return new Vector3(b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z));
    }), QuadraticBezierCurve3 = Curve.create(function(v0, v1, v2) {
        this.v0 = v0, this.v1 = v1, this.v2 = v2;
    }, function(t) {
        var b2 = ShapeUtils.b2;
        return new Vector3(b2(t, this.v0.x, this.v1.x, this.v2.x), b2(t, this.v0.y, this.v1.y, this.v2.y), b2(t, this.v0.z, this.v1.z, this.v2.z));
    }), LineCurve3 = Curve.create(function(v1, v2) {
        this.v1 = v1, this.v2 = v2;
    }, function(t) {
        if (1 === t) return this.v2.clone();
        var vector = new Vector3();
        return vector.subVectors(this.v2, this.v1), vector.multiplyScalar(t), vector.add(this.v1), 
        vector;
    });
    ArcCurve.prototype = Object.create(EllipseCurve.prototype), ArcCurve.prototype.constructor = ArcCurve;
    var SceneUtils = {
        createMultiMaterialObject: function(geometry, materials) {
            for (var group = new Group(), i = 0, l = materials.length; l > i; i++) group.add(new Mesh(geometry, materials[i]));
            return group;
        },
        detach: function(child, parent, scene) {
            child.applyMatrix(parent.matrixWorld), parent.remove(child), scene.add(child);
        },
        attach: function(child, scene, parent) {
            var matrixWorldInverse = new Matrix4();
            matrixWorldInverse.getInverse(parent.matrixWorld), child.applyMatrix(matrixWorldInverse), 
            scene.remove(child), parent.add(child);
        }
    }, LineStrip = 0, LinePieces = 1;
    Object.assign(Box2.prototype, {
        center: function(optionalTarget) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), 
            this.getCenter(optionalTarget);
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        },
        isIntersectionBox: function(box) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), 
            this.intersectsBox(box);
        },
        size: function(optionalTarget) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(optionalTarget);
        }
    }), Object.assign(Box3.prototype, {
        center: function(optionalTarget) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), 
            this.getCenter(optionalTarget);
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
        },
        isIntersectionBox: function(box) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), 
            this.intersectsBox(box);
        },
        isIntersectionSphere: function(sphere) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
            this.intersectsSphere(sphere);
        },
        size: function(optionalTarget) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(optionalTarget);
        }
    }), Object.assign(Line3.prototype, {
        center: function(optionalTarget) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), 
            this.getCenter(optionalTarget);
        }
    }), Object.assign(Matrix3.prototype, {
        multiplyVector3: function(vector) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), 
            vector.applyMatrix3(this);
        },
        multiplyVector3Array: function(a) {
            return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), 
            this.applyToVector3Array(a);
        }
    }), Object.assign(Matrix4.prototype, {
        extractPosition: function(m) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), 
            this.copyPosition(m);
        },
        setRotationFromQuaternion: function(q) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), 
            this.makeRotationFromQuaternion(q);
        },
        multiplyVector3: function(vector) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), 
            vector.applyProjection(this);
        },
        multiplyVector4: function(vector) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
            vector.applyMatrix4(this);
        },
        multiplyVector3Array: function(a) {
            return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), 
            this.applyToVector3Array(a);
        },
        rotateAxis: function(v) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), 
            v.transformDirection(this);
        },
        crossVector: function(vector) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), 
            vector.applyMatrix4(this);
        },
        translate: function(v) {
            console.error("THREE.Matrix4: .translate() has been removed.");
        },
        rotateX: function(angle) {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
        },
        rotateY: function(angle) {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
        },
        rotateZ: function(angle) {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
        },
        rotateByAxis: function(axis, angle) {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
        }
    }), Object.assign(Plane.prototype, {
        isIntersectionLine: function(line) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), 
            this.intersectsLine(line);
        }
    }), Object.assign(Quaternion.prototype, {
        multiplyVector3: function(vector) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), 
            vector.applyQuaternion(this);
        }
    }), Object.assign(Ray.prototype, {
        isIntersectionBox: function(box) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), 
            this.intersectsBox(box);
        },
        isIntersectionPlane: function(plane) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), 
            this.intersectsPlane(plane);
        },
        isIntersectionSphere: function(sphere) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), 
            this.intersectsSphere(sphere);
        }
    }), Object.assign(Shape.prototype, {
        extrude: function(options) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), 
            new ExtrudeGeometry(this, options);
        },
        makeGeometry: function(options) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), 
            new ShapeGeometry(this, options);
        }
    }), Object.assign(Vector3.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
        },
        getPositionFromMatrix: function(m) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), 
            this.setFromMatrixPosition(m);
        },
        getScaleFromMatrix: function(m) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), 
            this.setFromMatrixScale(m);
        },
        getColumnFromMatrix: function(index, matrix) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), 
            this.setFromMatrixColumn(matrix, index);
        }
    }), Object.assign(Object3D.prototype, {
        getChildByName: function(name) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), 
            this.getObjectByName(name);
        },
        renderDepth: function(value) {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
        },
        translate: function(distance, axis) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), 
            this.translateOnAxis(axis, distance);
        }
    }), Object.defineProperties(Object3D.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
            },
            set: function(value) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = value;
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
            },
            set: function(value) {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
            }
        }
    }), Object.defineProperties(LOD.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels;
            }
        }
    }), PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), 
        void 0 !== filmGauge && (this.filmGauge = filmGauge), this.setFocalLength(focalLength);
    }, Object.defineProperties(Light.prototype, {
        onlyShadow: {
            set: function(value) {
                console.warn("THREE.Light: .onlyShadow has been removed.");
            }
        },
        shadowCameraFov: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = value;
            }
        },
        shadowCameraLeft: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = value;
            }
        },
        shadowCameraRight: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = value;
            }
        },
        shadowCameraTop: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = value;
            }
        },
        shadowCameraBottom: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), 
                this.shadow.camera.bottom = value;
            }
        },
        shadowCameraNear: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = value;
            }
        },
        shadowCameraFar: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = value;
            }
        },
        shadowCameraVisible: {
            set: function(value) {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
            }
        },
        shadowBias: {
            set: function(value) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = value;
            }
        },
        shadowDarkness: {
            set: function(value) {
                console.warn("THREE.Light: .shadowDarkness has been removed.");
            }
        },
        shadowMapWidth: {
            set: function(value) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = value;
            }
        },
        shadowMapHeight: {
            set: function(value) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = value;
            }
        }
    }), Object.defineProperties(BufferAttribute.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), 
                this.array.length;
            }
        }
    }), Object.assign(BufferGeometry.prototype, {
        addIndex: function(index) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), 
            this.setIndex(index);
        },
        addDrawCall: function(start, count, indexOffset) {
            void 0 !== indexOffset && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), 
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(start, count);
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), 
            this.clearGroups();
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
        }
    }), Object.defineProperties(BufferGeometry.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), 
                this.groups;
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), 
                this.groups;
            }
        }
    }), Object.defineProperties(Material.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE." + this.type + ": .wrapAround has been removed.");
            },
            set: function(value) {
                console.warn("THREE." + this.type + ": .wrapAround has been removed.");
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE." + this.type + ": .wrapRGB has been removed."), new Color();
            }
        }
    }), Object.defineProperties(MeshPhongMaterial.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), 
                !1;
            },
            set: function(value) {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
            }
        }
    }), Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), 
                this.extensions.derivatives;
            },
            set: function(value) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), 
                this.extensions.derivatives = value;
            }
        }
    }), EventDispatcher.prototype = Object.assign(Object.create({
        constructor: EventDispatcher,
        apply: function(target) {
            console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in."), 
            Object.assign(target, this);
        }
    }), EventDispatcher.prototype), Object.defineProperties(Uniform.prototype, {
        dynamic: {
            set: function(value) {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), 
                this;
            }
        }
    }), Object.assign(WebGLRenderer.prototype, {
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), 
            this.extensions.get("OES_texture_float");
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), 
            this.extensions.get("OES_texture_half_float");
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), 
            this.extensions.get("OES_standard_derivatives");
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), 
            this.extensions.get("WEBGL_compressed_texture_s3tc");
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), 
            this.extensions.get("WEBGL_compressed_texture_pvrtc");
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), 
            this.extensions.get("EXT_blend_minmax");
        },
        supportsVertexTextures: function() {
            return this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), 
            this.extensions.get("ANGLE_instanced_arrays");
        },
        enableScissorTest: function(boolean) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), 
            this.setScissorTest(boolean);
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
        }
    }), Object.defineProperties(WebGLRenderer.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), 
                this.shadowMap.enabled = value;
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = value;
            }
        },
        shadowMapCullFace: {
            get: function() {
                return this.shadowMap.cullFace;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), 
                this.shadowMap.cullFace = value;
            }
        }
    }), Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
            get: function() {
                return this.renderReverseSided ? CullFaceFront : CullFaceBack;
            },
            set: function(cullFace) {
                var value = cullFace !== CullFaceBack;
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "."), 
                this.renderReverseSided = value;
            }
        }
    }), Object.defineProperties(WebGLRenderTarget.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = value;
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = value;
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), 
                this.texture.magFilter;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), 
                this.texture.magFilter = value;
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), 
                this.texture.minFilter;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), 
                this.texture.minFilter = value;
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), 
                this.texture.anisotropy;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), 
                this.texture.anisotropy = value;
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), 
                this.texture.offset;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = value;
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), 
                this.texture.repeat;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = value;
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), 
                this.texture.format;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = value;
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = value;
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
                this.texture.generateMipmaps;
            },
            set: function(value) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), 
                this.texture.generateMipmaps = value;
            }
        }
    }), Object.assign(Audio.prototype, {
        load: function(file) {
            console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
            var scope = this, audioLoader = new AudioLoader();
            return audioLoader.load(file, function(buffer) {
                scope.setBuffer(buffer);
            }), this;
        }
    }), Object.assign(AudioAnalyser.prototype, {
        getData: function(file) {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), 
            this.getFrequencyData();
        }
    });
    var GeometryUtils = {
        merge: function(geometry1, geometry2, materialIndexOffset) {
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
            var matrix;
            geometry2.isMesh && (geometry2.matrixAutoUpdate && geometry2.updateMatrix(), matrix = geometry2.matrix, 
            geometry2 = geometry2.geometry), geometry1.merge(geometry2, matrix, materialIndexOffset);
        },
        center: function(geometry) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), 
            geometry.center();
        }
    }, ImageUtils = {
        crossOrigin: void 0,
        loadTexture: function(url, mapping, onLoad, onError) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var loader = new TextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(url, onLoad, void 0, onError);
            return mapping && (texture.mapping = mapping), texture;
        },
        loadTextureCube: function(urls, mapping, onLoad, onError) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var loader = new CubeTextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(urls, onLoad, void 0, onError);
            return mapping && (texture.mapping = mapping), texture;
        },
        loadCompressedTexture: function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
        },
        loadCompressedTextureCube: function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
        }
    };
    exports.WebGLRenderTargetCube = WebGLRenderTargetCube, exports.WebGLRenderTarget = WebGLRenderTarget, 
    exports.WebGLRenderer = WebGLRenderer, exports.ShaderLib = ShaderLib, exports.UniformsLib = UniformsLib, 
    exports.UniformsUtils = UniformsUtils, exports.ShaderChunk = ShaderChunk, exports.FogExp2 = FogExp2, 
    exports.Fog = Fog, exports.Scene = Scene, exports.LensFlare = LensFlare, exports.Sprite = Sprite, 
    exports.LOD = LOD, exports.SkinnedMesh = SkinnedMesh, exports.Skeleton = Skeleton, 
    exports.Bone = Bone, exports.Mesh = Mesh, exports.LineSegments = LineSegments, exports.Line = Line, 
    exports.Points = Points, exports.Group = Group, exports.VideoTexture = VideoTexture, 
    exports.DataTexture = DataTexture, exports.CompressedTexture = CompressedTexture, 
    exports.CubeTexture = CubeTexture, exports.CanvasTexture = CanvasTexture, exports.DepthTexture = DepthTexture, 
    exports.TextureIdCount = TextureIdCount, exports.Texture = Texture, exports.MaterialIdCount = MaterialIdCount, 
    exports.CompressedTextureLoader = CompressedTextureLoader, exports.BinaryTextureLoader = BinaryTextureLoader, 
    exports.DataTextureLoader = DataTextureLoader, exports.CubeTextureLoader = CubeTextureLoader, 
    exports.TextureLoader = TextureLoader, exports.ObjectLoader = ObjectLoader, exports.MaterialLoader = MaterialLoader, 
    exports.BufferGeometryLoader = BufferGeometryLoader, exports.DefaultLoadingManager = DefaultLoadingManager, 
    exports.LoadingManager = LoadingManager, exports.JSONLoader = JSONLoader, exports.ImageLoader = ImageLoader, 
    exports.FontLoader = FontLoader, exports.XHRLoader = XHRLoader, exports.Loader = Loader, 
    exports.Cache = Cache, exports.AudioLoader = AudioLoader, exports.SpotLightShadow = SpotLightShadow, 
    exports.SpotLight = SpotLight, exports.PointLight = PointLight, exports.HemisphereLight = HemisphereLight, 
    exports.DirectionalLightShadow = DirectionalLightShadow, exports.DirectionalLight = DirectionalLight, 
    exports.AmbientLight = AmbientLight, exports.LightShadow = LightShadow, exports.Light = Light, 
    exports.StereoCamera = StereoCamera, exports.PerspectiveCamera = PerspectiveCamera, 
    exports.OrthographicCamera = OrthographicCamera, exports.CubeCamera = CubeCamera, 
    exports.Camera = Camera, exports.AudioListener = AudioListener, exports.PositionalAudio = PositionalAudio, 
    exports.getAudioContext = getAudioContext, exports.AudioAnalyser = AudioAnalyser, 
    exports.Audio = Audio, exports.VectorKeyframeTrack = VectorKeyframeTrack, exports.StringKeyframeTrack = StringKeyframeTrack, 
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack, exports.NumberKeyframeTrack = NumberKeyframeTrack, 
    exports.ColorKeyframeTrack = ColorKeyframeTrack, exports.BooleanKeyframeTrack = BooleanKeyframeTrack, 
    exports.PropertyMixer = PropertyMixer, exports.PropertyBinding = PropertyBinding, 
    exports.KeyframeTrack = KeyframeTrack, exports.AnimationUtils = AnimationUtils, 
    exports.AnimationObjectGroup = AnimationObjectGroup, exports.AnimationMixer = AnimationMixer, 
    exports.AnimationClip = AnimationClip, exports.Uniform = Uniform, exports.InstancedBufferGeometry = InstancedBufferGeometry, 
    exports.BufferGeometry = BufferGeometry, exports.GeometryIdCount = GeometryIdCount, 
    exports.Geometry = Geometry, exports.InterleavedBufferAttribute = InterleavedBufferAttribute, 
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer, exports.InterleavedBuffer = InterleavedBuffer, 
    exports.InstancedBufferAttribute = InstancedBufferAttribute, exports.DynamicBufferAttribute = DynamicBufferAttribute, 
    exports.Float64Attribute = Float64Attribute, exports.Float32Attribute = Float32Attribute, 
    exports.Uint32Attribute = Uint32Attribute, exports.Int32Attribute = Int32Attribute, 
    exports.Uint16Attribute = Uint16Attribute, exports.Int16Attribute = Int16Attribute, 
    exports.Uint8ClampedAttribute = Uint8ClampedAttribute, exports.Uint8Attribute = Uint8Attribute, 
    exports.Int8Attribute = Int8Attribute, exports.BufferAttribute = BufferAttribute, 
    exports.Face3 = Face3, exports.Object3DIdCount = Object3DIdCount, exports.Object3D = Object3D, 
    exports.Raycaster = Raycaster, exports.Layers = Layers, exports.EventDispatcher = EventDispatcher, 
    exports.Clock = Clock, exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant, 
    exports.LinearInterpolant = LinearInterpolant, exports.DiscreteInterpolant = DiscreteInterpolant, 
    exports.CubicInterpolant = CubicInterpolant, exports.Interpolant = Interpolant, 
    exports.Triangle = Triangle, exports.Spline = Spline, exports.Math = _Math, exports.Spherical = Spherical, 
    exports.Plane = Plane, exports.Frustum = Frustum, exports.Sphere = Sphere, exports.Ray = Ray, 
    exports.Matrix4 = Matrix4, exports.Matrix3 = Matrix3, exports.Box3 = Box3, exports.Box2 = Box2, 
    exports.Line3 = Line3, exports.Euler = Euler, exports.Vector4 = Vector4, exports.Vector3 = Vector3, 
    exports.Vector2 = Vector2, exports.Quaternion = Quaternion, exports.ColorKeywords = ColorKeywords, 
    exports.Color = Color, exports.MorphBlendMesh = MorphBlendMesh, exports.ImmediateRenderObject = ImmediateRenderObject, 
    exports.VertexNormalsHelper = VertexNormalsHelper, exports.SpotLightHelper = SpotLightHelper, 
    exports.SkeletonHelper = SkeletonHelper, exports.PointLightHelper = PointLightHelper, 
    exports.HemisphereLightHelper = HemisphereLightHelper, exports.GridHelper = GridHelper, 
    exports.FaceNormalsHelper = FaceNormalsHelper, exports.DirectionalLightHelper = DirectionalLightHelper, 
    exports.CameraHelper = CameraHelper, exports.BoundingBoxHelper = BoundingBoxHelper, 
    exports.BoxHelper = BoxHelper, exports.ArrowHelper = ArrowHelper, exports.AxisHelper = AxisHelper, 
    exports.ClosedSplineCurve3 = ClosedSplineCurve3, exports.CatmullRomCurve3 = CatmullRomCurve3, 
    exports.SplineCurve3 = SplineCurve3, exports.CubicBezierCurve3 = CubicBezierCurve3, 
    exports.QuadraticBezierCurve3 = QuadraticBezierCurve3, exports.LineCurve3 = LineCurve3, 
    exports.ArcCurve = ArcCurve, exports.EllipseCurve = EllipseCurve, exports.SplineCurve = SplineCurve, 
    exports.CubicBezierCurve = CubicBezierCurve, exports.QuadraticBezierCurve = QuadraticBezierCurve, 
    exports.LineCurve = LineCurve, exports.Shape = Shape, exports.ShapePath = ShapePath, 
    exports.Path = Path, exports.Font = Font, exports.CurvePath = CurvePath, exports.Curve = Curve, 
    exports.ShapeUtils = ShapeUtils, exports.SceneUtils = SceneUtils, exports.CurveUtils = CurveUtils, 
    exports.WireframeGeometry = WireframeGeometry, exports.ParametricGeometry = ParametricGeometry, 
    exports.ParametricBufferGeometry = ParametricBufferGeometry, exports.TetrahedronGeometry = TetrahedronGeometry, 
    exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry, exports.OctahedronGeometry = OctahedronGeometry, 
    exports.OctahedronBufferGeometry = OctahedronBufferGeometry, exports.IcosahedronGeometry = IcosahedronGeometry, 
    exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry, exports.DodecahedronGeometry = DodecahedronGeometry, 
    exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry, exports.PolyhedronGeometry = PolyhedronGeometry, 
    exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry, exports.TubeGeometry = TubeGeometry, 
    exports.TubeBufferGeometry = TubeBufferGeometry, exports.TorusKnotGeometry = TorusKnotGeometry, 
    exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry, exports.TorusGeometry = TorusGeometry, 
    exports.TorusBufferGeometry = TorusBufferGeometry, exports.TextGeometry = TextGeometry, 
    exports.SphereBufferGeometry = SphereBufferGeometry, exports.SphereGeometry = SphereGeometry, 
    exports.RingGeometry = RingGeometry, exports.RingBufferGeometry = RingBufferGeometry, 
    exports.PlaneBufferGeometry = PlaneBufferGeometry, exports.PlaneGeometry = PlaneGeometry, 
    exports.LatheGeometry = LatheGeometry, exports.LatheBufferGeometry = LatheBufferGeometry, 
    exports.ShapeGeometry = ShapeGeometry, exports.ExtrudeGeometry = ExtrudeGeometry, 
    exports.EdgesGeometry = EdgesGeometry, exports.ConeGeometry = ConeGeometry, exports.ConeBufferGeometry = ConeBufferGeometry, 
    exports.CylinderGeometry = CylinderGeometry, exports.CylinderBufferGeometry = CylinderBufferGeometry, 
    exports.CircleBufferGeometry = CircleBufferGeometry, exports.CircleGeometry = CircleGeometry, 
    exports.BoxBufferGeometry = BoxBufferGeometry, exports.BoxGeometry = BoxGeometry, 
    exports.ShadowMaterial = ShadowMaterial, exports.SpriteMaterial = SpriteMaterial, 
    exports.RawShaderMaterial = RawShaderMaterial, exports.ShaderMaterial = ShaderMaterial, 
    exports.PointsMaterial = PointsMaterial, exports.MultiMaterial = MultiMaterial, 
    exports.MeshPhysicalMaterial = MeshPhysicalMaterial, exports.MeshStandardMaterial = MeshStandardMaterial, 
    exports.MeshPhongMaterial = MeshPhongMaterial, exports.MeshNormalMaterial = MeshNormalMaterial, 
    exports.MeshLambertMaterial = MeshLambertMaterial, exports.MeshDepthMaterial = MeshDepthMaterial, 
    exports.MeshBasicMaterial = MeshBasicMaterial, exports.LineDashedMaterial = LineDashedMaterial, 
    exports.LineBasicMaterial = LineBasicMaterial, exports.Material = Material, exports.REVISION = REVISION, 
    exports.MOUSE = MOUSE, exports.CullFaceNone = CullFaceNone, exports.CullFaceBack = CullFaceBack, 
    exports.CullFaceFront = CullFaceFront, exports.CullFaceFrontBack = CullFaceFrontBack, 
    exports.FrontFaceDirectionCW = FrontFaceDirectionCW, exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW, 
    exports.BasicShadowMap = BasicShadowMap, exports.PCFShadowMap = PCFShadowMap, exports.PCFSoftShadowMap = PCFSoftShadowMap, 
    exports.FrontSide = FrontSide, exports.BackSide = BackSide, exports.DoubleSide = DoubleSide, 
    exports.FlatShading = FlatShading, exports.SmoothShading = SmoothShading, exports.NoColors = NoColors, 
    exports.FaceColors = FaceColors, exports.VertexColors = VertexColors, exports.NoBlending = NoBlending, 
    exports.NormalBlending = NormalBlending, exports.AdditiveBlending = AdditiveBlending, 
    exports.SubtractiveBlending = SubtractiveBlending, exports.MultiplyBlending = MultiplyBlending, 
    exports.CustomBlending = CustomBlending, exports.BlendingMode = BlendingMode, exports.AddEquation = AddEquation, 
    exports.SubtractEquation = SubtractEquation, exports.ReverseSubtractEquation = ReverseSubtractEquation, 
    exports.MinEquation = MinEquation, exports.MaxEquation = MaxEquation, exports.ZeroFactor = ZeroFactor, 
    exports.OneFactor = OneFactor, exports.SrcColorFactor = SrcColorFactor, exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor, 
    exports.SrcAlphaFactor = SrcAlphaFactor, exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor, 
    exports.DstAlphaFactor = DstAlphaFactor, exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor, 
    exports.DstColorFactor = DstColorFactor, exports.OneMinusDstColorFactor = OneMinusDstColorFactor, 
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor, exports.NeverDepth = NeverDepth, 
    exports.AlwaysDepth = AlwaysDepth, exports.LessDepth = LessDepth, exports.LessEqualDepth = LessEqualDepth, 
    exports.EqualDepth = EqualDepth, exports.GreaterEqualDepth = GreaterEqualDepth, 
    exports.GreaterDepth = GreaterDepth, exports.NotEqualDepth = NotEqualDepth, exports.MultiplyOperation = MultiplyOperation, 
    exports.MixOperation = MixOperation, exports.AddOperation = AddOperation, exports.NoToneMapping = NoToneMapping, 
    exports.LinearToneMapping = LinearToneMapping, exports.ReinhardToneMapping = ReinhardToneMapping, 
    exports.Uncharted2ToneMapping = Uncharted2ToneMapping, exports.CineonToneMapping = CineonToneMapping, 
    exports.UVMapping = UVMapping, exports.CubeReflectionMapping = CubeReflectionMapping, 
    exports.CubeRefractionMapping = CubeRefractionMapping, exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping, 
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping, exports.SphericalReflectionMapping = SphericalReflectionMapping, 
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping, exports.CubeUVRefractionMapping = CubeUVRefractionMapping, 
    exports.TextureMapping = TextureMapping, exports.RepeatWrapping = RepeatWrapping, 
    exports.ClampToEdgeWrapping = ClampToEdgeWrapping, exports.MirroredRepeatWrapping = MirroredRepeatWrapping, 
    exports.TextureWrapping = TextureWrapping, exports.NearestFilter = NearestFilter, 
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter, exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter, 
    exports.LinearFilter = LinearFilter, exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter, 
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter, exports.TextureFilter = TextureFilter, 
    exports.UnsignedByteType = UnsignedByteType, exports.ByteType = ByteType, exports.ShortType = ShortType, 
    exports.UnsignedShortType = UnsignedShortType, exports.IntType = IntType, exports.UnsignedIntType = UnsignedIntType, 
    exports.FloatType = FloatType, exports.HalfFloatType = HalfFloatType, exports.UnsignedShort4444Type = UnsignedShort4444Type, 
    exports.UnsignedShort5551Type = UnsignedShort5551Type, exports.UnsignedShort565Type = UnsignedShort565Type, 
    exports.UnsignedInt248Type = UnsignedInt248Type, exports.AlphaFormat = AlphaFormat, 
    exports.RGBFormat = RGBFormat, exports.RGBAFormat = RGBAFormat, exports.LuminanceFormat = LuminanceFormat, 
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat, exports.RGBEFormat = RGBEFormat, 
    exports.DepthFormat = DepthFormat, exports.DepthStencilFormat = DepthStencilFormat, 
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format, exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format, 
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format, exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format, 
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format, exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format, 
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format, exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format, 
    exports.RGB_ETC1_Format = RGB_ETC1_Format, exports.LoopOnce = LoopOnce, exports.LoopRepeat = LoopRepeat, 
    exports.LoopPingPong = LoopPingPong, exports.InterpolateDiscrete = InterpolateDiscrete, 
    exports.InterpolateLinear = InterpolateLinear, exports.InterpolateSmooth = InterpolateSmooth, 
    exports.ZeroCurvatureEnding = ZeroCurvatureEnding, exports.ZeroSlopeEnding = ZeroSlopeEnding, 
    exports.WrapAroundEnding = WrapAroundEnding, exports.TrianglesDrawMode = TrianglesDrawMode, 
    exports.TriangleStripDrawMode = TriangleStripDrawMode, exports.TriangleFanDrawMode = TriangleFanDrawMode, 
    exports.LinearEncoding = LinearEncoding, exports.sRGBEncoding = sRGBEncoding, exports.GammaEncoding = GammaEncoding, 
    exports.RGBEEncoding = RGBEEncoding, exports.LogLuvEncoding = LogLuvEncoding, exports.RGBM7Encoding = RGBM7Encoding, 
    exports.RGBM16Encoding = RGBM16Encoding, exports.RGBDEncoding = RGBDEncoding, exports.BasicDepthPacking = BasicDepthPacking, 
    exports.RGBADepthPacking = RGBADepthPacking, exports.CubeGeometry = BoxGeometry, 
    exports.Face4 = Face4, exports.LineStrip = LineStrip, exports.LinePieces = LinePieces, 
    exports.MeshFaceMaterial = MultiMaterial, exports.PointCloud = PointCloud, exports.Particle = Sprite, 
    exports.ParticleSystem = ParticleSystem, exports.PointCloudMaterial = PointCloudMaterial, 
    exports.ParticleBasicMaterial = ParticleBasicMaterial, exports.ParticleSystemMaterial = ParticleSystemMaterial, 
    exports.Vertex = Vertex, exports.EdgesHelper = EdgesHelper, exports.WireframeHelper = WireframeHelper, 
    exports.GeometryUtils = GeometryUtils, exports.ImageUtils = ImageUtils, exports.Projector = Projector, 
    exports.CanvasRenderer = CanvasRenderer, Object.defineProperty(exports, "__esModule", {
        value: !0
    }), Object.defineProperty(exports, "AudioContext", {
        get: function() {
            return exports.getAudioContext();
        }
    });
}), THREE.StereoEffect = function(renderer) {
    var _stereo = new THREE.StereoCamera();
    _stereo.aspect = .5, this.setEyeSeparation = function(eyeSep) {
        _stereo.eyeSep = eyeSep;
    }, this.setSize = function(width, height) {
        renderer.setSize(width, height);
    }, this.render = function(scene, camera) {
        scene.updateMatrixWorld(), null === camera.parent && camera.updateMatrixWorld(), 
        _stereo.update(camera);
        var size = renderer.getSize();
        renderer.autoClear && renderer.clear(), renderer.setScissorTest(!0), renderer.setScissor(0, 0, size.width / 2, size.height), 
        renderer.setViewport(0, 0, size.width / 2, size.height), renderer.render(scene, _stereo.cameraL), 
        renderer.setScissor(size.width / 2, 0, size.width / 2, size.height), renderer.setViewport(size.width / 2, 0, size.width / 2, size.height), 
        renderer.render(scene, _stereo.cameraR), renderer.setScissorTest(!1);
    };
}, THREE.AnaglyphEffect = function(renderer, width, height) {
    this.colorMatrixLeft = new THREE.Matrix3().fromArray([ 1.0671679973602295, -.0016435992438346148, .0001777536963345483, -.028107794001698494, -.00019593400065787137, -.0002875397040043026, -.04279090091586113, 15809757314855233e-21, -.00024287120322696865 ]), 
    this.colorMatrixRight = new THREE.Matrix3().fromArray([ -.0355340838432312, -.06440307199954987, .018319187685847282, -.10269022732973099, .8079727292060852, -.04835830628871918, .0001224992738571018, -.009558862075209618, .567823588848114 ]);
    var _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), _scene = new THREE.Scene(), _stereo = new THREE.StereoCamera(), _params = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.NearestFilter,
        format: THREE.RGBAFormat
    };
    void 0 === width && (width = 512), void 0 === height && (height = 512);
    var _renderTargetL = new THREE.WebGLRenderTarget(width, height, _params), _renderTargetR = new THREE.WebGLRenderTarget(width, height, _params), _material = new THREE.ShaderMaterial({
        uniforms: {
            mapLeft: {
                value: _renderTargetL.texture
            },
            mapRight: {
                value: _renderTargetR.texture
            },
            colorMatrixLeft: {
                value: this.colorMatrixLeft
            },
            colorMatrixRight: {
                value: this.colorMatrixRight
            }
        },
        vertexShader: [ "varying vec2 vUv;", "void main() {", "	vUv = vec2( uv.x, uv.y );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"),
        fragmentShader: [ "uniform sampler2D mapLeft;", "uniform sampler2D mapRight;", "varying vec2 vUv;", "uniform mat3 colorMatrixLeft;", "uniform mat3 colorMatrixRight;", "float lin( float c ) {", "	return c <= 0.04045 ? c * 0.0773993808 :", "			pow( c * 0.9478672986 + 0.0521327014, 2.4 );", "}", "vec4 lin( vec4 c ) {", "	return vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );", "}", "float dev( float c ) {", "	return c <= 0.0031308 ? c * 12.92", "			: pow( c, 0.41666 ) * 1.055 - 0.055;", "}", "void main() {", "	vec2 uv = vUv;", "	vec4 colorL = lin( texture2D( mapLeft, uv ) );", "	vec4 colorR = lin( texture2D( mapRight, uv ) );", "	vec3 color = clamp(", "			colorMatrixLeft * colorL.rgb +", "			colorMatrixRight * colorR.rgb, 0., 1. );", "	gl_FragColor = vec4(", "			dev( color.r ), dev( color.g ), dev( color.b ),", "			max( colorL.a, colorR.a ) );", "}" ].join("\n")
    }), mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _material);
    _scene.add(mesh), this.setSize = function(width, height) {
        renderer.setSize(width, height);
        var pixelRatio = renderer.getPixelRatio();
        _renderTargetL.setSize(width * pixelRatio, height * pixelRatio), _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);
    }, this.render = function(scene, camera) {
        scene.updateMatrixWorld(), null === camera.parent && camera.updateMatrixWorld(), 
        _stereo.update(camera), renderer.render(scene, _stereo.cameraL, _renderTargetL, !0), 
        renderer.render(scene, _stereo.cameraR, _renderTargetR, !0), renderer.render(_scene, _camera);
    }, this.dispose = function() {
        _renderTargetL && _renderTargetL.dispose(), _renderTargetR && _renderTargetR.dispose();
    };
}, THREE.OrbitControls = function(object, domElement) {
    function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
    }
    function getZoomScale() {
        return Math.pow(.95, scope.zoomSpeed);
    }
    function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
        sphericalDelta.phi -= angle;
    }
    function dollyIn(dollyScale) {
        scope.object instanceof THREE.PerspectiveCamera ? scale /= dollyScale : scope.object instanceof THREE.OrthographicCamera ? (scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale)), 
        scope.object.updateProjectionMatrix(), zoomChanged = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), 
        scope.enableZoom = !1);
    }
    function dollyOut(dollyScale) {
        scope.object instanceof THREE.PerspectiveCamera ? scale *= dollyScale : scope.object instanceof THREE.OrthographicCamera ? (scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale)), 
        scope.object.updateProjectionMatrix(), zoomChanged = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), 
        scope.enableZoom = !1);
    }
    function handleMouseDownRotate(event) {
        rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
        dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
        panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
        rotateEnd.set(event.clientX, event.clientY), rotateDelta.subVectors(rotateEnd, rotateStart);
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed), 
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed), 
        rotateStart.copy(rotateEnd), scope.update();
    }
    function handleMouseMoveDolly(event) {
        dollyEnd.set(event.clientX, event.clientY), dollyDelta.subVectors(dollyEnd, dollyStart), 
        dollyDelta.y > 0 ? dollyIn(getZoomScale()) : dollyDelta.y < 0 && dollyOut(getZoomScale()), 
        dollyStart.copy(dollyEnd), scope.update();
    }
    function handleMouseMovePan(event) {
        panEnd.set(event.clientX, event.clientY), panDelta.subVectors(panEnd, panStart), 
        pan(panDelta.x, panDelta.y), panStart.copy(panEnd), scope.update();
    }
    function handleMouseUp(event) {}
    function handleMouseWheel(event) {
        event.deltaY < 0 ? dollyOut(getZoomScale()) : event.deltaY > 0 && dollyIn(getZoomScale()), 
        scope.update();
    }
    function handleKeyDown(event) {
        switch (event.keyCode) {
          case scope.keys.UP:
            pan(0, scope.keyPanSpeed), scope.update();
            break;

          case scope.keys.BOTTOM:
            pan(0, -scope.keyPanSpeed), scope.update();
            break;

          case scope.keys.LEFT:
            pan(scope.keyPanSpeed, 0), scope.update();
            break;

          case scope.keys.RIGHT:
            pan(-scope.keyPanSpeed, 0), scope.update();
        }
    }
    function handleTouchStartRotate(event) {
        rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }
    function handleTouchStartDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX, dy = event.touches[0].pageY - event.touches[1].pageY, distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
    }
    function handleTouchStartPan(event) {
        panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    }
    function handleTouchMoveRotate(event) {
        rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY), rotateDelta.subVectors(rotateEnd, rotateStart);
        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed), 
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed), 
        rotateStart.copy(rotateEnd), scope.update();
    }
    function handleTouchMoveDolly(event) {
        var dx = event.touches[0].pageX - event.touches[1].pageX, dy = event.touches[0].pageY - event.touches[1].pageY, distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance), dollyDelta.subVectors(dollyEnd, dollyStart), dollyDelta.y > 0 ? dollyOut(getZoomScale()) : dollyDelta.y < 0 && dollyIn(getZoomScale()), 
        dollyStart.copy(dollyEnd), scope.update();
    }
    function handleTouchMovePan(event) {
        panEnd.set(event.touches[0].pageX, event.touches[0].pageY), panDelta.subVectors(panEnd, panStart), 
        pan(panDelta.x, panDelta.y), panStart.copy(panEnd), scope.update();
    }
    function handleTouchEnd(event) {}
    function onMouseDown(event) {
        if (scope.enabled !== !1) {
            if (event.preventDefault(), event.button === scope.mouseButtons.ORBIT) {
                if (scope.enableRotate === !1) return;
                handleMouseDownRotate(event), state = STATE.ROTATE;
            } else if (event.button === scope.mouseButtons.ZOOM) {
                if (scope.enableZoom === !1) return;
                handleMouseDownDolly(event), state = STATE.DOLLY;
            } else if (event.button === scope.mouseButtons.PAN) {
                if (scope.enablePan === !1) return;
                handleMouseDownPan(event), state = STATE.PAN;
            }
            state !== STATE.NONE && (document.addEventListener("mousemove", onMouseMove, !1), 
            document.addEventListener("mouseup", onMouseUp, !1), scope.dispatchEvent(startEvent));
        }
    }
    function onMouseMove(event) {
        if (scope.enabled !== !1) if (event.preventDefault(), state === STATE.ROTATE) {
            if (scope.enableRotate === !1) return;
            handleMouseMoveRotate(event);
        } else if (state === STATE.DOLLY) {
            if (scope.enableZoom === !1) return;
            handleMouseMoveDolly(event);
        } else if (state === STATE.PAN) {
            if (scope.enablePan === !1) return;
            handleMouseMovePan(event);
        }
    }
    function onMouseUp(event) {
        scope.enabled !== !1 && (handleMouseUp(event), document.removeEventListener("mousemove", onMouseMove, !1), 
        document.removeEventListener("mouseup", onMouseUp, !1), scope.dispatchEvent(endEvent), 
        state = STATE.NONE);
    }
    function onMouseWheel(event) {
        scope.enabled === !1 || scope.enableZoom === !1 || state !== STATE.NONE && state !== STATE.ROTATE || (event.preventDefault(), 
        event.stopPropagation(), handleMouseWheel(event), scope.dispatchEvent(startEvent), 
        scope.dispatchEvent(endEvent));
    }
    function onKeyDown(event) {
        scope.enabled !== !1 && scope.enableKeys !== !1 && scope.enablePan !== !1 && handleKeyDown(event);
    }
    function onTouchStart(event) {
        if (scope.enabled !== !1) {
            switch (event.touches.length) {
              case 1:
                if (scope.enableRotate === !1) return;
                handleTouchStartRotate(event), state = STATE.TOUCH_ROTATE;
                break;

              case 2:
                if (scope.enableZoom === !1) return;
                handleTouchStartDolly(event), state = STATE.TOUCH_DOLLY;
                break;

              case 3:
                if (scope.enablePan === !1) return;
                handleTouchStartPan(event), state = STATE.TOUCH_PAN;
                break;

              default:
                state = STATE.NONE;
            }
            state !== STATE.NONE && scope.dispatchEvent(startEvent);
        }
    }
    function onTouchMove(event) {
        if (scope.enabled !== !1) switch (event.preventDefault(), event.stopPropagation(), 
        event.touches.length) {
          case 1:
            if (scope.enableRotate === !1) return;
            if (state !== STATE.TOUCH_ROTATE) return;
            handleTouchMoveRotate(event);
            break;

          case 2:
            if (scope.enableZoom === !1) return;
            if (state !== STATE.TOUCH_DOLLY) return;
            handleTouchMoveDolly(event);
            break;

          case 3:
            if (scope.enablePan === !1) return;
            if (state !== STATE.TOUCH_PAN) return;
            handleTouchMovePan(event);
            break;

          default:
            state = STATE.NONE;
        }
    }
    function onTouchEnd(event) {
        scope.enabled !== !1 && (handleTouchEnd(event), scope.dispatchEvent(endEvent), state = STATE.NONE);
    }
    function onContextMenu(event) {
        event.preventDefault();
    }
    this.object = object, this.domElement = void 0 !== domElement ? domElement : document, 
    this.enabled = !0, this.target = new THREE.Vector3(), this.minDistance = 0, this.maxDistance = 1 / 0, 
    this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, 
    this.minAzimuthAngle = -(1 / 0), this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, 
    this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, 
    this.rotateSpeed = 1, this.enablePan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, 
    this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        BOTTOM: 40
    }, this.mouseButtons = {
        ORBIT: THREE.MOUSE.LEFT,
        ZOOM: THREE.MOUSE.MIDDLE,
        PAN: THREE.MOUSE.RIGHT
    }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), 
    this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
        return spherical.phi;
    }, this.getAzimuthalAngle = function() {
        return spherical.theta;
    }, this.reset = function() {
        scope.target.copy(scope.target0), scope.object.position.copy(scope.position0), scope.object.zoom = scope.zoom0, 
        scope.object.updateProjectionMatrix(), scope.dispatchEvent(changeEvent), scope.update(), 
        state = STATE.NONE;
    }, this.update = function() {
        var offset = new THREE.Vector3(), quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0)), quatInverse = quat.clone().inverse(), lastPosition = new THREE.Vector3(), lastQuaternion = new THREE.Quaternion();
        return function() {
            var position = scope.object.position;
            return offset.copy(position).sub(scope.target), offset.applyQuaternion(quat), spherical.setFromVector3(offset), 
            scope.autoRotate && state === STATE.NONE && rotateLeft(getAutoRotationAngle()), 
            spherical.theta += sphericalDelta.theta, spherical.phi += sphericalDelta.phi, spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta)), 
            spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi)), 
            spherical.makeSafe(), spherical.radius *= scale, spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)), 
            scope.target.add(panOffset), offset.setFromSpherical(spherical), offset.applyQuaternion(quatInverse), 
            position.copy(scope.target).add(offset), scope.object.lookAt(scope.target), scope.enableDamping === !0 ? (sphericalDelta.theta *= 1 - scope.dampingFactor, 
            sphericalDelta.phi *= 1 - scope.dampingFactor) : sphericalDelta.set(0, 0, 0), scale = 1, 
            panOffset.set(0, 0, 0), zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS ? (scope.dispatchEvent(changeEvent), 
            lastPosition.copy(scope.object.position), lastQuaternion.copy(scope.object.quaternion), 
            zoomChanged = !1, !0) : !1;
        };
    }(), this.dispose = function() {
        scope.domElement.removeEventListener("contextmenu", onContextMenu, !1), scope.domElement.removeEventListener("mousedown", onMouseDown, !1), 
        scope.domElement.removeEventListener("wheel", onMouseWheel, !1), scope.domElement.removeEventListener("touchstart", onTouchStart, !1), 
        scope.domElement.removeEventListener("touchend", onTouchEnd, !1), scope.domElement.removeEventListener("touchmove", onTouchMove, !1), 
        document.removeEventListener("mousemove", onMouseMove, !1), document.removeEventListener("mouseup", onMouseUp, !1), 
        window.removeEventListener("keydown", onKeyDown, !1);
    };
    var scope = this, changeEvent = {
        type: "change"
    }, startEvent = {
        type: "start"
    }, endEvent = {
        type: "end"
    }, STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY: 4,
        TOUCH_PAN: 5
    }, state = STATE.NONE, EPS = 1e-6, spherical = new THREE.Spherical(), sphericalDelta = new THREE.Spherical(), scale = 1, panOffset = new THREE.Vector3(), zoomChanged = !1, rotateStart = new THREE.Vector2(), rotateEnd = new THREE.Vector2(), rotateDelta = new THREE.Vector2(), panStart = new THREE.Vector2(), panEnd = new THREE.Vector2(), panDelta = new THREE.Vector2(), dollyStart = new THREE.Vector2(), dollyEnd = new THREE.Vector2(), dollyDelta = new THREE.Vector2(), panLeft = function() {
        var v = new THREE.Vector3();
        return function(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 0), v.multiplyScalar(-distance), panOffset.add(v);
        };
    }(), panUp = function() {
        var v = new THREE.Vector3();
        return function(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 1), v.multiplyScalar(distance), panOffset.add(v);
        };
    }(), pan = function() {
        var offset = new THREE.Vector3();
        return function(deltaX, deltaY) {
            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
            if (scope.object instanceof THREE.PerspectiveCamera) {
                var position = scope.object.position;
                offset.copy(position).sub(scope.target);
                var targetDistance = offset.length();
                targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180), panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix), 
                panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
            } else scope.object instanceof THREE.OrthographicCamera ? (panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix), 
            panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), 
            scope.enablePan = !1);
        };
    }();
    scope.domElement.addEventListener("contextmenu", onContextMenu, !1), scope.domElement.addEventListener("mousedown", onMouseDown, !1), 
    scope.domElement.addEventListener("wheel", onMouseWheel, !1), scope.domElement.addEventListener("touchstart", onTouchStart, !1), 
    scope.domElement.addEventListener("touchend", onTouchEnd, !1), scope.domElement.addEventListener("touchmove", onTouchMove, !1), 
    window.addEventListener("keydown", onKeyDown, !1), this.update();
}, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), 
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls, Object.defineProperties(THREE.OrbitControls.prototype, {
    center: {
        get: function() {
            return console.warn("THREE.OrbitControls: .center has been renamed to .target"), 
            this.target;
        }
    },
    noZoom: {
        get: function() {
            return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), 
            !this.enableZoom;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), 
            this.enableZoom = !value;
        }
    },
    noRotate: {
        get: function() {
            return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), 
            !this.enableRotate;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), 
            this.enableRotate = !value;
        }
    },
    noPan: {
        get: function() {
            return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), 
            !this.enablePan;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), 
            this.enablePan = !value;
        }
    },
    noKeys: {
        get: function() {
            return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), 
            !this.enableKeys;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), 
            this.enableKeys = !value;
        }
    },
    staticMoving: {
        get: function() {
            return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), 
            !this.enableDamping;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), 
            this.enableDamping = !value;
        }
    },
    dynamicDampingFactor: {
        get: function() {
            return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), 
            this.dampingFactor;
        },
        set: function(value) {
            console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), 
            this.dampingFactor = value;
        }
    }
}), THREE.FirstPersonControls = function(object, domElement) {
    function contextmenu(event) {
        event.preventDefault();
    }
    function bind(scope, fn) {
        return function() {
            fn.apply(scope, arguments);
        };
    }
    this.object = object, this.target = new THREE.Vector3(0, 0, 0), this.domElement = void 0 !== domElement ? domElement : document, 
    this.enabled = !0, this.movementSpeed = 1, this.lookSpeed = .005, this.lookVertical = !0, 
    this.autoForward = !1, this.activeLook = !0, this.heightSpeed = !1, this.heightCoef = 1, 
    this.heightMin = 0, this.heightMax = 1, this.constrainVertical = !1, this.verticalMin = 0, 
    this.verticalMax = Math.PI, this.autoSpeedFactor = 0, this.mouseX = 0, this.mouseY = 0, 
    this.lat = 0, this.lon = 0, this.phi = 0, this.theta = 0, this.moveForward = !1, 
    this.moveBackward = !1, this.moveLeft = !1, this.moveRight = !1, this.mouseDragOn = !1, 
    this.viewHalfX = 0, this.viewHalfY = 0, this.domElement !== document && this.domElement.setAttribute("tabindex", -1), 
    this.handleResize = function() {
        this.domElement === document ? (this.viewHalfX = window.innerWidth / 2, this.viewHalfY = window.innerHeight / 2) : (this.viewHalfX = this.domElement.offsetWidth / 2, 
        this.viewHalfY = this.domElement.offsetHeight / 2);
    }, this.onMouseDown = function(event) {
        if (this.domElement !== document && this.domElement.focus(), event.preventDefault(), 
        event.stopPropagation(), this.activeLook) switch (event.button) {
          case 0:
            this.moveForward = !0;
            break;

          case 2:
            this.moveBackward = !0;
        }
        this.mouseDragOn = !0;
    }, this.onMouseUp = function(event) {
        if (event.preventDefault(), event.stopPropagation(), this.activeLook) switch (event.button) {
          case 0:
            this.moveForward = !1;
            break;

          case 2:
            this.moveBackward = !1;
        }
        this.mouseDragOn = !1;
    }, this.onMouseMove = function(event) {
        this.domElement === document ? (this.mouseX = event.pageX - this.viewHalfX, this.mouseY = event.pageY - this.viewHalfY) : (this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX, 
        this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY);
    }, this.onKeyDown = function(event) {
        switch (event.keyCode) {
          case 38:
          case 87:
            this.moveForward = !0;
            break;

          case 37:
          case 65:
            this.moveLeft = !0;
            break;

          case 40:
          case 83:
            this.moveBackward = !0;
            break;

          case 39:
          case 68:
            this.moveRight = !0;
            break;

          case 82:
            this.moveUp = !0;
            break;

          case 70:
            this.moveDown = !0;
        }
    }, this.onKeyUp = function(event) {
        switch (event.keyCode) {
          case 38:
          case 87:
            this.moveForward = !1;
            break;

          case 37:
          case 65:
            this.moveLeft = !1;
            break;

          case 40:
          case 83:
            this.moveBackward = !1;
            break;

          case 39:
          case 68:
            this.moveRight = !1;
            break;

          case 82:
            this.moveUp = !1;
            break;

          case 70:
            this.moveDown = !1;
        }
    }, this.update = function(delta) {
        if (this.enabled !== !1) {
            if (this.heightSpeed) {
                var y = THREE.Math.clamp(this.object.position.y, this.heightMin, this.heightMax), heightDelta = y - this.heightMin;
                this.autoSpeedFactor = delta * (heightDelta * this.heightCoef);
            } else this.autoSpeedFactor = 0;
            var actualMoveSpeed = delta * this.movementSpeed;
            (this.moveForward || this.autoForward && !this.moveBackward) && this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor)), 
            this.moveBackward && this.object.translateZ(actualMoveSpeed), this.moveLeft && this.object.translateX(-actualMoveSpeed), 
            this.moveRight && this.object.translateX(actualMoveSpeed), this.moveUp && this.object.translateY(actualMoveSpeed), 
            this.moveDown && this.object.translateY(-actualMoveSpeed);
            var actualLookSpeed = delta * this.lookSpeed;
            this.activeLook || (actualLookSpeed = 0);
            var verticalLookRatio = 1;
            this.constrainVertical && (verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin)), 
            this.lon += this.mouseX * actualLookSpeed, this.lookVertical && (this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio), 
            this.lat = Math.max(-85, Math.min(85, this.lat)), this.phi = THREE.Math.degToRad(90 - this.lat), 
            this.theta = THREE.Math.degToRad(this.lon), this.constrainVertical && (this.phi = THREE.Math.mapLinear(this.phi, 0, Math.PI, this.verticalMin, this.verticalMax));
            var targetPosition = this.target, position = this.object.position;
            targetPosition.x = position.x + 100 * Math.sin(this.phi) * Math.cos(this.theta), 
            targetPosition.y = position.y + 100 * Math.cos(this.phi), targetPosition.z = position.z + 100 * Math.sin(this.phi) * Math.sin(this.theta), 
            this.object.lookAt(targetPosition);
        }
    }, this.dispose = function() {
        this.domElement.removeEventListener("contextmenu", contextmenu, !1), this.domElement.removeEventListener("mousedown", _onMouseDown, !1), 
        this.domElement.removeEventListener("mousemove", _onMouseMove, !1), this.domElement.removeEventListener("mouseup", _onMouseUp, !1), 
        window.removeEventListener("keydown", _onKeyDown, !1), window.removeEventListener("keyup", _onKeyUp, !1);
    };
    var _onMouseMove = bind(this, this.onMouseMove), _onMouseDown = bind(this, this.onMouseDown), _onMouseUp = bind(this, this.onMouseUp), _onKeyDown = bind(this, this.onKeyDown), _onKeyUp = bind(this, this.onKeyUp);
    this.domElement.addEventListener("contextmenu", contextmenu, !1), this.domElement.addEventListener("mousemove", _onMouseMove, !1), 
    this.domElement.addEventListener("mousedown", _onMouseDown, !1), this.domElement.addEventListener("mouseup", _onMouseUp, !1), 
    window.addEventListener("keydown", _onKeyDown, !1), window.addEventListener("keyup", _onKeyUp, !1), 
    this.handleResize();
}, THREE.PointerLockControls = function(camera) {
    var scope = this;
    camera.rotation.set(0, 0, 0);
    var pitchObject = new THREE.Object3D();
    pitchObject.add(camera);
    var yawObject = new THREE.Object3D();
    yawObject.position.y = 10, yawObject.add(pitchObject);
    var PI_2 = Math.PI / 2, onMouseMove = function(event) {
        if (scope.enabled !== !1) {
            var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0, movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            yawObject.rotation.y -= .002 * movementX, pitchObject.rotation.x -= .002 * movementY, 
            pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
        }
    };
    this.dispose = function() {
        document.removeEventListener("mousemove", onMouseMove, !1);
    }, document.addEventListener("mousemove", onMouseMove, !1), this.enabled = !1, this.getObject = function() {
        return yawObject;
    }, this.getDirection = function() {
        var direction = new THREE.Vector3(0, 0, -1), rotation = new THREE.Euler(0, 0, 0, "YXZ");
        return function(v) {
            return rotation.set(pitchObject.rotation.x, yawObject.rotation.y, 0), v.copy(direction).applyEuler(rotation), 
            v;
        };
    }();
}, THREE.ShaderLib.mirror = {
    uniforms: {
        mirrorColor: {
            value: new THREE.Color(8355711)
        },
        mirrorSampler: {
            value: null
        },
        textureMatrix: {
            value: new THREE.Matrix4()
        }
    },
    vertexShader: [ "uniform mat4 textureMatrix;", "varying vec4 mirrorCoord;", "void main() {", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "mirrorCoord = textureMatrix * worldPosition;", "gl_Position = projectionMatrix * mvPosition;", "}" ].join("\n"),
    fragmentShader: [ "uniform vec3 mirrorColor;", "uniform sampler2D mirrorSampler;", "varying vec4 mirrorCoord;", "float blendOverlay(float base, float blend) {", "return( base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );", "}", "void main() {", "vec4 color = texture2DProj(mirrorSampler, mirrorCoord);", "color = vec4(blendOverlay(mirrorColor.r, color.r), blendOverlay(mirrorColor.g, color.g), blendOverlay(mirrorColor.b, color.b), 1.0);", "gl_FragColor = color;", "}" ].join("\n")
}, THREE.Mirror = function(renderer, camera, options) {
    THREE.Object3D.call(this), this.name = "mirror_" + this.id, options = options || {}, 
    this.matrixNeedsUpdate = !0;
    var width = void 0 !== options.textureWidth ? options.textureWidth : 512, height = void 0 !== options.textureHeight ? options.textureHeight : 512;
    this.clipBias = void 0 !== options.clipBias ? options.clipBias : 0;
    var mirrorColor = void 0 !== options.color ? new THREE.Color(options.color) : new THREE.Color(8355711);
    this.renderer = renderer, this.mirrorPlane = new THREE.Plane(), this.normal = new THREE.Vector3(0, 0, 1), 
    this.mirrorWorldPosition = new THREE.Vector3(), this.cameraWorldPosition = new THREE.Vector3(), 
    this.rotationMatrix = new THREE.Matrix4(), this.lookAtPosition = new THREE.Vector3(0, 0, -1), 
    this.clipPlane = new THREE.Vector4();
    var debugMode = void 0 !== options.debugMode ? options.debugMode : !1;
    if (debugMode) {
        var arrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 10, 16777088), planeGeometry = new THREE.Geometry();
        planeGeometry.vertices.push(new THREE.Vector3(-10, -10, 0)), planeGeometry.vertices.push(new THREE.Vector3(10, -10, 0)), 
        planeGeometry.vertices.push(new THREE.Vector3(10, 10, 0)), planeGeometry.vertices.push(new THREE.Vector3(-10, 10, 0)), 
        planeGeometry.vertices.push(planeGeometry.vertices[0]);
        var plane = new THREE.Line(planeGeometry, new THREE.LineBasicMaterial({
            color: 16777088
        }));
        this.add(arrow), this.add(plane);
    }
    camera instanceof THREE.PerspectiveCamera ? this.camera = camera : (this.camera = new THREE.PerspectiveCamera(), 
    console.log(this.name + ": camera is not a Perspective Camera!")), this.textureMatrix = new THREE.Matrix4(), 
    this.mirrorCamera = this.camera.clone(), this.mirrorCamera.matrixAutoUpdate = !0;
    var parameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBFormat,
        stencilBuffer: !1
    };
    this.renderTarget = new THREE.WebGLRenderTarget(width, height, parameters), this.renderTarget2 = new THREE.WebGLRenderTarget(width, height, parameters);
    var mirrorShader = THREE.ShaderLib.mirror, mirrorUniforms = THREE.UniformsUtils.clone(mirrorShader.uniforms);
    this.material = new THREE.ShaderMaterial({
        fragmentShader: mirrorShader.fragmentShader,
        vertexShader: mirrorShader.vertexShader,
        uniforms: mirrorUniforms
    }), this.material.uniforms.mirrorSampler.value = this.renderTarget.texture, this.material.uniforms.mirrorColor.value = mirrorColor, 
    this.material.uniforms.textureMatrix.value = this.textureMatrix, THREE.Math.isPowerOfTwo(width) && THREE.Math.isPowerOfTwo(height) || (this.renderTarget.texture.generateMipmaps = !1, 
    this.renderTarget2.texture.generateMipmaps = !1), this.updateTextureMatrix(), this.render();
}, THREE.Mirror.prototype = Object.create(THREE.Object3D.prototype), THREE.Mirror.prototype.constructor = THREE.Mirror, 
THREE.Mirror.prototype.renderWithMirror = function(otherMirror) {
    this.updateTextureMatrix(), this.matrixNeedsUpdate = !1;
    var tempCamera = otherMirror.camera;
    otherMirror.camera = this.mirrorCamera, otherMirror.renderTemp(), otherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget2.texture, 
    this.render(), this.matrixNeedsUpdate = !0, otherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget.texture, 
    otherMirror.camera = tempCamera, otherMirror.updateTextureMatrix();
}, THREE.Mirror.prototype.updateTextureMatrix = function() {
    this.updateMatrixWorld(), this.camera.updateMatrixWorld(), this.mirrorWorldPosition.setFromMatrixPosition(this.matrixWorld), 
    this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld), this.rotationMatrix.extractRotation(this.matrixWorld), 
    this.normal.set(0, 0, 1), this.normal.applyMatrix4(this.rotationMatrix);
    var view = this.mirrorWorldPosition.clone().sub(this.cameraWorldPosition);
    view.reflect(this.normal).negate(), view.add(this.mirrorWorldPosition), this.rotationMatrix.extractRotation(this.camera.matrixWorld), 
    this.lookAtPosition.set(0, 0, -1), this.lookAtPosition.applyMatrix4(this.rotationMatrix), 
    this.lookAtPosition.add(this.cameraWorldPosition);
    var target = this.mirrorWorldPosition.clone().sub(this.lookAtPosition);
    target.reflect(this.normal).negate(), target.add(this.mirrorWorldPosition), this.up.set(0, -1, 0), 
    this.up.applyMatrix4(this.rotationMatrix), this.up.reflect(this.normal).negate(), 
    this.mirrorCamera.position.copy(view), this.mirrorCamera.up = this.up, this.mirrorCamera.lookAt(target), 
    this.mirrorCamera.updateProjectionMatrix(), this.mirrorCamera.updateMatrixWorld(), 
    this.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld), 
    this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), 
    this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse), this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal, this.mirrorWorldPosition), 
    this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse), this.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant);
    var q = new THREE.Vector4(), projectionMatrix = this.mirrorCamera.projectionMatrix;
    q.x = (Math.sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0], 
    q.y = (Math.sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5], 
    q.z = -1, q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    var c = new THREE.Vector4();
    c = this.clipPlane.multiplyScalar(2 / this.clipPlane.dot(q)), projectionMatrix.elements[2] = c.x, 
    projectionMatrix.elements[6] = c.y, projectionMatrix.elements[10] = c.z + 1 - this.clipBias, 
    projectionMatrix.elements[14] = c.w;
}, THREE.Mirror.prototype.render = function() {
    this.matrixNeedsUpdate && this.updateTextureMatrix(), this.matrixNeedsUpdate = !0;
    for (var scene = this; null !== scene.parent; ) scene = scene.parent;
    if (void 0 !== scene && scene instanceof THREE.Scene) {
        var visible = this.material.visible;
        this.material.visible = !1, this.renderer.render(scene, this.mirrorCamera, this.renderTarget, !0), 
        this.material.visible = visible;
    }
}, THREE.Mirror.prototype.renderTemp = function() {
    this.matrixNeedsUpdate && this.updateTextureMatrix(), this.matrixNeedsUpdate = !0;
    for (var scene = this; null !== scene.parent; ) scene = scene.parent;
    void 0 !== scene && scene instanceof THREE.Scene && this.renderer.render(scene, this.mirrorCamera, this.renderTarget2, !0);
};

var THREEx = THREEx || {};

THREEx.WindowResize = function(renderer, camera, dimension) {
    dimension = dimension || function() {
        return {
            width: window.innerWidth,
            height: window.innerHeight
        };
    };
    var callback = function() {
        var rendererSize = dimension();
        renderer.setSize(rendererSize.width, rendererSize.height), camera.aspect = rendererSize.width / rendererSize.height, 
        camera.updateProjectionMatrix();
    };
    return window.addEventListener("resize", callback, !1), {
        trigger: function() {
            callback();
        },
        destroy: function() {
            window.removeEventListener("resize", callback);
        }
    };
};

var THREEx = THREEx || {};

THREEx.RendererStats = function() {
    var container = document.createElement("div");
    container.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var msDiv = document.createElement("div");
    msDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#200;", 
    container.appendChild(msDiv);
    var msText = document.createElement("div");
    msText.style.cssText = "color:#f00;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    msText.innerHTML = "WebGLRenderer", msDiv.appendChild(msText);
    for (var msTexts = [], nLines = 9, i = 0; nLines > i; i++) msTexts[i] = document.createElement("div"), 
    msTexts[i].style.cssText = "color:#f00;background-color:#311;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px", 
    msDiv.appendChild(msTexts[i]), msTexts[i].innerHTML = "-";
    var lastTime = Date.now();
    return {
        domElement: container,
        update: function(webGLRenderer) {
            if (console.assert(webGLRenderer instanceof THREE.WebGLRenderer), !(Date.now() - lastTime < 1e3 / 30)) {
                lastTime = Date.now();
                var i = 0;
                msTexts[i++].textContent = "== Memory =====", msTexts[i++].textContent = "Programs: " + webGLRenderer.info.memory.programs, 
                msTexts[i++].textContent = "Geometries: " + webGLRenderer.info.memory.geometries, 
                msTexts[i++].textContent = "Textures: " + webGLRenderer.info.memory.textures, msTexts[i++].textContent = "== Render =====", 
                msTexts[i++].textContent = "Calls: " + webGLRenderer.info.render.calls, msTexts[i++].textContent = "Vertices: " + webGLRenderer.info.render.vertices, 
                msTexts[i++].textContent = "Faces: " + webGLRenderer.info.render.faces, msTexts[i++].textContent = "Points: " + webGLRenderer.info.render.points;
            }
        }
    };
};

var THREEx = THREEx || {};

THREEx.UniversalLoader = function() {}, THREEx.UniversalLoader.prototype.load = function(urls, onLoad) {
    return "string" == typeof urls && (urls = [ urls ]), urls[0].match(/\.stl$/i) && 1 === urls.length ? (this.loader = new THREE.STLLoader(), 
    this.loader.addEventListener("load", function(event) {
        var geometry = event.content, material = new THREE.MeshPhongMaterial(), object3d = new THREE.Mesh(geometry, material);
        onLoad(object3d);
    }), void this.loader.load(urls[0])) : urls[0].match(/\.dae$/i) && 1 === urls.length ? (this.loader = new THREE.ColladaLoader(), 
    this.loader.options.convertUpAxis = !0, void this.loader.load(urls[0], function(collada) {
        var object3d = collada.scene;
        onLoad(object3d);
    })) : urls[0].match(/\.js$/i) && 1 === urls.length ? (this.loader = new THREE.JSONLoader(), 
    void this.loader.load(urls[0], function(geometry, materials) {
        if (materials.length > 1) var material = new THREE.MeshFaceMaterial(materials); else var material = materials[0];
        var object3d = new THREE.Mesh(geometry, material);
        onLoad(object3d);
    })) : urls[0].match(/\.obj$/i) && 1 === urls.length ? (this.loader = new THREE.OBJLoader(), 
    void this.loader.load(urls[0], function(object3d) {
        onLoad(object3d);
    })) : 2 === urls.length && urls[0].match(/\.mtl$/i) && urls[1].match(/\.obj$/i) ? (this.loader = new THREE.OBJMTLLoader(), 
    void this.loader.load(urls[1], urls[0], function(object3d) {
        onLoad(object3d);
    })) : 2 === urls.length && urls[0].match(/\.obj$/i) && urls[1].match(/\.mtl$/i) ? (this.loader = new THREE.OBJMTLLoader(), 
    void this.loader.load(urls[0], urls[1], function(object3d) {
        onLoad(object3d);
    })) : void console.assert(!1);
};

var THREEx = THREEx || {};

THREEx.KeyboardState = function(domElement) {
    this.domElement = domElement || document, this.keyCodes = {}, this.modifiers = {};
    var _this = this;
    this._onKeyDown = function(event) {
        _this._onKeyChange(event);
    }, this._onKeyUp = function(event) {
        _this._onKeyChange(event);
    }, this.domElement.addEventListener("keydown", this._onKeyDown, !1), this.domElement.addEventListener("keyup", this._onKeyUp, !1), 
    this._onBlur = function() {
        for (var prop in _this.keyCodes) _this.keyCodes[prop] = !1;
        for (var prop in _this.modifiers) _this.modifiers[prop] = !1;
    }, window.addEventListener("blur", this._onBlur, !1);
}, THREEx.KeyboardState.prototype.destroy = function() {
    this.domElement.removeEventListener("keydown", this._onKeyDown, !1), this.domElement.removeEventListener("keyup", this._onKeyUp, !1), 
    window.removeEventListener("blur", this._onBlur, !1);
}, THREEx.KeyboardState.MODIFIERS = [ "shift", "ctrl", "alt", "meta" ], THREEx.KeyboardState.ALIAS = {
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    space: 32,
    pageup: 33,
    pagedown: 34,
    tab: 9,
    escape: 27
}, THREEx.KeyboardState.prototype._onKeyChange = function(event) {
    var keyCode = event.keyCode, pressed = "keydown" === event.type;
    this.keyCodes[keyCode] = pressed, this.modifiers.shift = event.shiftKey, this.modifiers.ctrl = event.ctrlKey, 
    this.modifiers.alt = event.altKey, this.modifiers.meta = event.metaKey;
}, THREEx.KeyboardState.prototype.pressed = function(keyDesc) {
    for (var keys = keyDesc.split("+"), i = 0; i < keys.length; i++) {
        var key = keys[i], pressed = !1;
        if (pressed = -1 !== THREEx.KeyboardState.MODIFIERS.indexOf(key) ? this.modifiers[key] : -1 != Object.keys(THREEx.KeyboardState.ALIAS).indexOf(key) ? this.keyCodes[THREEx.KeyboardState.ALIAS[key]] : this.keyCodes[key.toUpperCase().charCodeAt(0)], 
        !pressed) return !1;
    }
    return !0;
}, THREEx.KeyboardState.prototype.eventMatches = function(event, keyDesc) {
    for (var aliases = THREEx.KeyboardState.ALIAS, aliasKeys = Object.keys(aliases), keys = keyDesc.split("+"), i = 0; i < keys.length; i++) {
        var key = keys[i], pressed = !1;
        if ("shift" === key ? pressed = !!event.shiftKey : "ctrl" === key ? pressed = !!event.ctrlKey : "alt" === key ? pressed = !!event.altKey : "meta" === key ? pressed = !!event.metaKey : -1 !== aliasKeys.indexOf(key) ? pressed = event.keyCode === aliases[key] : event.keyCode === key.toUpperCase().charCodeAt(0) && (pressed = !0), 
        !pressed) return !1;
    }
    return !0;
};

var THREEx = THREEx || {};

THREEx.VolumetricSpotLightMaterial = function() {
    var vertexShader = [ "varying vec3 vNormal;", "varying vec3 vWorldPosition;", "void main(){", "// compute intensity", "vNormal		= normalize( normalMatrix * normal );", "vec4 worldPosition	= modelMatrix * vec4( position, 1.0 );", "vWorldPosition		= worldPosition.xyz;", "// set gl_Position", "gl_Position	= projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n"), fragmentShader = [ "varying vec3		vNormal;", "varying vec3		vWorldPosition;", "uniform vec3		lightColor;", "uniform vec3		spotPosition;", "uniform float		attenuation;", "uniform float		anglePower;", "void main(){", "float intensity;", "intensity	= distance(vWorldPosition, spotPosition)/attenuation;", "intensity	= 1.0 - clamp(intensity, 0.0, 1.0);", "vec3 normal	= vec3(vNormal.x, vNormal.y, abs(vNormal.z));", "float angleIntensity	= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );", "intensity	= intensity * angleIntensity;", "gl_FragColor	= vec4( lightColor, intensity);", "}" ].join("\n"), material = new THREE.ShaderMaterial({
        uniforms: {
            attenuation: {
                type: "f",
                value: 5
            },
            anglePower: {
                type: "f",
                value: 1.2
            },
            spotPosition: {
                type: "v3",
                value: new THREE.Vector3(0, 0, 0)
            },
            lightColor: {
                type: "c",
                value: new THREE.Color("cyan")
            }
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: !0,
        depthWrite: !1
    });
    return material;
}, THREE.ShaderLib.water = {
    uniforms: THREE.UniformsUtils.merge([ THREE.UniformsLib.fog, {
        normalSampler: {
            type: "t",
            value: null
        },
        mirrorSampler: {
            type: "t",
            value: null
        },
        alpha: {
            type: "f",
            value: 1
        },
        time: {
            type: "f",
            value: 0
        },
        distortionScale: {
            type: "f",
            value: 20
        },
        noiseScale: {
            type: "f",
            value: 1
        },
        textureMatrix: {
            type: "m4",
            value: new THREE.Matrix4()
        },
        sunColor: {
            type: "c",
            value: new THREE.Color(8355711)
        },
        sunDirection: {
            type: "v3",
            value: new THREE.Vector3(.70707, .70707, 0)
        },
        eye: {
            type: "v3",
            value: new THREE.Vector3(0, 0, 0)
        },
        waterColor: {
            type: "c",
            value: new THREE.Color(5592405)
        }
    } ]),
    vertexShader: [ "uniform mat4 textureMatrix;", "uniform float time;", "varying vec4 mirrorCoord;", "varying vec3 worldPosition;", "varying vec3 modelPosition;", "varying vec3 surfaceX;", "varying vec3 surfaceY;", "varying vec3 surfaceZ;", "void main()", "{", "  mirrorCoord = modelMatrix * vec4(position, 1.0);", "  worldPosition = mirrorCoord.xyz;", "  modelPosition = position;", "  surfaceX = vec3( modelMatrix[0][0], modelMatrix[0][1], modelMatrix[0][2]);", "  surfaceY = vec3( modelMatrix[1][0], modelMatrix[1][1], modelMatrix[1][2]);", "  surfaceZ = vec3( modelMatrix[2][0], modelMatrix[2][1], modelMatrix[2][2]);", "  mirrorCoord = textureMatrix * mirrorCoord;", "  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}" ].join("\n"),
    fragmentShader: [ "uniform sampler2D mirrorSampler;", "uniform float alpha;", "uniform float time;", "uniform float distortionScale;", "uniform float noiseScale;", "uniform sampler2D normalSampler;", "uniform vec3 sunColor;", "uniform vec3 sunDirection;", "uniform vec3 eye;", "uniform vec3 waterColor;", "varying vec4 mirrorCoord;", "varying vec3 worldPosition;", "varying vec3 modelPosition;", "varying vec3 surfaceX;", "varying vec3 surfaceY;", "varying vec3 surfaceZ;", "void sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, in float shiny, in float spec, in float diffuse, inout vec3 diffuseColor, inout vec3 specularColor)", "{", "  vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));", "  float direction = max(0.0, dot(eyeDirection, reflection));", "  specularColor += pow(direction, shiny) * sunColor * spec;", "  diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;", "}", "vec3 getNoise(in vec2 uv)", "{", "  vec2 uv0 = uv / (103.0 * noiseScale) + vec2(time / 17.0, time / 29.0);", "  vec2 uv1 = uv / (107.0 * noiseScale) - vec2(time / -19.0, time / 31.0);", "  vec2 uv2 = uv / (vec2(8907.0, 9803.0) * noiseScale) + vec2(time / 101.0, time /   97.0);", "  vec2 uv3 = uv / (vec2(1091.0, 1027.0) * noiseScale) - vec2(time / 109.0, time / -113.0);", "  vec4 noise = texture2D(normalSampler, uv0) +", "    texture2D(normalSampler, uv1) +", "    texture2D(normalSampler, uv2) +", "    texture2D(normalSampler, uv3);", "  return noise.xyz * 0.5 - 1.0;", "}", THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, "void main()", "{", "  vec3 worldToEye = eye - worldPosition;", "  vec3 eyeDirection = normalize(worldToEye);", "  vec3 noise = getNoise(modelPosition.xy * 1.0);", "  vec3 distordCoord = noise.x * surfaceX + noise.y * surfaceY;", "  vec3 distordNormal = distordCoord + surfaceZ;", "  if(dot(eyeDirection, surfaceZ) < 0.0)", "    distordNormal = distordNormal * -1.0;", "  vec3 diffuseLight = vec3(0.0);", "  vec3 specularLight = vec3(0.0);", "  sunLight(distordNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);", "  float distance = length(worldToEye);", "  vec2 distortion = distordCoord.xy * distortionScale * sqrt(distance) * 0.07;", " vec3 mirrorDistord = mirrorCoord.xyz + vec3(distortion.x, distortion.y, 1.0);", " vec3 reflectionSample = texture2DProj(mirrorSampler, mirrorDistord).xyz;", "  float theta = max(dot(eyeDirection, distordNormal), 0.0);", "  float reflectance = 0.3 + (1.0 - 0.3) * pow((1.0 - theta), 3.0);", "  vec3 scatter = max(0.0, dot(distordNormal, eyeDirection)) * waterColor;", "  vec3 albedo = mix(sunColor * diffuseLight * 0.3 + scatter, (vec3(0.1) + reflectionSample * 0.9 + reflectionSample * specularLight), reflectance);", " vec3 outgoingLight = albedo;", THREE.ShaderChunk.fog_fragment, " gl_FragColor = vec4( outgoingLight, alpha );", "}" ].join("\n")
}, THREE.Water = function(renderer, camera, scene, options) {
    function optionalParameter(value, defaultValue) {
        return void 0 !== value ? value : defaultValue;
    }
    THREE.Object3D.call(this), this.name = "water_" + this.id, options = options || {}, 
    this.matrixNeedsUpdate = !0;
    var width = optionalParameter(options.textureWidth, 512), height = optionalParameter(options.textureHeight, 512);
    this.clipBias = optionalParameter(options.clipBias, -1e-4), this.alpha = optionalParameter(options.alpha, 1), 
    this.time = optionalParameter(options.time, 0), this.normalSampler = optionalParameter(options.waterNormals, null), 
    this.sunDirection = optionalParameter(options.sunDirection, new THREE.Vector3(.70707, .70707, 0)), 
    this.sunColor = new THREE.Color(optionalParameter(options.sunColor, 16777215)), 
    this.waterColor = new THREE.Color(optionalParameter(options.waterColor, 8355711)), 
    this.eye = optionalParameter(options.eye, new THREE.Vector3(0, 0, 0)), this.distortionScale = optionalParameter(options.distortionScale, 20), 
    this.noiseScale = optionalParameter(options.noiseScale, 1), this.side = optionalParameter(options.side, THREE.FrontSide), 
    this.fog = optionalParameter(options.fog, !1), this.renderer = renderer, this.scene = scene, 
    this.mirrorPlane = new THREE.Plane(), this.normal = new THREE.Vector3(0, 0, 1), 
    this.cameraWorldPosition = new THREE.Vector3(), this.rotationMatrix = new THREE.Matrix4(), 
    this.lookAtPosition = new THREE.Vector3(0, 0, -1), this.clipPlane = new THREE.Vector4(), 
    camera instanceof THREE.PerspectiveCamera ? this.camera = camera : (this.camera = new THREE.PerspectiveCamera(), 
    console.log(this.name + ": camera is not a Perspective Camera!")), this.textureMatrix = new THREE.Matrix4(), 
    this.mirrorCamera = this.camera.clone(), this.texture = new THREE.WebGLRenderTarget(width, height), 
    this.tempTexture = new THREE.WebGLRenderTarget(width, height);
    var mirrorShader = THREE.ShaderLib.water, mirrorUniforms = THREE.UniformsUtils.clone(mirrorShader.uniforms);
    this.material = new THREE.ShaderMaterial({
        fragmentShader: mirrorShader.fragmentShader,
        vertexShader: mirrorShader.vertexShader,
        uniforms: mirrorUniforms,
        transparent: !0,
        side: this.side,
        fog: this.fog
    }), this.mesh = new THREE.Object3D(), this.material.uniforms.mirrorSampler.value = this.texture, 
    this.material.uniforms.textureMatrix.value = this.textureMatrix, this.material.uniforms.alpha.value = this.alpha, 
    this.material.uniforms.time.value = this.time, this.material.uniforms.normalSampler.value = this.normalSampler, 
    this.material.uniforms.sunColor.value = this.sunColor, this.material.uniforms.waterColor.value = this.waterColor, 
    this.material.uniforms.sunDirection.value = this.sunDirection, this.material.uniforms.distortionScale.value = this.distortionScale, 
    this.material.uniforms.noiseScale.value = this.noiseScale, this.material.uniforms.eye.value = this.eye, 
    THREE.Math.isPowerOfTwo(width) && THREE.Math.isPowerOfTwo(height) || (this.texture.generateMipmaps = !1, 
    this.tempTexture.generateMipmaps = !1);
}, THREE.Water.prototype = Object.create(THREE.Object3D.prototype), THREE.Water.prototype.renderWithMirror = function(otherMirror) {
    this.updateTextureMatrix(), this.matrixNeedsUpdate = !1;
    var tempCamera = otherMirror.camera;
    otherMirror.camera = this.mirrorCamera, otherMirror.render(!0), this.render(), this.matrixNeedsUpdate = !0, 
    otherMirror.camera = tempCamera, otherMirror.updateTextureMatrix();
}, THREE.Water.prototype.updateTextureMatrix = function() {
    function sign(x) {
        return x ? 0 > x ? -1 : 1 : 0;
    }
    void 0 !== this.parent && (this.mesh = this.parent), this.updateMatrixWorld(), this.camera.updateMatrixWorld(), 
    this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld), this.rotationMatrix.extractRotation(this.matrixWorld), 
    this.normal = new THREE.Vector3(0, 0, 1).applyEuler(this.mesh.rotation);
    var cameraPosition = this.camera.position.clone().sub(this.mesh.position);
    if (this.normal.dot(cameraPosition) < 0) {
        var meshNormal = new THREE.Vector3(0, 0, 1).applyEuler(this.mesh.rotation);
        this.normal.reflect(meshNormal);
    }
    var view = this.mesh.position.clone().sub(this.cameraWorldPosition);
    view.reflect(this.normal).negate(), view.add(this.mesh.position), this.rotationMatrix.extractRotation(this.camera.matrixWorld), 
    this.lookAtPosition.set(0, 0, -1), this.lookAtPosition.applyMatrix4(this.rotationMatrix), 
    this.lookAtPosition.add(this.cameraWorldPosition);
    var target = this.mesh.position.clone().sub(this.lookAtPosition);
    target.reflect(this.normal).negate(), target.add(this.mesh.position), this.up.set(0, -1, 0), 
    this.up.applyMatrix4(this.rotationMatrix), this.up.reflect(this.normal).negate(), 
    this.mirrorCamera.position.copy(view), this.mirrorCamera.up = this.up, this.mirrorCamera.lookAt(target), 
    this.mirrorCamera.aspect = this.camera.aspect, this.mirrorCamera.updateProjectionMatrix(), 
    this.mirrorCamera.updateMatrixWorld(), this.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld), 
    this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix), 
    this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse), this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal, this.mesh.position), 
    this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse), this.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant);
    var q = new THREE.Vector4(), projectionMatrix = this.mirrorCamera.projectionMatrix;
    q.x = (sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0], 
    q.y = (sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5], 
    q.z = -1, q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    var c = new THREE.Vector4();
    c = this.clipPlane.multiplyScalar(2 / this.clipPlane.dot(q)), projectionMatrix.elements[2] = c.x, 
    projectionMatrix.elements[6] = c.y, projectionMatrix.elements[10] = c.z + 1 - this.clipBias, 
    projectionMatrix.elements[14] = c.w;
    var worldCoordinates = new THREE.Vector3();
    worldCoordinates.setFromMatrixPosition(this.camera.matrixWorld), this.eye = worldCoordinates, 
    this.material.uniforms.eye.value = this.eye;
}, THREE.Water.prototype.render = function(isTempTexture) {
    if (this.matrixNeedsUpdate && this.updateTextureMatrix(), this.matrixNeedsUpdate = !0, 
    void 0 !== this.scene && this.scene instanceof THREE.Scene) {
        this.material.visible = !1;
        var renderTexture = void 0 !== isTempTexture && isTempTexture ? this.tempTexture : this.texture;
        this.renderer.render(this.scene, this.mirrorCamera, renderTexture, !0), this.material.visible = !0, 
        this.material.uniforms.mirrorSampler.value = renderTexture;
    }
};

var SPE = {
    distributions: {
        BOX: 1,
        SPHERE: 2,
        DISC: 3
    },
    valueOverLifetimeLength: 4
};

"function" == typeof define && define.amd ? define("spe", SPE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = SPE), 
SPE.TypedArrayHelper = function(TypedArrayConstructor, size, componentSize, indexOffset) {
    "use strict";
    this.componentSize = componentSize || 1, this.size = size || 1, this.TypedArrayConstructor = TypedArrayConstructor || Float32Array, 
    this.array = new TypedArrayConstructor(size * this.componentSize), this.indexOffset = indexOffset || 0;
}, SPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper, SPE.TypedArrayHelper.prototype.setSize = function(size, noComponentMultiply) {
    "use strict";
    var currentArraySize = this.array.length;
    return noComponentMultiply || (size *= this.componentSize), currentArraySize > size ? this.shrink(size) : size > currentArraySize ? this.grow(size) : void console.info("TypedArray is already of size:", size + ".", "Will not resize.");
}, SPE.TypedArrayHelper.prototype.shrink = function(size) {
    "use strict";
    return this.array = this.array.subarray(0, size), this.size = size, this;
}, SPE.TypedArrayHelper.prototype.grow = function(size) {
    "use strict";
    var existingArray = this.array, newArray = new this.TypedArrayConstructor(size);
    return newArray.set(existingArray), this.array = newArray, this.size = size, this;
}, SPE.TypedArrayHelper.prototype.splice = function(start, end) {
    "use strict";
    start *= this.componentSize, end *= this.componentSize;
    for (var data = [], array = this.array, size = array.length, i = 0; size > i; ++i) (start > i || i >= end) && data.push(array[i]);
    return this.setFromArray(0, data), this;
}, SPE.TypedArrayHelper.prototype.setFromArray = function(index, array) {
    "use strict";
    var sourceArraySize = array.length, newSize = index + sourceArraySize;
    return newSize > this.array.length ? this.grow(newSize) : newSize < this.array.length && this.shrink(newSize), 
    this.array.set(array, this.indexOffset + index), this;
}, SPE.TypedArrayHelper.prototype.setVec2 = function(index, vec2) {
    "use strict";
    return this.setVec2Components(index, vec2.x, vec2.y);
}, SPE.TypedArrayHelper.prototype.setVec2Components = function(index, x, y) {
    "use strict";
    var array = this.array, i = this.indexOffset + index * this.componentSize;
    return array[i] = x, array[i + 1] = y, this;
}, SPE.TypedArrayHelper.prototype.setVec3 = function(index, vec3) {
    "use strict";
    return this.setVec3Components(index, vec3.x, vec3.y, vec3.z);
}, SPE.TypedArrayHelper.prototype.setVec3Components = function(index, x, y, z) {
    "use strict";
    var array = this.array, i = this.indexOffset + index * this.componentSize;
    return array[i] = x, array[i + 1] = y, array[i + 2] = z, this;
}, SPE.TypedArrayHelper.prototype.setVec4 = function(index, vec4) {
    "use strict";
    return this.setVec4Components(index, vec4.x, vec4.y, vec4.z, vec4.w);
}, SPE.TypedArrayHelper.prototype.setVec4Components = function(index, x, y, z, w) {
    "use strict";
    var array = this.array, i = this.indexOffset + index * this.componentSize;
    return array[i] = x, array[i + 1] = y, array[i + 2] = z, array[i + 3] = w, this;
}, SPE.TypedArrayHelper.prototype.setMat3 = function(index, mat3) {
    "use strict";
    return this.setFromArray(this.indexOffset + index * this.componentSize, mat3.elements);
}, SPE.TypedArrayHelper.prototype.setMat4 = function(index, mat4) {
    "use strict";
    return this.setFromArray(this.indexOffset + index * this.componentSize, mat4.elements);
}, SPE.TypedArrayHelper.prototype.setColor = function(index, color) {
    "use strict";
    return this.setVec3Components(index, color.r, color.g, color.b);
}, SPE.TypedArrayHelper.prototype.setNumber = function(index, numericValue) {
    "use strict";
    return this.array[this.indexOffset + index * this.componentSize] = numericValue, 
    this;
}, SPE.TypedArrayHelper.prototype.getValueAtIndex = function(index) {
    "use strict";
    return this.array[this.indexOffset + index];
}, SPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function(index) {
    "use strict";
    return this.array.subarray(this.indexOffset + index * this.componentSize);
}, SPE.ShaderAttribute = function(type, dynamicBuffer, arrayType) {
    "use strict";
    var typeMap = SPE.ShaderAttribute.typeSizeMap;
    this.type = "string" == typeof type && typeMap.hasOwnProperty(type) ? type : "f", 
    this.componentSize = typeMap[this.type], this.arrayType = arrayType || Float32Array, 
    this.typedArray = null, this.bufferAttribute = null, this.dynamicBuffer = !!dynamicBuffer, 
    this.updateMin = 0, this.updateMax = 0;
}, SPE.ShaderAttribute.constructor = SPE.ShaderAttribute, SPE.ShaderAttribute.typeSizeMap = {
    f: 1,
    v2: 2,
    v3: 3,
    v4: 4,
    c: 3,
    m3: 9,
    m4: 16
}, SPE.ShaderAttribute.prototype.setUpdateRange = function(min, max) {
    "use strict";
    this.updateMin = Math.min(min * this.componentSize, this.updateMin * this.componentSize), 
    this.updateMax = Math.max(max * this.componentSize, this.updateMax * this.componentSize);
}, SPE.ShaderAttribute.prototype.flagUpdate = function() {
    "use strict";
    var attr = this.bufferAttribute, range = attr.updateRange;
    range.offset = this.updateMin, range.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length), 
    attr.needsUpdate = !0;
}, SPE.ShaderAttribute.prototype.resetUpdateRange = function() {
    "use strict";
    this.updateMin = 0, this.updateMax = 0;
}, SPE.ShaderAttribute.prototype.resetDynamic = function() {
    "use strict";
    this.bufferAttribute.dynamic = this.dynamicBuffer;
}, SPE.ShaderAttribute.prototype.splice = function(start, end) {
    "use strict";
    this.typedArray.splice(start, end), this.forceUpdateAll();
}, SPE.ShaderAttribute.prototype.forceUpdateAll = function() {
    "use strict";
    this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.updateRange.offset = 0, 
    this.bufferAttribute.updateRange.count = -1, this.bufferAttribute.dynamic = !1, 
    this.bufferAttribute.needsUpdate = !0;
}, SPE.ShaderAttribute.prototype._ensureTypedArray = function(size) {
    "use strict";
    null !== this.typedArray && this.typedArray.size === size * this.componentSize || (null !== this.typedArray && this.typedArray.size !== size ? this.typedArray.setSize(size) : null === this.typedArray && (this.typedArray = new SPE.TypedArrayHelper(this.arrayType, size, this.componentSize)));
}, SPE.ShaderAttribute.prototype._createBufferAttribute = function(size) {
    "use strict";
    return this._ensureTypedArray(size), null !== this.bufferAttribute ? (this.bufferAttribute.array = this.typedArray.array, 
    void (this.bufferAttribute.needsUpdate = !0)) : (this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize), 
    void (this.bufferAttribute.dynamic = this.dynamicBuffer));
}, SPE.ShaderAttribute.prototype.getLength = function() {
    "use strict";
    return null === this.typedArray ? 0 : this.typedArray.array.length;
}, SPE.shaderChunks = {
    defines: [ "#define PACKED_COLOR_SIZE 256.0", "#define PACKED_COLOR_DIVISOR 255.0" ].join("\n"),
    uniforms: [ "uniform float deltaTime;", "uniform float runTime;", "uniform sampler2D texture;", "uniform vec4 textureAnimation;", "uniform float scale;" ].join("\n"),
    attributes: [ "attribute vec4 acceleration;", "attribute vec3 velocity;", "attribute vec4 rotation;", "attribute vec3 rotationCenter;", "attribute vec4 params;", "attribute vec4 size;", "attribute vec4 angle;", "attribute vec4 color;", "attribute vec4 opacity;" ].join("\n"),
    varyings: [ "varying vec4 vColor;", "#ifdef SHOULD_ROTATE_TEXTURE", "    varying float vAngle;", "#endif", "#ifdef SHOULD_CALCULATE_SPRITE", "    varying vec4 vSpriteSheet;", "#endif" ].join("\n"),
    branchAvoidanceFunctions: [ "float when_gt(float x, float y) {", "    return max(sign(x - y), 0.0);", "}", "float when_lt(float x, float y) {", "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );", "}", "float when_eq( float x, float y ) {", "    return 1.0 - abs( sign( x - y ) );", "}", "float when_ge(float x, float y) {", "  return 1.0 - when_lt(x, y);", "}", "float when_le(float x, float y) {", "  return 1.0 - when_gt(x, y);", "}", "float and(float a, float b) {", "    return a * b;", "}", "float or(float a, float b) {", "    return min(a + b, 1.0);", "}" ].join("\n"),
    unpackColor: [ "vec3 unpackColor( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   return c;", "}" ].join("\n"),
    unpackRotationAxis: [ "vec3 unpackRotationAxis( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   c *= vec3( 2.0 );", "   c -= vec3( 1.0 );", "   return c;", "}" ].join("\n"),
    floatOverLifetime: [ "float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {", "    highp float value = 0.0;", "    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );", "    float fIndex = 0.0;", "    float shouldApplyValue = 0.0;", "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );", "", "    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {", "       fIndex = float( i );", "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );", "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );", "    }", "", "    return value;", "}" ].join("\n"),
    colorOverLifetime: [ "vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {", "    vec3 value = vec3( 0.0 );", "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );", "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );", "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );", "    return value;", "}" ].join("\n"),
    paramFetchingFunctions: [ "float getAlive() {", "   return params.x;", "}", "float getAge() {", "   return params.y;", "}", "float getMaxAge() {", "   return params.z;", "}", "float getWiggle() {", "   return params.w;", "}" ].join("\n"),
    forceFetchingFunctions: [ "vec4 getPosition( in float age ) {", "   return modelViewMatrix * vec4( position, 1.0 );", "}", "vec3 getVelocity( in float age ) {", "   return velocity * age;", "}", "vec3 getAcceleration( in float age ) {", "   return acceleration.xyz * age;", "}" ].join("\n"),
    rotationFunctions: [ "#ifdef SHOULD_ROTATE_PARTICLES", "   mat4 getRotationMatrix( in vec3 axis, in float angle) {", "       axis = normalize(axis);", "       float s = sin(angle);", "       float c = cos(angle);", "       float oc = 1.0 - c;", "", "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,", "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,", "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,", "                   0.0,                                0.0,                                0.0,                                1.0);", "   }", "", "   vec3 getRotation( in vec3 pos, in float positionInTime ) {", "      if( rotation.y == 0.0 ) {", "           return pos;", "      }", "", "      vec3 axis = unpackRotationAxis( rotation.x );", "      vec3 center = rotationCenter;", "      vec3 translated;", "      mat4 rotationMatrix;", "      float angle = 0.0;", "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;", "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );", "      translated = rotationCenter - pos;", "      rotationMatrix = getRotationMatrix( axis, angle );", "      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );", "   }", "#endif" ].join("\n"),
    rotateTexture: [ "    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );", "", "    #ifdef SHOULD_ROTATE_TEXTURE", "       float x = gl_PointCoord.x - 0.5;", "       float y = 1.0 - gl_PointCoord.y - 0.5;", "       float c = cos( -vAngle );", "       float s = sin( -vAngle );", "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );", "    #endif", "", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = vSpriteSheet.x;", "        float framesY = vSpriteSheet.y;", "        float columnNorm = vSpriteSheet.z;", "        float rowNorm = vSpriteSheet.w;", "        vUv.x = gl_PointCoord.x * framesX + columnNorm;", "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);", "    #endif", "", "    vec4 rotatedTexture = texture2D( texture, vUv );" ].join("\n")
}, SPE.shaders = {
    vertex: [ SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.unpackRotationAxis, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, "void main() {", "    highp float age = getAge();", "    highp float alive = getAlive();", "    highp float maxAge = getMaxAge();", "    highp float positionInTime = (age / maxAge);", "    highp float isAlive = when_gt( alive, 0.0 );", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        float wiggleAmount = positionInTime * getWiggle();", "        float wiggleSin = isAlive * sin( wiggleAmount );", "        float wiggleCos = isAlive * cos( wiggleAmount );", "    #endif", "    vec3 vel = getVelocity( age );", "    vec3 accel = getAcceleration( age );", "    vec3 force = vec3( 0.0 );", "    vec3 pos = vec3( position );", "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;", "    force += vel;", "    force *= drag;", "    force += accel * age;", "    pos += force;", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        pos.x += wiggleSin;", "        pos.y += wiggleCos;", "        pos.z += wiggleSin;", "    #endif", "    #ifdef SHOULD_ROTATE_PARTICLES", "        pos = getRotation( pos, positionInTime );", "    #endif", "    vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );", "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;", "    #ifdef HAS_PERSPECTIVE", "        float perspective = scale / length( mvPos.xyz );", "    #else", "        float perspective = 1.0;", "    #endif", "    float pointSizePerspective = pointSize * perspective;", "    #ifdef COLORIZE", "       vec3 c = isAlive * getColorOverLifetime(", "           positionInTime,", "           unpackColor( color.x ),", "           unpackColor( color.y ),", "           unpackColor( color.z ),", "           unpackColor( color.w )", "       );", "    #else", "       vec3 c = vec3(1.0);", "    #endif", "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );", "    vColor = vec4( c, o );", "    #ifdef SHOULD_ROTATE_TEXTURE", "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );", "    #endif", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = textureAnimation.x;", "        float framesY = textureAnimation.y;", "        float loopCount = textureAnimation.w;", "        float totalFrames = textureAnimation.z;", "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );", "        float column = floor(mod( frameNumber, framesX ));", "        float row = floor( (frameNumber - column) / framesX );", "        float columnNorm = column / framesX;", "        float rowNorm = row / framesY;", "        vSpriteSheet.x = 1.0 / framesX;", "        vSpriteSheet.y = 1.0 / framesY;", "        vSpriteSheet.z = columnNorm;", "        vSpriteSheet.w = rowNorm;", "    #endif", "    gl_PointSize = pointSizePerspective;", "    gl_Position = projectionMatrix * mvPos;", THREE.ShaderChunk.logdepthbuf_vertex, "}" ].join("\n"),
    fragment: [ SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, "void main() {", "    vec3 outgoingLight = vColor.xyz;", "    ", "    #ifdef ALPHATEST", "       if ( vColor.w < float(ALPHATEST) ) discard;", "    #endif", SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, "    outgoingLight = vColor.xyz * rotatedTexture.xyz;", THREE.ShaderChunk.fog_fragment, "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", "}" ].join("\n")
}, SPE.utils = {
    types: {
        BOOLEAN: "boolean",
        STRING: "string",
        NUMBER: "number",
        OBJECT: "object"
    },
    ensureTypedArg: function(arg, type, defaultValue) {
        "use strict";
        return typeof arg === type ? arg : defaultValue;
    },
    ensureArrayTypedArg: function(arg, type, defaultValue) {
        "use strict";
        if (Array.isArray(arg)) {
            for (var i = arg.length - 1; i >= 0; --i) if (typeof arg[i] !== type) return defaultValue;
            return arg;
        }
        return this.ensureTypedArg(arg, type, defaultValue);
    },
    ensureInstanceOf: function(arg, instance, defaultValue) {
        "use strict";
        return void 0 !== instance && arg instanceof instance ? arg : defaultValue;
    },
    ensureArrayInstanceOf: function(arg, instance, defaultValue) {
        "use strict";
        if (Array.isArray(arg)) {
            for (var i = arg.length - 1; i >= 0; --i) if (void 0 !== instance && arg[i] instanceof instance == !1) return defaultValue;
            return arg;
        }
        return this.ensureInstanceOf(arg, instance, defaultValue);
    },
    ensureValueOverLifetimeCompliance: function(property, minLength, maxLength) {
        "use strict";
        minLength = minLength || 3, maxLength = maxLength || 3, Array.isArray(property._value) === !1 && (property._value = [ property._value ]), 
        Array.isArray(property._spread) === !1 && (property._spread = [ property._spread ]);
        var valueLength = this.clamp(property._value.length, minLength, maxLength), spreadLength = this.clamp(property._spread.length, minLength, maxLength), desiredLength = Math.max(valueLength, spreadLength);
        property._value.length !== desiredLength && (property._value = this.interpolateArray(property._value, desiredLength)), 
        property._spread.length !== desiredLength && (property._spread = this.interpolateArray(property._spread, desiredLength));
    },
    interpolateArray: function(srcArray, newLength) {
        "use strict";
        for (var sourceLength = srcArray.length, newArray = [ "function" == typeof srcArray[0].clone ? srcArray[0].clone() : srcArray[0] ], factor = (sourceLength - 1) / (newLength - 1), i = 1; newLength - 1 > i; ++i) {
            var f = i * factor, before = Math.floor(f), after = Math.ceil(f), delta = f - before;
            newArray[i] = this.lerpTypeAgnostic(srcArray[before], srcArray[after], delta);
        }
        return newArray.push("function" == typeof srcArray[sourceLength - 1].clone ? srcArray[sourceLength - 1].clone() : srcArray[sourceLength - 1]), 
        newArray;
    },
    clamp: function(value, min, max) {
        "use strict";
        return Math.max(min, Math.min(value, max));
    },
    zeroToEpsilon: function(value, randomise) {
        "use strict";
        var epsilon = 1e-5, result = value;
        return result = randomise ? Math.random() * epsilon * 10 : epsilon, 0 > value && value > -epsilon && (result = -result), 
        result;
    },
    lerpTypeAgnostic: function(start, end, delta) {
        "use strict";
        var out, types = this.types;
        return typeof start === types.NUMBER && typeof end === types.NUMBER ? start + (end - start) * delta : start instanceof THREE.Vector2 && end instanceof THREE.Vector2 ? (out = start.clone(), 
        out.x = this.lerp(start.x, end.x, delta), out.y = this.lerp(start.y, end.y, delta), 
        out) : start instanceof THREE.Vector3 && end instanceof THREE.Vector3 ? (out = start.clone(), 
        out.x = this.lerp(start.x, end.x, delta), out.y = this.lerp(start.y, end.y, delta), 
        out.z = this.lerp(start.z, end.z, delta), out) : start instanceof THREE.Vector4 && end instanceof THREE.Vector4 ? (out = start.clone(), 
        out.x = this.lerp(start.x, end.x, delta), out.y = this.lerp(start.y, end.y, delta), 
        out.z = this.lerp(start.z, end.z, delta), out.w = this.lerp(start.w, end.w, delta), 
        out) : start instanceof THREE.Color && end instanceof THREE.Color ? (out = start.clone(), 
        out.r = this.lerp(start.r, end.r, delta), out.g = this.lerp(start.g, end.g, delta), 
        out.b = this.lerp(start.b, end.b, delta), out) : void console.warn("Invalid argument types, or argument types do not match:", start, end);
    },
    lerp: function(start, end, delta) {
        "use strict";
        return start + (end - start) * delta;
    },
    roundToNearestMultiple: function(n, multiple) {
        "use strict";
        var remainder = 0;
        return 0 === multiple ? n : (remainder = Math.abs(n) % multiple, 0 === remainder ? n : 0 > n ? -(Math.abs(n) - remainder) : n + multiple - remainder);
    },
    arrayValuesAreEqual: function(array) {
        "use strict";
        for (var i = 0; i < array.length - 1; ++i) if (array[i] !== array[i + 1]) return !1;
        return !0;
    },
    randomFloat: function(base, spread) {
        "use strict";
        return base + spread * (Math.random() - .5);
    },
    randomVector3: function(attribute, index, base, spread, spreadClamp) {
        "use strict";
        var x = base.x + (Math.random() * spread.x - .5 * spread.x), y = base.y + (Math.random() * spread.y - .5 * spread.y), z = base.z + (Math.random() * spread.z - .5 * spread.z);
        spreadClamp && (x = .5 * -spreadClamp.x + this.roundToNearestMultiple(x, spreadClamp.x), 
        y = .5 * -spreadClamp.y + this.roundToNearestMultiple(y, spreadClamp.y), z = .5 * -spreadClamp.z + this.roundToNearestMultiple(z, spreadClamp.z)), 
        attribute.typedArray.setVec3Components(index, x, y, z);
    },
    randomColor: function(attribute, index, base, spread) {
        "use strict";
        var r = base.r + Math.random() * spread.x, g = base.g + Math.random() * spread.y, b = base.b + Math.random() * spread.z;
        r = this.clamp(r, 0, 1), g = this.clamp(g, 0, 1), b = this.clamp(b, 0, 1), attribute.typedArray.setVec3Components(index, r, g, b);
    },
    randomColorAsHex: function() {
        "use strict";
        var workingColor = new THREE.Color();
        return function(attribute, index, base, spread) {
            for (var numItems = base.length, colors = [], i = 0; numItems > i; ++i) {
                var spreadVector = spread[i];
                workingColor.copy(base[i]), workingColor.r += Math.random() * spreadVector.x - .5 * spreadVector.x, 
                workingColor.g += Math.random() * spreadVector.y - .5 * spreadVector.y, workingColor.b += Math.random() * spreadVector.z - .5 * spreadVector.z, 
                workingColor.r = this.clamp(workingColor.r, 0, 1), workingColor.g = this.clamp(workingColor.g, 0, 1), 
                workingColor.b = this.clamp(workingColor.b, 0, 1), colors.push(workingColor.getHex());
            }
            attribute.typedArray.setVec4Components(index, colors[0], colors[1], colors[2], colors[3]);
        };
    }(),
    randomVector3OnSphere: function(attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp, distributionClamp) {
        "use strict";
        var depth = 2 * Math.random() - 1, t = 6.2832 * Math.random(), r = Math.sqrt(1 - depth * depth), rand = this.randomFloat(radius, radiusSpread), x = 0, y = 0, z = 0;
        radiusSpreadClamp && (rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp), 
        x = r * Math.cos(t) * rand, y = r * Math.sin(t) * rand, z = depth * rand, x *= radiusScale.x, 
        y *= radiusScale.y, z *= radiusScale.z, x += base.x, y += base.y, z += base.z, attribute.typedArray.setVec3Components(index, x, y, z);
    },
    seededRandom: function(seed) {
        var x = 1e4 * Math.sin(seed);
        return x - (0 | x);
    },
    randomVector3OnDisc: function(attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp) {
        "use strict";
        var t = 6.2832 * Math.random(), rand = Math.abs(this.randomFloat(radius, radiusSpread)), x = 0, y = 0, z = 0;
        radiusSpreadClamp && (rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp), 
        x = Math.cos(t) * rand, y = Math.sin(t) * rand, x *= radiusScale.x, y *= radiusScale.y, 
        x += base.x, y += base.y, z += base.z, attribute.typedArray.setVec3Components(index, x, y, z);
    },
    randomDirectionVector3OnSphere: function() {
        "use strict";
        var v = new THREE.Vector3();
        return function(attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {
            v.copy(emitterPosition), v.x -= posX, v.y -= posY, v.z -= posZ, v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread)), 
            attribute.typedArray.setVec3Components(index, v.x, v.y, v.z);
        };
    }(),
    randomDirectionVector3OnDisc: function() {
        "use strict";
        var v = new THREE.Vector3();
        return function(attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {
            v.copy(emitterPosition), v.x -= posX, v.y -= posY, v.z -= posZ, v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread)), 
            attribute.typedArray.setVec3Components(index, v.x, v.y, 0);
        };
    }(),
    getPackedRotationAxis: function() {
        "use strict";
        var v = new THREE.Vector3(), vSpread = new THREE.Vector3(), c = new THREE.Color(), addOne = new THREE.Vector3(1, 1, 1);
        return function(axis, axisSpread) {
            return v.copy(axis).normalize(), vSpread.copy(axisSpread).normalize(), v.x += .5 * -axisSpread.x + Math.random() * axisSpread.x, 
            v.y += .5 * -axisSpread.y + Math.random() * axisSpread.y, v.z += .5 * -axisSpread.z + Math.random() * axisSpread.z, 
            v.normalize().add(addOne).multiplyScalar(.5), c.setRGB(v.x, v.y, v.z), c.getHex();
        };
    }()
}, SPE.Group = function(options) {
    "use strict";
    var utils = SPE.utils, types = utils.types;
    options = utils.ensureTypedArg(options, types.OBJECT, {}), options.texture = utils.ensureTypedArg(options.texture, types.OBJECT, {}), 
    this.uuid = THREE.Math.generateUUID(), this.fixedTimeStep = utils.ensureTypedArg(options.fixedTimeStep, types.NUMBER, .016), 
    this.texture = utils.ensureInstanceOf(options.texture.value, THREE.Texture, null), 
    this.textureFrames = utils.ensureInstanceOf(options.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1)), 
    this.textureFrameCount = utils.ensureTypedArg(options.texture.frameCount, types.NUMBER, this.textureFrames.x * this.textureFrames.y), 
    this.textureLoop = utils.ensureTypedArg(options.texture.loop, types.NUMBER, 1), 
    this.textureFrames.max(new THREE.Vector2(1, 1)), this.hasPerspective = utils.ensureTypedArg(options.hasPerspective, types.BOOLEAN, !0), 
    this.colorize = utils.ensureTypedArg(options.colorize, types.BOOLEAN, !0), this.maxParticleCount = utils.ensureTypedArg(options.maxParticleCount, types.NUMBER, null), 
    this.blending = utils.ensureTypedArg(options.blending, types.NUMBER, THREE.AdditiveBlending), 
    this.transparent = utils.ensureTypedArg(options.transparent, types.BOOLEAN, !0), 
    this.alphaTest = parseFloat(utils.ensureTypedArg(options.alphaTest, types.NUMBER, 0)), 
    this.depthWrite = utils.ensureTypedArg(options.depthWrite, types.BOOLEAN, !1), this.depthTest = utils.ensureTypedArg(options.depthTest, types.BOOLEAN, !0), 
    this.fog = utils.ensureTypedArg(options.fog, types.BOOLEAN, !0), this.scale = utils.ensureTypedArg(options.scale, types.NUMBER, 300), 
    this.emitters = [], this.emitterIDs = [], this._pool = [], this._poolCreationSettings = null, 
    this._createNewWhenPoolEmpty = 0, this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !1, 
    this.particleCount = 0, this.uniforms = {
        texture: {
            type: "t",
            value: this.texture
        },
        textureAnimation: {
            type: "v4",
            value: new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1))
        },
        fogColor: {
            type: "c",
            value: null
        },
        fogNear: {
            type: "f",
            value: 10
        },
        fogFar: {
            type: "f",
            value: 200
        },
        fogDensity: {
            type: "f",
            value: .5
        },
        deltaTime: {
            type: "f",
            value: 0
        },
        runTime: {
            type: "f",
            value: 0
        },
        scale: {
            type: "f",
            value: this.scale
        }
    }, this.defines = {
        HAS_PERSPECTIVE: this.hasPerspective,
        COLORIZE: this.colorize,
        VALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,
        SHOULD_ROTATE_TEXTURE: !1,
        SHOULD_ROTATE_PARTICLES: !1,
        SHOULD_WIGGLE_PARTICLES: !1,
        SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1
    }, this.attributes = {
        position: new SPE.ShaderAttribute("v3", !0),
        acceleration: new SPE.ShaderAttribute("v4", !0),
        velocity: new SPE.ShaderAttribute("v3", !0),
        rotation: new SPE.ShaderAttribute("v4", !0),
        rotationCenter: new SPE.ShaderAttribute("v3", !0),
        params: new SPE.ShaderAttribute("v4", !0),
        size: new SPE.ShaderAttribute("v4", !0),
        angle: new SPE.ShaderAttribute("v4", !0),
        color: new SPE.ShaderAttribute("v4", !0),
        opacity: new SPE.ShaderAttribute("v4", !0)
    }, this.attributeKeys = Object.keys(this.attributes), this.attributeCount = this.attributeKeys.length, 
    this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: SPE.shaders.vertex,
        fragmentShader: SPE.shaders.fragment,
        blending: this.blending,
        transparent: this.transparent,
        alphaTest: this.alphaTest,
        depthWrite: this.depthWrite,
        depthTest: this.depthTest,
        defines: this.defines,
        fog: this.fog
    }), this.geometry = new THREE.BufferGeometry(), this.mesh = new THREE.Points(this.geometry, this.material), 
    null === this.maxParticleCount && console.warn("SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.");
}, SPE.Group.constructor = SPE.Group, SPE.Group.prototype._updateDefines = function() {
    "use strict";
    var emitter, emitters = this.emitters, i = emitters.length - 1, defines = this.defines;
    for (i; i >= 0; --i) emitter = emitters[i], defines.SHOULD_CALCULATE_SPRITE || (defines.SHOULD_ROTATE_TEXTURE = defines.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, emitter.angle.value), Math.max.apply(null, emitter.angle.spread))), 
    defines.SHOULD_ROTATE_PARTICLES = defines.SHOULD_ROTATE_PARTICLES || !!Math.max(emitter.rotation.angle, emitter.rotation.angleSpread), 
    defines.SHOULD_WIGGLE_PARTICLES = defines.SHOULD_WIGGLE_PARTICLES || !!Math.max(emitter.wiggle.value, emitter.wiggle.spread);
    this.material.needsUpdate = !0;
}, SPE.Group.prototype._applyAttributesToGeometry = function() {
    "use strict";
    var attribute, geometryAttribute, attributes = this.attributes, geometry = this.geometry, geometryAttributes = geometry.attributes;
    for (var attr in attributes) attributes.hasOwnProperty(attr) && (attribute = attributes[attr], 
    geometryAttribute = geometryAttributes[attr], geometryAttribute ? geometryAttribute.array = attribute.typedArray.array : geometry.addAttribute(attr, attribute.bufferAttribute), 
    attribute.bufferAttribute.needsUpdate = !0);
    this.geometry.setDrawRange(0, this.particleCount);
}, SPE.Group.prototype.addEmitter = function(emitter) {
    "use strict";
    if (emitter instanceof SPE.Emitter == !1) return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", emitter);
    if (this.emitterIDs.indexOf(emitter.uuid) > -1) return void console.error("Emitter already exists in this group. Will not add again.");
    if (null !== emitter.group) return void console.error("Emitter already belongs to another group. Will not add to requested group.");
    var attributes = this.attributes, start = this.particleCount, end = start + emitter.particleCount;
    this.particleCount = end, null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("SPE.Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount), 
    emitter._calculatePPSValue(emitter.maxAge._value + emitter.maxAge._spread), emitter._setBufferUpdateRanges(this.attributeKeys), 
    emitter._setAttributeOffset(start), emitter.group = this, emitter.attributes = this.attributes;
    for (var attr in attributes) attributes.hasOwnProperty(attr) && attributes[attr]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
    for (var i = start; end > i; ++i) emitter._assignPositionValue(i), emitter._assignForceValue(i, "velocity"), 
    emitter._assignForceValue(i, "acceleration"), emitter._assignAbsLifetimeValue(i, "opacity"), 
    emitter._assignAbsLifetimeValue(i, "size"), emitter._assignAngleValue(i), emitter._assignRotationValue(i), 
    emitter._assignParamsValue(i), emitter._assignColorValue(i);
    return this._applyAttributesToGeometry(), this.emitters.push(emitter), this.emitterIDs.push(emitter.uuid), 
    this._updateDefines(emitter), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, 
    this._attributesNeedRefresh = !0, this;
}, SPE.Group.prototype.removeEmitter = function(emitter) {
    "use strict";
    var emitterIndex = this.emitterIDs.indexOf(emitter.uuid);
    if (emitter instanceof SPE.Emitter == !1) return void console.error("`emitter` argument must be instance of SPE.Emitter. Was provided with:", emitter);
    if (-1 === emitterIndex) return void console.error("Emitter does not exist in this group. Will not remove.");
    for (var start = emitter.attributeOffset, end = start + emitter.particleCount, params = this.attributes.params.typedArray, i = start; end > i; ++i) params.array[4 * i] = 0, 
    params.array[4 * i + 1] = 0;
    this.emitters.splice(emitterIndex, 1), this.emitterIDs.splice(emitterIndex, 1);
    for (var attr in this.attributes) this.attributes.hasOwnProperty(attr) && this.attributes[attr].splice(start, end);
    this.particleCount -= emitter.particleCount, emitter._onRemove(), this._attributesNeedRefresh = !0;
}, SPE.Group.prototype.getFromPool = function() {
    "use strict";
    var pool = this._pool, createNew = this._createNewWhenPoolEmpty;
    return pool.length ? pool.pop() : createNew ? new SPE.Emitter(this._poolCreationSettings) : null;
}, SPE.Group.prototype.releaseIntoPool = function(emitter) {
    "use strict";
    return emitter instanceof SPE.Emitter == !1 ? void console.error("Argument is not instanceof SPE.Emitter:", emitter) : (emitter.reset(), 
    this._pool.unshift(emitter), this);
}, SPE.Group.prototype.getPool = function() {
    "use strict";
    return this._pool;
}, SPE.Group.prototype.addPool = function(numEmitters, emitterOptions, createNew) {
    "use strict";
    var emitter;
    this._poolCreationSettings = emitterOptions, this._createNewWhenPoolEmpty = !!createNew;
    for (var i = 0; numEmitters > i; ++i) emitter = Array.isArray(emitterOptions) ? new SPE.Emitter(emitterOptions[i]) : new SPE.Emitter(emitterOptions), 
    this.addEmitter(emitter), this.releaseIntoPool(emitter);
    return this;
}, SPE.Group.prototype._triggerSingleEmitter = function(pos) {
    "use strict";
    var emitter = this.getFromPool(), self = this;
    return null === emitter ? void console.log("SPE.Group pool ran out.") : (pos instanceof THREE.Vector3 && (emitter.position.value.copy(pos), 
    emitter.position.value = emitter.position.value), emitter.enable(), setTimeout(function() {
        emitter.disable(), self.releaseIntoPool(emitter);
    }, 1e3 * Math.max(emitter.duration, emitter.maxAge.value + emitter.maxAge.spread)), 
    this);
}, SPE.Group.prototype.triggerPoolEmitter = function(numEmitters, position) {
    "use strict";
    if ("number" == typeof numEmitters && numEmitters > 1) for (var i = 0; numEmitters > i; ++i) this._triggerSingleEmitter(position); else this._triggerSingleEmitter(position);
    return this;
}, SPE.Group.prototype._updateUniforms = function(dt) {
    "use strict";
    this.uniforms.runTime.value += dt, this.uniforms.deltaTime.value = dt;
}, SPE.Group.prototype._resetBufferRanges = function() {
    "use strict";
    var keys = this.attributeKeys, i = this.attributeCount - 1, attrs = this.attributes;
    for (i; i >= 0; --i) attrs[keys[i]].resetUpdateRange();
}, SPE.Group.prototype._updateBuffers = function(emitter) {
    "use strict";
    var key, emitterAttr, attr, keys = this.attributeKeys, i = this.attributeCount - 1, attrs = this.attributes, emitterRanges = emitter.bufferUpdateRanges;
    for (i; i >= 0; --i) key = keys[i], emitterAttr = emitterRanges[key], attr = attrs[key], 
    attr.setUpdateRange(emitterAttr.min, emitterAttr.max), attr.flagUpdate();
}, SPE.Group.prototype.tick = function(dt) {
    "use strict";
    var i, emitters = this.emitters, numEmitters = emitters.length, deltaTime = dt || this.fixedTimeStep, keys = this.attributeKeys, attrs = this.attributes;
    if (this._updateUniforms(deltaTime), this._resetBufferRanges(), 0 !== numEmitters || this._attributesNeedRefresh !== !1 || this._attributesNeedDynamicReset !== !1) {
        for (var emitter, i = 0; numEmitters > i; ++i) emitter = emitters[i], emitter.tick(deltaTime), 
        this._updateBuffers(emitter);
        if (this._attributesNeedDynamicReset === !0) {
            for (i = this.attributeCount - 1; i >= 0; --i) attrs[keys[i]].resetDynamic();
            this._attributesNeedDynamicReset = !1;
        }
        if (this._attributesNeedRefresh === !0) {
            for (i = this.attributeCount - 1; i >= 0; --i) attrs[keys[i]].forceUpdateAll();
            this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !0;
        }
    }
}, SPE.Group.prototype.dispose = function() {
    "use strict";
    return this.geometry.dispose(), this.material.dispose(), this;
}, SPE.Emitter = function(options) {
    "use strict";
    var utils = SPE.utils, types = utils.types, lifetimeLength = SPE.valueOverLifetimeLength;
    options = utils.ensureTypedArg(options, types.OBJECT, {}), options.position = utils.ensureTypedArg(options.position, types.OBJECT, {}), 
    options.velocity = utils.ensureTypedArg(options.velocity, types.OBJECT, {}), options.acceleration = utils.ensureTypedArg(options.acceleration, types.OBJECT, {}), 
    options.radius = utils.ensureTypedArg(options.radius, types.OBJECT, {}), options.drag = utils.ensureTypedArg(options.drag, types.OBJECT, {}), 
    options.rotation = utils.ensureTypedArg(options.rotation, types.OBJECT, {}), options.color = utils.ensureTypedArg(options.color, types.OBJECT, {}), 
    options.opacity = utils.ensureTypedArg(options.opacity, types.OBJECT, {}), options.size = utils.ensureTypedArg(options.size, types.OBJECT, {}), 
    options.angle = utils.ensureTypedArg(options.angle, types.OBJECT, {}), options.wiggle = utils.ensureTypedArg(options.wiggle, types.OBJECT, {}), 
    options.maxAge = utils.ensureTypedArg(options.maxAge, types.OBJECT, {}), options.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."), 
    this.uuid = THREE.Math.generateUUID(), this.type = utils.ensureTypedArg(options.type, types.NUMBER, SPE.distributions.BOX), 
    this.position = {
        _value: utils.ensureInstanceOf(options.position.value, THREE.Vector3, new THREE.Vector3()),
        _spread: utils.ensureInstanceOf(options.position.spread, THREE.Vector3, new THREE.Vector3()),
        _spreadClamp: utils.ensureInstanceOf(options.position.spreadClamp, THREE.Vector3, new THREE.Vector3()),
        _distribution: utils.ensureTypedArg(options.position.distribution, types.NUMBER, this.type),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1),
        _radius: utils.ensureTypedArg(options.position.radius, types.NUMBER, 10),
        _radiusScale: utils.ensureInstanceOf(options.position.radiusScale, THREE.Vector3, new THREE.Vector3(1, 1, 1)),
        _distributionClamp: utils.ensureTypedArg(options.position.distributionClamp, types.NUMBER, 0)
    }, this.velocity = {
        _value: utils.ensureInstanceOf(options.velocity.value, THREE.Vector3, new THREE.Vector3()),
        _spread: utils.ensureInstanceOf(options.velocity.spread, THREE.Vector3, new THREE.Vector3()),
        _distribution: utils.ensureTypedArg(options.velocity.distribution, types.NUMBER, this.type),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.acceleration = {
        _value: utils.ensureInstanceOf(options.acceleration.value, THREE.Vector3, new THREE.Vector3()),
        _spread: utils.ensureInstanceOf(options.acceleration.spread, THREE.Vector3, new THREE.Vector3()),
        _distribution: utils.ensureTypedArg(options.acceleration.distribution, types.NUMBER, this.type),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.drag = {
        _value: utils.ensureTypedArg(options.drag.value, types.NUMBER, 0),
        _spread: utils.ensureTypedArg(options.drag.spread, types.NUMBER, 0),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.wiggle = {
        _value: utils.ensureTypedArg(options.wiggle.value, types.NUMBER, 0),
        _spread: utils.ensureTypedArg(options.wiggle.spread, types.NUMBER, 0)
    }, this.rotation = {
        _axis: utils.ensureInstanceOf(options.rotation.axis, THREE.Vector3, new THREE.Vector3(0, 1, 0)),
        _axisSpread: utils.ensureInstanceOf(options.rotation.axisSpread, THREE.Vector3, new THREE.Vector3()),
        _angle: utils.ensureTypedArg(options.rotation.angle, types.NUMBER, 0),
        _angleSpread: utils.ensureTypedArg(options.rotation.angleSpread, types.NUMBER, 0),
        _static: utils.ensureTypedArg(options.rotation["static"], types.BOOLEAN, !1),
        _center: utils.ensureInstanceOf(options.rotation.center, THREE.Vector3, this.position._value.clone()),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.maxAge = {
        _value: utils.ensureTypedArg(options.maxAge.value, types.NUMBER, 2),
        _spread: utils.ensureTypedArg(options.maxAge.spread, types.NUMBER, 0)
    }, this.color = {
        _value: utils.ensureArrayInstanceOf(options.color.value, THREE.Color, new THREE.Color()),
        _spread: utils.ensureArrayInstanceOf(options.color.spread, THREE.Vector3, new THREE.Vector3()),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.opacity = {
        _value: utils.ensureArrayTypedArg(options.opacity.value, types.NUMBER, 1),
        _spread: utils.ensureArrayTypedArg(options.opacity.spread, types.NUMBER, 0),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.size = {
        _value: utils.ensureArrayTypedArg(options.size.value, types.NUMBER, 1),
        _spread: utils.ensureArrayTypedArg(options.size.spread, types.NUMBER, 0),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.angle = {
        _value: utils.ensureArrayTypedArg(options.angle.value, types.NUMBER, 0),
        _spread: utils.ensureArrayTypedArg(options.angle.spread, types.NUMBER, 0),
        _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1)
    }, this.particleCount = utils.ensureTypedArg(options.particleCount, types.NUMBER, 100), 
    this.duration = utils.ensureTypedArg(options.duration, types.NUMBER, null), this.isStatic = utils.ensureTypedArg(options.isStatic, types.BOOLEAN, !1), 
    this.activeMultiplier = utils.ensureTypedArg(options.activeMultiplier, types.NUMBER, 1), 
    this.direction = utils.ensureTypedArg(options.direction, types.NUMBER, 1), this.alive = utils.ensureTypedArg(options.alive, types.BOOLEAN, !0), 
    this.particlesPerSecond = 0, this.activationIndex = 0, this.attributeOffset = 0, 
    this.attributeEnd = 0, this.age = 0, this.activeParticleCount = 0, this.group = null, 
    this.attributes = null, this.paramsArray = null, this.resetFlags = {
        position: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, !1) || utils.ensureTypedArg(options.radius.randomise, types.BOOLEAN, !1),
        velocity: utils.ensureTypedArg(options.velocity.randomise, types.BOOLEAN, !1),
        acceleration: utils.ensureTypedArg(options.acceleration.randomise, types.BOOLEAN, !1) || utils.ensureTypedArg(options.drag.randomise, types.BOOLEAN, !1),
        rotation: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, !1),
        rotationCenter: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, !1),
        size: utils.ensureTypedArg(options.size.randomise, types.BOOLEAN, !1),
        color: utils.ensureTypedArg(options.color.randomise, types.BOOLEAN, !1),
        opacity: utils.ensureTypedArg(options.opacity.randomise, types.BOOLEAN, !1),
        angle: utils.ensureTypedArg(options.angle.randomise, types.BOOLEAN, !1)
    }, this.updateFlags = {}, this.updateCounts = {}, this.updateMap = {
        maxAge: "params",
        position: "position",
        velocity: "velocity",
        acceleration: "acceleration",
        drag: "acceleration",
        wiggle: "params",
        rotation: "rotation",
        size: "size",
        color: "color",
        opacity: "opacity",
        angle: "angle"
    };
    for (var i in this.updateMap) this.updateMap.hasOwnProperty(i) && (this.updateCounts[this.updateMap[i]] = 0, 
    this.updateFlags[this.updateMap[i]] = !1, this._createGetterSetters(this[i], i));
    this.bufferUpdateRanges = {}, this.attributeKeys = null, this.attributeCount = 0, 
    utils.ensureValueOverLifetimeCompliance(this.color, lifetimeLength, lifetimeLength), 
    utils.ensureValueOverLifetimeCompliance(this.opacity, lifetimeLength, lifetimeLength), 
    utils.ensureValueOverLifetimeCompliance(this.size, lifetimeLength, lifetimeLength), 
    utils.ensureValueOverLifetimeCompliance(this.angle, lifetimeLength, lifetimeLength);
}, SPE.Emitter.constructor = SPE.Emitter, SPE.Emitter.prototype._createGetterSetters = function(propObj, propName) {
    "use strict";
    var self = this;
    for (var i in propObj) if (propObj.hasOwnProperty(i)) {
        var name = i.replace("_", "");
        Object.defineProperty(propObj, name, {
            get: function(prop) {
                return function() {
                    return this[prop];
                };
            }(i),
            set: function(prop) {
                return function(value) {
                    var mapName = self.updateMap[propName], prevValue = this[prop], length = SPE.valueOverLifetimeLength;
                    "_rotationCenter" === prop ? (self.updateFlags.rotationCenter = !0, self.updateCounts.rotationCenter = 0) : "_randomise" === prop ? self.resetFlags[mapName] = value : (self.updateFlags[mapName] = !0, 
                    self.updateCounts[mapName] = 0), self.group._updateDefines(), this[prop] = value, 
                    Array.isArray(prevValue) && SPE.utils.ensureValueOverLifetimeCompliance(self[propName], length, length);
                };
            }(i)
        });
    }
}, SPE.Emitter.prototype._setBufferUpdateRanges = function(keys) {
    "use strict";
    this.attributeKeys = keys, this.attributeCount = keys.length;
    for (var i = this.attributeCount - 1; i >= 0; --i) this.bufferUpdateRanges[keys[i]] = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
    };
}, SPE.Emitter.prototype._calculatePPSValue = function(groupMaxAge) {
    "use strict";
    var particleCount = this.particleCount;
    this.duration ? this.particlesPerSecond = particleCount / (groupMaxAge < this.duration ? groupMaxAge : this.duration) : this.particlesPerSecond = particleCount / groupMaxAge;
}, SPE.Emitter.prototype._setAttributeOffset = function(startIndex) {
    this.attributeOffset = startIndex, this.activationIndex = startIndex, this.activationEnd = startIndex + this.particleCount;
}, SPE.Emitter.prototype._assignValue = function(prop, index) {
    "use strict";
    switch (prop) {
      case "position":
        this._assignPositionValue(index);
        break;

      case "velocity":
      case "acceleration":
        this._assignForceValue(index, prop);
        break;

      case "size":
      case "opacity":
        this._assignAbsLifetimeValue(index, prop);
        break;

      case "angle":
        this._assignAngleValue(index);
        break;

      case "params":
        this._assignParamsValue(index);
        break;

      case "rotation":
        this._assignRotationValue(index);
        break;

      case "color":
        this._assignColorValue(index);
    }
}, SPE.Emitter.prototype._assignPositionValue = function(index) {
    "use strict";
    var distributions = SPE.distributions, utils = SPE.utils, prop = this.position, attr = this.attributes.position, value = prop._value, spread = prop._spread, distribution = prop._distribution;
    switch (distribution) {
      case distributions.BOX:
        utils.randomVector3(attr, index, value, spread, prop._spreadClamp);
        break;

      case distributions.SPHERE:
        utils.randomVector3OnSphere(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x, prop._distributionClamp || this.particleCount);
        break;

      case distributions.DISC:
        utils.randomVector3OnDisc(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x);
    }
}, SPE.Emitter.prototype._assignForceValue = function(index, attrName) {
    "use strict";
    var pos, positionX, positionY, positionZ, i, distributions = SPE.distributions, utils = SPE.utils, prop = this[attrName], value = prop._value, spread = prop._spread, distribution = prop._distribution;
    switch (distribution) {
      case distributions.BOX:
        utils.randomVector3(this.attributes[attrName], index, value, spread);
        break;

      case distributions.SPHERE:
        pos = this.attributes.position.typedArray.array, i = 3 * index, positionX = pos[i], 
        positionY = pos[i + 1], positionZ = pos[i + 2], utils.randomDirectionVector3OnSphere(this.attributes[attrName], index, positionX, positionY, positionZ, this.position._value, prop._value.x, prop._spread.x);
        break;

      case distributions.DISC:
        pos = this.attributes.position.typedArray.array, i = 3 * index, positionX = pos[i], 
        positionY = pos[i + 1], positionZ = pos[i + 2], utils.randomDirectionVector3OnDisc(this.attributes[attrName], index, positionX, positionY, positionZ, this.position._value, prop._value.x, prop._spread.x);
    }
    if ("acceleration" === attrName) {
        var drag = utils.clamp(utils.randomFloat(this.drag._value, this.drag._spread), 0, 1);
        this.attributes.acceleration.typedArray.array[4 * index + 3] = drag;
    }
}, SPE.Emitter.prototype._assignAbsLifetimeValue = function(index, propName) {
    "use strict";
    var value, array = this.attributes[propName].typedArray, prop = this[propName], utils = SPE.utils;
    utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread) ? (value = Math.abs(utils.randomFloat(prop._value[0], prop._spread[0])), 
    array.setVec4Components(index, value, value, value, value)) : array.setVec4Components(index, Math.abs(utils.randomFloat(prop._value[0], prop._spread[0])), Math.abs(utils.randomFloat(prop._value[1], prop._spread[1])), Math.abs(utils.randomFloat(prop._value[2], prop._spread[2])), Math.abs(utils.randomFloat(prop._value[3], prop._spread[3])));
}, SPE.Emitter.prototype._assignAngleValue = function(index) {
    "use strict";
    var value, array = this.attributes.angle.typedArray, prop = this.angle, utils = SPE.utils;
    utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread) ? (value = utils.randomFloat(prop._value[0], prop._spread[0]), 
    array.setVec4Components(index, value, value, value, value)) : array.setVec4Components(index, utils.randomFloat(prop._value[0], prop._spread[0]), utils.randomFloat(prop._value[1], prop._spread[1]), utils.randomFloat(prop._value[2], prop._spread[2]), utils.randomFloat(prop._value[3], prop._spread[3]));
}, SPE.Emitter.prototype._assignParamsValue = function(index) {
    "use strict";
    this.attributes.params.typedArray.setVec4Components(index, this.isStatic ? 1 : 0, 0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread));
}, SPE.Emitter.prototype._assignRotationValue = function(index) {
    "use strict";
    this.attributes.rotation.typedArray.setVec3Components(index, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1), 
    this.attributes.rotationCenter.typedArray.setVec3(index, this.rotation._center);
}, SPE.Emitter.prototype._assignColorValue = function(index) {
    "use strict";
    SPE.utils.randomColorAsHex(this.attributes.color, index, this.color._value, this.color._spread);
}, SPE.Emitter.prototype._resetParticle = function(index) {
    "use strict";
    for (var key, updateFlag, resetFlags = this.resetFlags, updateFlags = this.updateFlags, updateCounts = this.updateCounts, keys = this.attributeKeys, i = this.attributeCount - 1; i >= 0; --i) key = keys[i], 
    updateFlag = updateFlags[key], resetFlags[key] !== !0 && updateFlag !== !0 || (this._assignValue(key, index), 
    this._updateAttributeUpdateRange(key, index), updateFlag === !0 && updateCounts[key] === this.particleCount ? (updateFlags[key] = !1, 
    updateCounts[key] = 0) : 1 == updateFlag && ++updateCounts[key]);
}, SPE.Emitter.prototype._updateAttributeUpdateRange = function(attr, i) {
    "use strict";
    var ranges = this.bufferUpdateRanges[attr];
    ranges.min = Math.min(i, ranges.min), ranges.max = Math.max(i, ranges.max);
}, SPE.Emitter.prototype._resetBufferRanges = function() {
    "use strict";
    var key, ranges = this.bufferUpdateRanges, keys = this.bufferUpdateKeys, i = this.bufferUpdateCount - 1;
    for (i; i >= 0; --i) key = keys[i], ranges[key].min = Number.POSITIVE_INFINITY, 
    ranges[key].max = Number.NEGATIVE_INFINITY;
}, SPE.Emitter.prototype._onRemove = function() {
    "use strict";
    this.particlesPerSecond = 0, this.attributeOffset = 0, this.activationIndex = 0, 
    this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, 
    this.age = 0;
}, SPE.Emitter.prototype._decrementParticleCount = function() {
    "use strict";
    --this.activeParticleCount;
}, SPE.Emitter.prototype._incrementParticleCount = function() {
    "use strict";
    ++this.activeParticleCount;
}, SPE.Emitter.prototype._checkParticleAges = function(start, end, params, dt) {
    "use strict";
    for (var index, maxAge, age, alive, i = end - 1; i >= start; --i) index = 4 * i, 
    alive = params[index], 0 !== alive && (age = params[index + 1], maxAge = params[index + 2], 
    1 === this.direction ? (age += dt, age >= maxAge && (age = 0, alive = 0, this._decrementParticleCount())) : (age -= dt, 
    0 >= age && (age = maxAge, alive = 0, this._decrementParticleCount())), params[index] = alive, 
    params[index + 1] = age, this._updateAttributeUpdateRange("params", i));
}, SPE.Emitter.prototype._activateParticles = function(activationStart, activationEnd, params, dtPerParticle) {
    "use strict";
    for (var index, dtValue, direction = this.direction, i = activationStart; activationEnd > i; ++i) index = 4 * i, 
    0 != params[index] && 1 !== this.particleCount || (this._incrementParticleCount(), 
    params[index] = 1, this._resetParticle(i), dtValue = dtPerParticle * (i - activationStart), 
    params[index + 1] = -1 === direction ? params[index + 2] - dtValue : dtValue, this._updateAttributeUpdateRange("params", i));
}, SPE.Emitter.prototype.tick = function(dt) {
    "use strict";
    if (!this.isStatic) {
        null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
        var start = this.attributeOffset, end = start + this.particleCount, params = this.paramsArray, ppsDt = this.particlesPerSecond * this.activeMultiplier * dt, activationIndex = this.activationIndex;
        if (this._resetBufferRanges(), this._checkParticleAges(start, end, params, dt), 
        this.alive === !1) return void (this.age = 0);
        if (null !== this.duration && this.age > this.duration) return this.alive = !1, 
        void (this.age = 0);
        var activationStart = 1 === this.particleCount ? activationIndex : 0 | activationIndex, activationEnd = Math.min(activationStart + ppsDt, this.activationEnd), activationCount = activationEnd - this.activationIndex | 0, dtPerParticle = activationCount > 0 ? dt / activationCount : 0;
        this._activateParticles(activationStart, activationEnd, params, dtPerParticle), 
        this.activationIndex += ppsDt, this.activationIndex > end && (this.activationIndex = start), 
        this.age += dt;
    }
}, SPE.Emitter.prototype.reset = function(force) {
    "use strict";
    if (this.age = 0, this.alive = !1, force === !0) {
        for (var index, start = this.attributeOffset, end = start + this.particleCount, array = this.paramsArray, attr = this.attributes.params.bufferAttribute, i = end - 1; i >= start; --i) index = 4 * i, 
        array[index] = 0, array[index + 1] = 0;
        attr.updateRange.offset = 0, attr.updateRange.count = -1, attr.needsUpdate = !0;
    }
    return this;
}, SPE.Emitter.prototype.enable = function() {
    "use strict";
    return this.alive = !0, this;
}, SPE.Emitter.prototype.disable = function() {
    "use strict";
    return this.alive = !1, this;
}, SPE.Emitter.prototype.remove = function() {
    "use strict";
    return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), 
    this;
};

var THREEx;

THREEx = THREEx || {}, THREEx.DynamicTexture = function(width, height) {
    var canvas, context, texture;
    canvas = document.createElement("canvas"), canvas.width = width, canvas.height = height, 
    this.canvas = canvas, context = canvas.getContext("2d"), this.context = context, 
    texture = new THREE.Texture(canvas), this.texture = texture;
}, THREEx.DynamicTexture.prototype.clear = function(fillStyle) {
    return void 0 !== fillStyle ? (this.context.fillStyle = fillStyle, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)) : this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), 
    this.texture.needsUpdate = !0, this;
}, THREEx.DynamicTexture.prototype.drawText = function(text, x, y, fillStyle, contextFont) {
    var textSize;
    return void 0 !== contextFont && (this.context.font = contextFont), void 0 !== x && null !== x || (textSize = this.context.measureText(text), 
    x = (this.canvas.width - textSize.width) / 2), this.context.fillStyle = fillStyle, 
    this.context.fillText(text, x, y), this.texture.needsUpdate = !0, this;
}, THREEx.DynamicTexture.prototype.drawTextCooked = function(options) {
    var canvas, computeMaxTextLength, context, maxText, params, text, textSize, x, y;
    for (context = this.context, canvas = this.canvas, computeMaxTextLength = function(text) {
        var maxText, maxWidth, textSize;
        for (maxText = "", maxWidth = (1 - 2 * params.margin) * canvas.width; maxText.length !== text.length && (textSize = context.measureText(maxText), 
        !(textSize.width > maxWidth)); ) maxText += text.substr(maxText.length, 1);
        return maxText;
    }, options = options || {}, text = options.text, params = {
        margin: void 0 !== options.margin ? options.margin : .1,
        lineHeight: void 0 !== options.lineHeight ? options.lineHeight : .1,
        align: void 0 !== options.align ? options.align : "left",
        fillStyle: void 0 !== options.fillStyle ? options.fillStyle : "black",
        fillLineWidth: null != options.fillLineWidth ? options.fillLineWidth : 1,
        strokeStyle: void 0,
        strokeLineWidth: null != options.strokeLineWidth ? options.strokeLineWidth : 20,
        font: void 0 !== options.font ? options.font : "bold 102.4px Arial",
        x: null != options.x ? options.x : 0,
        y: null != options.y ? options.y : 0
    }, console.assert("string" == typeof text), context.save(), context.fillStyle = params.fillStyle, 
    null != options.strokeStyle && (context.miterLimit = 2, context.lineJoin = "circle", 
    context.strokeStyle = options.strokeStyle), context.font = params.font, y = (params.lineHeight + params.margin) * canvas.height; text.length > 0; ) maxText = computeMaxTextLength(text), 
    text = text.substr(maxText.length), textSize = context.measureText(maxText), "left" === params.align ? x = params.margin * canvas.width : "right" === params.align ? x = (1 - params.margin) * canvas.width - textSize.width : "center" === params.align ? x = (canvas.width - textSize.width) / 2 : console.assert(!1), 
    null != options.strokeStyle && (this.context.lineWidth = params.strokeLineWidth, 
    this.context.strokeText(maxText, x + params.x, y + params.y)), this.context.lineWidth = params.fillLineWidth, 
    this.context.fillText(maxText, x + params.x, y + params.y), y += params.lineHeight * canvas.height;
    return context.restore(), this.texture.needsUpdate = !0, this;
}, THREEx.DynamicTexture.prototype.drawImage = function() {
    return this.context.drawImage.apply(this.context, arguments), this.texture.needsUpdate = !0, 
    this;
}, THREE.DeviceOrientationControls = function(object) {
    var onDeviceOrientationChangeEvent, onScreenOrientationChangeEvent, scope, setObjectQuaternion;
    scope = this, this.object = object, this.object.rotation.reorder("YXZ"), this.enabled = !0, 
    this.deviceOrientation = {}, this.screenOrientation = 0, this.alpha = 0, this.alphaOffsetAngle = 0, 
    onDeviceOrientationChangeEvent = function(event) {
        scope.deviceOrientation = event;
    }, onScreenOrientationChangeEvent = function() {
        scope.screenOrientation = window.orientation || 0;
    }, setObjectQuaternion = function() {
        var euler, q0, q1, zee;
        return zee = new THREE.Vector3(0, 0, 1), euler = new THREE.Euler(), q0 = new THREE.Quaternion(), 
        q1 = new THREE.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)), function(quaternion, alpha, beta, gamma, orient) {
            euler.set(beta, alpha, -gamma, "YXZ"), quaternion.setFromEuler(euler), quaternion.multiply(q1), 
            quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
        };
    }(), this.connect = function() {
        onScreenOrientationChangeEvent(), window.addEventListener("orientationchange", onScreenOrientationChangeEvent, !1), 
        window.addEventListener("deviceorientation", onDeviceOrientationChangeEvent, !1), 
        scope.enabled = !0;
    }, this.disconnect = function() {
        window.removeEventListener("orientationchange", onScreenOrientationChangeEvent, !1), 
        window.removeEventListener("deviceorientation", onDeviceOrientationChangeEvent, !1), 
        scope.enabled = !1;
    }, this.update = function() {
        var alpha, beta, gamma, orient;
        scope.enabled !== !1 && (alpha = scope.deviceOrientation.alpha ? THREE.Math.degToRad(scope.deviceOrientation.alpha) + this.alphaOffsetAngle : 0, 
        beta = scope.deviceOrientation.beta ? THREE.Math.degToRad(scope.deviceOrientation.beta) : 0, 
        gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad(scope.deviceOrientation.gamma) : 0, 
        orient = scope.screenOrientation ? THREE.Math.degToRad(scope.screenOrientation) : 0, 
        setObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient), this.alpha = alpha);
    }, this.updateAlphaOffsetAngle = function(angle) {
        this.alphaOffsetAngle = angle, this.update();
    }, this.dispose = function() {
        this.disconnect();
    }, this.connect();
};

var saveAs = saveAs || function(view) {
    "use strict";
    if ("undefined" == typeof navigator || !/MSIE [1-9]\./.test(navigator.userAgent)) {
        var doc = view.document, get_URL = function() {
            return view.URL || view.webkitURL || view;
        }, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"), can_use_save_link = "download" in save_link, click = function(node) {
            var event = new MouseEvent("click");
            node.dispatchEvent(event);
        }, is_safari = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent), webkit_req_fs = view.webkitRequestFileSystem, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem, throw_outside = function(ex) {
            (view.setImmediate || view.setTimeout)(function() {
                throw ex;
            }, 0);
        }, force_saveable_type = "application/octet-stream", fs_min_size = 0, arbitrary_revoke_timeout = 500, revoke = function(file) {
            var revoker = function() {
                "string" == typeof file ? get_URL().revokeObjectURL(file) : file.remove();
            };
            view.chrome ? revoker() : setTimeout(revoker, arbitrary_revoke_timeout);
        }, dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            for (var i = event_types.length; i--; ) {
                var listener = filesaver["on" + event_types[i]];
                if ("function" == typeof listener) try {
                    listener.call(filesaver, event || filesaver);
                } catch (ex) {
                    throw_outside(ex);
                }
            }
        }, auto_bom = function(blob) {
            return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type) ? new Blob([ "\ufeff", blob ], {
                type: blob.type
            }) : blob;
        }, FileSaver = function(blob, name, no_auto_bom) {
            no_auto_bom || (blob = auto_bom(blob));
            var object_url, target_view, slice, filesaver = this, type = blob.type, blob_changed = !1, dispatch_all = function() {
                dispatch(filesaver, "writestart progress write writeend".split(" "));
            }, fs_error = function() {
                if (target_view && is_safari && "undefined" != typeof FileReader) {
                    var reader = new FileReader();
                    return reader.onloadend = function() {
                        var base64Data = reader.result;
                        target_view.location.href = "data:attachment/file" + base64Data.slice(base64Data.search(/[,;]/)), 
                        filesaver.readyState = filesaver.DONE, dispatch_all();
                    }, reader.readAsDataURL(blob), void (filesaver.readyState = filesaver.INIT);
                }
                if (!blob_changed && object_url || (object_url = get_URL().createObjectURL(blob)), 
                target_view) target_view.location.href = object_url; else {
                    var new_tab = view.open(object_url, "_blank");
                    void 0 == new_tab && is_safari && (view.location.href = object_url);
                }
                filesaver.readyState = filesaver.DONE, dispatch_all(), revoke(object_url);
            }, abortable = function(func) {
                return function() {
                    return filesaver.readyState !== filesaver.DONE ? func.apply(this, arguments) : void 0;
                };
            }, create_if_not_found = {
                create: !0,
                exclusive: !1
            };
            return filesaver.readyState = filesaver.INIT, name || (name = "download"), can_use_save_link ? (object_url = get_URL().createObjectURL(blob), 
            void setTimeout(function() {
                save_link.href = object_url, save_link.download = name, click(save_link), dispatch_all(), 
                revoke(object_url), filesaver.readyState = filesaver.DONE;
            })) : (view.chrome && type && type !== force_saveable_type && (slice = blob.slice || blob.webkitSlice, 
            blob = slice.call(blob, 0, blob.size, force_saveable_type), blob_changed = !0), 
            webkit_req_fs && "download" !== name && (name += ".download"), (type === force_saveable_type || webkit_req_fs) && (target_view = view), 
            req_fs ? (fs_min_size += blob.size, void req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
                fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
                    var save = function() {
                        dir.getFile(name, create_if_not_found, abortable(function(file) {
                            file.createWriter(abortable(function(writer) {
                                writer.onwriteend = function(event) {
                                    target_view.location.href = file.toURL(), filesaver.readyState = filesaver.DONE, 
                                    dispatch(filesaver, "writeend", event), revoke(file);
                                }, writer.onerror = function() {
                                    var error = writer.error;
                                    error.code !== error.ABORT_ERR && fs_error();
                                }, "writestart progress write abort".split(" ").forEach(function(event) {
                                    writer["on" + event] = filesaver["on" + event];
                                }), writer.write(blob), filesaver.abort = function() {
                                    writer.abort(), filesaver.readyState = filesaver.DONE;
                                }, filesaver.readyState = filesaver.WRITING;
                            }), fs_error);
                        }), fs_error);
                    };
                    dir.getFile(name, {
                        create: !1
                    }, abortable(function(file) {
                        file.remove(), save();
                    }), abortable(function(ex) {
                        ex.code === ex.NOT_FOUND_ERR ? save() : fs_error();
                    }));
                }), fs_error);
            }), fs_error)) : void fs_error());
        }, FS_proto = FileSaver.prototype, saveAs = function(blob, name, no_auto_bom) {
            return new FileSaver(blob, name, no_auto_bom);
        };
        return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function(blob, name, no_auto_bom) {
            return no_auto_bom || (blob = auto_bom(blob)), navigator.msSaveOrOpenBlob(blob, name || "download");
        } : (FS_proto.abort = function() {
            var filesaver = this;
            filesaver.readyState = filesaver.DONE, dispatch(filesaver, "abort");
        }, FS_proto.readyState = FS_proto.INIT = 0, FS_proto.WRITING = 1, FS_proto.DONE = 2, 
        FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null, 
        saveAs);
    }
}("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);

"undefined" != typeof module && module.exports ? module.exports.saveAs = saveAs : "undefined" != typeof define && null !== define && null != define.amd && define([], function() {
    return saveAs;
});

var VirtualJoystick = function(opts) {
    opts = opts || {}, this._container = opts.container || document.body, this._strokeStyle = opts.strokeStyle || "cyan", 
    this._stickEl = opts.stickElement || this._buildJoystickStick(), this._baseEl = opts.baseElement || this._buildJoystickBase(), 
    this._mouseSupport = void 0 !== opts.mouseSupport ? opts.mouseSupport : !1, this._stationaryBase = opts.stationaryBase || !1, 
    this._baseX = this._stickX = opts.baseX || 0, this._baseY = this._stickY = opts.baseY || 0, 
    this._limitStickTravel = opts.limitStickTravel || !1, this._stickRadius = void 0 !== opts.stickRadius ? opts.stickRadius : 100, 
    this._deadZone = opts.deadZone || 0, this._useCssTransform = void 0 !== opts.useCssTransform ? opts.useCssTransform : !1, 
    this._container.style.position = "relative", this._container.appendChild(this._baseEl), 
    this._baseEl.style.position = "absolute", this._baseEl.style.display = "none", this._container.appendChild(this._stickEl), 
    this._stickEl.style.position = "absolute", this._stickEl.style.display = "none", 
    this._pressed = !1, this._touchIdx = null, this._stationaryBase === !0 && (this._baseEl.style.display = "", 
    this._baseEl.style.left = this._baseX - this._baseEl.width / 2 + "px", this._baseEl.style.top = this._baseY - this._baseEl.height / 2 + "px"), 
    this._transform = this._useCssTransform ? this._getTransformProperty() : !1, this._has3d = this._check3D();
    var __bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    };
    this._$onTouchStart = __bind(this._onTouchStart, this), this._$onTouchEnd = __bind(this._onTouchEnd, this), 
    this._$onTouchMove = __bind(this._onTouchMove, this), this._container.addEventListener("touchstart", this._$onTouchStart, !1), 
    this._container.addEventListener("touchend", this._$onTouchEnd, !1), this._container.addEventListener("touchmove", this._$onTouchMove, !1), 
    this._mouseSupport && (this._$onMouseDown = __bind(this._onMouseDown, this), this._$onMouseUp = __bind(this._onMouseUp, this), 
    this._$onMouseMove = __bind(this._onMouseMove, this), this._container.addEventListener("mousedown", this._$onMouseDown, !1), 
    this._container.addEventListener("mouseup", this._$onMouseUp, !1), this._container.addEventListener("mousemove", this._$onMouseMove, !1));
};

VirtualJoystick.prototype.destroy = function() {
    this._container.removeChild(this._baseEl), this._container.removeChild(this._stickEl), 
    this._container.removeEventListener("touchstart", this._$onTouchStart, !1), this._container.removeEventListener("touchend", this._$onTouchEnd, !1), 
    this._container.removeEventListener("touchmove", this._$onTouchMove, !1), this._mouseSupport && (this._container.removeEventListener("mouseup", this._$onMouseUp, !1), 
    this._container.removeEventListener("mousedown", this._$onMouseDown, !1), this._container.removeEventListener("mousemove", this._$onMouseMove, !1));
}, VirtualJoystick.touchScreenAvailable = function() {
    return "createTouch" in document;
}, function(destObj) {
    destObj.addEventListener = function(event, fct) {
        return void 0 === this._events && (this._events = {}), this._events[event] = this._events[event] || [], 
        this._events[event].push(fct), fct;
    }, destObj.removeEventListener = function(event, fct) {
        void 0 === this._events && (this._events = {}), event in this._events != !1 && this._events[event].splice(this._events[event].indexOf(fct), 1);
    }, destObj.dispatchEvent = function(event) {
        if (void 0 === this._events && (this._events = {}), void 0 !== this._events[event]) for (var tmpArray = this._events[event].slice(), i = 0; i < tmpArray.length; i++) {
            var result = tmpArray[i].apply(this, Array.prototype.slice.call(arguments, 1));
            if (void 0 !== result) return result;
        }
    };
}(VirtualJoystick.prototype), VirtualJoystick.prototype.deltaX = function() {
    return this._stickX - this._baseX;
}, VirtualJoystick.prototype.deltaY = function() {
    return this._stickY - this._baseY;
}, VirtualJoystick.prototype.up = function() {
    if (this._pressed === !1) return !1;
    var deltaX = this.deltaX(), deltaY = this.deltaY();
    return deltaY >= 0 ? !1 : Math.abs(deltaX) > 2 * Math.abs(deltaY) ? !1 : !(deltaY > -this._deadZone && deltaY < this._deadZone);
}, VirtualJoystick.prototype.down = function() {
    if (this._pressed === !1) return !1;
    var deltaX = this.deltaX(), deltaY = this.deltaY();
    return 0 >= deltaY ? !1 : Math.abs(deltaX) > 2 * Math.abs(deltaY) ? !1 : !(deltaY > -this._deadZone && deltaY < this._deadZone);
}, VirtualJoystick.prototype.right = function() {
    if (this._pressed === !1) return !1;
    var deltaX = this.deltaX(), deltaY = this.deltaY();
    return 0 >= deltaX ? !1 : Math.abs(deltaY) > 2 * Math.abs(deltaX) ? !1 : !(deltaX > -this._deadZone && deltaX < this._deadZone);
}, VirtualJoystick.prototype.left = function() {
    if (this._pressed === !1) return !1;
    var deltaX = this.deltaX(), deltaY = this.deltaY();
    return deltaX >= 0 ? !1 : Math.abs(deltaY) > 2 * Math.abs(deltaX) ? !1 : !(deltaX > -this._deadZone && deltaX < this._deadZone);
}, VirtualJoystick.prototype._onUp = function() {
    this._pressed = !1, this._stickEl.style.display = "none", 0 == this._stationaryBase && (this._baseEl.style.display = "none", 
    this._baseX = this._baseY = 0, this._stickX = this._stickY = 0);
}, VirtualJoystick.prototype._onDown = function(x, y) {
    if (this._pressed = !0, 0 == this._stationaryBase && (this._baseX = x, this._baseY = y, 
    this._baseEl.style.display = "", this._move(this._baseEl.style, this._baseX - this._baseEl.width / 2, this._baseY - this._baseEl.height / 2)), 
    this._stickX = x, this._stickY = y, this._limitStickTravel === !0) {
        var deltaX = this.deltaX(), deltaY = this.deltaY(), stickDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (stickDistance > this._stickRadius) {
            var stickNormalizedX = deltaX / stickDistance, stickNormalizedY = deltaY / stickDistance;
            this._stickX = stickNormalizedX * this._stickRadius + this._baseX, this._stickY = stickNormalizedY * this._stickRadius + this._baseY;
        }
    }
    this._stickEl.style.display = "", this._move(this._stickEl.style, this._stickX - this._stickEl.width / 2, this._stickY - this._stickEl.height / 2);
}, VirtualJoystick.prototype._onMove = function(x, y) {
    if (this._pressed === !0) {
        if (this._stickX = x, this._stickY = y, this._limitStickTravel === !0) {
            var deltaX = this.deltaX(), deltaY = this.deltaY(), stickDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (stickDistance > this._stickRadius) {
                var stickNormalizedX = deltaX / stickDistance, stickNormalizedY = deltaY / stickDistance;
                this._stickX = stickNormalizedX * this._stickRadius + this._baseX, this._stickY = stickNormalizedY * this._stickRadius + this._baseY;
            }
        }
        this._move(this._stickEl.style, this._stickX - this._stickEl.width / 2, this._stickY - this._stickEl.height / 2);
    }
}, VirtualJoystick.prototype._onMouseUp = function(event) {
    return this._onUp();
}, VirtualJoystick.prototype._onMouseDown = function(event) {
    event.preventDefault();
    var x = event.clientX, y = event.clientY;
    return this._onDown(x, y);
}, VirtualJoystick.prototype._onMouseMove = function(event) {
    var x = event.clientX, y = event.clientY;
    return this._onMove(x, y);
}, VirtualJoystick.prototype._onTouchStart = function(event) {
    if (null === this._touchIdx) {
        var isValid = this.dispatchEvent("touchStartValidation", event);
        if (isValid !== !1) {
            this.dispatchEvent("touchStart", event), event.preventDefault();
            var touch = event.changedTouches[0];
            this._touchIdx = touch.identifier;
            var x = touch.pageX, y = touch.pageY;
            return this._onDown(x, y);
        }
    }
}, VirtualJoystick.prototype._onTouchEnd = function(event) {
    if (null !== this._touchIdx) {
        this.dispatchEvent("touchEnd", event);
        for (var touchList = event.changedTouches, i = 0; i < touchList.length && touchList[i].identifier !== this._touchIdx; i++) ;
        if (i !== touchList.length) return this._touchIdx = null, event.preventDefault(), 
        this._onUp();
    }
}, VirtualJoystick.prototype._onTouchMove = function(event) {
    if (null !== this._touchIdx) {
        for (var touchList = event.changedTouches, i = 0; i < touchList.length && touchList[i].identifier !== this._touchIdx; i++) ;
        if (i !== touchList.length) {
            var touch = touchList[i];
            event.preventDefault();
            var x = touch.pageX, y = touch.pageY;
            return this._onMove(x, y);
        }
    }
}, VirtualJoystick.prototype._buildJoystickBase = function() {
    var canvas = document.createElement("canvas");
    canvas.width = 126, canvas.height = 126;
    var ctx = canvas.getContext("2d");
    return ctx.beginPath(), ctx.strokeStyle = this._strokeStyle, ctx.lineWidth = 6, 
    ctx.arc(canvas.width / 2, canvas.width / 2, 40, 0, 2 * Math.PI, !0), ctx.stroke(), 
    ctx.beginPath(), ctx.strokeStyle = this._strokeStyle, ctx.lineWidth = 2, ctx.arc(canvas.width / 2, canvas.width / 2, 60, 0, 2 * Math.PI, !0), 
    ctx.stroke(), canvas;
}, VirtualJoystick.prototype._buildJoystickStick = function() {
    var canvas = document.createElement("canvas");
    canvas.width = 86, canvas.height = 86;
    var ctx = canvas.getContext("2d");
    return ctx.beginPath(), ctx.strokeStyle = this._strokeStyle, ctx.lineWidth = 6, 
    ctx.arc(canvas.width / 2, canvas.width / 2, 40, 0, 2 * Math.PI, !0), ctx.stroke(), 
    canvas;
}, VirtualJoystick.prototype._move = function(style, x, y) {
    this._transform ? this._has3d ? style[this._transform] = "translate3d(" + x + "px," + y + "px, 0)" : style[this._transform] = "translate(" + x + "px," + y + "px)" : (style.left = x + "px", 
    style.top = y + "px");
}, VirtualJoystick.prototype._getTransformProperty = function() {
    for (var style, styles = [ "webkitTransform", "MozTransform", "msTransform", "OTransform", "transform" ], el = document.createElement("p"), i = 0; i < styles.length; i++) if (style = styles[i], 
    null != el.style[style]) return style;
}, VirtualJoystick.prototype._check3D = function() {
    var prop = this._getTransformProperty();
    if (!prop || !window.getComputedStyle) return module.exports = !1;
    var map = {
        webkitTransform: "-webkit-transform",
        OTransform: "-o-transform",
        msTransform: "-ms-transform",
        MozTransform: "-moz-transform",
        transform: "transform"
    }, el = document.createElement("div");
    el.style[prop] = "translate3d(1px,1px,1px)", document.body.insertBefore(el, null);
    var val = getComputedStyle(el).getPropertyValue(map[prop]);
    document.body.removeChild(el);
    var exports = null != val && val.length && "none" != val;
    return exports;
};

var Singleton, exports;

exports = void 0, "undefined" != typeof exports && null !== exports || (exports = {}), 
Singleton = function() {
    function Singleton() {}
    return Singleton;
}(), THREE.Object3D.prototype.clear = function() {
    var child, children, i;
    for (children = this.children, i = children.length - 1; i >= 0; ) child = children[i], 
    child.clear(), this.remove(child), i--;
};

var SceneManager;

SceneManager = function() {
    function SceneManager() {}
    var instance;
    return instance = null, Singleton.SceneManager = function() {
        function SceneManager() {}
        return SceneManager.prototype.scenes = [], SceneManager.prototype.currentSceneIndex = void 0, 
        SceneManager.prototype.currentScene = function() {
            if (null == this.currentSceneIndex) throw new Error("SceneManager.setScene not called");
            if (this.isEmpty()) throw new Error("Requires at least one scene");
            return this.scenes[this.currentSceneIndex];
        }, SceneManager.prototype.addScene = function(scene) {
            var i;
            if (null == scene) throw new Error("missing scene param");
            return i = this.scenes.indexOf(scene), -1 === i ? this.scenes.push(scene) : void 0;
        }, SceneManager.prototype.removeScene = function(scene) {
            var i;
            if (null == scene) throw new Error("missing scene param");
            return i = this.scenes.indexOf(scene), this.removeSceneByIndex(i);
        }, SceneManager.prototype.removeSceneByIndex = function(i) {
            return i >= 0 ? (i === this.currentSceneIndex && (this.currentSceneIndex = void 0), 
            array.splice(i, 1)) : void 0;
        }, SceneManager.prototype.setScene = function(scene) {
            var i;
            if (null == scene) throw new Error("missing scene param");
            if (i = this.scenes.indexOf(scene), -1 === i) throw new Error("scene not added to SceneManager");
            return this.setSceneByIndex(i), this.currentScene();
        }, SceneManager.prototype.setSceneByIndex = function(i) {
            var debugMsg, e, scene;
            if (this.isEmpty() || !this.isValidIndex(i)) throw new Error("invalid scene index");
            this.currentSceneIndex = i, scene = this.currentScene(), debugMsg = "Changing to scene " + i;
            try {
                debugMsg += ": " + scene.constructor.name;
            } catch (error) {
                e = error;
            }
            return console.ce(debugMsg), scene;
        }, SceneManager.prototype.isEmpty = function() {
            return 0 === this.scenes.length;
        }, SceneManager.prototype.isValidIndex = function(i) {
            return i >= 0 && i < this.scenes.length;
        }, SceneManager.prototype.hasScene = function(scene) {
            return this.scenes.includes(scene);
        }, SceneManager.prototype.tick = function(tpf) {
            return this.currentScene().fullTick(tpf);
        }, SceneManager;
    }(), SceneManager.get = function() {
        return null != instance ? instance : instance = new Singleton.SceneManager();
    }, SceneManager.currentScene = function() {
        return this.get().currentScene();
    }, SceneManager.addScene = function(scene) {
        return this.get().addScene(scene);
    }, SceneManager;
}();

var NetworkManager;

NetworkManager = function() {
    function NetworkManager() {}
    var instance;
    return instance = null, Singleton.NetworkManager = function() {
        function NetworkManager() {}
        return NetworkManager.prototype.socket = void 0, NetworkManager.prototype.inputId = 0, 
        NetworkManager.prototype.connect = function(namespace) {
            return null == namespace && (namespace = "/"), this.socket = io.connect(namespace);
        }, NetworkManager.prototype.getSessionId = function() {
            return null != this.socket ? this.socket.socket.sessionid : void 0;
        }, NetworkManager.prototype.on = function(event, func) {
            return this.socket.on(event, func);
        }, NetworkManager.prototype.rawEmit = function(name, data) {
            return null == data && (data = {}), data = this._prepareData(data), this.socket.emit(name, data);
        }, NetworkManager.prototype.fakeEmit = function(name, data) {
            return null == data && (data = {}), this._prepareData(data);
        }, NetworkManager.prototype._prepareData = function(data) {
            return null == data && (data = {}), data.timestamp = new Date().getTime(), data.inputId = this.inputId, 
            this.inputId += 1, data;
        }, NetworkManager.prototype.emit = function(data) {
            if (null == data && null == data.type) throw "data.type missing";
            return this.rawEmit("data", data);
        }, NetworkManager.prototype.fake = function(data) {
            if (null == data && null == data.type) throw "data.type missing";
            return this.fakeEmit("data", data);
        }, NetworkManager.prototype._hasListener = function(name) {
            return this.socket.listeners(name).any();
        }, NetworkManager;
    }(), NetworkManager.get = function() {
        return null != instance ? instance : instance = new Singleton.NetworkManager();
    }, NetworkManager.connect = function(namespace) {
        return this.get().connect(namespace);
    }, NetworkManager.getSessionId = function() {
        return this.get().getSessionId();
    }, NetworkManager.on = function(event, func) {
        return this.get().on(event, fund);
    }, NetworkManager.rawEmit = function(name, data) {
        return this.get().rawEmit(name, data);
    }, NetworkManager.fakeEmit = function(name, data) {
        return this.get().fakeEmit(name, data);
    }, NetworkManager.emit = function(data) {
        return this.get().emit(data);
    }, NetworkManager;
}();

var StatsManager;

StatsManager = function() {
    function StatsManager() {}
    var instance;
    return instance = null, Singleton.StatsManager = function() {
        function StatsManager() {
            this.stats = new Stats(), this.stats.domElement.style.position = "absolute", this.stats.domElement.style.top = "0px", 
            this.rendererStats = new THREEx.RendererStats(), this.rendererStats.domElement.style.position = "absolute", 
            this.rendererStats.domElement.style.left = "0px", this.rendererStats.domElement.style.bottom = "0px";
        }
        return StatsManager.prototype.statsVisible = !1, StatsManager.prototype.toggle = function() {
            return this.statsVisible = !this.statsVisible, this.statsVisible ? (document.body.appendChild(this.stats.domElement), 
            document.body.appendChild(this.rendererStats.domElement)) : (document.body.removeChild(this.stats.domElement), 
            document.body.removeChild(this.rendererStats.domElement)), this.statsVisible;
        }, StatsManager.prototype.setVisible = function(value) {
            return value !== this.statsVisible ? this.toggle() : void 0;
        }, StatsManager.prototype.update = function(renderer) {
            return this.statsVisible ? (this.stats.update(), this.rendererStats.update(renderer)) : void 0;
        }, StatsManager;
    }(), StatsManager.get = function() {
        return null != instance ? instance : instance = new Singleton.StatsManager();
    }, StatsManager.toggle = function() {
        return this.get().toggle();
    }, StatsManager.setVisible = function() {
        return this.get().setVisible();
    }, StatsManager.update = function(renderer) {
        return this.get().update(renderer);
    }, StatsManager;
}();

var SoundManager;

SoundManager = function() {
    function SoundManager() {}
    var instance;
    return instance = null, Singleton.SoundManager = function() {
        function SoundManager() {}
        return SoundManager.prototype.items = {}, SoundManager.prototype.loadCount = 0, 
        SoundManager.prototype.load = function(key, url) {
            var howl;
            if (void 0 === this.items[key]) return this.items[key] = null, url instanceof Array || (url = [ url ]), 
            howl = new Howl({
                autoplay: !1,
                urls: url,
                onload: function() {
                    return window.SoundManager.get()._loaded(key, howl);
                }
            });
        }, SoundManager.prototype._loaded = function(key, howl) {
            return this.items[key] = howl, this.loadCount += 1;
        }, SoundManager.prototype.cmd = function(options) {
            if (null == options && (options = {}), null == options.type) throw new Error("options.type missing");
            if (null == options.key) throw new Error("options.key missing");
            if (!(options.key in this.items)) throw new Error("Sound with key: " + options.key + " not found!");
            switch (options.type) {
              case "play":
              case "pause":
              case "stop":
                this.items[options.key][options.type]();
                break;

              case "fadeIn":
              case "fadeOut":
                null == options.to && (options.to = 1), null == options.duration && (options.duration = 1e3), 
                this.items[options.key][options.type](options.to, options.duration);
                break;

              case "volume":
              case "volumeAll":
                null == options.volume && (options.volume = 1), "volume" === options.type ? this.items[options.key][options.type](options.volume) : this.volumeAll(options.volume);
                break;

              case "loop":
                null == options.loop && (options.loop = !1), this.items[options.key][options.type](options.loop);
                break;

              default:
                throw new Error("unknown options.type " + options.type);
            }
            return this.items[options.key];
        }, SoundManager.prototype.play = function(key) {
            return this.cmd({
                type: "play",
                key: key
            });
        }, SoundManager.prototype.pause = function(key) {
            return this.cmd({
                type: "pause",
                key: key
            });
        }, SoundManager.prototype.stop = function(key) {
            return this.cmd({
                type: "stop",
                key: key
            });
        }, SoundManager.prototype.fadeIn = function(key, to) {
            return this.cmd({
                type: "fadeIn",
                key: key,
                to: to,
                duration: duration
            });
        }, SoundManager.prototype.fadeOut = function(key, to) {
            return this.cmd({
                type: "fadeOut",
                key: key,
                to: to,
                duration: duration
            });
        }, SoundManager.prototype.volume = function(key, volume) {
            return this.cmd({
                type: "volume",
                key: key,
                volume: volume
            });
        }, SoundManager.prototype.looping = function(key, looping) {
            return this.cmd({
                type: "loop",
                key: key,
                loop: looping
            });
        }, SoundManager.prototype.hasFinishedLoading = function() {
            return this.loadCount === Object.keys(this.items).size();
        }, SoundManager.prototype.volumeAll = function(i) {
            var key;
            0 > i && (i = 0), i > 1 && (i = 1);
            for (key in this.items) this.volume(key, i);
            return i;
        }, SoundManager.prototype.has = function(key) {
            return null != this.items[key];
        }, SoundManager;
    }(), SoundManager.get = function() {
        return null != instance ? instance : instance = new Singleton.SoundManager();
    }, SoundManager.has = function(key) {
        return this.get().has(key);
    }, SoundManager.play = function(key) {
        return this.get().play(key);
    }, SoundManager.pause = function(key) {
        return this.get().pause(key);
    }, SoundManager.stop = function(key) {
        return this.get().stop(key);
    }, SoundManager.fadeIn = function(key, to) {
        return this.get().fadeIn(key, to);
    }, SoundManager.fadeOut = function(key, to) {
        return this.get().fadeOut(key, to);
    }, SoundManager.volume = function(key, volume) {
        return this.get().volume(key, volume);
    }, SoundManager.looping = function(key, looping) {
        return this.get().looping(key, looping);
    }, SoundManager.volumeAll = function(i) {
        return this.get().volumeAll(i);
    }, SoundManager.load = function(key, url) {
        return this.get().load(key, url);
    }, SoundManager.cmd = function(options) {
        return this.get().cmd(options);
    }, SoundManager.hasFinishedLoading = function() {
        return this.get().hasFinishedLoading();
    }, SoundManager;
}();

var SaveObjectManager;

SaveObjectManager = function() {
    function SaveObjectManager() {}
    var instance;
    return instance = null, Singleton.SaveObjectManager = function() {
        function SaveObjectManager() {}
        return SaveObjectManager.prototype.items = {}, SaveObjectManager.prototype.loadCount = 0, 
        SaveObjectManager.prototype.load = function(key, url) {
            var request;
            if (void 0 === this.items[key]) return this.items[key] = null, request = new XMLHttpRequest(), 
            request.open("GET", url, !0), request.onload = function() {
                var data, som;
                if (request.status >= 200 && request.status < 400) {
                    try {
                        data = JSON.parse(request.responseText);
                    } catch (error) {
                        return void console.log("invalid json " + url);
                    }
                    som = window.SaveObjectManager.get(), som.items[key] = data, som._load();
                }
            }, request.onerror = function() {
                console.log("error loading " + url);
            }, request.send(), this;
        }, SaveObjectManager.prototype.hasFinishedLoading = function() {
            return this.loadCount === Object.keys(this.items).size();
        }, SaveObjectManager.prototype._load = function() {
            return window.SaveObjectManager.get().loadCount += 1;
        }, SaveObjectManager;
    }(), SaveObjectManager.get = function() {
        return null != instance ? instance : instance = new Singleton.SaveObjectManager();
    }, SaveObjectManager.hasFinishedLoading = function() {
        return this.get().hasFinishedLoading();
    }, SaveObjectManager.load = function() {
        return this.get().load(key, url);
    }, SaveObjectManager;
}();

var HighScoreManager;

HighScoreManager = function() {
    function HighScoreManager() {}
    var instance;
    return instance = null, Singleton.HighScoreManager = function() {
        function HighScoreManager() {}
        return HighScoreManager.prototype.apiKey = "guest", HighScoreManager.prototype.secret = "guest", 
        HighScoreManager.prototype.auth = function(apiKey, secret, tryRegister) {
            return null == tryRegister && (tryRegister = !1), tryRegister && jNorthPole.createUser(apiKey, secret, function(data) {
                return console.log("api key registered: " + apiKey);
            }), this._setTokens(apiKey, secret), this._ensureTokenPresence(), this;
        }, HighScoreManager.prototype._setTokens = function(apiKey, secret) {
            return this.apiKey = apiKey, this.secret = secret;
        }, HighScoreManager.prototype.addScore = function(name, score) {
            var json;
            if (this._ensureTokenPresence(), null == name) throw new Error("name required");
            if (!isNumeric(score)) throw new Error("score needs to be a number");
            return json = {
                api_key: this.apiKey,
                secret: this.secret,
                type: "highscore",
                name: name,
                score: score
            }, jNorthPole.createStorage(json, this.responseHandler, this.errorHandler);
        }, HighScoreManager.prototype.getScores = function(limit, order) {
            var json;
            return null == limit && (limit = 10), null == order && (order = "desc"), this._ensureTokenPresence(), 
            json = {
                api_key: this.apiKey,
                secret: this.secret,
                type: "highscore",
                __limit: limit,
                __sort: {
                    score: order
                }
            }, jNorthPole.getStorage(json, this.responseHandler, this.errorHandler);
        }, HighScoreManager.prototype.responseHandler = function(data) {
            return console.log(data);
        }, HighScoreManager.prototype.errorHandler = function(data, status) {
            return console.log(data);
        }, HighScoreManager.prototype._ensureTokenPresence = function() {
            if (null == this.apiKey) throw new Error("apiKey missing");
            if (null == this.secret) throw new Error("secret missing");
        }, HighScoreManager;
    }(), HighScoreManager.get = function() {
        return null != instance ? instance : instance = new Singleton.HighScoreManager();
    }, HighScoreManager.auth = function(apiKey, secret, tryRegister) {
        return this.get().auth(apiKey, secret, tryRegister);
    }, HighScoreManager.addScore = function(name, score) {
        return this.get().addScore(name, score);
    }, HighScoreManager.getScores = function(limit, order) {
        return this.get().getScores(limit, order);
    }, HighScoreManager;
}();

var Persist;

Persist = function() {
    function Persist() {
        this.storage = localStorage;
    }
    return Persist.PREFIX = "ce", Persist.DEFAULT_SUFFIX = "default", Persist.prototype.setJson = function(key, value, def) {
        return null == def && (def = void 0), value = JSON.stringify(value), null != def && (def = JSON.stringify(def)), 
        this.set(key, value, def);
    }, Persist.prototype.set = function(key, value, def) {
        if (null == def && (def = void 0), null == key) throw "key missing";
        return this.storage[Persist.PREFIX + "." + key] = value, null != def ? this["default"](key, def) : void 0;
    }, Persist.prototype.defaultJson = function(key, value) {
        return value = JSON.stringify(value), this["default"](key, value);
    }, Persist.prototype["default"] = function(key, value) {
        return this.set(key + "." + Persist.DEFAULT_SUFFIX, value);
    }, Persist.prototype.getJson = function(key) {
        var item;
        return item = this.get(key), null != item ? JSON.parse(item) : void 0;
    }, Persist.prototype.get = function(key) {
        var value;
        return value = this._get(key), null == value ? this._get(key + "." + Persist.DEFAULT_SUFFIX) : value;
    }, Persist.prototype._get = function(key) {
        var value;
        if (null == key) throw "key missing";
        return value = this.storage[Persist.PREFIX + "." + key], isNumeric(value) ? Number(value) : "true" === value ? !0 : "false" === value ? !1 : "undefined" !== value ? value : void 0;
    }, Persist.prototype.rm = function(key) {
        if (null == key) throw "key missing";
        return this.storage.removeItem(Persist.PREFIX + "." + key);
    }, Persist.prototype.clear = function(exceptions, withDefaults) {
        var results, storage;
        null == exceptions && (exceptions = []), null == withDefaults && (withDefaults = !1), 
        exceptions instanceof Array || (exceptions = [ exceptions ]), results = [];
        for (storage in this.storage) storage.endsWith("." + Persist.DEFAULT_SUFFIX) && withDefaults === !1 || (exceptions.includes(storage) ? results.push(void 0) : results.push(this.rm(storage)));
        return results;
    }, Persist.sessionStorage = function() {
        var persist;
        return persist = new Persist(), persist.storage = sessionStorage, persist;
    }, Persist.getJson = function(key) {
        return new Persist().getJson(key);
    }, Persist.get = function(key) {
        return new Persist().get(key);
    }, Persist.setJson = function(key, value, def) {
        return new Persist().setJson(key, value, def);
    }, Persist.set = function(key, value, def) {
        return new Persist().set(key, value, def);
    }, Persist["default"] = function(key, value) {
        return new Persist()["default"](key, value);
    }, Persist.defaultJson = function(key, value) {
        return new Persist().defaultJson(key, value);
    }, Persist.rm = function(key) {
        return new Persist().rm(key);
    }, Persist.clear = function(exceptions, withDefaults) {
        return new Persist().clear(exceptions, withDefaults);
    }, Persist;
}();

var Utils;

Utils = function() {
    function Utils() {}
    return Utils.JSON_URLS = [ ".json" ], Utils.IMG_URLS = [ ".png", ".jpg", ".jpeg" ], 
    Utils.SAVE_URLS = [ ".save.json" ], Utils.AUDIO_URLS = [ ".mp3", ".ogg", ".wav" ], 
    Utils.CAMERA_DEFAULT_VIEW_ANGLE = 45, Utils.CAMERA_DEFAULT_NEAR = 1, Utils.CAMERA_DEFAULT_FAR = 1e5, 
    Utils.CAMERA_DEFAULT_TYPE = "PerspectiveCamera", Utils.SKY_SPHERE_DEFAULT_RADIUS = 5e4, 
    Utils.SKY_SPHERE_DEFAULT_SEGMENTS = 64, Utils.PLANE_DEFAULT_COLOR = "#ff0000", Utils.PLANE_DEFAULT_WIDTH = 5, 
    Utils.PLANE_DEFAULT_HEIGHT = 5, Utils.PLANE_DEFAULT_W_SEGMENTS = 1, Utils.PLANE_DEFAULT_H_SEGMENTS = 1, 
    Utils.AMBIENT_LIGHT_DEFAULT_COLOR = "#404040", Utils.LIGHT_DEFAULT_COLOR = "#ffffff", 
    Utils.LIGHT_DEFAULT_POSITION_X = 0, Utils.LIGHT_DEFAULT_POSITION_Y = 100, Utils.LIGHT_DEFAULT_POSITION_Z = 60, 
    Utils.POINT_LIGHT_DEFAULT_COLOR = "#ffffff", Utils.POINT_LIGHT_DEFAULT_INTENSITY = 1, 
    Utils.POINT_LIGHT_DEFAULT_DISTANCE = 100, Utils.POINT_LIGHT_DEFAULT_DECAY = 1, Utils.MIRROR_DEFAULT_COLOR = "#777777", 
    Utils.MIRROR_DEFAULT_TEXTURE_WIDTH = 512, Utils.MIRROR_DEFAULT_TEXTURE_HEIGHT = 512, 
    Utils.MIRROR_DEFAULT_CLIP_BIAS = .003, Utils.WATER_DEFAULT_WATER_COLOR = "#001e0f", 
    Utils.WATER_DEFAULT_ALPHA = 1, Utils.CE_BUTTON_POSITIONS = [ "top-right", "bottom-right", "top-left", "bottom-left" ], 
    Utils.CE_BUTTON_TYPES = [ "fullscreen", "reinit" ], Utils.CE_UI_Z_INDEX = 1e3, Utils.ORIENTATIONS = [ "all", "landscape", "portrait" ], 
    Utils.FADE_DEFAULT_DURATION = 1e3, Utils.toggleFullscreen = function() {
        document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ? document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen && document.webkitExitFullscreen() : document.documentElement.requestFullscreen ? document.documentElement.requestFullscreen() : document.documentElement.msRequestFullscreen ? document.documentElement.msRequestFullscreen() : document.documentElement.mozRequestFullScreen ? document.documentElement.mozRequestFullScreen() : document.documentElement.webkitRequestFullscreen && document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }, Utils.guid = function() {
        var s4;
        return s4 = function() {
            return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
        }, s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
    }, Utils.setCursor = function(url) {
        return document.body.style.cursor = "url('" + url + "'), auto";
    }, Utils.rgbToHex = function(r, g, b) {
        if (r > 255 || g > 255 || b > 255) throw "Invalid color component";
        return (r << 16 | g << 8 | b).toString(16);
    }, Utils.getKeyName = function(url, array) {
        return url.replaceAny(array, "").split("/").last();
    }, Utils.encrypt = function(json) {
        var s;
        return s = JSON.stringify(json), window.btoa(s);
    }, Utils.decrypt = function(s) {
        return JSON.parse(window.atob(s));
    }, Utils.saveFile = function(content, fileName, format) {
        var blob, e, isFileSaverSupported, json;
        null == format && (format = "application/json");
        try {
            isFileSaverSupported = !!new Blob();
        } catch (error) {
            throw e = error, "FileSaver not supported";
        }
        return json = JSON.stringify(content, null, 2), blob = new Blob([ json ], {
            type: format + ";charset=utf-8"
        }), saveAs(blob, fileName);
    }, Utils.addCEButton = function(options) {
        var img, posArray;
        if (null == options && (options = {}), null == options.size && (options.size = "32px"), 
        null == options.padding && (options.padding = "32px"), null == options.position && (options.position = "bottom-right"), 
        null == options.type && (options.type = "fullscreen"), options.size.endsWith("px") || (options.size = options.size + "px"), 
        options.padding.endsWith("px") || (options.padding = options.padding + "px"), !Utils.CE_BUTTON_TYPES.includes(options.type)) throw new Error("invalid type " + options.type);
        if (!document.querySelector(".ce-button-" + options.type)) {
            if (!Utils.CE_BUTTON_POSITIONS.includes(options.position)) throw new Error("invalid position " + options.position);
            return posArray = options.position.split("-"), img = document.createElement("img"), 
            img.style = "position: absolute; width: " + options.size + "; height: " + options.size + ";" + (posArray[0] + ": " + options.padding + "; " + posArray[1] + ": " + options.padding), 
            img.setAttribute("class", "ce-button-" + options.type), "fullscreen" === options.type ? (img.setAttribute("onclick", "Utils.toggleFullscreen()"), 
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AYMDR07WbntUQAAAMZJREFUWMPtl7ENgzAQRR+IkhFYIdUVUTKP9wjswSCZIBHFVVmBEVKbNBTIMsFBcpLiXnlC9ke+7/suRGQinU5V23cfiEgLXFIXLPkxJqCK1J7AY0XcmLDmCAyRugcOQL0sFpEmvKvqOcffisgNOG0dQfnNI7cmNAEV0O2w2l564IphGEYwjsOMN6pqn2kcO6AJb8IwQA7zjZUDBxxtGJmALQE+434+ZsPpg1jeb1l0tppLjeWxd0EdRucFKWGiCa1mTfjXAl7JzisvsBIkfgAAAABJRU5ErkJggg==") : "reinit" === options.type && (img.setAttribute("onclick", "engine.initScene(SceneManager.currentScene())"), 
            img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfgBgwNMCmKKsb2AAACbklEQVRIx5XVz2tcVRQH8M971dZ01GppNWbhSHFjdJXTookiCOpGChKKVv8E68Yfiy6sol0J1l3ddCmIOxfBleBCyISqZ1BoxIUUuxCNJdVYiaEQdDF3zEzn1XG+m8u795zvvfec+77fSkHI3njEvCMeczQvGEI/YhiVnbR5C+7tL2Q1GhxP5WfX09wU73peeyT2e034MLY858tBktrbWv4eCV1pJLim7Xy8l2KAYFPb+ghFZ66JoAavxec7FHWyqe3X60/QbSJ4v4xPxHKfol/EM14djGwqIcQhF0yBM/l6IQjC18MlzAduQMBt1grFI86nmmSprP9UatFcQiRXzZaPjxN1iGfdA067v5SzuYSFIn90EtwXx0JFfOUwtnIq2OuSAx7KVf+J+FMLK7lQR8th8BalI5vj0nEazMettWfK1Llyx83tO43HuTI+WXsYXM7f+nf85tr4/Lzid/B4Xf6Db02KXuNnanfAyEscj3VwoC5vsZqYYBvsql0FBycmuAts1H4AcxMT9DIu1kUb9kd7kuxo299rR+3TMvfCRPv3o5cqIs3hr9w7wQk2TaGbsSvYcAw3z2z//MX/TH/D0+CVmdUK4hd3gwd9l+OSmdX7V9Zymppgsax2tWJcektf7RajJ5MpO86C3db/lYtmzFq3G3yQnezrbMiXLaOyx2qcuuH+p6zao0InTwyLqhTLFkrklnd8lJeG+v6iN93SF/18tG8u1aDzxVkvDWx4RddlHDRXno1y+BM73lQNm2fM+6R0pBlrFrMzbG2DistKTjuu0VV0Hc9pHUP22uTBUtzuqHDIPmy4KC3lH00G/w/Uq7TDOW+poQAAAABJRU5ErkJggg=="), 
            null != options.src && (img.src = options.src), document.body.appendChild(img);
        }
    }, Utils.isMobile = function() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }, Utils.orientation = function(orientation) {
        var a1, a2, baseStyle, div, existingElement, existingStyle, img, style;
        if (null == orientation && (orientation = "all"), existingElement = document.querySelector(".ce-turn-screen"), 
        null != existingElement && document.body.removeChild(existingElement), existingStyle = document.querySelector(".ce-turn-screen-style"), 
        null != existingStyle && document.head.removeChild(existingStyle), "all" !== orientation) {
            if (!Utils.ORIENTATIONS.includes(orientation)) throw new Error("invalid orientation type '" + orientation + "'");
            return div = document.createElement("div"), div.setAttribute("class", "ce-turn-screen"), 
            div.style = "position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #f0f0f0; z-index: " + Utils.CE_UI_Z_INDEX + ";", 
            img = document.createElement("img"), img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4AYNDy012n9FrgAABkxJREFUeNrt3T1sG+cBgGGTRx3FH5GipADhjyGAg5EgaBa1BWog7dIgY5DFXQLEBRJ4yFI0S7aqyOAtS1B3bBEgWYIMLYJ0MZKxk7yoSzoYgmFRaAtRKgmSIU++6xKgi4eTJYo0+TzzR+l0pxffd+Tx7to1AAAAAAAAAOD/MnbB07Xb7d2HDx/uTvN37OzsJPb0bOzt7aX638/aVU9Xq9V+1263d+2J5SYQkSAQkSAQkSAQkSAQkSAQkSAQkSAQkbCocsv2BzcajReDIHg1CIJXgiBo53K57SAI6kEQbGaz2Vo2m13NZDLhOSK5Nu1P3NN+6svlX52w8IE0m80bKysrb4Rh+Nrq6urNlZWV5hRmkqlHghnk0rRarZ/m8/lbxWLxrTAM21e03BKJQOZ66fRCPp+/XSqV3s3n8zdmdE4iEoHM3RLq5UKh8MHa2trb2Ww2Pwcn7iIRyFyE8VKpVNotl8u3MpmMk1gE8sNSaqtYLH5UqVTey2QywTxt28nJye/NHgKZiXq9ngnD8M76+vrdXC63Pm/bJw6BzHI51a5UKn8qFos/n8ftE4dAZmZ7e/udWq32SRAEa1f1O5MkeZJ2+SYOgcxqSbVaKpXuVavVX1/2zz47OzudTCb7URTtR1G0H8fxQRzHnSRJ/pUkSffo6ChK84msOAQyqyVVo1qt/qVQKPz4Mn5eHMfj4XD4zXg8vh9F0f04jvePjo4udEmCOAQyqzh+tLGx8XUYhq0LLpOS4XD47Wg0+iyKoi87nc5/nXPwXAfSarVubm1tfR0EQfUCs8X3/X7/09Fo9PHh4eF3TshZiECuX7/+i83Nza+CICg/YxiTXq93bzQa3e10Ov+exjaKQyCzmjl+dpE4+v3+F4PB4MPDw8OH09pGcQhkZuccW1tbf3uWOKIo6pyent559OjRV9PcRnEIZFZxNDY2Np7pnKPX630+GAze73Q6p+Jg4QKp1+ur1Wr1r+d9typJkqjb7f7m4ODg3rS3URzMLJByufzHQqGwc57XnJ2d/ef4+PjNx48f/10cLGwg29vb71Qqldvnec1kMnnU7XZfPzw8/OdVbKM4mEkgzWazXavVPjnPa8bj8XfdbveXnU7nsUPGVbrS2/7U6/VMpVL583kuPPxh5hAHix9IGIZ3isXia+c55+h2u6+Lg4UPpNFobK2vr99NOz6O48nx8fGbV3XOATMNpFgsfnSebwKenJz89irerYKZB9JsNl+qVCrvpR3f6/U+Pzg4+IPDw1IEUiqVdtN+Qy+Kos5gMHjfoWEpAmk2my+Xy+Vbacefnp7emfblIzA3gRQKhQ/S3req3+9/Me0LD2FuAmk0Gi+sra29nWZsHMeTwWDwoUPC0gSSz+dvp70daK/XuzfN73PA3AVSKpXeTTl7fD8aje46HCxNIK1W6ydp77Le7/c/ndbXZGEuA8nn879KMy5JkmQ0Gn3sULBUgRSLxbfSjBsOh99O4+4jMLeBNJvNG2mf7DQajT5zGFiqQFZWVt5IeXI+jqLoS4eBpQokDMNUl7QPh8NvLvOOh/BcBLK6unozzbjxeHzfIWCpAmk0Gi+mfdRyFEUCYbkCCYLg1TTjzs7OTuM43ncIWLZAXkkzbjKZXPgRBPA8BpLq7d0oisweLF8guVxuO+US6x92P8s4g9TTjHvy5MmB3c8yBrKZZlySJB27n6ULJJvN1tKMi+PY1bssZSCrKWcQ3ztn+QLJZDJhmnFHR0cju595d+k3r37w4EFgt2IGAYGAQACBgEBAICAQEAgIBAQCAgGBAAIBgYBAQCAgEBAICAQEAgIBgQACAYHA5Ul947idnR0Pu5mR53Hf7+3tZcwgYIkFAgEEAgIBgYBAQCAgEHguXfoj2BblE1SebtmuqDCDgEBAICAQEAgIBAQCAgGBgEAAgYBAQCAgEBAICAQEAgIBgYBAAIGAQEAgIBAQCAgEBAICAYEAAgGBgEBAICAQmDc5u4BpWJRHtZlBQCAgEBAICAQEAgIBgYBAYAn5JJ2p2Nvby5hBwBILBAIIBAQCAgGBgEBAICAQEAgIBBAICAQEAgIBgYBAQCAgEBAICAQQCAgEBAICAYGAQEAgsFAu/e7ui/J8bDCDgEBAICAQEAgIBAQCAgGBAAAAAAAAAADAtf8BFNg15uCjV1oAAAAASUVORK5CYII=", 
            baseStyle = "position: absolute; margin: auto; top: 0; left: 0; right: 0; bottom: 0;", 
            "landscape" === orientation ? (img.style = baseStyle + "transform: rotate(90deg);", 
            a1 = "canvas#coffee-engine-dom", a2 = ".ce-turn-screen") : (img.style = baseStyle, 
            a1 = ".ce-turn-screen", a2 = "canvas#coffee-engine-dom"), style = document.createElement("style"), 
            style.setAttribute("class", "ce-turn-screen-style"), style.setAttribute("type", "text/css"), 
            style.setAttribute("media", "all"), style.innerHTML = "@media all and (orientation:portrait) { " + a1 + " { display: none; } } @media all and (orientation:landscape) { " + a2 + " { display: none; } }", 
            document.head.appendChild(style), div.appendChild(img), document.body.appendChild(div);
        }
    }, Utils.overrideConsole = function() {
        return window._log = console.log, window._warn = console.warn, window._info = console.info, 
        window._error = console.error, window._ceOutput = "coffee-engine console >", console.log = function(message) {
            var html;
            window._ceOutput += "\n" + message, html = document.querySelector(".ce-console-text"), 
            null != html && (html.innerHTML = window._ceOutput, html.scrollTop = html.scrollHeight), 
            window._log.apply(console, arguments);
        }, console.info = function(message) {
            var html;
            window._ceOutput += "\n" + message, html = document.querySelector(".ce-console-text"), 
            null != html && (html.innerHTML = window._ceOutput, html.scrollTop = html.scrollHeight), 
            window._info.apply(console, arguments);
        }, console.warn = function(message) {
            var html;
            window._ceOutput += "\n" + message, html = document.querySelector(".ce-console-text"), 
            null != html && (html.innerHTML = window._ceOutput, html.scrollTop = html.scrollHeight), 
            window._warn.apply(console, arguments);
        }, console.error = function(message) {
            var html;
            window._ceOutput += "\n" + message, html = document.querySelector(".ce-console-text"), 
            null != html && (html.innerHTML = window._ceOutput, html.scrollTop = html.scrollHeight), 
            window._error.apply(console, arguments);
        };
    }, Utils.console = function() {
        var div, divText, existingElement, existingStyle, style;
        return null == window._ceOutput && this.overrideConsole(), existingElement = document.querySelector(".ce-console"), 
        null != existingElement ? (document.body.removeChild(existingElement), existingStyle = document.head.querySelector(".ce-console-style"), 
        null != existingStyle && document.head.removeChild(existingStyle), !1) : (div = document.createElement("div"), 
        div.setAttribute("class", "ce-console"), divText = document.createElement("div"), 
        divText.setAttribute("class", "ce-console-text"), "undefined" != typeof _ceOutput && null !== _ceOutput && (divText.innerHTML = _ceOutput), 
        style = document.createElement("style"), style.setAttribute("class", "ce-console-style"), 
        style.setAttribute("type", "text/css"), style.setAttribute("media", "all"), style.innerHTML = ".ce-console { position: absolute; top: 0px; left: 0px; width: 100%; z-index: 3; background-color: gray; } .ce-console-text { height: 120px; padding: 5px; overflow-y: scroll; white-space: pre; color: black; }", 
        document.head.appendChild(style), div.appendChild(divText), document.body.appendChild(div), 
        !0);
    }, Utils.fade = function(options) {
        var animationEvent, div, existingElement, existingStyle, pointerEvents, style;
        return null == options && (options = {}), null == options.duration && (options.duration = Utils.FADE_DEFAULT_DURATION), 
        options.duration = options.duration / 1e3, null == options.type && (options.type = "in"), 
        "in" === options.type ? (options.opacityFrom = 0, options.opacityTo = 1) : (options.opacityFrom = 1, 
        options.opacityTo = 0), null == options.clickThrough && (options.clickThrough = !0), 
        existingElement = document.querySelector(".ce-fader"), null != existingElement && (document.body.removeChild(existingElement), 
        existingStyle = document.head.querySelector(".ce-fader-style"), null != existingStyle && document.head.removeChild(existingStyle)), 
        div = document.createElement("div"), div.setAttribute("class", "ce-fader"), options.clickThrough && (pointerEvents = "  pointer-events: none;"), 
        style = document.createElement("style"), style.setAttribute("class", "ce-fader-style"), 
        style.setAttribute("type", "text/css"), style.setAttribute("media", "all"), style.innerHTML = ".ce-fader { position: absolute; top: 0px; left: 0px; width: 100%; height: 100%; background-color: black; z-index: " + (Utils.CE_UI_Z_INDEX - 1) + "; " + pointerEvents + " -webkit-animation: fade-animation " + options.duration + "s; /* Safari, Chrome and Opera > 12.1 */ -moz-animation: fade-animation " + options.duration + "s; /* Firefox < 16 */ -ms-animation: fade-animation " + options.duration + "s; /* Internet Explorer */ -o-animation: fade-animation " + options.duration + "s; /* Opera < 12.1 */ animation: fade-animation " + options.duration + "s; } @keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } } /* Firefox < 16 */ @-moz-keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } } /* Safari, Chrome and Opera > 12.1 */ @-webkit-keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } } /* Internet Explorer */ @-ms-keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } } /* Opera < 12.1 */ @-o-keyframes fade-animation { from { opacity: " + options.opacityFrom + "; } to   { opacity: " + options.opacityTo + "; } }", 
        document.head.appendChild(style), document.body.appendChild(div), 0 === options.opacityTo && (animationEvent = whichAnimationEvent(), 
        animationEvent && div.addEventListener(animationEvent, function() {
            document.body.removeChild(div), document.head.removeChild(style);
        })), !0;
    }, Utils;
}(), exports.Utils = Utils;

var VirtualController;

VirtualController = function() {
    function VirtualController(options) {
        null == options && (options = {}), this.init(options);
    }
    return VirtualController.prototype.init = function(options) {
        return options = this._defaultOptions(options), this.joystick1 = new VirtualJoystick(options.joystick1), 
        this.joystick1.addEventListener("touchStartValidation", this._leftHalfTouch), this.joystick2 = new VirtualJoystick(options.joystick2), 
        this.joystick2.addEventListener("touchStartValidation", this._rightHalfTouch);
    }, VirtualController.prototype.isAvailable = function() {
        return VirtualJoystick.touchScreenAvailable();
    }, VirtualController.prototype._leftHalfTouch = function(event) {
        var touch;
        return touch = event.changedTouches[0], touch.pageX < window.innerWidth / 2;
    }, VirtualController.prototype._rightHalfTouch = function(event) {
        var touch;
        return touch = event.changedTouches[0], touch.pageX >= window.innerWidth / 2;
    }, VirtualController.prototype._defaultOptions = function(options) {
        var base, base1, base2, base3, base4, base5, base6;
        return null == options.joystick1 && (options.joystick1 = {}), null == (base = options.joystick1).strokeStyle && (base.strokeStyle = "cyan"), 
        null == (base1 = options.joystick1).limitStickTravel && (base1.limitStickTravel = !0), 
        null == (base2 = options.joystick1).mouseSupport && (base2.mouseSupport = !0), null == (base3 = options.joystick1).stickRadius && (base3.stickRadius = 60), 
        null == options.joystick2 && (options.joystick2 = {}), null == (base4 = options.joystick2).strokeStyle && (base4.strokeStyle = "orange"), 
        null == (base5 = options.joystick2).limitStickTravel && (base5.limitStickTravel = !0), 
        null == (base6 = options.joystick2).stickRadius && (base6.stickRadius = 0), options;
    }, VirtualController;
}();

var JsonModelManager;

JsonModelManager = function() {
    function JsonModelManager() {}
    var instance;
    return instance = null, Singleton.JsonModelManager = function() {
        function JsonModelManager() {}
        return JsonModelManager.prototype.baseUrl = "", JsonModelManager.prototype.loader = new THREE.JSONLoader(), 
        JsonModelManager.prototype.items = {}, JsonModelManager.prototype.loadCount = 0, 
        JsonModelManager.prototype.load = function(key, url, callback) {
            return null == callback && (callback = function() {
                return {};
            }), void 0 === this.items[key] ? (this.items[key] = null, this.loader.load("" + this.baseUrl + url, function(geometry, materials) {
                var i, jmm, len, mat, mesh;
                for (jmm = window.JsonModelManager.get(), mesh = new THREE.SkinnedMesh(geometry, new THREE.MeshFaceMaterial(materials)), 
                i = 0, len = materials.length; len > i; i++) mat = materials[i], mat.skinning = !0;
                if (null != mesh.animations) throw "mesh already has animations. not overwriting default behaviour";
                return mesh = jmm.initAnimations(mesh), jmm.items[key] = mesh, jmm.loadCount += 1, 
                callback(mesh), this;
            })) : void 0;
        }, JsonModelManager.prototype.initAnimations = function(mesh) {
            var anim, animation, i, len, ref;
            if (null == mesh) throw new Error("missing param mesh");
            if (mesh.animations = [], mesh.animationsMixer = new THREE.AnimationMixer(mesh), 
            null != mesh.geometry.animations) for (ref = mesh.geometry.animations, i = 0, len = ref.length; len > i; i++) anim = ref[i], 
            animation = mesh.animationsMixer.clipAction(anim), animation.setEffectiveWeight(1), 
            mesh.animations.push(animation);
            return mesh;
        }, JsonModelManager.prototype.clone = function(key) {
            var mesh;
            if (null == this.items[key]) throw new Error("key '" + key + "' not found for JsonModelManager");
            return mesh = this._hack(this.items[key].clone()), this.initAnimations(mesh);
        }, JsonModelManager.prototype._hack = function(mesh) {
            return mesh.material = mesh.material.clone(), mesh.material.materials[0].map = mesh.material.materials[0].map.clone(), 
            mesh.material.materials[0].map.needsUpdate = !0, mesh;
        }, JsonModelManager.prototype.hasFinishedLoading = function() {
            return this.loadCount === Object.keys(this.items).size();
        }, JsonModelManager;
    }(), JsonModelManager.get = function() {
        return null != instance ? instance : instance = new Singleton.JsonModelManager();
    }, JsonModelManager.clone = function(key) {
        return this.get().clone(key);
    }, JsonModelManager.load = function(key, url, callback) {
        return this.get().load(key, url, callback);
    }, JsonModelManager.initAnimations = function(mesh) {
        return this.get().initAnimations(mesh);
    }, JsonModelManager;
}(), exports.JsonModelManager = JsonModelManager;

var TextureManager;

TextureManager = function() {
    function TextureManager() {}
    var instance;
    return instance = null, Singleton.TextureManager = function() {
        function TextureManager() {}
        return TextureManager.prototype.items = {}, TextureManager.prototype.loadCount = 0, 
        TextureManager.prototype.load = function(key, url, callback) {
            var loader, texture;
            return null == callback && (callback = function() {
                return {};
            }), void 0 === this.items[key] ? (this.items[key] = null, loader = new THREE.TextureLoader(), 
            texture = loader.load(url, function(image) {
                return setTimeout(function() {
                    return window.TextureManager.get()._load(image, key, callback);
                }, 100);
            }, void 0, function(err) {
                return console.log(err);
            }), this) : void 0;
        }, TextureManager.prototype.hasFinishedLoading = function() {
            return this.loadCount === Object.keys(this.items).size();
        }, TextureManager.prototype._load = function(image, key, callback) {
            return window.TextureManager.get().items[key] = image, window.TextureManager.get().loadCount += 1, 
            callback(key);
        }, TextureManager;
    }(), TextureManager.get = function() {
        return null != instance ? instance : instance = new Singleton.TextureManager();
    }, TextureManager.load = function(key, url, callback) {
        return this.get().load(key, url, callback);
    }, TextureManager.hasFinishedLoading = function() {
        return this.get().hasFinishedLoading();
    }, TextureManager;
}();

var MaterialManager;

MaterialManager = function() {
    function MaterialManager() {}
    var instance;
    return instance = null, Singleton.MaterialManager = function() {
        function MaterialManager() {}
        return MaterialManager.prototype.items = {}, MaterialManager.prototype.load = function(key, material) {
            return this.items[key] = material, this;
        }, MaterialManager.prototype.item = function(key) {
            throw new Error(key + " not found in MaterialManager");
        }, MaterialManager;
    }(), MaterialManager.get = function() {
        return null != instance ? instance : instance = new Singleton.MaterialManager();
    }, MaterialManager.load = function(key, material) {
        return this.get().load(key, material);
    }, MaterialManager.item = function(key) {
        return this.get().item(key);
    }, MaterialManager;
}();

var BaseScene;

BaseScene = function() {
    function BaseScene() {
        this.scene = new THREE.Scene(), this.jmm = JsonModelManager.get(), this.sm = SoundManager.get(), 
        this.config = Config.get(), this.som = SaveObjectManager.get(), this.tm = TextureManager.get(), 
        this.lastMousePosition = void 0, this.keyboard = new THREEx.KeyboardState(), this.loaded = !1, 
        this.uptime = 0;
    }
    return BaseScene.prototype.fullTick = function(tpf) {
        return this.uptime += tpf, this.scene.traverse(function(obj) {
            return null != obj.animationsMixer ? obj.animationsMixer.update(tpf) : void 0;
        }), this.tick(tpf);
    }, BaseScene.prototype.init = function(options) {
        throw "scene.init not implemented";
    }, BaseScene.prototype.uninit = function() {
        return this.clear();
    }, BaseScene.prototype.clear = function() {
        var child, children, i;
        for (children = this.scene.children, i = this.scene.children.length - 1; i >= 0; ) child = children[i], 
        child.clear(), this.scene.remove(child), i--;
    }, BaseScene.prototype.tick = function(tpf) {
        throw "scene.tick not implemented";
    }, BaseScene.prototype.doMouseEvent = function(event, raycaster) {
        throw "scene.doMouseEvent not implemented";
    }, BaseScene.prototype.doKeyboardEvent = function(event) {
        throw "scene.doKeyboardEvent not implemented";
    }, BaseScene.prototype.tweenLookAt = function(object, camera, duration, easing) {
        var endRotation, startRotation, tween;
        return null == duration && (duration = 1e3), null == easing && (easing = TWEEN.Easing.Cubic.InOut), 
        startRotation = camera.rotation.clone(), camera.lookAt(object.position), endRotation = camera.rotation.clone(), 
        camera.rotation.set(startRotation.x, startRotation.y, startRotation.z), tween = new TWEEN.Tween(startRotation).to(endRotation, duration).onUpdate(function() {
            camera.rotation.set(this.x, this.y, this.z);
        }).easing(easing).start();
    }, BaseScene.prototype.tweenMoveTo = function(object, camera, duration, easing) {
        var endPosition, startPosition, tween;
        return null == duration && (duration = 1e3), null == easing && (easing = TWEEN.Easing.Cubic.InOut), 
        startPosition = camera.position.clone(), endPosition = object.position.clone(), 
        tween = new TWEEN.Tween(camera.position).to(endPosition, duration).onUpdate(function() {
            camera.position.set(this.x, this.y, this.z);
        }).easing(easing).start();
    }, BaseScene;
}();

var BaseModel;

BaseModel = function() {
    function BaseModel() {
        this.visible = !1, this.mesh = void 0;
    }
    return BaseModel.prototype.setScale = function(i) {
        return this.mesh.scale.set(i, i, i);
    }, BaseModel.prototype.setOpacity = function(opacity) {
        return this.mesh.material.opacity = opacity;
    }, BaseModel.prototype.setPosition = function(pos) {
        return this.mesh.position.set(pos.x, pos.y, pos.z);
    }, BaseModel.prototype.setVisible = function(value) {
        return this.mesh.traverse(function(object) {
            return object.visible = value;
        }), this.visible = value;
    }, BaseModel.prototype.attachToBone = function(boneName, mesh) {
        var added;
        return added = !1, this.mesh instanceof THREE.SkinnedMesh ? this.mesh.traverse(function(object) {
            return added ? void 0 : object instanceof THREE.Bone && object.name === boneName ? (added = !0, 
            object.add(mesh)) : void 0;
        }) : void 0;
    }, BaseModel.prototype.detachFromBone = function(boneName, mesh) {
        return this.mesh instanceof THREE.SkinnedMesh ? this.mesh.traverse(function(object) {
            return object instanceof THREE.Bone && object.name === boneName ? object.remove(mesh) : void 0;
        }) : void 0;
    }, BaseModel.prototype.setSkin = function(key) {
        var tex;
        if (tex = TextureManager.get().items[key], null == tex) throw new Error("texture not loaded");
        return this.mesh.material.materials[0].map = tex;
    }, BaseModel.prototype.toggleWireframe = function() {
        var j, k, len, len1, material, mesh, ref, ref1, results;
        if (null != this.mesh) {
            if (null != this.mesh.material) {
                if (this.mesh.material.wireframe = !this.mesh.material.wireframe, null != this.mesh.material.materials) for (ref = this.mesh.material.materials, 
                j = 0, len = ref.length; len > j; j++) material = ref[j], material.wireframe = !material.wireframe;
                return this.mesh.material.wireframe;
            }
            if (null != this.mesh.children) {
                for (ref1 = this.mesh.children, results = [], k = 0, len1 = ref1.length; len1 > k; k++) mesh = ref1[k], 
                null != mesh.material && results.push(mesh.material.wireframe = !mesh.material.wireframe);
                return results;
            }
        }
    }, BaseModel.prototype.isHovered = function(raycaster) {
        return raycaster.intersectObject(this.mesh, !0).length > 0;
    }, BaseModel.prototype.animate = function(animationName, options) {
        var anim;
        return null == options && (options = {}), null == options.loop && (options.loop = !0), 
        null == options.reverse && (options.reverse = !1), null == options.timeScale && (options.timeScale = 1), 
        null == options.name && (options.name = animationName), options.reverse && (options.timeScale *= -1), 
        this.stopAnimations(), anim = this.animation(options.name), anim.setEffectiveTimeScale(options.timeScale), 
        options.loop ? (anim.clampWhenFinished = !1, anim.setLoop(THREE.LoopRepeat)) : options.reverse || (anim.clampWhenFinished = !0, 
        anim.setLoop(THREE.LoopOnce, 0)), anim.play(), options.reverse && options.loop === !1 && setTimeout(function() {
            return anim.stop();
        }, 1e3 * anim._clip.duration), anim;
    }, BaseModel.prototype.updateAnimations = function(tpf) {
        return null != this.mesh.animationsMixer ? this.mesh.animationsMixer.update(tpf) : void 0;
    }, BaseModel.prototype.stopAnimations = function() {
        var animation, j, len, ref, results;
        for (ref = this.mesh.animations, results = [], j = 0, len = ref.length; len > j; j++) animation = ref[j], 
        results.push(animation.stop());
        return results;
    }, BaseModel.prototype.isPlaying = function(animationName) {
        return this.animation(animationName).isRunning();
    }, BaseModel.prototype.animation = function(animationName) {
        var allAnimations, animation, animationIndex, j, len, ref;
        if (!(this.mesh instanceof THREE.SkinnedMesh)) throw "@mesh is not a THREE.SkinnedMesh";
        if (isNumeric(animationName)) {
            if (animationIndex = parseInt(animationName), animationIndex >= this.mesh.animations.size()) throw "Animation index " + animationIndex + " out of bounds";
            return this.mesh.animations[animationIndex];
        }
        for (ref = this.mesh.animations, j = 0, len = ref.length; len > j; j++) if (animation = ref[j], 
        animation._clip.name === animationName) return animation;
        throw allAnimations = this.mesh.animations.map(function(a) {
            return a.data.name;
        }), animationName + " not found. Possible animations are: " + allAnimations;
    }, BaseModel;
}();

var BaseControls;

BaseControls = function() {
    function BaseControls(jsonModel, keyboard) {
        this.enabled = !0, this.jsonModel = jsonModel, this.keyboard = keyboard, this.lock = !1, 
        this.moving = !1;
    }
    return BaseControls.KEY_BINDINGS = {
        UP: "w",
        DOWN: [ "s" ],
        LEFT: "a",
        RIGHT: "d"
    }, BaseControls.prototype.toggleLock = function(target) {
        return this.enabled ? (this.lock = !this.lock, this.lock ? this.target = target : this.target = void 0) : void 0;
    }, BaseControls.prototype.isPressed = function(bindings) {
        var binding, i, len;
        for (bindings instanceof Array || (bindings = [ bindings ]), i = 0, len = bindings.length; len > i; i++) if (binding = bindings[i], 
        this.keyboard.pressed(binding)) return !0;
        return !1;
    }, BaseControls.prototype.formatOutput = function() {
        return {
            moving: this.moving,
            lock: this.lock
        };
    }, BaseControls.prototype.withLock = function(tpf) {
        return null != this.target ? (this.jsonModel.model.lookAt(this.target.model.position), 
        this.isPressed(BaseControls.KEY_BINDINGS.UP) ? (this.jsonModel.model.translateZ(tpf), 
        this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.DOWN) ? (this.jsonModel.model.translateZ(-tpf), 
        this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.LEFT) ? (this.jsonModel.model.translateX(tpf), 
        this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.RIGHT) ? (this.jsonModel.model.translateX(-tpf), 
        this.moving = !0) : this.moving = !1, this.formatOutput()) : void 0;
    }, BaseControls.prototype.noLock = function(tpf) {
        return this.isPressed(BaseControls.KEY_BINDINGS.UP) ? (this.jsonModel.model.rotation.set(0, Math.PI, 0), 
        this.jsonModel.model.translateZ(tpf), this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.DOWN) ? (this.jsonModel.model.rotation.set(0, 0, 0), 
        this.jsonModel.model.translateZ(tpf), this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.LEFT) ? (this.jsonModel.model.rotation.set(0, -Math.PI / 2, 0), 
        this.jsonModel.model.translateZ(tpf), this.moving = !0) : this.isPressed(BaseControls.KEY_BINDINGS.RIGHT) ? (this.jsonModel.model.rotation.set(0, Math.PI / 2, 0), 
        this.jsonModel.model.translateZ(tpf), this.moving = !0) : this.moving = !1, this.formatOutput();
    }, BaseControls.prototype.tick = function(tpf) {
        var output;
        if (this.enabled) return output = this.lock ? this.withLock(tpf) : this.noLock(tpf), 
        this.jsonModel instanceof BaseModel && (this.moving ? this.jsonModel.isPlaying("walk") || (this.jsonModel.stopAnimations(), 
        this.jsonModel.animate("walk")) : this.jsonModel.isPlaying("idle") || (this.jsonModel.stopAnimations(), 
        this.jsonModel.animate("idle"))), output;
    }, BaseControls.prototype.doKeyboardEvent = function(event) {}, BaseControls.prototype.doMouseEvent = function(event, raycaster) {}, 
    BaseControls;
}();

var BaseParticle, BaseParticle2, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

BaseParticle = function(superClass) {
    function BaseParticle(texturePath) {
        var base, i, json, key, len, ref;
        if (json = {}, "string" == typeof texturePath) json = {
            group: {
                texture: THREE.ImageUtils.loadTexture(texturePath)
            }
        }; else {
            if (json = texturePath, null == json.group && (json.group = {}), null == (base = json.group).asset && (base.asset = {}), 
            null == json.group.asset.libPath) throw new Error("json.group.asset.libPath is required");
            key = Utils.getKeyName(json.group.asset.libPath, Utils.IMG_URLS), json.group.texture = TextureManager.get().items[key];
        }
        json = this.formatDefaults(json), this.particleGroup = new SPE.Group(json.group);
        for (key in json.emitter) if ("object" == typeof json.emitter[key]) {
            if (null == json.emitter[key]) continue;
            null != json.emitter[key].x && (json.emitter[key] = Helper.toVector3(json.emitter[key]));
        }
        for (ref = [ "colorStart", "colorMiddle", "colorEnd" ], i = 0, len = ref.length; len > i; i++) key = ref[i], 
        null != json.emitter[key] && (json.emitter[key] = new THREE.Color(json.emitter[key]));
        this.emitter = new SPE.Emitter(json.emitter), this.particleGroup.addEmitter(this.emitter), 
        this.mesh = this.particleGroup.mesh;
    }
    return extend(BaseParticle, superClass), BaseParticle.prototype.formatDefaults = function(json) {
        var attr, base, base1, base10, base11, base12, base13, base14, base15, base16, base17, base18, base19, base2, base20, base21, base22, base23, base24, base25, base26, base27, base28, base29, base3, base30, base31, base32, base33, base34, base35, base36, base37, base38, base39, base4, base40, base41, base42, base43, base44, base45, base46, base47, base48, base49, base5, base50, base51, base52, base53, base54, base55, base56, base57, base58, base6, base7, base8, base9, coord, i, j, len, len1, ref, ref1;
        for (null == json && (json = {}), null == json.group && (json.group = {}), null == (base = json.group).maxParticleCount && (base.maxParticleCount = 100), 
        null == (base1 = json.group).maxAge && (base1.maxAge = 3), null == (base2 = json.group).hasPerspective && (base2.hasPerspective = !0), 
        null == (base3 = json.group).colorize && (base3.colorize = !0), null == (base4 = json.group).blending && (base4.blending = 2), 
        null == (base5 = json.group).transparent && (base5.transparent = !0), null == (base6 = json.group).alphaTest && (base6.alphaTest = .5), 
        null == (base7 = json.group).depthWrite && (base7.depthWrite = !1), null == (base8 = json.group).depthTest && (base8.depthTest = !0), 
        null != json.group.fixedTimeStep && null == (base9 = json.group).fixedTimeStep && (base9.fixedTimeStep = .016), 
        null == (base10 = json.group).fog && (base10.fog = !0), null == json.emitter && (json.emitter = {}), 
        null == (base11 = json.emitter).type && (base11.type = "cube"), ref = [ "position", "positionSpread", "acceleration", "accelerationSpread", "velocity", "velocitySpread" ], 
        i = 0, len = ref.length; len > i; i++) for (attr = ref[i], null == (base12 = json.emitter)[attr] && (base12[attr] = {}), 
        ref1 = [ "x", "y", "z" ], j = 0, len1 = ref1.length; len1 > j; j++) coord = ref1[j], 
        null == (base13 = json.emitter[attr])[coord] && (base13[coord] = 0);
        return null == (base14 = json.emitter).radius && (base14.radius = 10), null == (base15 = json.emitter).radiusScale && (base15.radiusScale = {}), 
        null == (base16 = json.emitter.radiusScale).x && (base16.x = 1), null == (base17 = json.emitter.radiusScale).y && (base17.y = 1), 
        null == (base18 = json.emitter.radiusScale).z && (base18.z = 1), null == (base19 = json.emitter).speed && (base19.speed = 0), 
        null == (base20 = json.emitter).speedSpread && (base20.speedSpread = 0), null == (base21 = json.emitter).sizeStart && (base21.sizeStart = 10), 
        null == (base22 = json.emitter).sizeStartSpread && (base22.sizeStartSpread = 0), 
        null == (base23 = json.emitter).sizeMiddle && (base23.sizeMiddle = 10), null == (base24 = json.emitter).sizeMiddleSpread && (base24.sizeMiddleSpread = 0), 
        null == (base25 = json.emitter).sizeEnd && (base25.sizeEnd = 10), null == (base26 = json.emitter).sizeEndSpread && (base26.sizeEndSpread = 0), 
        null == (base27 = json.emitter).angleStart && (base27.angleStart = 0), null == (base28 = json.emitter).angleStartSpread && (base28.angleStartSpread = 0), 
        null == (base29 = json.emitter).angleMiddle && (base29.angleMiddle = 0), null == (base30 = json.emitter).angleMiddleSpread && (base30.angleMiddleSpread = 0), 
        null == (base31 = json.emitter).angleEnd && (base31.angleEnd = 0), null == (base32 = json.emitter).angleEndSpread && (base32.angleEndSpread = 0), 
        null == (base33 = json.emitter).angleAlignVelocity && (base33.angleAlignVelocity = !1), 
        null == (base34 = json.emitter).colorStart && (base34.colorStart = "white"), null == (base35 = json.emitter).colorStartSpread && (base35.colorStartSpread = {}), 
        null == (base36 = json.emitter.colorStartSpread).x && (base36.x = 0), null == (base37 = json.emitter.colorStartSpread).y && (base37.y = 0), 
        null == (base38 = json.emitter.colorStartSpread).z && (base38.z = 0), null == (base39 = json.emitter).colorMiddle && (base39.colorMiddle = "white"), 
        null == (base40 = json.emitter).colorMiddleSpread && (base40.colorMiddleSpread = {}), 
        null == (base41 = json.emitter.colorMiddleSpread).x && (base41.x = 0), null == (base42 = json.emitter.colorMiddleSpread).y && (base42.y = 0), 
        null == (base43 = json.emitter.colorMiddleSpread).z && (base43.z = 0), null == (base44 = json.emitter).colorEnd && (base44.colorEnd = "blue"), 
        null == (base45 = json.emitter).colorEndSpread && (base45.colorEndSpread = {}), 
        null == (base46 = json.emitter.colorEndSpread).x && (base46.x = 0), null == (base47 = json.emitter.colorEndSpread).y && (base47.y = 0), 
        null == (base48 = json.emitter.colorEndSpread).z && (base48.z = 0), null == (base49 = json.emitter).opacityStart && (base49.opacityStart = 1), 
        null == (base50 = json.emitter).opacityStartSpread && (base50.opacityStartSpread = 0), 
        null == (base51 = json.emitter).opacityMiddle && (base51.opacityMiddle = .5), null == (base52 = json.emitter).opacityMiddleSpread && (base52.opacityMiddleSpread = 0), 
        null == (base53 = json.emitter).opacityEnd && (base53.opacityEnd = 0), null == (base54 = json.emitter).opacityEndSpread && (base54.opacityEndSpread = 0), 
        null == (base55 = json.emitter).particlesPerSecond && (base55.particlesPerSecond = 100), 
        null == (base56 = json.emitter).emitterDuration && (base56.emitterDuration = null), 
        null == (base57 = json.emitter).alive && (base57.alive = 1), null == (base58 = json.emitter).isStatic && (base58.isStatic = 0), 
        json;
    }, BaseParticle.prototype.tick = function(tpf) {
        return this.particleGroup.tick(tpf);
    }, BaseParticle.fromJson = function(assetJson) {
        var json;
        if ("particle" !== assetJson.type) throw new Error("not a particle");
        if (null == assetJson.key) throw new Error("key missing");
        return json = SaveObjectManager.get().items[assetJson.key], new BaseParticle(json);
    }, BaseParticle;
}(BaseModel), BaseParticle2 = function(superClass) {
    function BaseParticle2(input) {
        var emitJson, emitter, group, i, j, json, jsonInput, len, len1, ref;
        for (this.groups = [], this.mesh = new THREE.Object3D(), eval("var jsonInput = " + input), 
        "undefined" != typeof jsonInput && null !== jsonInput || (jsonInput = []), i = 0, 
        len = jsonInput.length; len > i; i++) {
            for (json = jsonInput[i], group = new SPE.Group(json), ref = json.emitters, j = 0, 
            len1 = ref.length; len1 > j; j++) emitJson = ref[j], emitter = new SPE.Emitter(emitJson), 
            group.addEmitter(emitter);
            this.groups.push(group), this.mesh.add(group.mesh);
        }
    }
    return extend(BaseParticle2, superClass), BaseParticle2.prototype.tick = function(tpf) {
        var group, i, len, ref, results;
        for (ref = this.groups, results = [], i = 0, len = ref.length; len > i; i++) group = ref[i], 
        results.push(group.tick(tpf));
        return results;
    }, BaseParticle2.fromJson = function(assetJson) {
        var json;
        if ("particle" !== assetJson.type) throw new Error("not a particle");
        if (null == assetJson.key) throw new Error("key missing");
        return json = SaveObjectManager.get().items[assetJson.key], new BaseParticle2(json.particle);
    }, BaseParticle2;
}(BaseModel);

var Config;

Config = function() {
    function Config() {}
    var instance;
    return instance = null, Singleton.Config = function() {
        function Config() {}
        return Config.prototype.showStatsOnLoad = !1, Config.prototype.contextMenuDisabled = !0, 
        Config.prototype.antialias = !0, Config.prototype.anaglyph = !1, Config.prototype.stereoVR = !1, 
        Config.prototype.resize = !1, Config.prototype.width = 1280, Config.prototype.height = 1024, 
        Config.prototype.soundEnabled = !1, Config.prototype.debug = !1, Config.prototype.preventDefaultMouseEvents = !0, 
        Config.prototype.transparentBackground = !1, Config.prototype.sortObjects = !0, 
        Config.prototype.fillWindow = function() {
            return this.resize = !0, this.width = window.innerWidth, this.height = window.innerHeight;
        }, Config.prototype.toggleAnaglyph = function() {
            return this.anaglyph = !this.anaglyph;
        }, Config.prototype.toggleStats = function() {
            return StatsManager.toggle();
        }, Config.prototype.toggleSound = function() {
            return this.soundEnabled = !this.soundEnabled;
        }, Config.prototype.toggleDebug = function() {
            return this.debug = !this.debug;
        }, Config.prototype.toggleFullscreen = function() {
            return Utils.toggleFullscreen();
        }, Config;
    }(), Config.get = function() {
        return null != instance ? instance : instance = new Singleton.Config();
    }, Config.fillWindow = function() {
        return this.get().fillWindow();
    }, Config.toggleAnaglyph = function() {
        return this.get().toggleAnaglyph();
    }, Config.toggleStats = function() {
        return this.get().toggleStats();
    }, Config.toggleSound = function() {
        return this.get().toggleSound();
    }, Config.toggleDebug = function() {
        return this.get().toggleDebug();
    }, Config.toggleFullscreen = function() {
        return this.get().toggleFullscreen();
    }, Config;
}(), exports.Config = Config;

var Helper;

Helper = function() {
    function Helper() {}
    return Helper.zero = new THREE.Vector3(0, 0, 0), Helper.one = new THREE.Vector3(1, 1, 1), 
    Helper.up = new THREE.Vector3(0, 1, 0), Helper.down = new THREE.Vector3(0, -1, 0), 
    Helper.toggleFullscreen = Utils.toggleFullscreen, Helper.addCEButton = Utils.addCEButton, 
    Helper.orientation = Utils.orientation, Helper.fade = Utils.fade, Helper.guid = Utils.guid, 
    Helper.setCursor = Utils.setCursor, Helper.rgbToHex = Utils.rgbToHex, Helper.defaultTweenDuration = 1e3, 
    Helper.toVector3 = function(json) {
        return new THREE.Vector3(json.x, json.y, json.z);
    }, Helper.shallowClone = function(json) {
        return JSON.parse(JSON.stringify(json));
    }, Helper.random = function(min, max, mult) {
        return null == max && (max = min, min = 0), null != mult && (min *= mult, max *= mult), 
        Math.floor(Math.random() * (max - min + 1)) + min;
    }, Helper.distanceTo = function(v1, v2) {
        var dx, dy, dz;
        return dx = v1.x - v2.x, dy = v1.y - v2.y, dz = v1.z - v2.z, Math.sqrt(dx * dx + dy * dy + dz * dz);
    }, Helper.camera = function(options) {
        var config;
        return null == options && (options = {}), config = Config.get(), null == options.view_angle && (options.view_angle = Utils.CAMERA_DEFAULT_VIEW_ANGLE), 
        null == options.aspect && (options.aspect = config.width / config.height), null == options.near && (options.near = Utils.CAMERA_DEFAULT_NEAR), 
        null == options.far && (options.far = Utils.CAMERA_DEFAULT_FAR), options.type || (options.type = Utils.CAMERA_DEFAULT_TYPE), 
        new THREE[options.type](options.view_angle, options.aspect, options.near, options.far);
    }, Helper.light = function(options) {
        var base, base1, base2, light;
        return null == options && (options = {}), null == options.position && (options.position = {}), 
        null == (base = options.position).x && (base.x = Utils.LIGHT_DEFAULT_POSITION_X), 
        null == (base1 = options.position).y && (base1.y = Utils.LIGHT_DEFAULT_POSITION_Y), 
        null == (base2 = options.position).z && (base2.z = Utils.LIGHT_DEFAULT_POSITION_Z), 
        null == options.color && (options.color = Utils.LIGHT_DEFAULT_COLOR), light = new THREE.DirectionalLight(options.color), 
        light.position.set(options.position.x, options.position.y, options.position.z), 
        light.castShadow = !0, light.shadow.camera.left = -60, light.shadow.camera.top = -60, 
        light.shadow.camera.right = 60, light.shadow.camera.bottom = 60, light.shadow.camera.near = 1, 
        light.shadow.camera.far = 1e3, light.shadow.bias = -1e-4, light.shadow.mapSize.width = light.shadow.mapSize.height = 1024, 
        light.shadow.darkness = .7, light;
    }, Helper.directionalLight = function(options) {
        return null == options && (options = {}), this.light(options);
    }, Helper.ambientLight = function(options) {
        return null == options && (options = {}), null == options.color && (options.color = Utils.AMBIENT_LIGHT_DEFAULT_COLOR), 
        new THREE.AmbientLight(options.color);
    }, Helper.pointLight = function(options) {
        return null == options && (options = {}), null == options.color && (options.color = Utils.POINT_LIGHT_DEFAULT_COLOR), 
        null == options.intensity && (options.intensity = Utils.POINT_LIGHT_DEFAULT_INTENSITY), 
        null == options.distance && (options.distance = Utils.POINT_LIGHT_DEFAULT_DISTANCE), 
        null == options.decay && (options.decay = Utils.POINT_LIGHT_DEFAULT_DECAY), new THREE.PointLight(options.color, options.intensity, options.distance, options.decay);
    }, Helper.cube = function(options) {
        var box, mat;
        return null == options && (options = {}), null == options.size && (options.size = 1), 
        null == options.material && (options.material = "MeshNormalMaterial"), null == options.color && (options.color = 16711680), 
        box = new THREE.BoxGeometry(options.size, options.size, options.size), mat = null != options.map ? new THREE.MeshBasicMaterial({
            map: TextureManager.get().items[options.map],
            transparent: !0,
            side: THREE.DoubleSide
        }) : new THREE[options.material]({
            color: options.color
        }), new THREE.Mesh(box, mat);
    }, Helper.model = function(options) {
        if (null == options && (options = {}), null == options.key) throw new Error("key missing for: " + JSON.stringify(options));
        return JsonModelManager.clone(options.key);
    }, Helper.terrain = function(options) {
        return null == options && (options = {}), Terrain.fromJson(options);
    }, Helper.particle = function(options) {
        return null == options && (options = {}), BaseParticle2.fromJson(options);
    }, Helper.mirror = function(engine, options) {
        return null == options && (options = {}), new Mirror(engine, options);
    }, Helper.water = function(engine, scene, options) {
        return null == options && (options = {}), new Water(engine, scene, options);
    }, Helper.graffiti = function(assetJson) {
        var json, material, plane;
        if ("graffiti" !== assetJson.type) throw new Error("not a graffiti");
        if (null == assetJson.key) throw new Error("key missing");
        return json = SaveObjectManager.get().items[assetJson.key], material = MaterialManager.get().items[assetJson.key], 
        null == material && (this.art = new ArtGenerator({
            width: json.width,
            height: json.height
        }), this.art.fromJson(json), material = this.materialFromCanvas(this.art.canvas)), 
        plane = this.plane(json.plane), plane.material = material, plane;
    }, Helper.plane = function(options) {
        var geometry, material;
        return null == options && (options = {}), null != options.size ? (options.width = options.size, 
        options.height = options.size) : (null == options.width && (options.width = Utils.PLANE_DEFAULT_WIDTH), 
        null == options.height && (options.height = Utils.PLANE_DEFAULT_HEIGHT)), null == options.wSegments && (options.wSegments = Utils.PLANE_DEFAULT_W_SEGMENTS), 
        null == options.hSegments && (options.hSegments = Utils.PLANE_DEFAULT_H_SEGMENTS), 
        null == options.color && (options.color = Utils.PLANE_DEFAULT_COLOR), null == options["class"] && (options["class"] = "PlaneBufferGeometry"), 
        material = null != options.map ? new THREE.MeshBasicMaterial({
            map: TextureManager.get().items[options.map],
            side: THREE.DoubleSide
        }) : null != options.material ? options.material : new THREE.MeshBasicMaterial({
            color: options.color,
            side: THREE.DoubleSide
        }), geometry = new THREE[options["class"]](options.width, options.height, options.wSegments, options.hSegments), 
        new THREE.Mesh(geometry, material);
    }, Helper.fancyShadows = function(renderer) {
        return renderer.shadowMap.enabled = !0, renderer.shadowMap.soft = !0, renderer.shadowMap.type = THREE.PCFShadowMap, 
        renderer.shadowMap.autoUpdate = !0;
    }, Helper.skySphere = function(options) {
        var geom, mat, name;
        if (null == options && (options = {}), null == options.textureUrl && null == options.map) throw "options.textureUrl or options.map not defined";
        return null == options.radius && (options.radius = Utils.SKY_SPHERE_DEFAULT_RADIUS), 
        null == options.segments && (options.segments = Utils.SKY_SPHERE_DEFAULT_SEGMENTS), 
        geom = new THREE.SphereGeometry(options.radius, options.segments, options.segments), 
        name = null != options.map ? options.map : Utils.getKeyName(options.textureUrl, Utils.IMG_URLS), 
        mat = new THREE.MeshBasicMaterial({
            map: TextureManager.get().items[name],
            side: THREE.BackSide
        }), new THREE.Mesh(geom, mat);
    }, Helper.skyBox = function(imgUrls, size) {
        var aCubeMap, aShader, aSkyBoxMaterial;
        return null == size && (size = 9e5), aCubeMap = THREE.ImageUtils.loadTextureCube(imgUrls), 
        aCubeMap.format = THREE.RGBFormat, aShader = THREE.ShaderLib.cube, aShader.uniforms.tCube.value = aCubeMap, 
        aSkyBoxMaterial = new THREE.ShaderMaterial({
            fragmentShader: aShader.fragmentShader,
            vertexShader: aShader.vertexShader,
            uniforms: aShader.uniforms,
            depthWrite: !1,
            side: THREE.BackSide
        }), new THREE.Mesh(new THREE.BoxGeometry(size, size, size), aSkyBoxMaterial);
    }, Helper.sampleShaderMaterial = function() {
        var shader;
        return shader = {
            uniforms: {
                time: {
                    type: "f",
                    value: 0
                },
                resolution: {
                    type: "v2",
                    value: new THREE.Vector2()
                }
            },
            fragment: [ "uniform float time;", "varying vec2 vUv;", "", "void main() {", "  vec2 position = -1.0 + 2.0 * vUv;", "", "  float red = abs(sin(position.x * position.y + time / 5.0));", "  float green = abs(sin(position.x * position.y + time / 4.0));", "  float blue = abs(sin(position.x * position.y + time / 3.0 ));", "  gl_FragColor = vec4(red, green, blue, 1.0);", "}" ].join("\n"),
            vertex: [ "varying vec2 vUv;", "", "void main() {", "  vUv = uv;", "  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}" ].join("\n")
        }, new THREE.ShaderMaterial({
            uniforms: shader.uniforms,
            vertexShader: shader.vertex,
            fragmentShader: shader.fragment
        });
    }, Helper.sampleShader = function() {
        var itemMaterial, mesh;
        return itemMaterial = this.sampleShaderMaterial(), mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), itemMaterial), 
        mesh.shaderSrc = itemMaterial, mesh;
    }, Helper.orbitControls = function(engine) {
        return new THREE.OrbitControls(engine.camera, engine.renderer.domElement);
    }, Helper.fog = function(options) {
        return null == options && (options = {}), null == options.color && (options.color = 0), 
        null == options.near && (options.near = 0), null == options.far && (options.far = 500), 
        new THREE.Fog(options.color, options.near, options.far);
    }, Helper.grid = function(options) {
        return null == options && (options = {}), null == options.size && (options.size = 10), 
        null == options.step && (options.step = 1), null == options.color && (options.color = 16777215), 
        null == options.colorCenterLine && (options.colorCenterLine = options.color), new THREE.GridHelper(options.size, options.step, options.colorCenterLine, options.color);
    }, Helper.materialFromCanvas = function(canvas) {
        var texture;
        return texture = new THREE.Texture(canvas), texture.needsUpdate = !0, texture.minFilter = THREE.LinearFilter, 
        new THREE.MeshBasicMaterial({
            map: texture,
            transparent: !0
        });
    }, Helper.intersectPlane = function() {
        return new THREE.Plane(new THREE.Vector3(0, 0, 1), -1);
    }, Helper.shake = function(target, options) {
        var i, j, k, originalPos, rand, randX, randY, randZ, ref, tween, tweenArray;
        for (null == options && (options = {}), null == options.kind && (options.kind = "Cubic"), 
        null == options.direction && (options.direction = "In"), null == options.stepDuration && (options.stepDuration = 150), 
        originalPos = {
            x: target.position.x,
            y: target.position.y,
            z: target.position.z
        }, rand = Helper.random(100) / 100, tweenArray = [], i = j = 0; 20 > j; i = ++j) randX = Helper.random(100) / 100, 
        randY = Helper.random(100) / 100, randZ = Helper.random(100) / 100, Helper.random(100) < 50 && (randX *= -1), 
        Helper.random(100) < 50 && (randY *= -1), Helper.random(100) < 50 && (randZ *= -1), 
        tween = this.tween({
            target: {
                x: randX,
                y: randY,
                z: randZ
            },
            mesh: target,
            relative: !0,
            duration: options.stepDuration,
            kind: options.kind,
            direction: options.direction
        }), tweenArray.push(tween);
        for (i = k = 0, ref = tweenArray.size(); ref >= 0 ? ref > k : k > ref; i = ref >= 0 ? ++k : --k) null != tweenArray[i + 1] && tweenArray[i].chain(tweenArray[i + 1]);
        return tweenArray.last().onComplete(function(_this) {
            return function() {
                return _this.tween({
                    target: {
                        x: originalPos.x,
                        y: originalPos.y,
                        z: originalPos.z
                    },
                    mesh: target,
                    relative: !1,
                    duration: options.stepDuration,
                    kind: options.kind,
                    direction: options.direction
                }).start();
            };
        }(this)), tweenArray[0].start(), tweenArray;
    }, Helper.tween = function(options) {
        var base, base1, base2, base3, base4, base5, e, j, k, len, len1, ref, ref1, tween;
        if (null == options && (options = {}), null == options.target) throw new Error("options.target missing");
        if (null == options.mesh) throw new Error("options.mesh missing");
        if (null == options.relative && (options.relative = !1), null == options.duration && (options.duration = Helper.defaultTweenDuration), 
        null == options.kind && (options.kind = "Linear"), null == options.direction && (options.direction = "None"), 
        null == options.delay && (options.delay = 0), null == options.position && (options.position = options.mesh.position.clone()), 
        options.position.rX = options.mesh.rotation.x, options.position.rY = options.mesh.rotation.y, 
        options.position.rZ = options.mesh.rotation.z, options.relative) {
            for (ref = [ "x", "y", "z" ], j = 0, len = ref.length; len > j; j++) e = ref[j], 
            null != options.target[e] ? options.target[e] += options.mesh.position[e] : options.target[e] = options.mesh.position[e];
            for (ref1 = [ "rX", "rY", "rZ" ], k = 0, len1 = ref1.length; len1 > k; k++) e = ref1[k], 
            null != options.target[e] ? options.target[e] += options.mesh.rotation[e.toLowerCase()[1]] : options.target[e] = options.mesh.rotation[e.toLowerCase()[1]];
        } else null == (base = options.target).x && (base.x = options.position.x), null == (base1 = options.target).y && (base1.y = options.position.y), 
        null == (base2 = options.target).z && (base2.z = options.position.z), null == (base3 = options.target).rX && (base3.rX = options.position.rX), 
        null == (base4 = options.target).rY && (base4.rY = options.position.rY), null == (base5 = options.target).rZ && (base5.rZ = options.position.rZ);
        if (options.position === options.target) throw new Error("target same as position");
        return tween = new TWEEN.Tween(options.position).to(options.target, options.duration).easing(TWEEN.Easing[options.kind][options.direction]).onUpdate(function() {
            return options.mesh.position.set(this.x, this.y, this.z), options.mesh.rotation.set(this.rX, this.rY, this.rZ);
        }), 0 !== options.delay && tween.delay(options.delay), tween;
    }, Helper.tweenCustom = function(options) {
        var tween;
        if (null == options && (options = {}), null == options.src) throw new Error("options.src missing");
        if (null == options.dest) throw new Error("options.dest missing");
        if (null == options.onUpdate) throw new Error("options.onUpdate missing");
        return null == options.duration && (options.duration = Helper.defaultTweenDuration), 
        null == options.kind && (options.kind = "Linear"), null == options.direction && (options.direction = "None"), 
        null == options.onComplete && (options.onComplete = function() {
            return {};
        }), tween = new TWEEN.Tween(options.src).to(options.dest, options.duration).easing(TWEEN.Easing[options.kind][options.direction]).onUpdate(options.onUpdate).onComplete(options.onComplete);
    }, Helper.vrPointer = function(camera, options) {
        var cube, scene, vector;
        return null == options && (options = {}), cube = this.cube({
            size: .5
        }), scene = SceneManager.currentScene(), scene.vrPointer = cube, vector = new THREE.Vector3(), 
        camera.getWorldDirection(vector), cube.translateZ(-1), scene.scene.add(cube);
    }, Helper.forest = function(options) {
        var attr, attrHash, base, base1, base10, base11, base12, base13, base14, base15, base16, base17, base2, base3, base4, base5, base6, base7, base8, base9, coords, i, item, j, k, l, len, len1, model, node, ref, ref1, ref2, singleGeometry;
        for (null == options && (options = {}), null == options.items && (options.items = []), 
        null == options.positionMin && (options.positionMin = {}), null == (base = options.positionMin).x && (base.x = 0), 
        null == (base1 = options.positionMin).y && (base1.y = 0), null == (base2 = options.positionMin).z && (base2.z = 0), 
        null == options.positionMax && (options.positionMax = {}), null == (base3 = options.positionMax).x && (base3.x = 10), 
        null == (base4 = options.positionMax).y && (base4.y = 0), null == (base5 = options.positionMax).z && (base5.z = 10), 
        null == options.rotationMin && (options.rotationMin = {}), null == (base6 = options.rotationMin).x && (base6.x = 0), 
        null == (base7 = options.rotationMin).y && (base7.y = 0), null == (base8 = options.rotationMin).z && (base8.z = 0), 
        null == options.rotationMax && (options.rotationMax = {}), null == (base9 = options.rotationMax).x && (base9.x = 0), 
        null == (base10 = options.rotationMax).y && (base10.y = Math.PI), null == (base11 = options.rotationMax).z && (base11.z = 0), 
        null == options.scaleMin && (options.scaleMin = {}), null == (base12 = options.scaleMin).x && (base12.x = .5), 
        null == (base13 = options.scaleMin).y && (base13.y = .5), null == (base14 = options.scaleMin).z && (base14.z = .5), 
        null == options.scaleMax && (options.scaleMax = {}), null == (base15 = options.scaleMax).x && (base15.x = 1.5), 
        null == (base16 = options.scaleMax).y && (base16.y = 1.5), null == (base17 = options.scaleMax).z && (base17.z = 1.5), 
        node = new THREE.Object3D(), coords = function(item, options, attr, coord, which) {
            var s;
            return s = "" + attr + which, null != item[s] && null != item[s][coord] ? item[s][coord] : options[s][coord];
        }, singleGeometry = new THREE.Geometry(), ref = options.items, j = 0, len = ref.length; len > j; j++) for (item = ref[j], 
        null == item.count && (item.count = 1), i = k = 0, ref1 = item.count; ref1 >= 0 ? ref1 > k : k > ref1; i = ref1 >= 0 ? ++k : --k) {
            for (model = JsonModelManager.clone(item.type), ref2 = [ "scale", "position", "rotation" ], 
            l = 0, len1 = ref2.length; len1 > l; l++) attr = ref2[l], attrHash = {
                x: Helper.random(coords(item, options, attr, "x", "Min"), coords(item, options, attr, "x", "Max"), 1e3) / 1e3,
                y: Helper.random(coords(item, options, attr, "y", "Min"), coords(item, options, attr, "y", "Max"), 1e3) / 1e3,
                z: Helper.random(coords(item, options, attr, "z", "Min"), coords(item, options, attr, "z", "Max"), 1e3) / 1e3
            }, model[attr].set(attrHash.x, attrHash.y, attrHash.z);
            node.add(model);
        }
        return node;
    }, Helper.basicMaterial = function(key) {
        return new THREE.MeshBasicMaterial({
            map: TextureManager.get().items[key],
            transparent: !0
        });
    }, Helper.dissolveMaterial = function(texture) {
        return new THREE.ShaderMaterial({
            uniforms: {
                texture: {
                    type: "t",
                    value: texture
                },
                noise: {
                    type: "t",
                    value: texture
                },
                dissolve: {
                    type: "f",
                    value: 0
                }
            },
            morphTargets: !0,
            vertexShader: THREE.ShaderLib.dissolve.vertexShader,
            fragmentShader: THREE.ShaderLib.dissolve.fragmentShader,
            shading: THREE.SmoothShading
        });
    }, Helper.setDissolveMaterialColor = function(dm, r, g, b) {
        return null == dm && new Error("missing dm param"), r = parseFloat(r).toFixed(1), 
        g = parseFloat(g).toFixed(1), b = parseFloat(b).toFixed(1), dm.fragmentShader = dm.fragmentShader.replace("    color.r = 1.0; color.g = 0.5; color.b = 0.0;", "    color.r = " + r + "; color.g = " + g + "; color.b = " + b + ";"), 
        dm;
    }, Helper.networkReload = function() {
        var nm;
        return nm = NetworkManager.get(), nm._hasListener("reload") || nm.on("reload", function(data) {
            return location.reload();
        }), nm.emit({
            type: "reload"
        });
    }, Helper.tendToZero = function(n, amount) {
        return 0 === n ? n : (n > 0 ? (n -= amount, 0 > n && (n = 0)) : (n += amount, n > 0 && (n = 0)), 
        n);
    }, Helper.addWithMinMax = function(n, amount, min, max) {
        return n += amount, n > max && (n = max), min > n && (n = min), n;
    }, Helper;
}(), THREE.ShaderLib.dissolve = {
    vertexShader: [ "varying vec2 vUv;", "uniform float morphTargetInfluences[ 8 ];", "void main() {", "  vUv = uv;", "  vec3 morphed = vec3( 0.0 );", "  morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];", "  morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];", "  morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];", "  morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];", "  morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];", "  morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];", "  morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];", "  morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];", "  morphed += position;", "  vec4 mvPosition;", "  mvPosition = modelViewMatrix * vec4( morphed, 1.0 );", "  gl_Position = projectionMatrix * mvPosition;", "  //vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );", "}" ].join("\n"),
    fragmentShader: [ "varying vec2 vUv;", "uniform sampler2D texture;", "uniform sampler2D noise;", "uniform float dissolve;", "void main()", "{", "  vec4 color = texture2D( texture, vUv );", "  float n = texture2D( noise, vUv ).x;", "  n = ( n - dissolve ) * 50.0;", "  if (n < 0.0) {", "    discard;", "  }", "  if (n < 1.0) {", "    color.r = 1.0; color.g = 0.5; color.b = 0.0;", "  }", "  gl_FragColor = color;", "}" ].join("\n")
};

var PoolManager;

PoolManager = function() {
    function PoolManager() {}
    var instance;
    return instance = null, Singleton.PoolManager = function() {
        function PoolManager() {}
        return PoolManager.prototype.validEvents = [ "spawn", "release" ], PoolManager.prototype.items = {}, 
        PoolManager.prototype.itemsInUse = {}, PoolManager.prototype.spawnEvents = {}, PoolManager.prototype.releaseEvents = {}, 
        PoolManager.prototype.spawn = function(type) {
            var item;
            return this._validation(type), item = this.items[type].isEmpty() ? new type() : this.items[type].shift(), 
            this.itemsInUse[type].push(item), null != this.spawnEvents[type] && this.spawnEvents[type](item), 
            item;
        }, PoolManager.prototype.release = function(item) {
            var type;
            if ("object" != typeof item || null == item.constructor) throw new Error("item " + item + " can not be released. wront type");
            if (type = this._validation(item.constructor), -1 === this.itemsInUse[type].indexOf(item)) throw new Error("item (" + type + ") was not spawned from the pool");
            this.itemsInUse[type].remove(item), this.items[type].push(item), null != this.releaseEvents[type] && this.releaseEvents[type](item);
        }, PoolManager.prototype.on = function(which, type, func) {
            var base;
            if (!("function" == typeof (base = this.validEvents).includes ? base.includes(which) : void 0)) throw new Error(which + " invalid. Allowed: " + this.validEvents.join(", "));
            return this[which + "Events"][type] = func;
        }, PoolManager.prototype.onSpawn = function(type, func) {
            return this.on("spawn", type, func);
        }, PoolManager.prototype.onRelease = function(type, func) {
            return this.on("release", type, func);
        }, PoolManager.prototype._validation = function(type) {
            if (!(type.prototype instanceof BaseModel)) throw new Error("type " + type + " not instance of base model");
            return null == this.items[type] && (this.items[type] = []), null == this.itemsInUse[type] && (this.itemsInUse[type] = []), 
            type;
        }, PoolManager.prototype._count = function(items) {
            var count, key;
            count = 0;
            for (key in items) count += items[key].size();
            return count;
        }, PoolManager.prototype.toString = function() {
            var inPool, inUse;
            return inUse = this._count(this.itemsInUse), inPool = this._count(this.items), inUse + " items in use\n" + inPool + " items waiting in all pools\n" + (inUse + inPool) + " total items";
        }, PoolManager.prototype.releaseAll = function() {
            var i, item, j, key, len, len1, ref, toRelease;
            toRelease = [];
            for (key in this.itemsInUse) for (ref = this.itemsInUse[key], i = 0, len = ref.length; len > i; i++) item = ref[i], 
            toRelease.push(item);
            for (j = 0, len1 = toRelease.length; len1 > j; j++) item = toRelease[j], this.release(item);
            return toRelease;
        }, PoolManager;
    }(), PoolManager.get = function() {
        return null != instance ? instance : instance = new Singleton.PoolManager();
    }, PoolManager.spawn = function(type) {
        return this.get().spawn(type);
    }, PoolManager.release = function(item) {
        return this.get().release(item);
    }, PoolManager.on = function(which, type, func) {
        return this.get().on(which, type, func);
    }, PoolManager.onSpawn = function(type, func) {
        return this.get().on("spawn", type, func);
    }, PoolManager.onRelease = function(type, func) {
        return this.get().on("release", type, func);
    }, PoolManager.releaseAll = function() {
        return this.get().releaseAll();
    }, PoolManager;
}();

var BaseText, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

BaseText = function(superClass) {
    function BaseText(options) {
        var geom, material;
        null == options && (options = {}), BaseText.__super__.constructor.call(this), this.canvasW = options.canvasW || 500, 
        this.canvasH = options.canvasH || 500, this.w = options.w || 4, this.h = options.h || 4, 
        this.margin = options.margin, this.lineHeight = options.lineHeight, this.align = options.align, 
        this.font = options.font, this.fillStyle = options.fillStyle, this.fillLineWidth = options.fillLineWidth, 
        this.strokeStyle = options.strokeStyle, this.strokeLineWidth = options.strokeLineWidth, 
        this.text = options.text, this.x = options.x, this.y = options.y, this.dynamicTexture = new THREEx.DynamicTexture(this.canvasW, this.canvasH), 
        this.setText(this.text), geom = new THREE.PlaneGeometry(this.w, this.h), material = new THREE.MeshBasicMaterial({
            map: this.dynamicTexture.texture,
            transparent: !0
        }), this.mesh = new THREE.Mesh(geom, material);
    }
    return extend(BaseText, superClass), BaseText.prototype.setText = function(text) {
        return "" !== text && null != text || (text = " "), this.text = text.toString(), 
        this.clear(), this.dynamicTexture.drawTextCooked({
            text: this.text,
            margin: this.margin,
            lineHeight: this.lineHeight,
            align: this.align,
            fillStyle: this.fillStyle,
            fillLineWidth: this.fillLineWidth,
            strokeStyle: this.strokeStyle,
            strokeLineWidth: this.strokeLineWidth,
            x: this.x,
            y: this.y,
            font: this.font
        });
    }, BaseText.prototype.clear = function() {
        return this.dynamicTexture.clear();
    }, BaseText.prototype.getTextWidth = function(s) {
        return this.dynamicTexture.context.measureText(s).width;
    }, BaseText;
}(BaseModel);

var Terrain, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

Terrain = function(superClass) {
    function Terrain(textureUrl, width, height, wSegments, hSegments) {
        var geom, json, key, mat;
        1 === arguments.length ? (json = textureUrl, key = Utils.getKeyName(json.texture.destPath, Utils.IMG_URLS), 
        mat = new THREE.MeshLambertMaterial({
            map: TextureManager.get().items[key]
        }), geom = new THREE.PlaneGeometry(json.width, json.height, json.wSegments, json.hSegments)) : (mat = new THREE.MeshLambertMaterial({
            map: THREE.ImageUtils.loadTexture(textureUrl)
        }), geom = new THREE.PlaneGeometry(width, height, wSegments, hSegments)), this.mesh = new THREE.Mesh(geom, mat), 
        this.mesh.rotation.x -= Math.PI / 2, this.raycaster = new THREE.Raycaster();
    }
    return extend(Terrain, superClass), Terrain.prototype.getHeightAt = function(position) {
        var intersects;
        return this.raycaster.set(new THREE.Vector3(position.x, 1e3, position.z), Helper.down), 
        intersects = this.raycaster.intersectObject(this.mesh), null != intersects[0] ? intersects[0].point.y : 0;
    }, Terrain.prototype.applyHeightmap = function(imageData) {
        var i, k, len, ref, results, vertice;
        for (i = 0, ref = this.mesh.geometry.vertices, results = [], k = 0, len = ref.length; len > k; k++) vertice = ref[k], 
        vertice.z = imageData[i], results.push(i++);
        return results;
    }, Terrain.heightmap = function(textureUrl, heightmapUrl, width, height, wSegments, hSegments, scale, scene) {
        return null == scale && (scale = 1), THREE.ImageUtils.loadTexture(heightmapUrl, THREE.UVMapping, function(_this) {
            return function(hm) {
                var terrain;
                return hm.heightData = Terrain.getHeightData(hm.image, scale), null == wSegments && (wSegments = hm.image.width - 1), 
                null == hSegments && (hSegments = hm.image.height - 1), terrain = new Terrain(textureUrl, width, height, wSegments, hSegments), 
                terrain.applyHeightmap(hm.heightData), null == scene && (scene = SceneManager.currentScene()), 
                scene.terrain = terrain, scene.scene.add(terrain.mesh);
            };
        }(this));
    }, Terrain.getHeightData = function(img, scale) {
        var all, canvas, context, data, i, imgd, j, pix, size;
        for (null == scale && (scale = 1), canvas = document.createElement("canvas"), canvas.width = img.width, 
        canvas.height = img.height, context = canvas.getContext("2d"), size = img.width * img.height, 
        data = new Float32Array(size), context.drawImage(img, 0, 0), i = 0; size > i; ) data[i] = 0, 
        i++;
        for (imgd = context.getImageData(0, 0, img.width, img.height), pix = imgd.data, 
        j = 0, i = 0; i < pix.length; ) all = pix[i] + pix[i + 1] + pix[i + 2], data[j++] = all / (12 * scale), 
        i += 4;
        return data;
    }, Terrain.fromJson = function(assetJson) {
        var hm, json, k, key, l, len, len1, ref, ref1, terrain;
        if ("terrain" !== assetJson.type) throw new Error("not a terrain");
        if (null == assetJson.key) throw new Error("key missing");
        for (json = SaveObjectManager.get().items[assetJson.key], ref = [ "width", "height", "scale", "texture", "heightmap" ], 
        k = 0, len = ref.length; len > k; k++) if (key = ref[k], null == json[key]) throw new Error(key + " missing for terrain");
        for (ref1 = [ "texture", "heightmap" ], l = 0, len1 = ref1.length; len1 > l; l++) if (key = ref1[l], 
        null == json[key].destPath) throw new Error(key + ".destPath missing for terrain");
        return key = Utils.getKeyName(json.heightmap.destPath, Utils.IMG_URLS), hm = TextureManager.get().items[key], 
        hm.heightData = Terrain.getHeightData(hm.image, json.scale), null == json.wSegments && (json.wSegments = hm.image.width - 1), 
        null == json.hSegments && (json.hSegments = hm.image.height - 1), terrain = new Terrain(json), 
        terrain.applyHeightmap(hm.heightData), terrain;
    }, Terrain;
}(BaseModel);

var Tree, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

Tree = function(superClass) {
    function Tree(material, size, children) {
        var sizeModifier;
        null == size && (size = 1), null == children && (children = 5), this.mesh = new THREE.Object3D(), 
        null == material && (material = Helper.sampleShaderMaterial()), sizeModifier = .65, 
        this.branchPivots = [], this.mesh = this.createBranch(size, material, children, !1, sizeModifier);
    }
    return extend(Tree, superClass), Tree.prototype.createBranch = function(size, material, children, isChild, sizeModifier) {
        var branch, branchEnd, branchPivot, c, child, endSize, length;
        if (branchPivot = new THREE.Object3D(), branchEnd = new THREE.Object3D(), this.branchPivots.push(branchPivot), 
        length = Math.random() * size * 10 + 5 * size, endSize = 0 === children ? 0 : size * sizeModifier, 
        branch = new THREE.Mesh(new THREE.CylinderGeometry(endSize, size, length, 5, 1, !0), material), 
        branchPivot.add(branch), branch.add(branchEnd), branch.position.y = length / 2, 
        branchEnd.position.y = length / 2 - .4 * size, isChild ? (branchPivot.rotation.z += 1.5 * Math.random() - 1.05 * sizeModifier, 
        branchPivot.rotation.x += 1.5 * Math.random() - 1.05 * sizeModifier) : (branchPivot.rotation.z += .1 * Math.random() - .05, 
        branchPivot.rotation.x += .1 * Math.random() - .05), children > 0) for (c = 0; children > c; ) child = this.createBranch(size * sizeModifier, material, children - 1, !0, sizeModifier), 
        branchEnd.add(child), c++;
        return branchPivot;
    }, Tree.prototype.wind = function(wind) {
        var b, i, len, ref, results;
        for (ref = this.branchPivots, results = [], i = 0, len = ref.length; len > i; i++) b = ref[i], 
        results.push(b.rotation.z += 5e-4 * Math.cos(wind * Math.random()));
        return results;
    }, Tree;
}(BaseModel);

var SpotLight, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

SpotLight = function(superClass) {
    function SpotLight(x, y, z) {
        var geometry;
        geometry = new THREE.CylinderGeometry(.1, 2.5, 5, 64, 40, !0), geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -geometry.parameters.height / 2, 0)), 
        geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2)), this.material = new THREEx.VolumetricSpotLightMaterial(), 
        this.mesh = new THREE.Mesh(geometry, this.material), this.mesh.position.set(x, y, z), 
        this.mesh.lookAt(new THREE.Vector3(0, 0, 0)), this.setColor("white"), this.material.uniforms.spotPosition.value = this.mesh.position, 
        this.spotLight = new THREE.SpotLight(), this.spotLight.position.copy(this.mesh.position), 
        this.spotLight.color = this.mesh.material.uniforms.lightColor.value, this.spotLight.exponent = 30, 
        this.spotLight.angle = Math.PI / 3, this.spotLight.intensity = 3, this.spotLight.castShadow = !0, 
        this.spotLight.shadow.camera.near = .01, this.spotLight.shadow.camera.far = 100, 
        this.spotLight.shadow.camera.fov = 45, this.spotLight.shadow.camera.left = -8, this.spotLight.shadow.camera.right = 8, 
        this.spotLight.shadow.camera.top = 8, this.spotLight.shadow.camera.bottom = -8, 
        this.spotLight.shadow.bias = .1, this.spotLight.shadow.darkness = .5, this.spotLight.shadow.mapSize.width = 1024, 
        this.spotLight.shadow.mapSize.height = 1024, this.direction = new THREE.Vector3(0, 0, 0), 
        this.lastDir = 0;
    }
    return extend(SpotLight, superClass), SpotLight.prototype.lookAt = function(node) {
        var target;
        return target = node.position, this.mesh.lookAt(target), this.spotLight.target.position.copy(target);
    }, SpotLight.prototype.addToScene = function(scene) {
        return scene.add(this.mesh), scene.add(this.spotLight), scene.add(this.spotLight.target);
    }, SpotLight.prototype.setColor = function(color) {
        return this.material.uniforms.lightColor.value.set(color);
    }, SpotLight;
}(BaseModel);

var Mirror, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

Mirror = function(superClass) {
    function Mirror(engine, options) {
        var base, base1, base2, base3, planeGeo;
        null == options && (options = {}), null == options.width && (options.width = Utils.PLANE_DEFAULT_WIDTH), 
        null == options.height && (options.height = Utils.PLANE_DEFAULT_HEIGHT), null == options.mirror && (options.mirror = {}), 
        null == (base = options.mirror).clipBias && (base.clipBias = Utils.MIRROR_DEFAULT_CLIP_BIAS), 
        null == (base1 = options.mirror).textureWidth && (base1.textureWidth = Utils.MIRROR_DEFAULT_TEXTURE_WIDTH), 
        null == (base2 = options.mirror).textureHeight && (base2.textureHeight = Utils.MIRROR_DEFAULT_TEXTURE_HEIGHT), 
        null == (base3 = options.mirror).color && (base3.color = Utils.MIRROR_DEFAULT_COLOR), 
        planeGeo = new THREE.PlaneBufferGeometry(options.width, options.height), this.mirror = new THREE.Mirror(engine.renderer, engine.camera, options.mirror), 
        this.mesh = new THREE.Mesh(planeGeo, this.mirror.material), this.mesh.add(this.mirror), 
        this.mesh.rotateX(-Math.PI / 2);
    }
    return extend(Mirror, superClass), Mirror.prototype.tick = function() {
        return this.mirror.render();
    }, Mirror;
}(BaseModel);

var LookAtTimer;

LookAtTimer = function() {
    function LookAtTimer(from, mesh) {
        this.mesh = mesh, this.walker = new Walker(from), this.amount = 0, this.enabled = !0;
    }
    return LookAtTimer.prototype.tick = function(tpf) {
        var intersection;
        if (this.enabled) return intersection = this.walker.fromWorldDirection().intersects(this.mesh).first(), 
        null != intersection ? (this.amount += tpf, this.amount > 1 && (this.amount = 1)) : (this.amount -= tpf, 
        this.amount < 0 && (this.amount = 0)), this._transform(tpf);
    }, LookAtTimer.prototype.isSelected = function() {
        return 1 === this.amount;
    }, LookAtTimer.prototype._transform = function(tpf) {
        return this.mesh.scale.set(1 + this.amount, 1 + this.amount, 1 + this.amount);
    }, LookAtTimer;
}();

var LoadingScene, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

LoadingScene = function(superClass) {
    function LoadingScene(urls, hasFinishedLoading) {
        if (null == hasFinishedLoading && (hasFinishedLoading = void 0), LoadingScene.__super__.constructor.call(this), 
        !(urls instanceof Array)) throw "urls needs to be an array";
        this.hasFinishedLoading = hasFinishedLoading, this.preStart(), this.loadAssets(urls);
    }
    return extend(LoadingScene, superClass), LoadingScene.prototype.loadAssets = function(assets) {
        var asset, i, interval, len, url;
        for (i = 0, len = assets.length; len > i; i++) asset = assets[i], url = "string" == typeof asset ? asset : asset.destPath, 
        url.endsWithAny(Utils.SAVE_URLS) ? this._loadSaveObject(url) : url.endsWithAny(Utils.JSON_URLS) ? this._loadJsonModel(url) : url.endsWithAny(Utils.IMG_URLS) ? this._loadTexture(url) : url.endsWithAny(Utils.AUDIO_URLS) ? this._loadAudio(url) : console.log("WARNING: " + url + " is not a valid format");
        return interval = setInterval(function(_this) {
            return function() {
                return _this.isLoadingDone() ? (clearInterval(interval), console.ce("Finished loading"), 
                _this.hasFinishedLoading()) : void 0;
            };
        }(this), 100);
    }, LoadingScene.prototype.preStart = function() {}, LoadingScene.prototype.isLoadingDone = function() {
        return this.jmm.hasFinishedLoading() && this.tm.hasFinishedLoading() && this.som.hasFinishedLoading() && this.sm.hasFinishedLoading();
    }, LoadingScene.prototype._loadJsonModel = function(url) {
        var name;
        return name = Utils.getKeyName(url, Utils.JSON_URLS), console.ce("Loading model '" + name + "' from '" + url + "'"), 
        this.jmm.load(name, url);
    }, LoadingScene.prototype._loadTexture = function(url) {
        var name;
        return name = Utils.getKeyName(url, Utils.IMG_URLS), console.ce("Loading texture '" + name + "' from '" + url + "'"), 
        this.tm.load(name, url);
    }, LoadingScene.prototype._loadSaveObject = function(url) {
        var name;
        return name = Utils.getKeyName(url, Utils.SAVE_URLS), console.ce("Loading save object '" + name + "' from '" + url + "'"), 
        this.som.load(name, url);
    }, LoadingScene.prototype._loadAudio = function(url) {
        var name;
        return name = Utils.getKeyName(url, Utils.AUDIO_URLS), console.ce("Loading audio '" + name + "' from '" + url + "'"), 
        this.sm.load(name, url);
    }, LoadingScene.prototype.init = function() {}, LoadingScene.prototype.tick = function(tpf) {}, 
    LoadingScene.prototype.doMouseEvent = function(event, raycaster) {}, LoadingScene.prototype.doKeyboardEvent = function(event) {}, 
    LoadingScene.prototype.hasFinishedLoading = function() {
        if (null != this.hasFinishedLoading) return this.hasFinishedLoading();
        throw "not implemented";
    }, LoadingScene;
}(BaseScene);

var Cinematic;

Cinematic = function() {
    function Cinematic(json, scene) {
        this.loaded = !1, null != scene && (this.scene = scene), this.cameras = [], this.items = [], 
        this.json = json, this._initUI(), this._loadFog(), this._loadMaterials(), this._loadCameras(), 
        this._loadItems(), this._loadSceneProperties(), this.loaded = !0;
    }
    return Cinematic.prototype._initUI = function() {
        var ceButtonType, i, len, ref;
        for (ref = Utils.CE_BUTTON_TYPES, i = 0, len = ref.length; len > i; i++) ceButtonType = ref[i], 
        null != this.json.ui && null != this.json.ui[ceButtonType + "Button"] && this.json.ui[ceButtonType + "Button"].enabled && (this.json.ui[ceButtonType + "Button"].type = ceButtonType, 
        Helper.addCEButton(this.json.ui[ceButtonType + "Button"]));
        return null != this.json.engine.orientation && Helper.orientation(this.json.engine.orientation), 
        Helper.fade({
            type: "out"
        });
    }, Cinematic.prototype._loadFog = function() {
        return null != this.json.fog && this.json.fog.enabled ? this.scene.fog = Helper.fog(this.json.fog) : void 0;
    }, Cinematic.prototype._loadMaterials = function() {
        var art, i, item, key, len, material, ref, results, so;
        for (ref = this.json.assets, results = [], i = 0, len = ref.length; len > i; i++) item = ref[i], 
        "graffiti" === item.type ? (key = Utils.getKeyName(item.destPath, Utils.SAVE_URLS), 
        so = SaveObjectManager.get().items[key], art = new ArtGenerator({
            width: so.width,
            height: so.height
        }), art.fromJson(so), material = Helper.materialFromCanvas(art.canvas), results.push(MaterialManager.load(key, material))) : results.push(void 0);
        return results;
    }, Cinematic.prototype._loadCameras = function() {
        var camera, i, item, len, ref, results, vector;
        for (ref = this.json.cameras, results = [], i = 0, len = ref.length; len > i; i++) item = ref[i], 
        camera = Helper.camera(item), this.setId(camera, item), this.setXYZProp("position", camera, item), 
        this.setXYZProp("rotation", camera, item), null != item.lookAt && (vector = this.getLookAtVector(item.lookAt), 
        camera.lookAt(vector)), results.push(this.cameras.push(camera));
        return results;
    }, Cinematic.prototype._loadItems = function() {
        var baseModel, i, item, len, obj, playlist, ref, results;
        for (ref = this.json.items, results = [], i = 0, len = ref.length; len > i; i++) switch (item = ref[i], 
        item.type) {
          case "playlist":
            playlist = new Playlist(item.items), this.setId(item, item), this.setId(playlist, item), 
            playlist.json = item, results.push(this.items.push(playlist));
            break;

          case "water":
            item[item.type] = item, baseModel = Helper[item.type](engine, this.scene, item), 
            obj = baseModel.mesh, results.push(this.cinemize(item, baseModel, obj));
            break;

          case "mirror":
            item[item.type] = item, baseModel = Helper[item.type](engine, item), obj = baseModel.mesh, 
            results.push(this.cinemize(item, baseModel, obj));
            break;

          case "terrain":
          case "particle":
            baseModel = Helper[item.type](item), obj = baseModel.mesh, results.push(this.cinemize(item, baseModel, obj));
            break;

          case "cube":
          case "plane":
          case "model":
          case "ambientLight":
          case "light":
          case "pointLight":
          case "skySphere":
          case "graffiti":
          case "forest":
            obj = Helper[item.type](item), baseModel = new BaseModel(), baseModel.mesh = obj, 
            results.push(this.cinemize(item, baseModel, obj));
            break;

          default:
            results.push(console.log("unknown item type " + item.type));
        }
        return results;
    }, Cinematic.prototype._loadSceneProperties = function() {
        return null != this.json.engine.camera ? engine.setCamera(this.cameras[this.json.engine.camera]) : void 0;
    }, Cinematic.prototype.cinemize = function(item, baseModel, obj) {
        return this.setId(baseModel, item), this.setId(obj, item), this.setName(obj, item), 
        this.setXYZProp("position", obj, item), this.setXYZProp("rotation", obj, item), 
        this.setXYZProp("scale", obj, item, 1), null != item.lookAt && engine.camera.lookAt(this.toVector3(item.lookAt)), 
        this.items.push(baseModel), this.scene ? this.scene.add(baseModel.mesh) : void 0;
    }, Cinematic.prototype.addAll = function(scene) {
        var i, item, len, ref, results;
        for (ref = this.items, results = [], i = 0, len = ref.length; len > i; i++) item = ref[i], 
        item.mesh && results.push(scene.add(item.mesh));
        return results;
    }, Cinematic.prototype.find = function(id) {
        return this.items.where({
            ceId: id
        }).first() || this.cameras.where({
            ceId: id
        }).first();
    }, Cinematic.prototype.allMeshes = function() {
        var i, item, len, meshes, ref;
        for (meshes = [], ref = this.items, i = 0, len = ref.length; len > i; i++) item = ref[i], 
        null != item.mesh && meshes.push(item.mesh);
        return meshes;
    }, Cinematic.prototype.tick = function(tpf) {
        var action, i, item, j, len, len1, ref, ref1, script;
        if (this.loaded === !0) {
            for (ref = this.items, i = 0, len = ref.length; len > i; i++) item = ref[i], item instanceof BaseParticle2 && item.tick(tpf), 
            item instanceof Mirror && item.tick(tpf), item instanceof Water && item.tick(tpf);
            if (!this.json.scripts.where({
                processing: !0
            }).any()) {
                if (script = this.json.scripts.where({
                    processed: void 0
                }).first(), null == script) return "finished";
                for (script.processed = !0, script.processing = !0, ref1 = script.actions, j = 0, 
                len1 = ref1.length; len1 > j; j++) action = ref1[j], this.processAction(action);
                return this.setNotProcessing(script);
            }
        }
    }, Cinematic.prototype.processAction = function(action) {
        var asset, i, isCamera, isSound, len, ref, target;
        if (null == action.delay && (action.delay = 0), null != action.target) {
            if (target = this.items.where({
                ceId: action.target
            }).first(), null == target && (target = {
                mesh: this.cameras.where({
                    ceId: action.target
                }).first()
            }, null != target.mesh && (isCamera = !0), null == target.mesh)) {
                for (ref = this.json.assets, i = 0, len = ref.length; len > i; i++) asset = ref[i], 
                "sound" === asset.type && Utils.getKeyName(asset.destPath, Utils.AUDIO_URLS) === action.target && (target = {
                    mesh: asset
                }, isSound = !0);
                if (null == target.mesh && !isCamera && !isSound) throw new Error("action.target " + action.target + " not found");
            }
            return setTimeout(function(_this) {
                return function() {
                    var vector;
                    return isSound ? (action.sound.key = action.target, SoundManager.get().cmd(action.sound)) : null != target.json && "playlist" === target.json.type ? target.cmd(action.sound) : (null != action.lookAt && (vector = _this.getLookAtVector(action.lookAt), 
                    target.mesh.lookAt(vector)), null != action.animate && isCamera !== !0 && (null != action.animate.stopOtherAnimations && target.stopAnimations(), 
                    target.animate(null, action.animate)), null != action.tween ? (action.tween.mesh = target.mesh, 
                    Helper.tween(action.tween).start()) : void 0);
                };
            }(this), action.delay);
        }
    }, Cinematic.prototype.setNotProcessing = function(script) {
        var duration;
        return duration = this.getScriptDuration(script), setTimeout(function(_this) {
            return function() {
                return script.processing = !1;
            };
        }(this), duration);
    }, Cinematic.prototype.getScriptDuration = function(script) {
        var action, actionDuration, animateDuration, i, len, longestDuration, ref;
        for (longestDuration = 0, ref = script.actions, i = 0, len = ref.length; len > i; i++) action = ref[i], 
        null != action.animate && action.animate.loop !== !0 && (animateDuration = action.animate.waitScript || 0, 
        animateDuration += action.delay || 0, animateDuration > longestDuration && (longestDuration = animateDuration)), 
        null != action.tween && (actionDuration = action.tween.duration || Helper.defaultTweenDuration, 
        actionDuration += action.delay || 0, actionDuration > longestDuration && (longestDuration = actionDuration));
        return longestDuration;
    }, Cinematic.prototype.getLookAtVector = function(json) {
        var coord, i, len, ref, vector;
        for (vector = this.toVector3(json), ref = [ "x", "y", "z" ], i = 0, len = ref.length; len > i; i++) coord = ref[i], 
        vector[coord] += json["offset" + coord.toUpperCase()] || 0;
        return vector;
    }, Cinematic.prototype.toVector3 = function(hash) {
        return null == hash.x && (hash.x = 0), null == hash.y && (hash.y = 0), null == hash.z && (hash.z = 0), 
        new THREE.Vector3(hash.x, hash.y, hash.z);
    }, Cinematic.prototype.setId = function(object, json) {
        return object.ceId = json.id;
    }, Cinematic.prototype.setName = function(object, json) {
        return object.name = json.id;
    }, Cinematic.prototype.setXYZProp = function(prop, object, json, def) {
        var base, coordinate, i, len, newJs, ref;
        for (null == def && (def = 0), null == json[prop] && (json[prop] = {}), ref = [ "x", "y", "z" ], 
        i = 0, len = ref.length; len > i; i++) coordinate = ref[i], null == (base = json[prop])[coordinate] && (base[coordinate] = def), 
        "string" == typeof json[prop][coordinate] && json[prop][coordinate].contains("PI") && (newJs = json[prop][coordinate].replace("PI", "Math.PI"), 
        json[prop][coordinate] = eval(newJs));
        return object[prop].set(json[prop].x, json[prop].y, json[prop].z);
    }, Cinematic;
}();

var CinematicScene, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

CinematicScene = function(superClass) {
    function CinematicScene(json) {
        CinematicScene.__super__.constructor.call(this), this.cinematic = new Cinematic(json, this.scene);
    }
    return extend(CinematicScene, superClass), CinematicScene.fromJson = function(json) {
        return new CinematicScene(json);
    }, CinematicScene.fromSaveObjectKey = function(key) {
        var json;
        return json = SaveObjectManager.get().items[key], this.fromJson(json);
    }, CinematicScene.prototype.tick = function(tpf) {
        var result;
        return result = this.cinematic.tick(tpf), "finished" === result ? this.afterCinematic(tpf) : void 0;
    }, CinematicScene.prototype.afterCinematic = function(tpf) {}, CinematicScene.prototype.doMouseEvent = function(event, ray) {}, 
    CinematicScene.prototype.doKeyboardEvent = function(event) {}, CinematicScene.prototype.init = function(options) {}, 
    CinematicScene.getAssets = function(key) {
        return SaveObjectManager.get().items[key].assets;
    }, CinematicScene;
}(BaseScene);

var ArtGenerator;

ArtGenerator = function() {
    function ArtGenerator(options) {
        this.options = options, this.tm = TextureManager.get(), this.canvas = document.createElement("canvas"), 
        this.canvas.width = options.width, this.canvas.height = options.height, this.ctx = this.canvas.getContext("2d");
    }
    return ArtGenerator.prototype.fromJson = function(json) {
        var i, item, len, ref, results;
        for (this.clear(), ref = json.items, results = [], i = 0, len = ref.length; len > i; i++) item = ref[i], 
        null != item.asset && null != item.asset.key && (item.key = item.asset.key), "image" === item.type && this.drawImage(item), 
        "text" === item.type && this.drawText(item), "bezier" === item.type ? results.push(this.drawBezier(item)) : results.push(void 0);
        return results;
    }, ArtGenerator.prototype.drawBezier = function(options) {
        return StackOverflow.drawBezier(options, this.ctx);
    }, ArtGenerator.prototype.drawText = function(options) {
        if (null == options && (options = {}), null == options.text) throw "options.text missing";
        return null == options.fillStyle && (options.fillStyle = "white"), null == options.fillLineWidth && (options.fillLineWidth = 1), 
        null == options.strokeLineWidth && (options.strokeLineWidth = 7), null == options.strokeStyle && (options.strokeStyle = void 0), 
        null == options.font && (options.font = "40px Helvetica"), null == options.x && (options.x = 0), 
        null == options.y && (options.y = 0), this.ctx.save(), this.ctx.font = options.font, 
        null != options.strokeStyle && (this.ctx.miterLimit = 2, this.ctx.lineJoin = "circle", 
        this.ctx.strokeStyle = options.strokeStyle, this.ctx.lineWidth = options.strokeLineWidth, 
        this.ctx.strokeText(options.text, options.x, options.y)), this.ctx.lineWidth = options.fillLineWidth, 
        this.ctx.fillStyle = options.fillStyle, this.ctx.fillText(options.text, options.x, options.y), 
        this.ctx.restore();
    }, ArtGenerator.prototype.drawImage = function(options) {
        var image, x, y;
        if (null == options && (options = {}), null == options.key) throw "key not found";
        return null == options.x && (options.x = 0), null == options.y && (options.y = 0), 
        null == options.angle && (options.angle = 0), x = options.x, y = options.y, image = this.tm.items[options.key].image, 
        0 !== options.angle && (this.ctx.save(), this.ctx.translate(options.x + image.width / 2, options.y + image.height / 2), 
        this.ctx.rotate(options.angle * Math.PI / 180), x = -(image.width / 2), y = -(image.height / 2)), 
        this.ctx.drawImage(image, x, y), 0 !== options.angle ? this.ctx.restore() : void 0;
    }, ArtGenerator.prototype.clear = function() {
        return this.ctx.clearRect(0, 0, this.options.width, this.options.height);
    }, ArtGenerator;
}();

var BaseModifier, FadeInModifier, FadeModifier, NoticeMeModifier, ScaleModifier, ShakeModifier, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

BaseModifier = function() {
    function BaseModifier() {}
    return BaseModifier.prototype.start = function() {
        return this.tween.start();
    }, BaseModifier.prototype.delay = function(delay) {
        return null == delay && (delay = 0), this.tween.delay(delay), this;
    }, BaseModifier;
}(), FadeInModifier = function(superClass) {
    function FadeInModifier(model) {
        this.tween = new TWEEN.Tween({
            x: .5
        }).to({
            x: 1
        }, 700).easing(TWEEN.Easing.Exponential.Out), this.tween.onUpdate(function() {
            return model.setOpacity(this.x);
        });
    }
    return extend(FadeInModifier, superClass), FadeInModifier;
}(BaseModifier), FadeModifier = function(superClass) {
    function FadeModifier(model, srcX, destX, t) {
        this.tween = new TWEEN.Tween({
            x: srcX
        }).to({
            x: destX
        }, t).easing(TWEEN.Easing.Exponential.Out), this.tween.onUpdate(function() {
            return model.setOpacity(this.x);
        });
    }
    return extend(FadeModifier, superClass), FadeModifier;
}(BaseModifier), ShakeModifier = function(superClass) {
    function ShakeModifier(model, t) {
        var ease, originalRZ;
        ease = TWEEN.Easing.Linear.None, originalRZ = model.mesh.rotation.z, this.tween = new TWEEN.Tween({
            x: 0
        }).to({
            x: t
        }, t).easing(ease), this.tween.onUpdate(function() {
            return model.mesh.rotation.z += Math.random() - .5, 1 === this.x ? model.mesh.rotation.z = originalRZ : void 0;
        });
    }
    return extend(ShakeModifier, superClass), ShakeModifier;
}(BaseModifier), ScaleModifier = function(superClass) {
    function ScaleModifier(model, srcX, destX, t) {
        var ease;
        ease = TWEEN.Easing.Linear.None, this.tween = new TWEEN.Tween({
            x: srcX
        }).to({
            x: destX
        }, t).easing(ease), this.tween.onUpdate(function() {
            return model.mesh.scale.set(this.x, this.x, this.x);
        });
    }
    return extend(ScaleModifier, superClass), ScaleModifier;
}(BaseModifier), NoticeMeModifier = function(superClass) {
    function NoticeMeModifier(model, srcX, destX, t) {
        this.scale1 = new ScaleModifier(model, srcX, destX, t / 2), this.scale2 = new ScaleModifier(model, destX, srcX, t / 2), 
        this.t = t;
    }
    return extend(NoticeMeModifier, superClass), NoticeMeModifier.prototype.start = function() {
        return this.scale1.start(), this.scale2.start();
    }, NoticeMeModifier.prototype.delay = function(delay) {
        return null == delay && (delay = 0), this.scale1.delay(delay), this.scale2.delay(delay + this.t / 2), 
        this;
    }, NoticeMeModifier;
}(BaseModifier);

var VRControls, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

VRControls = function(superClass) {
    function VRControls(target) {
        var setOrientationControls;
        this.enabled = !0, this.supported = !1, this.controls = new THREE.DeviceOrientationControls(target, !0), 
        setOrientationControls = function(_this) {
            return function(e) {
                return e.alpha ? (_this.supported = !0, _this.controls.connect(), _this.controls.update(), 
                void window.removeEventListener("deviceorientation", setOrientationControls, !0)) : void (_this.enabled = !1);
            };
        }(this), window.addEventListener("deviceorientation", setOrientationControls, !0);
    }
    return extend(VRControls, superClass), VRControls.prototype.tick = function(tpf) {
        return this.enabled ? this.controls.update(tpf) : void 0;
    }, VRControls.prototype.update = function(tpf) {
        return this.tick(tpf);
    }, VRControls.prototype.updateAlphaOffsetAngle = function(angle) {
        return this.controls.updateAlphaOffsetAngle(angle);
    }, VRControls.prototype.turn = function(angle) {
        return null == angle && (angle = 45), this.updateAlphaOffsetAngle(this.controls.alphaOffsetAngle + angle);
    }, VRControls.prototype.isSupported = function() {
        return this.areSupported();
    }, VRControls.prototype.areSupported = function() {
        return this.supported;
    }, VRControls;
}(BaseControls);

var Walker;

Walker = function() {
    function Walker(mesh, x, y, z) {
        null == x && (x = 0), null == y && (y = -1), null == z && (z = 0), this.mesh = mesh, 
        this.raycaster = new THREE.Raycaster(), this.direction = new THREE.Vector3(x, y, z);
    }
    return Walker.prototype.getContact = function(mesh) {
        var fromPosition, intersects;
        return null == mesh ? void console.log("walker.getContact needs a mesh") : (fromPosition = this.mesh.position.clone(), 
        this.raycaster.set(fromPosition, this.direction), intersects = this.raycaster.intersectObject(mesh), 
        intersects.size() > 0 ? intersects.first().point : null);
    }, Walker.prototype.intersects = function(meshes) {
        var fromPosition;
        return null == meshes ? void console.log("walker.intersects needs a mesh") : (meshes = [].concat(meshes), 
        fromPosition = this.mesh.position.clone(), this.raycaster.set(fromPosition, this.direction), 
        this.raycaster.intersectObjects(meshes));
    }, Walker.prototype.first = function(meshes) {
        return this.intersects(meshes).first();
    }, Walker.prototype.fromWorldDirection = function() {
        return this.mesh.getWorldDirection(this.direction), this;
    }, Walker;
}();

var Water, extend = function(child, parent) {
    function ctor() {
        this.constructor = child;
    }
    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
    return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
    child;
}, hasProp = {}.hasOwnProperty;

Water = function(superClass) {
    function Water(engine, scene, options) {
        var base, base1, base2, base3, base4, base5, base6, waterNormals;
        if (null == options && (options = {}), null == options.map) throw new Error("map missing. needs to be a TextureManager key");
        null == options.width && (options.width = Utils.PLANE_DEFAULT_WIDTH), null == options.height && (options.height = Utils.PLANE_DEFAULT_HEIGHT), 
        null == options.wSegments && (options.wSegments = Utils.PLANE_DEFAULT_W_SEGMENTS), 
        null == options.hSegments && (options.hSegments = Utils.PLANE_DEFAULT_H_SEGMENTS), 
        null == options.water && (options.water = {}), null == (base = options.water).textureWidth && (base.textureWidth = Utils.MIRROR_DEFAULT_TEXTURE_WIDTH / 2), 
        null == (base1 = options.water).textureHeight && (base1.textureHeight = Utils.MIRROR_DEFAULT_TEXTURE_HEIGHT / 2), 
        null == (base2 = options.water).alpha && (base2.alpha = Utils.WATER_DEFAULT_ALPHA), 
        null == (base3 = options.water).sunColor && (base3.sunColor = Utils.LIGHT_DEFAULT_COLOR), 
        null == (base4 = options.water).waterColor && (base4.waterColor = Utils.WATER_DEFAULT_WATER_COLOR), 
        null == (base5 = options.water).betaVersion && (base5.betaVersion = 0), null == (base6 = options.water).side && (base6.side = THREE.DoubleSide), 
        waterNormals = TextureManager.get().items[options.map], waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping, 
        options.water.waterNormals = waterNormals, this.water = new THREE.Water(engine.renderer, engine.camera, scene, options.water), 
        this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(options.width, options.height, options.wSegments, options.hSegments), this.water.material), 
        this.mesh.add(this.water), this.mesh.rotation.x = .5 * -Math.PI, this.speed = 1;
    }
    return extend(Water, superClass), Water.prototype.tick = function(tpf) {
        return this.water.material.uniforms.time.value += tpf * this.speed, this.water.render();
    }, Water;
}(BaseModel);

var Engine3D, bind = function(fn, me) {
    return function() {
        return fn.apply(me, arguments);
    };
};

Engine3D = function() {
    function Engine3D() {
        this.implode = bind(this.implode, this), this.render = bind(this.render, this), 
        this.keyboardHandler = bind(this.keyboardHandler, this), this.mouseHandler = bind(this.mouseHandler, this);
        var camera;
        this.uptime = 0, this.time = void 0, this.config = Config.get(), this.width = this.config.width, 
        this.height = this.config.height, this.renderer = new THREE.WebGLRenderer({
            antialias: this.config.antialias,
            alpha: this.config.transparentBackground,
            logarithmicDepthBuffer: !1
        }), this.renderer.sortObjects = this.config.sortObjects, this.renderer.setSize(this.width, this.height), 
        this.appendDom(), this.renderer.domElement.setAttribute("id", "coffee-engine-dom"), 
        camera = Helper.camera({
            aspect: this.width / this.height,
            near: Utils.CAMERA_DEFAULT_NEAR,
            far: Utils.CAMERA_DEFAULT_FAR
        }), this.setCamera(camera), this.camera.position.z = 10, this.anaglyphEffect = new THREE.AnaglyphEffect(this.renderer), 
        this.anaglyphEffect.setSize(this.width, this.height), this.stereoEffect = new THREE.StereoEffect(this.renderer), 
        this.stereoEffect.setSize(this.width, this.height), this.sceneManager = SceneManager.get(), 
        this.renderer.domElement.addEventListener("mouseup", this.mouseHandler, !1), this.renderer.domElement.addEventListener("mousedown", this.mouseHandler, !1), 
        this.renderer.domElement.addEventListener("mousemove", this.mouseHandler, !1), document.addEventListener("keydown", this.keyboardHandler, !1), 
        document.addEventListener("keyup", this.keyboardHandler, !1), this.renderer.domElement.addEventListener("touchstart", this.touchHandler, !1), 
        this.renderer.domElement.addEventListener("touchmove", this.touchHandler, !1), this.renderer.domElement.addEventListener("touchend", this.touchHandler, !1), 
        this.renderer.domElement.addEventListener("touchcancel", this.touchHandler, !1), 
        this.config.contextMenuDisabled && document.addEventListener("contextmenu", function(e) {
            return e.preventDefault();
        }, !1), this.config.showStatsOnLoad && StatsManager.toggle();
    }
    return Engine3D.prototype.setWidthHeight = function(width, height) {
        return this.width = width, this.height = height, this.config.width = width, this.config.height = height, 
        this.camera.aspect = this.width / this.height, this.camera.updateProjectionMatrix(), 
        this.renderer.setSize(this.width, this.height);
    }, Engine3D.prototype.touchHandler = function(event) {
        var first, simulatedEvent, touches, type;
        switch (touches = event.changedTouches, first = touches[0], type = "", event.type) {
          case "touchstart":
            type = "mousedown";
            break;

          case "touchmove":
            type = "mousemove";
            break;

          case "touchend":
            type = "mouseup";
            break;

          default:
            return;
        }
        simulatedEvent = document.createEvent("MouseEvent"), simulatedEvent.initMouseEvent(type, !0, !0, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, !1, !1, !1, !1, 0, null), 
        first.target.dispatchEvent(simulatedEvent), event.preventDefault();
    }, Engine3D.prototype.mouseHandler = function(event) {
        var raycaster;
        return raycaster = this._parseMouseEvent(event), null != raycaster ? this.sceneManager.currentScene().doMouseEvent(event, raycaster) : void 0;
    }, Engine3D.prototype.keyboardHandler = function(event) {
        return this.sceneManager.currentScene().doKeyboardEvent(event);
    }, Engine3D.prototype.setCamera = function(camera) {
        return this.camera = camera, this.config.resize ? this.winResize = new THREEx.WindowResize(this.renderer, this.camera) : void 0;
    }, Engine3D.prototype.setClearColor = function(color, alpha) {
        return this.renderer.setClearColor(color, alpha);
    }, Engine3D.prototype.addScene = function(scene) {
        return this.sceneManager.addScene(scene), null == this.sceneManager.currentSceneIndex ? this.sceneManager.setScene(scene) : void 0;
    }, Engine3D.prototype.initScene = function(scene, options, fade) {
        return null == options && (options = {}), null == fade && (fade = !0), fade ? (Helper.fade({
            type: "in"
        }), setTimeout(function(_this) {
            return function() {
                return _this._doInitScene(scene, options), Helper.fade({
                    type: "out"
                });
            };
        }(this), Utils.FADE_DEFAULT_DURATION)) : this._doInitScene(scene, options);
    }, Engine3D.prototype._doInitScene = function(scene, options) {
        var currentScene;
        return currentScene = this.sceneManager.currentScene(), null != currentScene && currentScene.uninit(), 
        this.sceneManager.hasScene(scene) || this.sceneManager.addScene(scene), scene.init(options), 
        this.sceneManager.setScene(scene);
    }, Engine3D.prototype.removeScene = function(scene) {
        return this.sceneManager.removeScene(scene);
    }, Engine3D.prototype.render = function() {
        var now, tpf;
        if (!this.stop) return requestAnimationFrame(this.render), this.width = window.innerWidth, 
        this.height = window.innerHeight, now = new Date().getTime(), tpf = (now - (this.time || now)) / 1e3, 
        this.time = now, this.uptime += tpf, this.sceneManager.tick(tpf), StatsManager.update(this.renderer), 
        TWEEN.update(), this.config.anaglyph ? this.anaglyphEffect.render(this.sceneManager.currentScene().scene, this.camera) : this.config.stereoVR ? this.stereoEffect.render(this.sceneManager.currentScene().scene, this.camera) : this.renderer.render(this.sceneManager.currentScene().scene, this.camera);
    }, Engine3D.prototype.implode = function() {
        return this.stop = !0, this.removeDom();
    }, Engine3D.prototype.unproject = function(x, y) {
        var mouseX, mouseY, vector;
        return mouseX = x / this.width * 2 - 1, mouseY = 2 * -(y / this.height) + 1, vector = new THREE.Vector3(mouseX, mouseY, .5), 
        vector.unproject(this.camera), new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize());
    }, Engine3D.prototype.removeDom = function() {
        var e;
        if (null !== this.renderer.domElement.parentNode) try {
            return document.body.removeChild(this.renderer.domElement);
        } catch (error) {
            return e = error, console.log(e);
        }
    }, Engine3D.prototype.appendDom = function() {
        return document.body.appendChild(this.renderer.domElement);
    }, Engine3D.prototype._parseMouseEvent = function(event) {
        var mouseX, mouseY, vector;
        return this.config.preventDefaultMouseEvents && event.preventDefault(), event.target === this.renderer.domElement ? (mouseX = event.layerX / this.width * 2 - 1, 
        mouseY = 2 * -(event.layerY / this.height) + 1, vector = new THREE.Vector3(mouseX, mouseY, .5), 
        vector.unproject(this.camera), new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize())) : void 0;
    }, Engine3D.scenify = function(zeEngine, callback) {
        var loadingScene;
        return null == callback && (callback = function() {
            return {};
        }), loadingScene = new LoadingScene([ "assets/scenes/start.save.json" ], function() {
            var assets;
            return loadingScene.hasFinishedLoading = function() {
                var scene;
                return scene = CinematicScene.fromSaveObjectKey("start"), zeEngine.addScene(scene), 
                zeEngine.sceneManager.setScene(scene), callback();
            }, assets = CinematicScene.getAssets("start"), loadingScene.loadAssets(assets);
        }), zeEngine.addScene(loadingScene), loadingScene;
    }, Engine3D.prototype.currentScene = function() {
        return this.sceneManager.currentScene();
    }, Engine3D;
}();

var CyclicArray, Playlist, isNumeric, whichAnimationEvent;

Array.prototype.isEmpty = function() {
    return 0 === this.length;
}, Array.prototype.any = function() {
    return !this.isEmpty();
}, Array.prototype.clear = function() {
    var results;
    for (results = []; this.any(); ) results.push(this.pop());
    return results;
}, Array.prototype.last = function() {
    return this[this.length - 1];
}, Array.prototype.first = function() {
    return this[0];
}, Array.prototype.size = function() {
    return this.length;
}, Array.prototype.includes = function(e) {
    return -1 !== this.indexOf(e);
}, Array.prototype.shuffle = function() {
    var array, i, m, t;
    for (array = this, m = array.length, t = void 0, i = void 0; m; ) i = Math.floor(Math.random() * m--), 
    t = array[m], array[m] = array[i], array[i] = t;
    return array;
}, Array.prototype.equalsArray = function(a) {
    var eq, i, j, ref;
    for (eq = !0, i = j = 0, ref = a.size(); ref >= 0 ? ref >= j : j >= ref; i = ref >= 0 ? ++j : --j) if (a[i] !== this[i]) {
        eq = !1;
        break;
    }
    return eq;
}, Array.prototype.random = function() {
    return this.shuffle().first();
}, Array.prototype.diff = function(a) {
    return this.filter(function(i) {
        return a.indexOf(i) < 0;
    });
}, Array.prototype.remove = function(e) {
    var pos;
    return pos = this.indexOf(e), pos > -1 && this.splice(pos, 1), pos > -1 ? e : null;
}, Array.prototype.findById = function(id) {
    return this.filter(function(i) {
        return i.id === id;
    });
}, Array.prototype.sum = function() {
    var e, j, len, ref, sum;
    for (sum = 0, ref = this, j = 0, len = ref.length; len > j; j++) e = ref[j], sum += e;
    return sum;
}, Array.prototype.where = function(hash) {
    return this.filter(function(d) {
        var found, item, j, key, len, ok, ref;
        ok = !0;
        for (key in hash) if (found = !1, hash[key] instanceof Array) {
            for (ref = hash[key], j = 0, len = ref.length; len > j; j++) if (item = ref[j], 
            d[key] === item) {
                found = !0;
                break;
            }
            ok = ok && found;
        } else ok = ok && d[key] === hash[key];
        return ok;
    });
}, Array.prototype.insert = function(index, item) {
    this.splice(index, 0, item);
}, Array.prototype.toCyclicArray = function() {
    return new CyclicArray(this);
}, String.prototype.size = function(s) {
    return this.length;
}, String.prototype.startsWith = function(s) {
    return 0 === this.indexOf(s);
}, String.prototype.startsWithAny = function(prefixes) {
    var j, len, prefix, startsWith;
    for (startsWith = !1, j = 0, len = prefixes.length; len > j; j++) prefix = prefixes[j], 
    this.startsWith(prefix) && (startsWith = !0);
    return startsWith;
}, String.prototype.endsWith = function(suffix) {
    return -1 !== this.indexOf(suffix, this.length - suffix.length);
}, String.prototype.endsWithAny = function(suffixes) {
    var endsWith, j, len, suffix;
    if (endsWith = !1, null == suffixes) return !1;
    for (j = 0, len = suffixes.length; len > j; j++) suffix = suffixes[j], this.endsWith(suffix) && (endsWith = !0);
    return endsWith;
}, String.prototype.replaceAny = function(sources, dest) {
    var j, len, source, tmp;
    for (tmp = this, j = 0, len = sources.length; len > j; j++) source = sources[j], 
    tmp = tmp.replace(source, dest);
    return tmp;
}, String.prototype.isEmpty = function() {
    return 0 === this.size();
}, String.prototype.contains = function(s) {
    return -1 !== this.indexOf(s);
}, String.prototype.containsAny = function(strings) {
    var containsAny, j, len, s;
    if (containsAny = !1, null == strings) return !1;
    for (j = 0, len = strings.length; len > j; j++) s = strings[j], this.contains(s) && (containsAny = !0);
    return containsAny;
}, String.prototype.isPresent = function() {
    return null != this && !this.isEmpty();
}, String.prototype.capitalizeFirstLetter = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
}, isNumeric = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}, Number.prototype.endsWith = function(s) {
    return this.toString().endsWith(s);
}, console.ce = function(message) {
    ("undefined" == typeof Config || null === Config || Config.get().debug) && console.log(message);
}, CyclicArray = function() {
    function CyclicArray(items) {
        null == items && (items = []), this.items = items, this.index = 0;
    }
    return CyclicArray.prototype.get = function() {
        return this.items[this.index];
    }, CyclicArray.prototype.next = function() {
        return this.index += 1, this.index > this.items.size() - 1 && (this.index = 0), 
        this.get();
    }, CyclicArray.prototype.prev = function() {
        return this.index -= 1, this.index < 0 && (this.index = this.items.size() - 1), 
        this.get();
    }, CyclicArray;
}(), whichAnimationEvent = function() {
    var animations, el, t;
    el = document.createElement("fakeelement"), animations = {
        animation: "animationend",
        OAnimation: "oAnimationEnd",
        MozAnimation: "animationend",
        WebkitAnimation: "webkitAnimationEnd"
    };
    for (t in animations) if (void 0 !== el.style[t]) return animations[t];
}, Playlist = function() {
    function Playlist(keys) {
        var j, key, len;
        if (!(keys instanceof Array)) throw new Error("keys needs to be an array");
        for (j = 0, len = keys.length; len > j; j++) if (key = keys[j], !SoundManager.has(key)) throw new Error("key '" + key + "' not loaded in SoundManager");
        this.items = new CyclicArray(keys);
    }
    return Playlist.prototype.cmd = function(options) {
        var audio, item, j, len, ref;
        if (options.key = this.items.get(), "volumeAll" === options.type) for (options.type = "volume", 
        ref = this.items.items, j = 0, len = ref.length; len > j; j++) item = ref[j], options.key = item, 
        SoundManager.cmd(options); else audio = SoundManager.cmd(options);
        return [ "play", "fadeIn" ].includes(options.type) ? (audio._onend = [], audio.on("end", function(_this) {
            return function(data) {
                return _this.items.next(), _this.cmd(options);
            };
        }(this))) : [ "volume", "volumeAll" ].includes(options.type) ? void 0 : audio._onend = [];
    }, Playlist.prototype.getPlayingKey = function() {
        return this.items.get();
    }, Playlist.prototype.getPlayingAudio = function() {
        return SoundManager.get().items[this.getPlayingKey()];
    }, Playlist;
}();

var EngineHolder;

EngineHolder = function() {
    function EngineHolder() {}
    var instance;
    return instance = null, Singleton.EngineHolder = function() {
        function EngineHolder() {}
        return EngineHolder;
    }(), EngineHolder.get = function() {
        return null != instance ? instance : instance = new Singleton.EngineHolder();
    }, EngineHolder;
}(), function() {
    var cache = {}, ctx = null, usingWebAudio = !0, noAudio = !1;
    try {
        "undefined" != typeof AudioContext ? ctx = new AudioContext() : "undefined" != typeof webkitAudioContext ? ctx = new webkitAudioContext() : usingWebAudio = !1;
    } catch (e) {
        usingWebAudio = !1;
    }
    if (!usingWebAudio) if ("undefined" != typeof Audio) try {
        new Audio();
    } catch (e) {
        noAudio = !0;
    } else noAudio = !0;
    if (usingWebAudio) {
        var masterGain = "undefined" == typeof ctx.createGain ? ctx.createGainNode() : ctx.createGain();
        masterGain.gain.value = 1, masterGain.connect(ctx.destination);
    }
    var HowlerGlobal = function(codecs) {
        this._volume = 1, this._muted = !1, this.usingWebAudio = usingWebAudio, this.ctx = ctx, 
        this.noAudio = noAudio, this._howls = [], this._codecs = codecs, this.iOSAutoEnable = !0;
    };
    HowlerGlobal.prototype = {
        volume: function(vol) {
            var self = this;
            if (vol = parseFloat(vol), vol >= 0 && 1 >= vol) {
                self._volume = vol, usingWebAudio && (masterGain.gain.value = vol);
                for (var key in self._howls) if (self._howls.hasOwnProperty(key) && self._howls[key]._webAudio === !1) for (var i = 0; i < self._howls[key]._audioNode.length; i++) self._howls[key]._audioNode[i].volume = self._howls[key]._volume * self._volume;
                return self;
            }
            return usingWebAudio ? masterGain.gain.value : self._volume;
        },
        mute: function() {
            return this._setMuted(!0), this;
        },
        unmute: function() {
            return this._setMuted(!1), this;
        },
        _setMuted: function(muted) {
            var self = this;
            self._muted = muted, usingWebAudio && (masterGain.gain.value = muted ? 0 : self._volume);
            for (var key in self._howls) if (self._howls.hasOwnProperty(key) && self._howls[key]._webAudio === !1) for (var i = 0; i < self._howls[key]._audioNode.length; i++) self._howls[key]._audioNode[i].muted = muted;
        },
        codecs: function(ext) {
            return this._codecs[ext];
        },
        _enableiOSAudio: function() {
            var self = this;
            if (!ctx || !self._iOSEnabled && /iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                self._iOSEnabled = !1;
                var unlock = function() {
                    var buffer = ctx.createBuffer(1, 1, 22050), source = ctx.createBufferSource();
                    source.buffer = buffer, source.connect(ctx.destination), "undefined" == typeof source.start ? source.noteOn(0) : source.start(0), 
                    setTimeout(function() {
                        source.playbackState !== source.PLAYING_STATE && source.playbackState !== source.FINISHED_STATE || (self._iOSEnabled = !0, 
                        self.iOSAutoEnable = !1, window.removeEventListener("touchend", unlock, !1));
                    }, 0);
                };
                return window.addEventListener("touchend", unlock, !1), self;
            }
        }
    };
    var audioTest = null, codecs = {};
    noAudio || (audioTest = new Audio(), codecs = {
        mp3: !!audioTest.canPlayType("audio/mpeg;").replace(/^no$/, ""),
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
        aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
        m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
        mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")
    });
    var Howler = new HowlerGlobal(codecs), Howl = function(o) {
        var self = this;
        self._autoplay = o.autoplay || !1, self._buffer = o.buffer || !1, self._duration = o.duration || 0, 
        self._format = o.format || null, self._loop = o.loop || !1, self._loaded = !1, self._sprite = o.sprite || {}, 
        self._src = o.src || "", self._pos3d = o.pos3d || [ 0, 0, -.5 ], self._volume = void 0 !== o.volume ? o.volume : 1, 
        self._urls = o.urls || [], self._rate = o.rate || 1, self._model = o.model || null, 
        self._onload = [ o.onload || function() {} ], self._onloaderror = [ o.onloaderror || function() {} ], 
        self._onend = [ o.onend || function() {} ], self._onpause = [ o.onpause || function() {} ], 
        self._onplay = [ o.onplay || function() {} ], self._onendTimer = [], self._webAudio = usingWebAudio && !self._buffer, 
        self._audioNode = [], self._webAudio && self._setupAudioNode(), "undefined" != typeof ctx && ctx && Howler.iOSAutoEnable && Howler._enableiOSAudio(), 
        Howler._howls.push(self), self.load();
    };
    if (Howl.prototype = {
        load: function() {
            var self = this, url = null;
            if (noAudio) return void self.on("loaderror", new Error("No audio support."));
            for (var i = 0; i < self._urls.length; i++) {
                var ext, urlItem;
                if (self._format) ext = self._format; else {
                    if (urlItem = self._urls[i], ext = /^data:audio\/([^;,]+);/i.exec(urlItem), ext || (ext = /\.([^.]+)$/.exec(urlItem.split("?", 1)[0])), 
                    !ext) return void self.on("loaderror", new Error("Could not extract format from passed URLs, please add format parameter."));
                    ext = ext[1].toLowerCase();
                }
                if (codecs[ext]) {
                    url = self._urls[i];
                    break;
                }
            }
            if (!url) return void self.on("loaderror", new Error("No codec support for selected audio sources."));
            if (self._src = url, self._webAudio) loadBuffer(self, url); else {
                var newNode = new Audio();
                newNode.addEventListener("error", function() {
                    newNode.error && 4 === newNode.error.code && (HowlerGlobal.noAudio = !0), self.on("loaderror", {
                        type: newNode.error ? newNode.error.code : 0
                    });
                }, !1), self._audioNode.push(newNode), newNode.src = url, newNode._pos = 0, newNode.preload = "auto", 
                newNode.volume = Howler._muted ? 0 : self._volume * Howler.volume();
                var listener = function() {
                    self._duration = Math.ceil(10 * newNode.duration) / 10, 0 === Object.getOwnPropertyNames(self._sprite).length && (self._sprite = {
                        _default: [ 0, 1e3 * self._duration ]
                    }), self._loaded || (self._loaded = !0, self.on("load")), self._autoplay && self.play(), 
                    newNode.removeEventListener("canplaythrough", listener, !1);
                };
                newNode.addEventListener("canplaythrough", listener, !1), newNode.load();
            }
            return self;
        },
        urls: function(urls) {
            var self = this;
            return urls ? (self.stop(), self._urls = "string" == typeof urls ? [ urls ] : urls, 
            self._loaded = !1, self.load(), self) : self._urls;
        },
        play: function(sprite, callback) {
            var self = this;
            return "function" == typeof sprite && (callback = sprite), sprite && "function" != typeof sprite || (sprite = "_default"), 
            self._loaded ? self._sprite[sprite] ? (self._inactiveNode(function(node) {
                node._sprite = sprite;
                var pos = node._pos > 0 ? node._pos : self._sprite[sprite][0] / 1e3, duration = 0;
                self._webAudio ? (duration = self._sprite[sprite][1] / 1e3 - node._pos, node._pos > 0 && (pos = self._sprite[sprite][0] / 1e3 + pos)) : duration = self._sprite[sprite][1] / 1e3 - (pos - self._sprite[sprite][0] / 1e3);
                var timerId, loop = !(!self._loop && !self._sprite[sprite][2]), soundId = "string" == typeof callback ? callback : Math.round(Date.now() * Math.random()) + "";
                if (function() {
                    var data = {
                        id: soundId,
                        sprite: sprite,
                        loop: loop
                    };
                    timerId = setTimeout(function() {
                        !self._webAudio && loop && self.stop(data.id).play(sprite, data.id), self._webAudio && !loop && (self._nodeById(data.id).paused = !0, 
                        self._nodeById(data.id)._pos = 0, self._clearEndTimer(data.id)), self._webAudio || loop || self.stop(data.id), 
                        self.on("end", soundId);
                    }, duration / self._rate * 1e3), self._onendTimer.push({
                        timer: timerId,
                        id: data.id
                    });
                }(), self._webAudio) {
                    var loopStart = self._sprite[sprite][0] / 1e3, loopEnd = self._sprite[sprite][1] / 1e3;
                    node.id = soundId, node.paused = !1, refreshBuffer(self, [ loop, loopStart, loopEnd ], soundId), 
                    self._playStart = ctx.currentTime, node.gain.value = self._volume, "undefined" == typeof node.bufferSource.start ? loop ? node.bufferSource.noteGrainOn(0, pos, 86400) : node.bufferSource.noteGrainOn(0, pos, duration) : loop ? node.bufferSource.start(0, pos, 86400) : node.bufferSource.start(0, pos, duration);
                } else {
                    if (4 !== node.readyState && (node.readyState || !navigator.isCocoonJS)) return self._clearEndTimer(soundId), 
                    function() {
                        var sound = self, playSprite = sprite, fn = callback, newNode = node, listener = function() {
                            sound.play(playSprite, fn), newNode.removeEventListener("canplaythrough", listener, !1);
                        };
                        newNode.addEventListener("canplaythrough", listener, !1);
                    }(), self;
                    node.readyState = 4, node.id = soundId, node.currentTime = pos, node.muted = Howler._muted || node.muted, 
                    node.volume = self._volume * Howler.volume(), setTimeout(function() {
                        node.play();
                    }, 0);
                }
                return self.on("play"), "function" == typeof callback && callback(soundId), self;
            }), self) : ("function" == typeof callback && callback(), self) : (self.on("load", function() {
                self.play(sprite, callback);
            }), self);
        },
        pause: function(id) {
            var self = this;
            if (!self._loaded) return self.on("play", function() {
                self.pause(id);
            }), self;
            self._clearEndTimer(id);
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            if (activeNode) if (activeNode._pos = self.pos(null, id), self._webAudio) {
                if (!activeNode.bufferSource || activeNode.paused) return self;
                activeNode.paused = !0, "undefined" == typeof activeNode.bufferSource.stop ? activeNode.bufferSource.noteOff(0) : activeNode.bufferSource.stop(0);
            } else activeNode.pause();
            return self.on("pause"), self;
        },
        stop: function(id) {
            var self = this;
            if (!self._loaded) return self.on("play", function() {
                self.stop(id);
            }), self;
            self._clearEndTimer(id);
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            if (activeNode) if (activeNode._pos = 0, self._webAudio) {
                if (!activeNode.bufferSource || activeNode.paused) return self;
                activeNode.paused = !0, "undefined" == typeof activeNode.bufferSource.stop ? activeNode.bufferSource.noteOff(0) : activeNode.bufferSource.stop(0);
            } else isNaN(activeNode.duration) || (activeNode.pause(), activeNode.currentTime = 0);
            return self;
        },
        mute: function(id) {
            var self = this;
            if (!self._loaded) return self.on("play", function() {
                self.mute(id);
            }), self;
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            return activeNode && (self._webAudio ? activeNode.gain.value = 0 : activeNode.muted = !0), 
            self;
        },
        unmute: function(id) {
            var self = this;
            if (!self._loaded) return self.on("play", function() {
                self.unmute(id);
            }), self;
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            return activeNode && (self._webAudio ? activeNode.gain.value = self._volume : activeNode.muted = !1), 
            self;
        },
        volume: function(vol, id) {
            var self = this;
            if (vol = parseFloat(vol), vol >= 0 && 1 >= vol) {
                if (self._volume = vol, !self._loaded) return self.on("play", function() {
                    self.volume(vol, id);
                }), self;
                var activeNode = id ? self._nodeById(id) : self._activeNode();
                return activeNode && (self._webAudio ? activeNode.gain.value = vol : activeNode.volume = vol * Howler.volume()), 
                self;
            }
            return self._volume;
        },
        loop: function(loop) {
            var self = this;
            return "boolean" == typeof loop ? (self._loop = loop, self) : self._loop;
        },
        sprite: function(sprite) {
            var self = this;
            return "object" == typeof sprite ? (self._sprite = sprite, self) : self._sprite;
        },
        pos: function(pos, id) {
            var self = this;
            if (!self._loaded) return self.on("load", function() {
                self.pos(pos);
            }), "number" == typeof pos ? self : self._pos || 0;
            pos = parseFloat(pos);
            var activeNode = id ? self._nodeById(id) : self._activeNode();
            if (activeNode) return pos >= 0 ? (self.pause(id), activeNode._pos = pos, self.play(activeNode._sprite, id), 
            self) : self._webAudio ? activeNode._pos + (ctx.currentTime - self._playStart) : activeNode.currentTime;
            if (pos >= 0) return self;
            for (var i = 0; i < self._audioNode.length; i++) if (self._audioNode[i].paused && 4 === self._audioNode[i].readyState) return self._webAudio ? self._audioNode[i]._pos : self._audioNode[i].currentTime;
        },
        pos3d: function(x, y, z, id) {
            var self = this;
            if (y = "undefined" != typeof y && y ? y : 0, z = "undefined" != typeof z && z ? z : -.5, 
            !self._loaded) return self.on("play", function() {
                self.pos3d(x, y, z, id);
            }), self;
            if (!(x >= 0 || 0 > x)) return self._pos3d;
            if (self._webAudio) {
                var activeNode = id ? self._nodeById(id) : self._activeNode();
                activeNode && (self._pos3d = [ x, y, z ], activeNode.panner.setPosition(x, y, z), 
                activeNode.panner.panningModel = self._model || "HRTF");
            }
            return self;
        },
        fade: function(from, to, len, callback, id) {
            var self = this, diff = Math.abs(from - to), dir = from > to ? "down" : "up", steps = diff / .01, stepTime = len / steps;
            if (!self._loaded) return self.on("load", function() {
                self.fade(from, to, len, callback, id);
            }), self;
            self.volume(from, id);
            for (var i = 1; steps >= i; i++) !function() {
                var change = self._volume + ("up" === dir ? .01 : -.01) * i, vol = Math.round(1e3 * change) / 1e3, toVol = to;
                setTimeout(function() {
                    self.volume(vol, id), vol === toVol && callback && callback();
                }, stepTime * i);
            }();
        },
        fadeIn: function(to, len, callback) {
            return this.volume(0).play().fade(0, to, len, callback);
        },
        fadeOut: function(to, len, callback, id) {
            var self = this;
            return self.fade(self._volume, to, len, function() {
                callback && callback(), self.pause(id), self.on("end");
            }, id);
        },
        _nodeById: function(id) {
            for (var self = this, node = self._audioNode[0], i = 0; i < self._audioNode.length; i++) if (self._audioNode[i].id === id) {
                node = self._audioNode[i];
                break;
            }
            return node;
        },
        _activeNode: function() {
            for (var self = this, node = null, i = 0; i < self._audioNode.length; i++) if (!self._audioNode[i].paused) {
                node = self._audioNode[i];
                break;
            }
            return self._drainPool(), node;
        },
        _inactiveNode: function(callback) {
            for (var self = this, node = null, i = 0; i < self._audioNode.length; i++) if (self._audioNode[i].paused && 4 === self._audioNode[i].readyState) {
                callback(self._audioNode[i]), node = !0;
                break;
            }
            if (self._drainPool(), !node) {
                var newNode;
                if (self._webAudio) newNode = self._setupAudioNode(), callback(newNode); else {
                    self.load(), newNode = self._audioNode[self._audioNode.length - 1];
                    var listenerEvent = navigator.isCocoonJS ? "canplaythrough" : "loadedmetadata", listener = function() {
                        newNode.removeEventListener(listenerEvent, listener, !1), callback(newNode);
                    };
                    newNode.addEventListener(listenerEvent, listener, !1);
                }
            }
        },
        _drainPool: function() {
            var i, self = this, inactive = 0;
            for (i = 0; i < self._audioNode.length; i++) self._audioNode[i].paused && inactive++;
            for (i = self._audioNode.length - 1; i >= 0 && !(5 >= inactive); i--) self._audioNode[i].paused && (self._webAudio && self._audioNode[i].disconnect(0), 
            inactive--, self._audioNode.splice(i, 1));
        },
        _clearEndTimer: function(soundId) {
            for (var self = this, index = -1, i = 0; i < self._onendTimer.length; i++) if (self._onendTimer[i].id === soundId) {
                index = i;
                break;
            }
            var timer = self._onendTimer[index];
            timer && (clearTimeout(timer.timer), self._onendTimer.splice(index, 1));
        },
        _setupAudioNode: function() {
            var self = this, node = self._audioNode, index = self._audioNode.length;
            return node[index] = "undefined" == typeof ctx.createGain ? ctx.createGainNode() : ctx.createGain(), 
            node[index].gain.value = self._volume, node[index].paused = !0, node[index]._pos = 0, 
            node[index].readyState = 4, node[index].connect(masterGain), node[index].panner = ctx.createPanner(), 
            node[index].panner.panningModel = self._model || "equalpower", node[index].panner.setPosition(self._pos3d[0], self._pos3d[1], self._pos3d[2]), 
            node[index].panner.connect(node[index]), node[index];
        },
        on: function(event, fn) {
            var self = this, events = self["_on" + event];
            if ("function" == typeof fn) events.push(fn); else for (var i = 0; i < events.length; i++) fn ? events[i].call(self, fn) : events[i].call(self);
            return self;
        },
        off: function(event, fn) {
            var self = this, events = self["_on" + event];
            if (fn) {
                for (var i = 0; i < events.length; i++) if (fn === events[i]) {
                    events.splice(i, 1);
                    break;
                }
            } else self["_on" + event] = [];
            return self;
        },
        unload: function() {
            for (var self = this, nodes = self._audioNode, i = 0; i < self._audioNode.length; i++) nodes[i].paused || (self.stop(nodes[i].id), 
            self.on("end", nodes[i].id)), self._webAudio ? nodes[i].disconnect(0) : nodes[i].src = "";
            for (i = 0; i < self._onendTimer.length; i++) clearTimeout(self._onendTimer[i].timer);
            var index = Howler._howls.indexOf(self);
            null !== index && index >= 0 && Howler._howls.splice(index, 1), delete cache[self._src], 
            self = null;
        }
    }, usingWebAudio) var loadBuffer = function(obj, url) {
        if (url in cache) return obj._duration = cache[url].duration, void loadSound(obj);
        if (/^data:[^;]+;base64,/.test(url)) {
            for (var data = atob(url.split(",")[1]), dataView = new Uint8Array(data.length), i = 0; i < data.length; ++i) dataView[i] = data.charCodeAt(i);
            decodeAudioData(dataView.buffer, obj, url);
        } else {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, !0), xhr.responseType = "arraybuffer", xhr.onload = function() {
                decodeAudioData(xhr.response, obj, url);
            }, xhr.onerror = function() {
                obj._webAudio && (obj._buffer = !0, obj._webAudio = !1, obj._audioNode = [], delete obj._gainNode, 
                delete cache[url], obj.load());
            };
            try {
                xhr.send();
            } catch (e) {
                xhr.onerror();
            }
        }
    }, decodeAudioData = function(arraybuffer, obj, url) {
        ctx.decodeAudioData(arraybuffer, function(buffer) {
            buffer && (cache[url] = buffer, loadSound(obj, buffer));
        }, function(err) {
            obj.on("loaderror", err);
        });
    }, loadSound = function(obj, buffer) {
        obj._duration = buffer ? buffer.duration : obj._duration, 0 === Object.getOwnPropertyNames(obj._sprite).length && (obj._sprite = {
            _default: [ 0, 1e3 * obj._duration ]
        }), obj._loaded || (obj._loaded = !0, obj.on("load")), obj._autoplay && obj.play();
    }, refreshBuffer = function(obj, loop, id) {
        var node = obj._nodeById(id);
        node.bufferSource = ctx.createBufferSource(), node.bufferSource.buffer = cache[obj._src], 
        node.bufferSource.connect(node.panner), node.bufferSource.loop = loop[0], loop[0] && (node.bufferSource.loopStart = loop[1], 
        node.bufferSource.loopEnd = loop[1] + loop[2]), node.bufferSource.playbackRate.value = obj._rate;
    };
    "function" == typeof define && define.amd && define(function() {
        return {
            Howler: Howler,
            Howl: Howl
        };
    }), "undefined" != typeof exports && (exports.Howler = Howler, exports.Howl = Howl), 
    "undefined" != typeof window && (window.Howler = Howler, window.Howl = Howl);
}();

var io = "undefined" == typeof module ? {} : module.exports;

!function() {
    if (function(exports, global) {
        var io = exports;
        io.version = "0.9.17", io.protocol = 1, io.transports = [], io.j = [], io.sockets = {}, 
        io.connect = function(host, details) {
            var uuri, socket, uri = io.util.parseUri(host);
            global && global.location && (uri.protocol = uri.protocol || global.location.protocol.slice(0, -1), 
            uri.host = uri.host || (global.document ? global.document.domain : global.location.hostname), 
            uri.port = uri.port || global.location.port), uuri = io.util.uniqueUri(uri);
            var options = {
                host: uri.host,
                secure: "https" == uri.protocol,
                port: uri.port || ("https" == uri.protocol ? 443 : 80),
                query: uri.query || ""
            };
            return io.util.merge(options, details), !options["force new connection"] && io.sockets[uuri] || (socket = new io.Socket(options)), 
            !options["force new connection"] && socket && (io.sockets[uuri] = socket), socket = socket || io.sockets[uuri], 
            socket.of(uri.path.length > 1 ? uri.path : "");
        };
    }("object" == typeof module ? module.exports : this.io = {}, this), function(exports, global) {
        var util = exports.util = {}, re = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [ "source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor" ];
        util.parseUri = function(str) {
            for (var m = re.exec(str || ""), uri = {}, i = 14; i--; ) uri[parts[i]] = m[i] || "";
            return uri;
        }, util.uniqueUri = function(uri) {
            var protocol = uri.protocol, host = uri.host, port = uri.port;
            return "document" in global ? (host = host || document.domain, port = port || ("https" == protocol && "https:" !== document.location.protocol ? 443 : document.location.port)) : (host = host || "localhost", 
            port || "https" != protocol || (port = 443)), (protocol || "http") + "://" + host + ":" + (port || 80);
        }, util.query = function(base, addition) {
            var query = util.chunkQuery(base || ""), components = [];
            util.merge(query, util.chunkQuery(addition || ""));
            for (var part in query) query.hasOwnProperty(part) && components.push(part + "=" + query[part]);
            return components.length ? "?" + components.join("&") : "";
        }, util.chunkQuery = function(qs) {
            for (var kv, query = {}, params = qs.split("&"), i = 0, l = params.length; l > i; ++i) kv = params[i].split("="), 
            kv[0] && (query[kv[0]] = kv[1]);
            return query;
        };
        var pageLoaded = !1;
        util.load = function(fn) {
            return "document" in global && "complete" === document.readyState || pageLoaded ? fn() : void util.on(global, "load", fn, !1);
        }, util.on = function(element, event, fn, capture) {
            element.attachEvent ? element.attachEvent("on" + event, fn) : element.addEventListener && element.addEventListener(event, fn, capture);
        }, util.request = function(xdomain) {
            if (xdomain && "undefined" != typeof XDomainRequest && !util.ua.hasCORS) return new XDomainRequest();
            if ("undefined" != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) return new XMLHttpRequest();
            if (!xdomain) try {
                return new (window[[ "Active" ].concat("Object").join("X")])("Microsoft.XMLHTTP");
            } catch (e) {}
            return null;
        }, "undefined" != typeof window && util.load(function() {
            pageLoaded = !0;
        }), util.defer = function(fn) {
            return util.ua.webkit && "undefined" == typeof importScripts ? void util.load(function() {
                setTimeout(fn, 100);
            }) : fn();
        }, util.merge = function(target, additional, deep, lastseen) {
            var prop, seen = lastseen || [], depth = "undefined" == typeof deep ? 2 : deep;
            for (prop in additional) additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0 && ("object" == typeof target[prop] && depth ? util.merge(target[prop], additional[prop], depth - 1, seen) : (target[prop] = additional[prop], 
            seen.push(additional[prop])));
            return target;
        }, util.mixin = function(ctor, ctor2) {
            util.merge(ctor.prototype, ctor2.prototype);
        }, util.inherit = function(ctor, ctor2) {
            function f() {}
            f.prototype = ctor2.prototype, ctor.prototype = new f();
        }, util.isArray = Array.isArray || function(obj) {
            return "[object Array]" === Object.prototype.toString.call(obj);
        }, util.intersect = function(arr, arr2) {
            for (var ret = [], longest = arr.length > arr2.length ? arr : arr2, shortest = arr.length > arr2.length ? arr2 : arr, i = 0, l = shortest.length; l > i; i++) ~util.indexOf(longest, shortest[i]) && ret.push(shortest[i]);
            return ret;
        }, util.indexOf = function(arr, o, i) {
            for (var j = arr.length, i = 0 > i ? 0 > i + j ? 0 : i + j : i || 0; j > i && arr[i] !== o; i++) ;
            return i >= j ? -1 : i;
        }, util.toArray = function(enu) {
            for (var arr = [], i = 0, l = enu.length; l > i; i++) arr.push(enu[i]);
            return arr;
        }, util.ua = {}, util.ua.hasCORS = "undefined" != typeof XMLHttpRequest && function() {
            try {
                var a = new XMLHttpRequest();
            } catch (e) {
                return !1;
            }
            return void 0 != a.withCredentials;
        }(), util.ua.webkit = "undefined" != typeof navigator && /webkit/i.test(navigator.userAgent), 
        util.ua.iDevice = "undefined" != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent);
    }("undefined" != typeof io ? io : module.exports, this), function(exports, io) {
        function EventEmitter() {}
        exports.EventEmitter = EventEmitter, EventEmitter.prototype.on = function(name, fn) {
            return this.$events || (this.$events = {}), this.$events[name] ? io.util.isArray(this.$events[name]) ? this.$events[name].push(fn) : this.$events[name] = [ this.$events[name], fn ] : this.$events[name] = fn, 
            this;
        }, EventEmitter.prototype.addListener = EventEmitter.prototype.on, EventEmitter.prototype.once = function(name, fn) {
            function on() {
                self.removeListener(name, on), fn.apply(this, arguments);
            }
            var self = this;
            return on.listener = fn, this.on(name, on), this;
        }, EventEmitter.prototype.removeListener = function(name, fn) {
            if (this.$events && this.$events[name]) {
                var list = this.$events[name];
                if (io.util.isArray(list)) {
                    for (var pos = -1, i = 0, l = list.length; l > i; i++) if (list[i] === fn || list[i].listener && list[i].listener === fn) {
                        pos = i;
                        break;
                    }
                    if (0 > pos) return this;
                    list.splice(pos, 1), list.length || delete this.$events[name];
                } else (list === fn || list.listener && list.listener === fn) && delete this.$events[name];
            }
            return this;
        }, EventEmitter.prototype.removeAllListeners = function(name) {
            return void 0 === name ? (this.$events = {}, this) : (this.$events && this.$events[name] && (this.$events[name] = null), 
            this);
        }, EventEmitter.prototype.listeners = function(name) {
            return this.$events || (this.$events = {}), this.$events[name] || (this.$events[name] = []), 
            io.util.isArray(this.$events[name]) || (this.$events[name] = [ this.$events[name] ]), 
            this.$events[name];
        }, EventEmitter.prototype.emit = function(name) {
            if (!this.$events) return !1;
            var handler = this.$events[name];
            if (!handler) return !1;
            var args = Array.prototype.slice.call(arguments, 1);
            if ("function" == typeof handler) handler.apply(this, args); else {
                if (!io.util.isArray(handler)) return !1;
                for (var listeners = handler.slice(), i = 0, l = listeners.length; l > i; i++) listeners[i].apply(this, args);
            }
            return !0;
        };
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), 
    function(exports, nativeJSON) {
        "use strict";
        function f(n) {
            return 10 > n ? "0" + n : n;
        }
        function date(d, key) {
            return isFinite(d.valueOf()) ? d.getUTCFullYear() + "-" + f(d.getUTCMonth() + 1) + "-" + f(d.getUTCDate()) + "T" + f(d.getUTCHours()) + ":" + f(d.getUTCMinutes()) + ":" + f(d.getUTCSeconds()) + "Z" : null;
        }
        function quote(string) {
            return escapable.lastIndex = 0, escapable.test(string) ? '"' + string.replace(escapable, function(a) {
                var c = meta[a];
                return "string" == typeof c ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' : '"' + string + '"';
        }
        function str(key, holder) {
            var i, k, v, length, partial, mind = gap, value = holder[key];
            switch (value instanceof Date && (value = date(key)), "function" == typeof rep && (value = rep.call(holder, key, value)), 
            typeof value) {
              case "string":
                return quote(value);

              case "number":
                return isFinite(value) ? String(value) : "null";

              case "boolean":
              case "null":
                return String(value);

              case "object":
                if (!value) return "null";
                if (gap += indent, partial = [], "[object Array]" === Object.prototype.toString.apply(value)) {
                    for (length = value.length, i = 0; length > i; i += 1) partial[i] = str(i, value) || "null";
                    return v = 0 === partial.length ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]", 
                    gap = mind, v;
                }
                if (rep && "object" == typeof rep) for (length = rep.length, i = 0; length > i; i += 1) "string" == typeof rep[i] && (k = rep[i], 
                v = str(k, value), v && partial.push(quote(k) + (gap ? ": " : ":") + v)); else for (k in value) Object.prototype.hasOwnProperty.call(value, k) && (v = str(k, value), 
                v && partial.push(quote(k) + (gap ? ": " : ":") + v));
                return v = 0 === partial.length ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}", 
                gap = mind, v;
            }
        }
        if (nativeJSON && nativeJSON.parse) return exports.JSON = {
            parse: nativeJSON.parse,
            stringify: nativeJSON.stringify
        };
        var JSON = exports.JSON = {}, cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
            "\b": "\\b",
            "	": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            '"': '\\"',
            "\\": "\\\\"
        }, rep;
        JSON.stringify = function(value, replacer, space) {
            var i;
            if (gap = "", indent = "", "number" == typeof space) for (i = 0; space > i; i += 1) indent += " "; else "string" == typeof space && (indent = space);
            if (rep = replacer, replacer && "function" != typeof replacer && ("object" != typeof replacer || "number" != typeof replacer.length)) throw new Error("JSON.stringify");
            return str("", {
                "": value
            });
        }, JSON.parse = function(text, reviver) {
            function walk(holder, key) {
                var k, v, value = holder[key];
                if (value && "object" == typeof value) for (k in value) Object.prototype.hasOwnProperty.call(value, k) && (v = walk(value, k), 
                void 0 !== v ? value[k] = v : delete value[k]);
                return reviver.call(holder, key, value);
            }
            var j;
            if (text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function(a) {
                return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            })), /^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return j = eval("(" + text + ")"), 
            "function" == typeof reviver ? walk({
                "": j
            }, "") : j;
            throw new SyntaxError("JSON.parse");
        };
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof JSON ? JSON : void 0), 
    function(exports, io) {
        var parser = exports.parser = {}, packets = parser.packets = [ "disconnect", "connect", "heartbeat", "message", "json", "event", "ack", "error", "noop" ], reasons = parser.reasons = [ "transport not supported", "client not handshaken", "unauthorized" ], advice = parser.advice = [ "reconnect" ], JSON = io.JSON, indexOf = io.util.indexOf;
        parser.encodePacket = function(packet) {
            var type = indexOf(packets, packet.type), id = packet.id || "", endpoint = packet.endpoint || "", ack = packet.ack, data = null;
            switch (packet.type) {
              case "error":
                var reason = packet.reason ? indexOf(reasons, packet.reason) : "", adv = packet.advice ? indexOf(advice, packet.advice) : "";
                "" === reason && "" === adv || (data = reason + ("" !== adv ? "+" + adv : ""));
                break;

              case "message":
                "" !== packet.data && (data = packet.data);
                break;

              case "event":
                var ev = {
                    name: packet.name
                };
                packet.args && packet.args.length && (ev.args = packet.args), data = JSON.stringify(ev);
                break;

              case "json":
                data = JSON.stringify(packet.data);
                break;

              case "connect":
                packet.qs && (data = packet.qs);
                break;

              case "ack":
                data = packet.ackId + (packet.args && packet.args.length ? "+" + JSON.stringify(packet.args) : "");
            }
            var encoded = [ type, id + ("data" == ack ? "+" : ""), endpoint ];
            return null !== data && void 0 !== data && encoded.push(data), encoded.join(":");
        }, parser.encodePayload = function(packets) {
            var decoded = "";
            if (1 == packets.length) return packets[0];
            for (var i = 0, l = packets.length; l > i; i++) {
                var packet = packets[i];
                decoded += "�" + packet.length + "�" + packets[i];
            }
            return decoded;
        };
        var regexp = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;
        parser.decodePacket = function(data) {
            var pieces = data.match(regexp);
            if (!pieces) return {};
            var id = pieces[2] || "", data = pieces[5] || "", packet = {
                type: packets[pieces[1]],
                endpoint: pieces[4] || ""
            };
            switch (id && (packet.id = id, pieces[3] ? packet.ack = "data" : packet.ack = !0), 
            packet.type) {
              case "error":
                var pieces = data.split("+");
                packet.reason = reasons[pieces[0]] || "", packet.advice = advice[pieces[1]] || "";
                break;

              case "message":
                packet.data = data || "";
                break;

              case "event":
                try {
                    var opts = JSON.parse(data);
                    packet.name = opts.name, packet.args = opts.args;
                } catch (e) {}
                packet.args = packet.args || [];
                break;

              case "json":
                try {
                    packet.data = JSON.parse(data);
                } catch (e) {}
                break;

              case "connect":
                packet.qs = data || "";
                break;

              case "ack":
                var pieces = data.match(/^([0-9]+)(\+)?(.*)/);
                if (pieces && (packet.ackId = pieces[1], packet.args = [], pieces[3])) try {
                    packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];
                } catch (e) {}
                break;

              case "disconnect":
              case "heartbeat":            }
            return packet;
        }, parser.decodePayload = function(data) {
            if ("�" == data.charAt(0)) {
                for (var ret = [], i = 1, length = ""; i < data.length; i++) "�" == data.charAt(i) ? (ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length))), 
                i += Number(length) + 1, length = "") : length += data.charAt(i);
                return ret;
            }
            return [ parser.decodePacket(data) ];
        };
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), 
    function(exports, io) {
        function Transport(socket, sessid) {
            this.socket = socket, this.sessid = sessid;
        }
        exports.Transport = Transport, io.util.mixin(Transport, io.EventEmitter), Transport.prototype.heartbeats = function() {
            return !0;
        }, Transport.prototype.onData = function(data) {
            if (this.clearCloseTimeout(), (this.socket.connected || this.socket.connecting || this.socket.reconnecting) && this.setCloseTimeout(), 
            "" !== data) {
                var msgs = io.parser.decodePayload(data);
                if (msgs && msgs.length) for (var i = 0, l = msgs.length; l > i; i++) this.onPacket(msgs[i]);
            }
            return this;
        }, Transport.prototype.onPacket = function(packet) {
            return this.socket.setHeartbeatTimeout(), "heartbeat" == packet.type ? this.onHeartbeat() : ("connect" == packet.type && "" == packet.endpoint && this.onConnect(), 
            "error" == packet.type && "reconnect" == packet.advice && (this.isOpen = !1), this.socket.onPacket(packet), 
            this);
        }, Transport.prototype.setCloseTimeout = function() {
            if (!this.closeTimeout) {
                var self = this;
                this.closeTimeout = setTimeout(function() {
                    self.onDisconnect();
                }, this.socket.closeTimeout);
            }
        }, Transport.prototype.onDisconnect = function() {
            return this.isOpen && this.close(), this.clearTimeouts(), this.socket.onDisconnect(), 
            this;
        }, Transport.prototype.onConnect = function() {
            return this.socket.onConnect(), this;
        }, Transport.prototype.clearCloseTimeout = function() {
            this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null);
        }, Transport.prototype.clearTimeouts = function() {
            this.clearCloseTimeout(), this.reopenTimeout && clearTimeout(this.reopenTimeout);
        }, Transport.prototype.packet = function(packet) {
            this.send(io.parser.encodePacket(packet));
        }, Transport.prototype.onHeartbeat = function(heartbeat) {
            this.packet({
                type: "heartbeat"
            });
        }, Transport.prototype.onOpen = function() {
            this.isOpen = !0, this.clearCloseTimeout(), this.socket.onOpen();
        }, Transport.prototype.onClose = function() {
            this.isOpen = !1, this.socket.onClose(), this.onDisconnect();
        }, Transport.prototype.prepareUrl = function() {
            var options = this.socket.options;
            return this.scheme() + "://" + options.host + ":" + options.port + "/" + options.resource + "/" + io.protocol + "/" + this.name + "/" + this.sessid;
        }, Transport.prototype.ready = function(socket, fn) {
            fn.call(this);
        };
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), 
    function(exports, io, global) {
        function Socket(options) {
            if (this.options = {
                port: 80,
                secure: !1,
                document: "document" in global ? document : !1,
                resource: "socket.io",
                transports: io.transports,
                "connect timeout": 1e4,
                "try multiple transports": !0,
                reconnect: !0,
                "reconnection delay": 500,
                "reconnection limit": 1 / 0,
                "reopen delay": 3e3,
                "max reconnection attempts": 10,
                "sync disconnect on unload": !1,
                "auto connect": !0,
                "flash policy port": 10843,
                manualFlush: !1
            }, io.util.merge(this.options, options), this.connected = !1, this.open = !1, this.connecting = !1, 
            this.reconnecting = !1, this.namespaces = {}, this.buffer = [], this.doBuffer = !1, 
            this.options["sync disconnect on unload"] && (!this.isXDomain() || io.util.ua.hasCORS)) {
                var self = this;
                io.util.on(global, "beforeunload", function() {
                    self.disconnectSync();
                }, !1);
            }
            this.options["auto connect"] && this.connect();
        }
        function empty() {}
        exports.Socket = Socket, io.util.mixin(Socket, io.EventEmitter), Socket.prototype.of = function(name) {
            return this.namespaces[name] || (this.namespaces[name] = new io.SocketNamespace(this, name), 
            "" !== name && this.namespaces[name].packet({
                type: "connect"
            })), this.namespaces[name];
        }, Socket.prototype.publish = function() {
            this.emit.apply(this, arguments);
            var nsp;
            for (var i in this.namespaces) this.namespaces.hasOwnProperty(i) && (nsp = this.of(i), 
            nsp.$emit.apply(nsp, arguments));
        }, Socket.prototype.handshake = function(fn) {
            function complete(data) {
                data instanceof Error ? (self.connecting = !1, self.onError(data.message)) : fn.apply(null, data.split(":"));
            }
            var self = this, options = this.options, url = [ "http" + (options.secure ? "s" : "") + ":/", options.host + ":" + options.port, options.resource, io.protocol, io.util.query(this.options.query, "t=" + +new Date()) ].join("/");
            if (this.isXDomain() && !io.util.ua.hasCORS) {
                var insertAt = document.getElementsByTagName("script")[0], script = document.createElement("script");
                script.src = url + "&jsonp=" + io.j.length, insertAt.parentNode.insertBefore(script, insertAt), 
                io.j.push(function(data) {
                    complete(data), script.parentNode.removeChild(script);
                });
            } else {
                var xhr = io.util.request();
                xhr.open("GET", url, !0), this.isXDomain() && (xhr.withCredentials = !0), xhr.onreadystatechange = function() {
                    4 == xhr.readyState && (xhr.onreadystatechange = empty, 200 == xhr.status ? complete(xhr.responseText) : 403 == xhr.status ? self.onError(xhr.responseText) : (self.connecting = !1, 
                    !self.reconnecting && self.onError(xhr.responseText)));
                }, xhr.send(null);
            }
        }, Socket.prototype.getTransport = function(override) {
            for (var transport, transports = override || this.transports, i = 0; transport = transports[i]; i++) if (io.Transport[transport] && io.Transport[transport].check(this) && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) return new io.Transport[transport](this, this.sessionid);
            return null;
        }, Socket.prototype.connect = function(fn) {
            if (this.connecting) return this;
            var self = this;
            return self.connecting = !0, this.handshake(function(sid, heartbeat, close, transports) {
                function connect(transports) {
                    return self.transport && self.transport.clearTimeouts(), self.transport = self.getTransport(transports), 
                    self.transport ? void self.transport.ready(self, function() {
                        self.connecting = !0, self.publish("connecting", self.transport.name), self.transport.open(), 
                        self.options["connect timeout"] && (self.connectTimeoutTimer = setTimeout(function() {
                            if (!self.connected && (self.connecting = !1, self.options["try multiple transports"])) {
                                for (var remaining = self.transports; remaining.length > 0 && remaining.splice(0, 1)[0] != self.transport.name; ) ;
                                remaining.length ? connect(remaining) : self.publish("connect_failed");
                            }
                        }, self.options["connect timeout"]));
                    }) : self.publish("connect_failed");
                }
                self.sessionid = sid, self.closeTimeout = 1e3 * close, self.heartbeatTimeout = 1e3 * heartbeat, 
                self.transports || (self.transports = self.origTransports = transports ? io.util.intersect(transports.split(","), self.options.transports) : self.options.transports), 
                self.setHeartbeatTimeout(), connect(self.transports), self.once("connect", function() {
                    clearTimeout(self.connectTimeoutTimer), fn && "function" == typeof fn && fn();
                });
            }), this;
        }, Socket.prototype.setHeartbeatTimeout = function() {
            if (clearTimeout(this.heartbeatTimeoutTimer), !this.transport || this.transport.heartbeats()) {
                var self = this;
                this.heartbeatTimeoutTimer = setTimeout(function() {
                    self.transport.onClose();
                }, this.heartbeatTimeout);
            }
        }, Socket.prototype.packet = function(data) {
            return this.connected && !this.doBuffer ? this.transport.packet(data) : this.buffer.push(data), 
            this;
        }, Socket.prototype.setBuffer = function(v) {
            this.doBuffer = v, !v && this.connected && this.buffer.length && (this.options.manualFlush || this.flushBuffer());
        }, Socket.prototype.flushBuffer = function() {
            this.transport.payload(this.buffer), this.buffer = [];
        }, Socket.prototype.disconnect = function() {
            return (this.connected || this.connecting) && (this.open && this.of("").packet({
                type: "disconnect"
            }), this.onDisconnect("booted")), this;
        }, Socket.prototype.disconnectSync = function() {
            var xhr = io.util.request(), uri = [ "http" + (this.options.secure ? "s" : "") + ":/", this.options.host + ":" + this.options.port, this.options.resource, io.protocol, "", this.sessionid ].join("/") + "/?disconnect=1";
            xhr.open("GET", uri, !1), xhr.send(null), this.onDisconnect("booted");
        }, Socket.prototype.isXDomain = function() {
            var port = global.location.port || ("https:" == global.location.protocol ? 443 : 80);
            return this.options.host !== global.location.hostname || this.options.port != port;
        }, Socket.prototype.onConnect = function() {
            this.connected || (this.connected = !0, this.connecting = !1, this.doBuffer || this.setBuffer(!1), 
            this.emit("connect"));
        }, Socket.prototype.onOpen = function() {
            this.open = !0;
        }, Socket.prototype.onClose = function() {
            this.open = !1, clearTimeout(this.heartbeatTimeoutTimer);
        }, Socket.prototype.onPacket = function(packet) {
            this.of(packet.endpoint).onPacket(packet);
        }, Socket.prototype.onError = function(err) {
            err && err.advice && "reconnect" === err.advice && (this.connected || this.connecting) && (this.disconnect(), 
            this.options.reconnect && this.reconnect()), this.publish("error", err && err.reason ? err.reason : err);
        }, Socket.prototype.onDisconnect = function(reason) {
            var wasConnected = this.connected, wasConnecting = this.connecting;
            this.connected = !1, this.connecting = !1, this.open = !1, (wasConnected || wasConnecting) && (this.transport.close(), 
            this.transport.clearTimeouts(), wasConnected && (this.publish("disconnect", reason), 
            "booted" != reason && this.options.reconnect && !this.reconnecting && this.reconnect()));
        }, Socket.prototype.reconnect = function() {
            function reset() {
                if (self.connected) {
                    for (var i in self.namespaces) self.namespaces.hasOwnProperty(i) && "" !== i && self.namespaces[i].packet({
                        type: "connect"
                    });
                    self.publish("reconnect", self.transport.name, self.reconnectionAttempts);
                }
                clearTimeout(self.reconnectionTimer), self.removeListener("connect_failed", maybeReconnect), 
                self.removeListener("connect", maybeReconnect), self.reconnecting = !1, delete self.reconnectionAttempts, 
                delete self.reconnectionDelay, delete self.reconnectionTimer, delete self.redoTransports, 
                self.options["try multiple transports"] = tryMultiple;
            }
            function maybeReconnect() {
                return self.reconnecting ? self.connected ? reset() : self.connecting && self.reconnecting ? self.reconnectionTimer = setTimeout(maybeReconnect, 1e3) : void (self.reconnectionAttempts++ >= maxAttempts ? self.redoTransports ? (self.publish("reconnect_failed"), 
                reset()) : (self.on("connect_failed", maybeReconnect), self.options["try multiple transports"] = !0, 
                self.transports = self.origTransports, self.transport = self.getTransport(), self.redoTransports = !0, 
                self.connect()) : (self.reconnectionDelay < limit && (self.reconnectionDelay *= 2), 
                self.connect(), self.publish("reconnecting", self.reconnectionDelay, self.reconnectionAttempts), 
                self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay))) : void 0;
            }
            this.reconnecting = !0, this.reconnectionAttempts = 0, this.reconnectionDelay = this.options["reconnection delay"];
            var self = this, maxAttempts = this.options["max reconnection attempts"], tryMultiple = this.options["try multiple transports"], limit = this.options["reconnection limit"];
            this.options["try multiple transports"] = !1, this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay), 
            this.on("connect", maybeReconnect);
        };
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), 
    function(exports, io) {
        function SocketNamespace(socket, name) {
            this.socket = socket, this.name = name || "", this.flags = {}, this.json = new Flag(this, "json"), 
            this.ackPackets = 0, this.acks = {};
        }
        function Flag(nsp, name) {
            this.namespace = nsp, this.name = name;
        }
        exports.SocketNamespace = SocketNamespace, io.util.mixin(SocketNamespace, io.EventEmitter), 
        SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit, SocketNamespace.prototype.of = function() {
            return this.socket.of.apply(this.socket, arguments);
        }, SocketNamespace.prototype.packet = function(packet) {
            return packet.endpoint = this.name, this.socket.packet(packet), this.flags = {}, 
            this;
        }, SocketNamespace.prototype.send = function(data, fn) {
            var packet = {
                type: this.flags.json ? "json" : "message",
                data: data
            };
            return "function" == typeof fn && (packet.id = ++this.ackPackets, packet.ack = !0, 
            this.acks[packet.id] = fn), this.packet(packet);
        }, SocketNamespace.prototype.emit = function(name) {
            var args = Array.prototype.slice.call(arguments, 1), lastArg = args[args.length - 1], packet = {
                type: "event",
                name: name
            };
            return "function" == typeof lastArg && (packet.id = ++this.ackPackets, packet.ack = "data", 
            this.acks[packet.id] = lastArg, args = args.slice(0, args.length - 1)), packet.args = args, 
            this.packet(packet);
        }, SocketNamespace.prototype.disconnect = function() {
            return "" === this.name ? this.socket.disconnect() : (this.packet({
                type: "disconnect"
            }), this.$emit("disconnect")), this;
        }, SocketNamespace.prototype.onPacket = function(packet) {
            function ack() {
                self.packet({
                    type: "ack",
                    args: io.util.toArray(arguments),
                    ackId: packet.id
                });
            }
            var self = this;
            switch (packet.type) {
              case "connect":
                this.$emit("connect");
                break;

              case "disconnect":
                "" === this.name ? this.socket.onDisconnect(packet.reason || "booted") : this.$emit("disconnect", packet.reason);
                break;

              case "message":
              case "json":
                var params = [ "message", packet.data ];
                "data" == packet.ack ? params.push(ack) : packet.ack && this.packet({
                    type: "ack",
                    ackId: packet.id
                }), this.$emit.apply(this, params);
                break;

              case "event":
                var params = [ packet.name ].concat(packet.args);
                "data" == packet.ack && params.push(ack), this.$emit.apply(this, params);
                break;

              case "ack":
                this.acks[packet.ackId] && (this.acks[packet.ackId].apply(this, packet.args), delete this.acks[packet.ackId]);
                break;

              case "error":
                packet.advice ? this.socket.onError(packet) : "unauthorized" == packet.reason ? this.$emit("connect_failed", packet.reason) : this.$emit("error", packet.reason);
            }
        }, Flag.prototype.send = function() {
            this.namespace.flags[this.name] = !0, this.namespace.send.apply(this.namespace, arguments);
        }, Flag.prototype.emit = function() {
            this.namespace.flags[this.name] = !0, this.namespace.emit.apply(this.namespace, arguments);
        };
    }("undefined" != typeof io ? io : module.exports, "undefined" != typeof io ? io : module.parent.exports), 
    function(exports, io, global) {
        function WS(socket) {
            io.Transport.apply(this, arguments);
        }
        exports.websocket = WS, io.util.inherit(WS, io.Transport), WS.prototype.name = "websocket", 
        WS.prototype.open = function() {
            var Socket, query = io.util.query(this.socket.options.query), self = this;
            return Socket || (Socket = global.MozWebSocket || global.WebSocket), this.websocket = new Socket(this.prepareUrl() + query), 
            this.websocket.onopen = function() {
                self.onOpen(), self.socket.setBuffer(!1);
            }, this.websocket.onmessage = function(ev) {
                self.onData(ev.data);
            }, this.websocket.onclose = function() {
                self.onClose(), self.socket.setBuffer(!0);
            }, this.websocket.onerror = function(e) {
                self.onError(e);
            }, this;
        }, io.util.ua.iDevice ? WS.prototype.send = function(data) {
            var self = this;
            return setTimeout(function() {
                self.websocket.send(data);
            }, 0), this;
        } : WS.prototype.send = function(data) {
            return this.websocket.send(data), this;
        }, WS.prototype.payload = function(arr) {
            for (var i = 0, l = arr.length; l > i; i++) this.packet(arr[i]);
            return this;
        }, WS.prototype.close = function() {
            return this.websocket.close(), this;
        }, WS.prototype.onError = function(e) {
            this.socket.onError(e);
        }, WS.prototype.scheme = function() {
            return this.socket.options.secure ? "wss" : "ws";
        }, WS.check = function() {
            return "WebSocket" in global && !("__addTask" in WebSocket) || "MozWebSocket" in global;
        }, WS.xdomainCheck = function() {
            return !0;
        }, io.transports.push("websocket");
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), 
    function(exports, io) {
        function Flashsocket() {
            io.Transport.websocket.apply(this, arguments);
        }
        exports.flashsocket = Flashsocket, io.util.inherit(Flashsocket, io.Transport.websocket), 
        Flashsocket.prototype.name = "flashsocket", Flashsocket.prototype.open = function() {
            var self = this, args = arguments;
            return WebSocket.__addTask(function() {
                io.Transport.websocket.prototype.open.apply(self, args);
            }), this;
        }, Flashsocket.prototype.send = function() {
            var self = this, args = arguments;
            return WebSocket.__addTask(function() {
                io.Transport.websocket.prototype.send.apply(self, args);
            }), this;
        }, Flashsocket.prototype.close = function() {
            return WebSocket.__tasks.length = 0, io.Transport.websocket.prototype.close.call(this), 
            this;
        }, Flashsocket.prototype.ready = function(socket, fn) {
            function init() {
                var options = socket.options, port = options["flash policy port"], path = [ "http" + (options.secure ? "s" : "") + ":/", options.host + ":" + options.port, options.resource, "static/flashsocket", "WebSocketMain" + (socket.isXDomain() ? "Insecure" : "") + ".swf" ];
                Flashsocket.loaded || ("undefined" == typeof WEB_SOCKET_SWF_LOCATION && (WEB_SOCKET_SWF_LOCATION = path.join("/")), 
                843 !== port && WebSocket.loadFlashPolicyFile("xmlsocket://" + options.host + ":" + port), 
                WebSocket.__initialize(), Flashsocket.loaded = !0), fn.call(self);
            }
            var self = this;
            return document.body ? init() : void io.util.load(init);
        }, Flashsocket.check = function() {
            return "undefined" != typeof WebSocket && "__initialize" in WebSocket && swfobject ? swfobject.getFlashPlayerVersion().major >= 10 : !1;
        }, Flashsocket.xdomainCheck = function() {
            return !0;
        }, "undefined" != typeof window && (WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = !0), 
        io.transports.push("flashsocket");
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports), 
    "undefined" != typeof window) var swfobject = function() {
        function f() {
            if (!J) {
                try {
                    var Z = j.getElementsByTagName("body")[0].appendChild(C("span"));
                    Z.parentNode.removeChild(Z);
                } catch (aa) {
                    return;
                }
                J = !0;
                for (var X = U.length, Y = 0; X > Y; Y++) U[Y]();
            }
        }
        function K(X) {
            J ? X() : U[U.length] = X;
        }
        function s(Y) {
            if (typeof O.addEventListener != D) O.addEventListener("load", Y, !1); else if (typeof j.addEventListener != D) j.addEventListener("load", Y, !1); else if (typeof O.attachEvent != D) i(O, "onload", Y); else if ("function" == typeof O.onload) {
                var X = O.onload;
                O.onload = function() {
                    X(), Y();
                };
            } else O.onload = Y;
        }
        function h() {
            T ? V() : H();
        }
        function V() {
            var X = j.getElementsByTagName("body")[0], aa = C(r);
            aa.setAttribute("type", q);
            var Z = X.appendChild(aa);
            if (Z) {
                var Y = 0;
                !function() {
                    if (typeof Z.GetVariable != D) {
                        var ab = Z.GetVariable("$version");
                        ab && (ab = ab.split(" ")[1].split(","), M.pv = [ parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10) ]);
                    } else if (10 > Y) return Y++, void setTimeout(arguments.callee, 10);
                    X.removeChild(aa), Z = null, H();
                }();
            } else H();
        }
        function H() {
            var ag = o.length;
            if (ag > 0) for (var af = 0; ag > af; af++) {
                var Y = o[af].id, ab = o[af].callbackFn, aa = {
                    success: !1,
                    id: Y
                };
                if (M.pv[0] > 0) {
                    var ae = c(Y);
                    if (ae) if (!F(o[af].swfVersion) || M.wk && M.wk < 312) if (o[af].expressInstall && A()) {
                        var ai = {};
                        ai.data = o[af].expressInstall, ai.width = ae.getAttribute("width") || "0", ai.height = ae.getAttribute("height") || "0", 
                        ae.getAttribute("class") && (ai.styleclass = ae.getAttribute("class")), ae.getAttribute("align") && (ai.align = ae.getAttribute("align"));
                        for (var ah = {}, X = ae.getElementsByTagName("param"), ac = X.length, ad = 0; ac > ad; ad++) "movie" != X[ad].getAttribute("name").toLowerCase() && (ah[X[ad].getAttribute("name")] = X[ad].getAttribute("value"));
                        P(ai, ah, Y, ab);
                    } else p(ae), ab && ab(aa); else w(Y, !0), ab && (aa.success = !0, aa.ref = z(Y), 
                    ab(aa));
                } else if (w(Y, !0), ab) {
                    var Z = z(Y);
                    Z && typeof Z.SetVariable != D && (aa.success = !0, aa.ref = Z), ab(aa);
                }
            }
        }
        function z(aa) {
            var X = null, Y = c(aa);
            if (Y && "OBJECT" == Y.nodeName) if (typeof Y.SetVariable != D) X = Y; else {
                var Z = Y.getElementsByTagName(r)[0];
                Z && (X = Z);
            }
            return X;
        }
        function A() {
            return !a && F("6.0.65") && (M.win || M.mac) && !(M.wk && M.wk < 312);
        }
        function P(aa, ab, X, Z) {
            a = !0, E = Z || null, B = {
                success: !1,
                id: X
            };
            var ae = c(X);
            if (ae) {
                "OBJECT" == ae.nodeName ? (l = g(ae), Q = null) : (l = ae, Q = X), aa.id = R, (typeof aa.width == D || !/%$/.test(aa.width) && parseInt(aa.width, 10) < 310) && (aa.width = "310"), 
                (typeof aa.height == D || !/%$/.test(aa.height) && parseInt(aa.height, 10) < 137) && (aa.height = "137"), 
                j.title = j.title.slice(0, 47) + " - Flash Player Installation";
                var ad = M.ie && M.win ? [ "Active" ].concat("").join("X") : "PlugIn", ac = "MMredirectURL=" + O.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + ad + "&MMdoctitle=" + j.title;
                if (typeof ab.flashvars != D ? ab.flashvars += "&" + ac : ab.flashvars = ac, M.ie && M.win && 4 != ae.readyState) {
                    var Y = C("div");
                    X += "SWFObjectNew", Y.setAttribute("id", X), ae.parentNode.insertBefore(Y, ae), 
                    ae.style.display = "none", function() {
                        4 == ae.readyState ? ae.parentNode.removeChild(ae) : setTimeout(arguments.callee, 10);
                    }();
                }
                u(aa, ab, X);
            }
        }
        function p(Y) {
            if (M.ie && M.win && 4 != Y.readyState) {
                var X = C("div");
                Y.parentNode.insertBefore(X, Y), X.parentNode.replaceChild(g(Y), X), Y.style.display = "none", 
                function() {
                    4 == Y.readyState ? Y.parentNode.removeChild(Y) : setTimeout(arguments.callee, 10);
                }();
            } else Y.parentNode.replaceChild(g(Y), Y);
        }
        function g(ab) {
            var aa = C("div");
            if (M.win && M.ie) aa.innerHTML = ab.innerHTML; else {
                var Y = ab.getElementsByTagName(r)[0];
                if (Y) {
                    var ad = Y.childNodes;
                    if (ad) for (var X = ad.length, Z = 0; X > Z; Z++) 1 == ad[Z].nodeType && "PARAM" == ad[Z].nodeName || 8 == ad[Z].nodeType || aa.appendChild(ad[Z].cloneNode(!0));
                }
            }
            return aa;
        }
        function u(ai, ag, Y) {
            var X, aa = c(Y);
            if (M.wk && M.wk < 312) return X;
            if (aa) if (typeof ai.id == D && (ai.id = Y), M.ie && M.win) {
                var ah = "";
                for (var ae in ai) ai[ae] != Object.prototype[ae] && ("data" == ae.toLowerCase() ? ag.movie = ai[ae] : "styleclass" == ae.toLowerCase() ? ah += ' class="' + ai[ae] + '"' : "classid" != ae.toLowerCase() && (ah += " " + ae + '="' + ai[ae] + '"'));
                var af = "";
                for (var ad in ag) ag[ad] != Object.prototype[ad] && (af += '<param name="' + ad + '" value="' + ag[ad] + '" />');
                aa.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + ah + ">" + af + "</object>", 
                N[N.length] = ai.id, X = c(ai.id);
            } else {
                var Z = C(r);
                Z.setAttribute("type", q);
                for (var ac in ai) ai[ac] != Object.prototype[ac] && ("styleclass" == ac.toLowerCase() ? Z.setAttribute("class", ai[ac]) : "classid" != ac.toLowerCase() && Z.setAttribute(ac, ai[ac]));
                for (var ab in ag) ag[ab] != Object.prototype[ab] && "movie" != ab.toLowerCase() && e(Z, ab, ag[ab]);
                aa.parentNode.replaceChild(Z, aa), X = Z;
            }
            return X;
        }
        function e(Z, X, Y) {
            var aa = C("param");
            aa.setAttribute("name", X), aa.setAttribute("value", Y), Z.appendChild(aa);
        }
        function y(Y) {
            var X = c(Y);
            X && "OBJECT" == X.nodeName && (M.ie && M.win ? (X.style.display = "none", function() {
                4 == X.readyState ? b(Y) : setTimeout(arguments.callee, 10);
            }()) : X.parentNode.removeChild(X));
        }
        function b(Z) {
            var Y = c(Z);
            if (Y) {
                for (var X in Y) "function" == typeof Y[X] && (Y[X] = null);
                Y.parentNode.removeChild(Y);
            }
        }
        function c(Z) {
            var X = null;
            try {
                X = j.getElementById(Z);
            } catch (Y) {}
            return X;
        }
        function C(X) {
            return j.createElement(X);
        }
        function i(Z, X, Y) {
            Z.attachEvent(X, Y), I[I.length] = [ Z, X, Y ];
        }
        function F(Z) {
            var Y = M.pv, X = Z.split(".");
            return X[0] = parseInt(X[0], 10), X[1] = parseInt(X[1], 10) || 0, X[2] = parseInt(X[2], 10) || 0, 
            Y[0] > X[0] || Y[0] == X[0] && Y[1] > X[1] || Y[0] == X[0] && Y[1] == X[1] && Y[2] >= X[2];
        }
        function v(ac, Y, ad, ab) {
            if (!M.ie || !M.mac) {
                var aa = j.getElementsByTagName("head")[0];
                if (aa) {
                    var X = ad && "string" == typeof ad ? ad : "screen";
                    if (ab && (n = null, G = null), !n || G != X) {
                        var Z = C("style");
                        Z.setAttribute("type", "text/css"), Z.setAttribute("media", X), n = aa.appendChild(Z), 
                        M.ie && M.win && typeof j.styleSheets != D && j.styleSheets.length > 0 && (n = j.styleSheets[j.styleSheets.length - 1]), 
                        G = X;
                    }
                    M.ie && M.win ? n && typeof n.addRule == r && n.addRule(ac, Y) : n && typeof j.createTextNode != D && n.appendChild(j.createTextNode(ac + " {" + Y + "}"));
                }
            }
        }
        function w(Z, X) {
            if (m) {
                var Y = X ? "visible" : "hidden";
                J && c(Z) ? c(Z).style.visibility = Y : v("#" + Z, "visibility:" + Y);
            }
        }
        function L(Y) {
            var Z = /[\\\"<>\.;]/, X = null != Z.exec(Y);
            return X && typeof encodeURIComponent != D ? encodeURIComponent(Y) : Y;
        }
        var l, Q, E, B, n, G, D = "undefined", r = "object", S = "Shockwave Flash", W = "ShockwaveFlash.ShockwaveFlash", q = "application/x-shockwave-flash", R = "SWFObjectExprInst", x = "onreadystatechange", O = window, j = document, t = navigator, T = !1, U = [ h ], o = [], N = [], I = [], J = !1, a = !1, m = !0, M = function() {
            var aa = typeof j.getElementById != D && typeof j.getElementsByTagName != D && typeof j.createElement != D, ah = t.userAgent.toLowerCase(), Y = t.platform.toLowerCase(), ae = Y ? /win/.test(Y) : /win/.test(ah), ac = Y ? /mac/.test(Y) : /mac/.test(ah), af = /webkit/.test(ah) ? parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : !1, X = !1, ag = [ 0, 0, 0 ], ab = null;
            if (typeof t.plugins != D && typeof t.plugins[S] == r) ab = t.plugins[S].description, 
            !ab || typeof t.mimeTypes != D && t.mimeTypes[q] && !t.mimeTypes[q].enabledPlugin || (T = !0, 
            X = !1, ab = ab.replace(/^.*\s+(\S+\s+\S+$)/, "$1"), ag[0] = parseInt(ab.replace(/^(.*)\..*$/, "$1"), 10), 
            ag[1] = parseInt(ab.replace(/^.*\.(.*)\s.*$/, "$1"), 10), ag[2] = /[a-zA-Z]/.test(ab) ? parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0); else if (typeof O[[ "Active" ].concat("Object").join("X")] != D) try {
                var ad = new (window[[ "Active" ].concat("Object").join("X")])(W);
                ad && (ab = ad.GetVariable("$version"), ab && (X = !0, ab = ab.split(" ")[1].split(","), 
                ag = [ parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10) ]));
            } catch (Z) {}
            return {
                w3: aa,
                pv: ag,
                wk: af,
                ie: X,
                win: ae,
                mac: ac
            };
        }();
        (function() {
            M.w3 && ((typeof j.readyState != D && "complete" == j.readyState || typeof j.readyState == D && (j.getElementsByTagName("body")[0] || j.body)) && f(), 
            J || (typeof j.addEventListener != D && j.addEventListener("DOMContentLoaded", f, !1), 
            M.ie && M.win && (j.attachEvent(x, function() {
                "complete" == j.readyState && (j.detachEvent(x, arguments.callee), f());
            }), O == top && !function() {
                if (!J) {
                    try {
                        j.documentElement.doScroll("left");
                    } catch (X) {
                        return void setTimeout(arguments.callee, 0);
                    }
                    f();
                }
            }()), M.wk && !function() {
                return J ? void 0 : /loaded|complete/.test(j.readyState) ? void f() : void setTimeout(arguments.callee, 0);
            }(), s(f)));
        })(), function() {
            M.ie && M.win && window.attachEvent("onunload", function() {
                for (var ac = I.length, ab = 0; ac > ab; ab++) I[ab][0].detachEvent(I[ab][1], I[ab][2]);
                for (var Z = N.length, aa = 0; Z > aa; aa++) y(N[aa]);
                for (var Y in M) M[Y] = null;
                M = null;
                for (var X in swfobject) swfobject[X] = null;
                swfobject = null;
            });
        }();
        return {
            registerObject: function(ab, X, aa, Z) {
                if (M.w3 && ab && X) {
                    var Y = {};
                    Y.id = ab, Y.swfVersion = X, Y.expressInstall = aa, Y.callbackFn = Z, o[o.length] = Y, 
                    w(ab, !1);
                } else Z && Z({
                    success: !1,
                    id: ab
                });
            },
            getObjectById: function(X) {
                return M.w3 ? z(X) : void 0;
            },
            embedSWF: function(ab, ah, ae, ag, Y, aa, Z, ad, af, ac) {
                var X = {
                    success: !1,
                    id: ah
                };
                M.w3 && !(M.wk && M.wk < 312) && ab && ah && ae && ag && Y ? (w(ah, !1), K(function() {
                    ae += "", ag += "";
                    var aj = {};
                    if (af && typeof af === r) for (var al in af) aj[al] = af[al];
                    aj.data = ab, aj.width = ae, aj.height = ag;
                    var am = {};
                    if (ad && typeof ad === r) for (var ak in ad) am[ak] = ad[ak];
                    if (Z && typeof Z === r) for (var ai in Z) typeof am.flashvars != D ? am.flashvars += "&" + ai + "=" + Z[ai] : am.flashvars = ai + "=" + Z[ai];
                    if (F(Y)) {
                        var an = u(aj, am, ah);
                        aj.id == ah && w(ah, !0), X.success = !0, X.ref = an;
                    } else {
                        if (aa && A()) return aj.data = aa, void P(aj, am, ah, ac);
                        w(ah, !0);
                    }
                    ac && ac(X);
                })) : ac && ac(X);
            },
            switchOffAutoHideShow: function() {
                m = !1;
            },
            ua: M,
            getFlashPlayerVersion: function() {
                return {
                    major: M.pv[0],
                    minor: M.pv[1],
                    release: M.pv[2]
                };
            },
            hasFlashPlayerVersion: F,
            createSWF: function(Z, Y, X) {
                return M.w3 ? u(Z, Y, X) : void 0;
            },
            showExpressInstall: function(Z, aa, X, Y) {
                M.w3 && A() && P(Z, aa, X, Y);
            },
            removeSWF: function(X) {
                M.w3 && y(X);
            },
            createCSS: function(aa, Z, Y, X) {
                M.w3 && v(aa, Z, Y, X);
            },
            addDomLoadEvent: K,
            addLoadEvent: s,
            getQueryParamValue: function(aa) {
                var Z = j.location.search || j.location.hash;
                if (Z) {
                    if (/\?/.test(Z) && (Z = Z.split("?")[1]), null == aa) return L(Z);
                    for (var Y = Z.split("&"), X = 0; X < Y.length; X++) if (Y[X].substring(0, Y[X].indexOf("=")) == aa) return L(Y[X].substring(Y[X].indexOf("=") + 1));
                }
                return "";
            },
            expressInstallCallback: function() {
                if (a) {
                    var X = c(R);
                    X && l && (X.parentNode.replaceChild(l, X), Q && (w(Q, !0), M.ie && M.win && (l.style.display = "block")), 
                    E && E(B)), a = !1;
                }
            }
        };
    }();
    !function() {
        if ("undefined" != typeof window && !window.WebSocket) {
            var console = window.console;
            if (console && console.log && console.error || (console = {
                log: function() {},
                error: function() {}
            }), !swfobject.hasFlashPlayerVersion("10.0.0")) return void console.error("Flash Player >= 10.0.0 is required.");
            "file:" == location.protocol && console.error("WARNING: web-socket-js doesn't work in file:///... URL unless you set Flash Security Settings properly. Open the page via Web server i.e. http://..."), 
            WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {
                var self = this;
                self.__id = WebSocket.__nextId++, WebSocket.__instances[self.__id] = self, self.readyState = WebSocket.CONNECTING, 
                self.bufferedAmount = 0, self.__events = {}, protocols ? "string" == typeof protocols && (protocols = [ protocols ]) : protocols = [], 
                setTimeout(function() {
                    WebSocket.__addTask(function() {
                        WebSocket.__flash.create(self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);
                    });
                }, 0);
            }, WebSocket.prototype.send = function(data) {
                if (this.readyState == WebSocket.CONNECTING) throw "INVALID_STATE_ERR: Web Socket connection has not been established";
                var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));
                return 0 > result ? !0 : (this.bufferedAmount += result, !1);
            }, WebSocket.prototype.close = function() {
                this.readyState != WebSocket.CLOSED && this.readyState != WebSocket.CLOSING && (this.readyState = WebSocket.CLOSING, 
                WebSocket.__flash.close(this.__id));
            }, WebSocket.prototype.addEventListener = function(type, listener, useCapture) {
                type in this.__events || (this.__events[type] = []), this.__events[type].push(listener);
            }, WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {
                if (type in this.__events) for (var events = this.__events[type], i = events.length - 1; i >= 0; --i) if (events[i] === listener) {
                    events.splice(i, 1);
                    break;
                }
            }, WebSocket.prototype.dispatchEvent = function(event) {
                for (var events = this.__events[event.type] || [], i = 0; i < events.length; ++i) events[i](event);
                var handler = this["on" + event.type];
                handler && handler(event);
            }, WebSocket.prototype.__handleEvent = function(flashEvent) {
                "readyState" in flashEvent && (this.readyState = flashEvent.readyState), "protocol" in flashEvent && (this.protocol = flashEvent.protocol);
                var jsEvent;
                if ("open" == flashEvent.type || "error" == flashEvent.type) jsEvent = this.__createSimpleEvent(flashEvent.type); else if ("close" == flashEvent.type) jsEvent = this.__createSimpleEvent("close"); else {
                    if ("message" != flashEvent.type) throw "unknown event type: " + flashEvent.type;
                    var data = decodeURIComponent(flashEvent.message);
                    jsEvent = this.__createMessageEvent("message", data);
                }
                this.dispatchEvent(jsEvent);
            }, WebSocket.prototype.__createSimpleEvent = function(type) {
                if (document.createEvent && window.Event) {
                    var event = document.createEvent("Event");
                    return event.initEvent(type, !1, !1), event;
                }
                return {
                    type: type,
                    bubbles: !1,
                    cancelable: !1
                };
            }, WebSocket.prototype.__createMessageEvent = function(type, data) {
                if (document.createEvent && window.MessageEvent && !window.opera) {
                    var event = document.createEvent("MessageEvent");
                    return event.initMessageEvent("message", !1, !1, data, null, null, window, null), 
                    event;
                }
                return {
                    type: type,
                    data: data,
                    bubbles: !1,
                    cancelable: !1
                };
            }, WebSocket.CONNECTING = 0, WebSocket.OPEN = 1, WebSocket.CLOSING = 2, WebSocket.CLOSED = 3, 
            WebSocket.__flash = null, WebSocket.__instances = {}, WebSocket.__tasks = [], WebSocket.__nextId = 0, 
            WebSocket.loadFlashPolicyFile = function(url) {
                WebSocket.__addTask(function() {
                    WebSocket.__flash.loadManualPolicyFile(url);
                });
            }, WebSocket.__initialize = function() {
                if (!WebSocket.__flash) {
                    if (WebSocket.__swfLocation && (window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation), 
                    !window.WEB_SOCKET_SWF_LOCATION) return void console.error("[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf");
                    var container = document.createElement("div");
                    container.id = "webSocketContainer", container.style.position = "absolute", WebSocket.__isFlashLite() ? (container.style.left = "0px", 
                    container.style.top = "0px") : (container.style.left = "-100px", container.style.top = "-100px");
                    var holder = document.createElement("div");
                    holder.id = "webSocketFlash", container.appendChild(holder), document.body.appendChild(container), 
                    swfobject.embedSWF(WEB_SOCKET_SWF_LOCATION, "webSocketFlash", "1", "1", "10.0.0", null, null, {
                        hasPriority: !0,
                        swliveconnect: !0,
                        allowScriptAccess: "always"
                    }, null, function(e) {
                        e.success || console.error("[WebSocket] swfobject.embedSWF failed");
                    });
                }
            }, WebSocket.__onFlashInitialized = function() {
                setTimeout(function() {
                    WebSocket.__flash = document.getElementById("webSocketFlash"), WebSocket.__flash.setCallerUrl(location.href), 
                    WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
                    for (var i = 0; i < WebSocket.__tasks.length; ++i) WebSocket.__tasks[i]();
                    WebSocket.__tasks = [];
                }, 0);
            }, WebSocket.__onFlashEvent = function() {
                return setTimeout(function() {
                    try {
                        for (var events = WebSocket.__flash.receiveEvents(), i = 0; i < events.length; ++i) WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);
                    } catch (e) {
                        console.error(e);
                    }
                }, 0), !0;
            }, WebSocket.__log = function(message) {
                console.log(decodeURIComponent(message));
            }, WebSocket.__error = function(message) {
                console.error(decodeURIComponent(message));
            }, WebSocket.__addTask = function(task) {
                WebSocket.__flash ? task() : WebSocket.__tasks.push(task);
            }, WebSocket.__isFlashLite = function() {
                if (!window.navigator || !window.navigator.mimeTypes) return !1;
                var mimeType = window.navigator.mimeTypes["application/x-shockwave-flash"];
                return mimeType && mimeType.enabledPlugin && mimeType.enabledPlugin.filename ? !!mimeType.enabledPlugin.filename.match(/flashlite/i) : !1;
            }, window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION || (window.addEventListener ? window.addEventListener("load", function() {
                WebSocket.__initialize();
            }, !1) : window.attachEvent("onload", function() {
                WebSocket.__initialize();
            }));
        }
    }(), function(exports, io, global) {
        function XHR(socket) {
            socket && (io.Transport.apply(this, arguments), this.sendBuffer = []);
        }
        function empty() {}
        exports.XHR = XHR, io.util.inherit(XHR, io.Transport), XHR.prototype.open = function() {
            return this.socket.setBuffer(!1), this.onOpen(), this.get(), this.setCloseTimeout(), 
            this;
        }, XHR.prototype.payload = function(payload) {
            for (var msgs = [], i = 0, l = payload.length; l > i; i++) msgs.push(io.parser.encodePacket(payload[i]));
            this.send(io.parser.encodePayload(msgs));
        }, XHR.prototype.send = function(data) {
            return this.post(data), this;
        }, XHR.prototype.post = function(data) {
            function stateChange() {
                4 == this.readyState && (this.onreadystatechange = empty, self.posting = !1, 200 == this.status ? self.socket.setBuffer(!1) : self.onClose());
            }
            function onload() {
                this.onload = empty, self.socket.setBuffer(!1);
            }
            var self = this;
            this.socket.setBuffer(!0), this.sendXHR = this.request("POST"), global.XDomainRequest && this.sendXHR instanceof XDomainRequest ? this.sendXHR.onload = this.sendXHR.onerror = onload : this.sendXHR.onreadystatechange = stateChange, 
            this.sendXHR.send(data);
        }, XHR.prototype.close = function() {
            return this.onClose(), this;
        }, XHR.prototype.request = function(method) {
            var req = io.util.request(this.socket.isXDomain()), query = io.util.query(this.socket.options.query, "t=" + +new Date());
            if (req.open(method || "GET", this.prepareUrl() + query, !0), "POST" == method) try {
                req.setRequestHeader ? req.setRequestHeader("Content-type", "text/plain;charset=UTF-8") : req.contentType = "text/plain";
            } catch (e) {}
            return req;
        }, XHR.prototype.scheme = function() {
            return this.socket.options.secure ? "https" : "http";
        }, XHR.check = function(socket, xdomain) {
            try {
                var request = io.util.request(xdomain), usesXDomReq = global.XDomainRequest && request instanceof XDomainRequest, socketProtocol = socket && socket.options && socket.options.secure ? "https:" : "http:", isXProtocol = global.location && socketProtocol != global.location.protocol;
                if (request && (!usesXDomReq || !isXProtocol)) return !0;
            } catch (e) {}
            return !1;
        }, XHR.xdomainCheck = function(socket) {
            return XHR.check(socket, !0);
        };
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), 
    function(exports, io) {
        function HTMLFile(socket) {
            io.Transport.XHR.apply(this, arguments);
        }
        exports.htmlfile = HTMLFile, io.util.inherit(HTMLFile, io.Transport.XHR), HTMLFile.prototype.name = "htmlfile", 
        HTMLFile.prototype.get = function() {
            this.doc = new (window[[ "Active" ].concat("Object").join("X")])("htmlfile"), this.doc.open(), 
            this.doc.write("<html></html>"), this.doc.close(), this.doc.parentWindow.s = this;
            var iframeC = this.doc.createElement("div");
            iframeC.className = "socketio", this.doc.body.appendChild(iframeC), this.iframe = this.doc.createElement("iframe"), 
            iframeC.appendChild(this.iframe);
            var self = this, query = io.util.query(this.socket.options.query, "t=" + +new Date());
            this.iframe.src = this.prepareUrl() + query, io.util.on(window, "unload", function() {
                self.destroy();
            });
        }, HTMLFile.prototype._ = function(data, doc) {
            data = data.replace(/\\\//g, "/"), this.onData(data);
            try {
                var script = doc.getElementsByTagName("script")[0];
                script.parentNode.removeChild(script);
            } catch (e) {}
        }, HTMLFile.prototype.destroy = function() {
            if (this.iframe) {
                try {
                    this.iframe.src = "about:blank";
                } catch (e) {}
                this.doc = null, this.iframe.parentNode.removeChild(this.iframe), this.iframe = null, 
                CollectGarbage();
            }
        }, HTMLFile.prototype.close = function() {
            return this.destroy(), io.Transport.XHR.prototype.close.call(this);
        }, HTMLFile.check = function(socket) {
            if ("undefined" != typeof window && [ "Active" ].concat("Object").join("X") in window) try {
                var a = new (window[[ "Active" ].concat("Object").join("X")])("htmlfile");
                return a && io.Transport.XHR.check(socket);
            } catch (e) {}
            return !1;
        }, HTMLFile.xdomainCheck = function() {
            return !1;
        }, io.transports.push("htmlfile");
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports), 
    function(exports, io, global) {
        function XHRPolling() {
            io.Transport.XHR.apply(this, arguments);
        }
        function empty() {}
        exports["xhr-polling"] = XHRPolling, io.util.inherit(XHRPolling, io.Transport.XHR), 
        io.util.merge(XHRPolling, io.Transport.XHR), XHRPolling.prototype.name = "xhr-polling", 
        XHRPolling.prototype.heartbeats = function() {
            return !1;
        }, XHRPolling.prototype.open = function() {
            var self = this;
            return io.Transport.XHR.prototype.open.call(self), !1;
        }, XHRPolling.prototype.get = function() {
            function stateChange() {
                4 == this.readyState && (this.onreadystatechange = empty, 200 == this.status ? (self.onData(this.responseText), 
                self.get()) : self.onClose());
            }
            function onload() {
                this.onload = empty, this.onerror = empty, self.retryCounter = 1, self.onData(this.responseText), 
                self.get();
            }
            function onerror() {
                self.retryCounter++, !self.retryCounter || self.retryCounter > 3 ? self.onClose() : self.get();
            }
            if (this.isOpen) {
                var self = this;
                this.xhr = this.request(), global.XDomainRequest && this.xhr instanceof XDomainRequest ? (this.xhr.onload = onload, 
                this.xhr.onerror = onerror) : this.xhr.onreadystatechange = stateChange, this.xhr.send(null);
            }
        }, XHRPolling.prototype.onClose = function() {
            if (io.Transport.XHR.prototype.onClose.call(this), this.xhr) {
                this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;
                try {
                    this.xhr.abort();
                } catch (e) {}
                this.xhr = null;
            }
        }, XHRPolling.prototype.ready = function(socket, fn) {
            var self = this;
            io.util.defer(function() {
                fn.call(self);
            });
        }, io.transports.push("xhr-polling");
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), 
    function(exports, io, global) {
        function JSONPPolling(socket) {
            io.Transport["xhr-polling"].apply(this, arguments), this.index = io.j.length;
            var self = this;
            io.j.push(function(msg) {
                self._(msg);
            });
        }
        var indicator = global.document && "MozAppearance" in global.document.documentElement.style;
        exports["jsonp-polling"] = JSONPPolling, io.util.inherit(JSONPPolling, io.Transport["xhr-polling"]), 
        JSONPPolling.prototype.name = "jsonp-polling", JSONPPolling.prototype.post = function(data) {
            function complete() {
                initIframe(), self.socket.setBuffer(!1);
            }
            function initIframe() {
                self.iframe && self.form.removeChild(self.iframe);
                try {
                    iframe = document.createElement('<iframe name="' + self.iframeId + '">');
                } catch (e) {
                    iframe = document.createElement("iframe"), iframe.name = self.iframeId;
                }
                iframe.id = self.iframeId, self.form.appendChild(iframe), self.iframe = iframe;
            }
            var self = this, query = io.util.query(this.socket.options.query, "t=" + +new Date() + "&i=" + this.index);
            if (!this.form) {
                var iframe, form = document.createElement("form"), area = document.createElement("textarea"), id = this.iframeId = "socketio_iframe_" + this.index;
                form.className = "socketio", form.style.position = "absolute", form.style.top = "0px", 
                form.style.left = "0px", form.style.display = "none", form.target = id, form.method = "POST", 
                form.setAttribute("accept-charset", "utf-8"), area.name = "d", form.appendChild(area), 
                document.body.appendChild(form), this.form = form, this.area = area;
            }
            this.form.action = this.prepareUrl() + query, initIframe(), this.area.value = io.JSON.stringify(data);
            try {
                this.form.submit();
            } catch (e) {}
            this.iframe.attachEvent ? iframe.onreadystatechange = function() {
                "complete" == self.iframe.readyState && complete();
            } : this.iframe.onload = complete, this.socket.setBuffer(!0);
        }, JSONPPolling.prototype.get = function() {
            var self = this, script = document.createElement("script"), query = io.util.query(this.socket.options.query, "t=" + +new Date() + "&i=" + this.index);
            this.script && (this.script.parentNode.removeChild(this.script), this.script = null), 
            script.async = !0, script.src = this.prepareUrl() + query, script.onerror = function() {
                self.onClose();
            };
            var insertAt = document.getElementsByTagName("script")[0];
            insertAt.parentNode.insertBefore(script, insertAt), this.script = script, indicator && setTimeout(function() {
                var iframe = document.createElement("iframe");
                document.body.appendChild(iframe), document.body.removeChild(iframe);
            }, 100);
        }, JSONPPolling.prototype._ = function(msg) {
            return this.onData(msg), this.isOpen && this.get(), this;
        }, JSONPPolling.prototype.ready = function(socket, fn) {
            var self = this;
            return indicator ? void io.util.load(function() {
                fn.call(self);
            }) : fn.call(this);
        }, JSONPPolling.check = function() {
            return "document" in global;
        }, JSONPPolling.xdomainCheck = function() {
            return !0;
        }, io.transports.push("jsonp-polling");
    }("undefined" != typeof io ? io.Transport : module.exports, "undefined" != typeof io ? io : module.parent.exports, this), 
    "function" == typeof define && define.amd && define([], function() {
        return io;
    });
}();

var StackOverflow, bezier, bezier1, bezier2, bezierT;

StackOverflow = StackOverflow || {}, StackOverflow.drawBezier = function(options, ctx) {
    var a, b, c, cDist, curveSample, i, j, k, len, letterPadding, p, point, ref, ribbon, ribbonSpecs, textCurve, totalLength, totalPadding, w, ww, x1, x2, xDist, z;
    if (null == options && (options = {}), options = Helper.shallowClone(options), null != options.curve && null == options.points && (options.points = options.curve.split(",")), 
    null == options.text && (options.text = "Text"), null == options.letterPadding && (options.letterPadding = .25), 
    null == options.fillStyle && (options.fillStyle = "white"), null == options.fillLineWidth && (options.fillLineWidth = 1), 
    null == options.strokeLineWidth && (options.strokeLineWidth = 10), null == options.strokeStyle && (options.strokeStyle = void 0), 
    null == options.font && (options.font = "40px Helvetica"), null == options.points && (options.points = []), 
    null == options.drawText && (options.drawText = !0), null == options.drawCurve && (options.drawCurve = !1), 
    null == options.maxChar && (options.maxChar = 50), null == options.x && (options.x = 0), 
    null == options.y && (options.y = 0), 8 !== options.points.length) throw "needs 8 points";
    for (options.points = options.points.map(function(item) {
        return parseFloat(item);
    }), i = 0, ref = options.points, k = 0, len = ref.length; len > k; k++) point = ref[k], 
    i % 2 === 0 ? options.points[i] += options.x : options.points[i] += options.y, i += 1;
    if (ribbonSpecs = {
        maxChar: options.maxChar,
        startX: options.points[0],
        startY: options.points[1],
        control1X: options.points[2],
        control1Y: options.points[3],
        control2X: options.points[4],
        control2Y: options.points[5],
        endX: options.points[6],
        endY: options.points[7]
    }, options.drawCurve && (ctx.save(), ctx.beginPath(), ctx.moveTo(ribbonSpecs.startX, ribbonSpecs.startY), 
    ctx.bezierCurveTo(ribbonSpecs.control1X, ribbonSpecs.control1Y, ribbonSpecs.control2X, ribbonSpecs.control2Y, ribbonSpecs.endX, ribbonSpecs.endY), 
    ctx.stroke(), ctx.restore()), options.drawText) {
        for (textCurve = [], ribbon = options.text.substring(0, ribbonSpecs.maxChar), curveSample = 1e3, 
        xDist = 0, i = 0, i = 0; curveSample > i; ) a = new bezier2(i / curveSample, ribbonSpecs.startX, ribbonSpecs.startY, ribbonSpecs.control1X, ribbonSpecs.control1Y, ribbonSpecs.control2X, ribbonSpecs.control2Y, ribbonSpecs.endX, ribbonSpecs.endY), 
        b = new bezier2((i + 1) / curveSample, ribbonSpecs.startX, ribbonSpecs.startY, ribbonSpecs.control1X, ribbonSpecs.control1Y, ribbonSpecs.control2X, ribbonSpecs.control2Y, ribbonSpecs.endX, ribbonSpecs.endY), 
        c = new bezier(a, b), textCurve.push({
            bezier: a,
            curve: c.curve
        }), i++;
        for (letterPadding = ctx.measureText(" ").width * options.letterPadding, w = ribbon.length, 
        ww = Math.round(ctx.measureText(ribbon).width), totalPadding = (w - 1) * letterPadding, 
        totalLength = ww + totalPadding, p = 0, cDist = textCurve[curveSample - 1].curve.cDist, 
        z = cDist / 2 - totalLength / 2, i = 0; curveSample > i; ) {
            if (textCurve[i].curve.cDist >= z) {
                p = i;
                break;
            }
            i++;
        }
        for (i = 0; w > i; ) {
            for (ctx.save(), ctx.translate(textCurve[p].bezier.point.x, textCurve[p].bezier.point.y), 
            ctx.rotate(textCurve[p].curve.rad), ctx.font = options.font, null != options.strokeStyle && (ctx.strokeStyle = options.strokeStyle, 
            ctx.lineWidth = options.strokeLineWidth, ctx.strokeText(ribbon[i], 0, 0)), ctx.fillStyle = options.fillStyle, 
            ctx.lineWidth = options.fillLineWidth, ctx.fillText(ribbon[i], 0, 0), ctx.restore(), 
            x1 = ctx.measureText(ribbon[i]).width + letterPadding, x2 = 0, j = p; curveSample > j; ) {
                if (x2 += textCurve[j].curve.dist, x2 >= x1) {
                    p = j;
                    break;
                }
                j++;
            }
            i++;
        }
    }
}, bezier = function(b1, b2) {
    var dx, dx2, xDist;
    this.rad = Math.atan(b1.point.mY / b1.point.mX), this.b2 = b2, this.b1 = b1, dx = b2.x - b1.x, 
    dx2 = (b2.x - b1.x) * (b2.x - b1.x), this.dist = Math.sqrt((b2.x - b1.x) * (b2.x - b1.x) + (b2.y - b1.y) * (b2.y - b1.y)), 
    xDist += this.dist, this.curve = {
        rad: this.rad,
        dist: this.dist,
        cDist: xDist
    };
}, bezierT = function(t, startX, startY, control1X, control1Y, control2X, control2Y, endX, endY) {
    this.mx = 3 * (1 - t) * (1 - t) * (control1X - startX) + 6 * (1 - t) * t * (control2X - control1X) + 3 * t * t * (endX - control2X), 
    this.my = 3 * (1 - t) * (1 - t) * (control1Y - startY) + 6 * (1 - t) * t * (control2Y - control1Y) + 3 * t * t * (endY - control2Y);
}, bezier2 = function(t, startX, startY, control1X, control1Y, control2X, control2Y, endX, endY) {
    this.Bezier1 = new bezier1(t, startX, startY, control1X, control1Y, control2X, control2Y), 
    this.Bezier2 = new bezier1(t, control1X, control1Y, control2X, control2Y, endX, endY), 
    this.x = (1 - t) * this.Bezier1.x + t * this.Bezier2.x, this.y = (1 - t) * this.Bezier1.y + t * this.Bezier2.y, 
    this.slope = new bezierT(t, startX, startY, control1X, control1Y, control2X, control2Y, endX, endY), 
    this.point = {
        t: t,
        x: this.x,
        y: this.y,
        mX: this.slope.mx,
        mY: this.slope.my
    };
}, bezier1 = function(t, startX, startY, control1X, control1Y, control2X, control2Y) {
    this.x = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * control1X + t * t * control2X, 
    this.y = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * control1Y + t * t * control2Y;
}, window.jNorthPole = {
    BASE_URL: "https://json.northpole.ro/",
    help: "NorthPole JS wrapper example usage:\n\nresponseHandler = function (data) {\n  console.log(data);\n};\n\njNorthPole.getStorage(json, responseHandler);\n\nsocket = jNorthPole.getNewRealtimeSocket(responseHandler)\njNorthPole.subscribe(socket, 'foo')\njNorthPole.publish(socket, 'foo', { message: 'hello' })",
    genericRequest: function(jsonObj, method, endPoint, responseHandler, errorHandler) {
        var r;
        if (null == errorHandler && (errorHandler = responseHandler), null == responseHandler) throw "responseHandler function missing";
        r = new XMLHttpRequest(), r.open(method, "" + this.BASE_URL + endPoint + ".json", !0), 
        r.onreadystatechange = function() {
            4 === r.readyState && (200 === r.status ? responseHandler(JSON.parse(r.responseText), r.status) : errorHandler(JSON.parse(r.responseText), r.status));
        }, r.send(JSON.stringify(jsonObj));
    },
    createUser: function(api_key, secret, success, failure) {
        var jsonObj;
        jsonObj = {
            api_key: api_key,
            secret: secret
        }, this.genericRequest(jsonObj, "POST", "user", success, failure);
    },
    getUser: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "SEARCH", "user", responseHandler, errorHandler);
    },
    createStorage: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "POST", "storage", responseHandler, errorHandler);
    },
    getStorage: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "SEARCH", "storage", responseHandler, errorHandler);
    },
    putStorage: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "PUT", "storage", responseHandler, errorHandler);
    },
    deleteStorage: function(jsonObj, responseHandler, errorHandler) {
        this.genericRequest(jsonObj, "DELETE", "storage", responseHandler, errorHandler);
    },
    getNewRealtimeSocket: function(responseHandler, errorHandler) {
        var socket, socketUrl;
        return null == errorHandler && (errorHandler = responseHandler), socketUrl = this.BASE_URL.replace("http", "ws"), 
        socket = new WebSocket(socketUrl + "realtime"), socket.onmessage = responseHandler, 
        socket.onclose = errorHandler, socket;
    },
    subscribe: function(socket, channel_name) {
        return socket.send(JSON.stringify({
            type: "subscribe",
            channel_name: channel_name
        }));
    },
    unsubscribe: function(socket, channel_name) {
        return socket.send(JSON.stringify({
            type: "unsubscribe",
            channel_name: channel_name
        }));
    },
    publish: function(socket, channel_name, json) {
        return socket.send(JSON.stringify({
            type: "publish",
            channel_name: channel_name,
            content: json
        }));
    }
};

var GameInstance, Utils, e, bind = function(fn, me) {
    return function() {
        return fn.apply(me, arguments);
    };
};

try {
    Utils = require("../shared/Utils.coffee").Utils;
} catch (error) {
    e = error, console.ce(e);
}

GameInstance = function() {
    function GameInstance(config) {
        null == config && (config = {}), this.tick = bind(this.tick, this), null == config.ticksPerSecond && (config.ticksPerSecond = 10), 
        null == config.autoStart && (config.autoStart = !0), this.players = {}, this.sockets = {}, 
        this.inputs = [], this.id = Utils.guid(), this.config = config, this.config.autoStart && this.setTickInterval(this.config.ticksPerSecond);
    }
    return GameInstance.prototype.tick = function() {
        throw "tick needs to be implemented";
    }, GameInstance.prototype.setTickInterval = function(tps) {
        return null == tps && (tps = 10), this.config.ticksPerSecond = tps, null != this.tickInterval && clearInterval(this.tickInterval), 
        this.tickInterval = setInterval(this.tick, 1e3 / this.config.ticksPerSecond);
    }, GameInstance.prototype.startTicking = function() {
        return this.setTickInterval(this.config.ticksPerSecond);
    }, GameInstance.prototype.stopTicking = function() {
        return null != this.tickInterval ? clearInterval(this.tickInterval) : void 0;
    }, GameInstance;
}(), exports.GameInstance = GameInstance;
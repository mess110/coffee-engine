// Generated by CoffeeScript 1.10.0
var BloodParticle, LoadingScene, camera, config, engine, loadingScene,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

config = Config.get();

config.fillWindow();

camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);

engine = new Engine3D();

engine.setCamera(camera);

camera.position.set(0, 20, 27);

camera.lookAt(new THREE.Vector3(0, 0, 0));

SoundManager.get().add('shotgun', 'sounds/shotgun.wav');

SoundManager.get().add('hit', 'sounds/hit.wav');

Helper.fancyShadows(engine.renderer);

BloodParticle = (function(superClass) {
  extend(BloodParticle, superClass);

  function BloodParticle(texturePath) {
    this.particleGroup = new SPE.Group({
      texture: THREE.ImageUtils.loadTexture(texturePath),
      maxAge: 0.2,
      blending: THREE.NormalBlending,
      hasPerspective: true,
      colorize: true
    });
    this.emitter = new SPE.Emitter({
      position: new THREE.Vector3(0, 0, 0),
      positionSpread: new THREE.Vector3(2, 2, 2),
      acceleration: new THREE.Vector3(0, 0, 0),
      accelerationSpread: new THREE.Vector3(0, 0, 0),
      velocity: new THREE.Vector3(0, 0, -20),
      velocitySpread: new THREE.Vector3(10, 10, 10),
      colorStart: new THREE.Color('red'),
      colorMiddle: new THREE.Color('red'),
      colorEnd: new THREE.Color('red'),
      sizeStart: 0,
      sizeMiddle: 4,
      sizeEnd: 5,
      particleCount: 1000
    });
    this.particleGroup.addEmitter(this.emitter);
    this.mesh = this.particleGroup.mesh;
  }

  return BloodParticle;

})(BaseParticle);

LoadingScene = (function(superClass) {
  extend(LoadingScene, superClass);

  function LoadingScene() {
    var box, geometry, mat, material, texture;
    LoadingScene.__super__.constructor.call(this);
    this.particle2 = new BloodParticle('imgs/splatter_particle.png');
    this.particle2.emitter.disable();
    this.scene.add(this.particle2.mesh);
    this.splats = [];
    this.bunnies = [];
    this.started = false;
    this.score = 0;
    this.ambientLights = [Helper.ambientLight(), Helper.ambientLight(), Helper.ambientLight(), Helper.ambientLight()];
    this.killingSpree = 0;
    box = new THREE.BoxGeometry(1, 1, 1);
    mat = new THREE.MeshPhongMaterial({
      color: 0xff0000
    });
    this.spotLight = new SpotLight(0, 30, 25);
    this.spotLight.addToScene(this.scene);
    this.spawnBunny(true);
    JsonModelManager.get().load('bear', 'models/bear_all.json', (function(_this) {
      return function(mesh) {
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        _this.bear = mesh;
        _this.bear.position.set(0, 0, 0);
        _this.bear.animations[0].play();
        _this.bear.speed = 5;
        _this.scene.add(_this.bear);
        if (_this.bear != null) {
          _this.spotLight.lookAt(_this.bear);
        }
        _this.cameraPosition(0);
        return JsonModelManager.get().load('shotgun', 'models/shotgun.json', function(mesh) {
          mesh.receiveShadow = true;
          mesh.castShadow = true;
          _this.shotgun = mesh;
          _this.shotgun.animations[1].loop = false;
          _this.shotgun.scale.set(0.3, 0.3, 0.3);
          _this.shotgun.position.set(0, 3, 2.5);
          _this.bear.add(_this.shotgun);
          _this.particle = new BaseParticle('./imgs/star.png');
          _this.particle.mesh.rotation.set(Math.PI / 2, 0, 0);
          _this.particle.mesh.position.set(0, 0.75, 5);
          _this.particle.mesh.visible = false;
          return _this.shotgun.add(_this.particle.mesh);
        });
      };
    })(this));
    JsonModelManager.get().load('drapes', 'models/drapes.json', (function(_this) {
      return function(mesh) {
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        _this.drapesBg = mesh;
        _this.drapesBg.position.set(0, 0, -15);
        _this.drapesBg.scale.set(3.5, 2, 1);
        return _this.scene.add(_this.drapesBg);
      };
    })(this));
    JsonModelManager.get().load('drapes', 'models/drapes2.json', (function(_this) {
      return function(mesh) {
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        _this.drapes = mesh;
        _this.drapes.opened = false;
        _this.drapes.position.set(0, 0, 15);
        _this.drapes.scale.x = 2;
        return _this.scene.add(_this.drapes);
      };
    })(this));
    JsonModelManager.get().load('mask', 'models/theater_mask.json', (function(_this) {
      return function(mesh) {
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        _this.mask = mesh;
        _this.mask.position.set(0, 16, 16);
        return _this.scene.add(_this.mask);
      };
    })(this));
    texture = THREE.ImageUtils.loadTexture('models/diffuse.png');
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(6, 6);
    mat = new THREE.MeshPhongMaterial({
      shininess: 0,
      map: texture,
      combine: THREE.MixOperation,
      reflectivity: 0.00
    });
    geometry = new THREE.PlaneGeometry(80, 80, 32);
    material = new THREE.MeshBasicMaterial({
      color: 0xffff00,
      side: THREE.DoubleSide
    });
    this.plane = new THREE.Mesh(geometry, mat);
    this.plane.receiveShadow = true;
    this.plane.castShadow = true;
    this.plane.position.z = -20;
    this.plane.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
    this.scene.add(this.plane);
    this.raycaster = new THREE.Raycaster();
    this.splatElevation = 0;
    this.splatTexture = THREE.ImageUtils.loadTexture('imgs/splatter.png');
    this.loaded = true;
  }

  LoadingScene.prototype.mkSplat = function(pos) {
    var splat, splatGeometry;
    this.splatElevation += 0.0002;
    this.splatMat = new THREE.MeshPhongMaterial({
      map: this.splatTexture,
      transparent: true,
      opacity: 0.0
    });
    splatGeometry = new THREE.PlaneBufferGeometry(5, 5);
    splat = new THREE.Mesh(splatGeometry, this.splatMat);
    splat.receiveShadow = true;
    splat.position.set(pos.x, this.splatElevation, pos.z);
    splat.rotation.set(-Math.PI / 2, 0, Math.random() * Math.PI);
    this.splats.push(splat);
    return this.scene.add(splat);
  };

  LoadingScene.prototype.toggleLights = function() {
    var action, j, len, light, ref;
    action = this.lights ? 'remove' : 'add';
    ref = this.ambientLights;
    for (j = 0, len = ref.length; j < len; j++) {
      light = ref[j];
      this.scene[action](light);
    }
    return this.lights = !this.lights;
  };

  LoadingScene.prototype.tick = function(tpf) {
    var asd, bar, bunny, direction, geometry, intersected, intersects, j, k, len, len1, matrix, pnt, ref, ref1, results, snd, splat;
    if (!this.loaded) {
      return;
    }
    if (this.particle != null) {
      this.particle.tick(tpf);
    }
    if (this.particle2 != null) {
      this.particle2.tick(tpf);
    }
    if (this.mask && this.drapes) {
      this.mask.castShadow = !this.drapes.opened;
    }
    if ((this.bear != null) && (this.shotgun != null) && this.bunnies.any()) {
      this.spotLight.lookAt(this.bear);
      this.moving = false;
      if (this.gameOver) {
        return;
      }
      if (this.keyboard.pressed(' ') && !this.shotgun.animations[1].isPlaying) {
        this.shotgun.animations[1].play();
        this.particle.mesh.visible = true;
        setTimeout((function(_this) {
          return function() {
            return _this.particle.mesh.visible = false;
          };
        })(this), 150);
        snd = SoundManager.get().sounds['shotgun'];
        snd.volume = 0.4;
        snd.playbackRate = 1.3;
        snd.play('shotgun');
        if (!this.started) {
          return;
        }
        matrix = new THREE.Matrix4;
        matrix.extractRotation(this.bear.matrix);
        direction = new THREE.Vector3(0, 0, 1);
        direction.applyMatrix4(matrix);
        this.raycaster.set(this.bear.position, direction);
        intersects = this.raycaster.intersectObjects(this.bunnies);
        if (intersects.any()) {
          this.killingSpree += 1;
          pnt = intersects[0].point;
          this.particle2.mesh.position.set(pnt.x, pnt.y + 2, pnt.z);
          this.particle2.mesh.lookAt(this.bear.position);
          this.particle2.emitter.enable();
          geometry = new THREE.Geometry;
          geometry.vertices.push(this.bear.position);
          geometry.vertices.push(pnt);
          this.scene.remove(this.line);
          this.line = new THREE.Line(geometry, new THREE.LineBasicMaterial({
            color: 'gold'
          }));
          this.scene.add(this.line);
          SoundManager.get().play('hit');
          this.score += this.killingSpree * pnt.distanceTo(this.bear.position);
          document.getElementById('count').innerHTML = this.score;
          intersected = intersects.first().object;
          asd = this.getBunnySpawnPoint();
          bar = intersected.position.clone();
          intersected.dead = true;
          setTimeout((function(_this) {
            return function() {
              var tween;
              _this.particle2.emitter.disable();
              _this.mkSplat(pnt);
              tween = new TWEEN.Tween(bar).to(asd, 1000).onUpdate(function() {
                intersected.position.set(this.x, this.y, this.z);
              }).easing(TWEEN.Easing.Cubic.InOut).start();
              setTimeout(function() {
                intersected.dead = false;
                intersected.animations[1].play();
                return delete intersected.deathAnimated;
              }, 1000);
              return _this.spawnBunny();
            };
          })(this), 350);
        } else {
          this.killingSpree = 0;
        }
      }
      if (this.keyboard.pressed('w') || this.keyboard.pressed('up')) {
        this.moving = true;
        this.bear.translateZ(tpf * this.bear.speed);
      }
      if (this.keyboard.pressed('s') || this.keyboard.pressed('down')) {
        this.moving = true;
        this.bear.translateZ(-tpf * this.bear.speed);
      }
      if (this.keyboard.pressed('a') || this.keyboard.pressed('left')) {
        this.moving = true;
        this.bear.rotation.y += tpf * this.bear.speed / 2;
      }
      if (this.keyboard.pressed('d') || this.keyboard.pressed('right')) {
        this.moving = true;
        this.bear.rotation.y -= tpf * this.bear.speed / 2;
      }
      if (this.bear.animations[0].isPlaying && this.moving) {
        this.bear.animations[1].play();
        this.bear.animations[0].stop();
      }
      if (this.bear.animations[1].isPlaying && !this.moving) {
        this.bear.animations[0].play();
        this.bear.animations[1].stop();
      }
      ref = this.splats;
      for (j = 0, len = ref.length; j < len; j++) {
        splat = ref[j];
        if (splat.material.opacity < 0.5) {
          splat.material.opacity += tpf;
        }
      }
      ref1 = this.bunnies;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        bunny = ref1[k];
        if (!bunny.dead) {
          bunny.lookAt(this.bear.position);
        }
        if (this.moving) {
          bunny.translateZ(tpf * bunny.speed);
        }
        if (bunny.position.distanceTo(this.bear.position) < 2.5 && !bunny.dead) {
          this.gameOver = true;
          this.toggleDrapes();
          this.resetScene();
        }
        if (bunny.dead && !bunny.deathAnimated) {
          bunny.deathAnimated = true;
          bunny.animations[0].stop();
          bunny.animations[1].stop();
          results.push(bunny.animations[2].play());
        } else {
          if (bunny.animations[0].isPlaying && this.moving) {
            bunny.animations[0].stop();
            bunny.animations[1].play();
            bunny.animations[2].stop();
          }
          if (bunny.animations[1].isPlaying && !this.moving) {
            bunny.animations[0].play();
            bunny.animations[1].stop();
            results.push(bunny.animations[2].stop());
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    }
  };

  LoadingScene.prototype.resetScene = function() {
    this.cameraPosition(0);
    return setTimeout((function(_this) {
      return function() {
        var bunny, j, k, len, len1, ref, ref1, splat;
        _this.bear.position.set(0, 0, 0);
        _this.bear.rotation.set(0, 0, 0);
        ref = _this.bunnies;
        for (j = 0, len = ref.length; j < len; j++) {
          bunny = ref[j];
          _this.scene.remove(bunny);
        }
        _this.bunnies = [];
        ref1 = _this.splats;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          splat = ref1[k];
          _this.scene.remove(splat);
        }
        _this.splats = [];
        _this.splatElevation = 0;
        _this.started = false;
        _this.gameOver = false;
        return _this.spawnBunny(true);
      };
    })(this), 1000);
  };

  LoadingScene.prototype.getRandomArbitrary = function(min, max) {
    return Math.random() * (max - min) + min;
  };

  LoadingScene.prototype.spawnBunny = function(first) {
    if (first == null) {
      first = false;
    }
    return JsonModelManager.get().load('bunny', 'models/bunny_all.json', (function(_this) {
      return function(mesh) {
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        _this.bunny = mesh;
        if (first) {
          _this.bunny.position.set(20, 0, 0);
        } else {
          _this.bunny.position.copy(_this.getBunnySpawnPoint());
        }
        _this.bunny.scale.set(0.5, 0.5, 0.5);
        _this.bunny.animations[1].play();
        _this.bunny.animations[2].loop = false;
        _this.bunny.speed = 3;
        _this.bunny.dead = false;
        _this.bunnies.push(_this.bunny);
        return _this.scene.add(_this.bunny);
      };
    })(this));
  };

  LoadingScene.prototype.cameraPosition = function(i) {
    var e;
    if (i == null) {
      i = 0;
    }
    e = [
      {
        x: 0,
        y: 20,
        z: 27
      }, {
        x: 0,
        y: 33,
        z: 0
      }
    ][i];
    this.selectedCameraPosition = i;
    this.tweenMoveTo({
      position: new THREE.Vector3(e.x, e.y, e.z)
    }, camera, 500);
    return setTimeout((function(_this) {
      return function() {
        return _this.tweenLookAt({
          position: new THREE.Vector3(0, 0, 0)
        }, camera, 500);
      };
    })(this), 501);
  };

  LoadingScene.prototype.toggleCamera = function() {
    var i;
    i = this.selectedCameraPosition === 0 ? 1 : 0;
    return this.cameraPosition(i);
  };

  LoadingScene.prototype.getBunnySpawnPoint = function() {
    var angle, radius;
    angle = Math.random() * Math.PI * 2;
    radius = this.getRandomArbitrary(20, 30);
    return {
      x: Math.cos(angle) * radius,
      y: 0,
      z: Math.sin(angle) * radius
    };
  };

  LoadingScene.prototype.toggleDrapes = function() {
    var count, help, menu, score;
    if (this.drapes.animations[0].isPlaying) {
      return;
    }
    count = document.getElementById('count');
    menu = document.getElementById('menu');
    help = document.getElementById('help');
    score = document.getElementById('score');
    if (this.started === false) {
      this.score = 0;
      count.innerHTML = this.score;
      menu.className = 'hidden';
      help.className = 'hidden';
      score.className = 'visible';
    } else {
      menu.className = 'visible';
      help.className = 'visible';
    }
    this.started = true;
    this.drapes.animations[0].play();
    setTimeout((function(_this) {
      return function() {
        return _this.drapes.opened = !_this.drapes.opened;
      };
    })(this), this.drapes.opened ? (this.drapes.animations[0].data.length * 1000 - 100) / 3 : (this.drapes.animations[0].data.length * 1000 - 100) / 4 * 3 - 150);
    return setTimeout((function(_this) {
      return function() {
        _this.drapes.animations[0].stop();
        return _this.drapes.animations[0].timeScale *= -1;
      };
    })(this), this.drapes.animations[0].data.length * 1000 - 100);
  };

  LoadingScene.prototype.doMouseEvent = function(event, raycaster) {};

  LoadingScene.prototype.doKeyboardEvent = function(event) {
    if (event.type !== 'keyup') {
      return;
    }
    if (this.drapes == null) {
      return;
    }
    if (event.which === 49) {
      this.cameraPosition(0);
    }
    if (event.which === 50) {
      this.cameraPosition(1);
    }
    if (event.which === 67) {
      this.toggleCamera();
    }
    if (event.which === 32 && !this.started) {
      return this.toggleDrapes();
    }
  };

  return LoadingScene;

})(BaseScene);

loadingScene = new LoadingScene();

engine.addScene(loadingScene);

engine.render();
